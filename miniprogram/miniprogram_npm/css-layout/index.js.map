{"version":3,"sources":["css-layout.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// UMD (Universal Module Definition)\r\n// See https://github.com/umdjs/umd for reference\r\n//\r\n// This file uses the following specific UMD implementation:\r\n// https://github.com/umdjs/umd/blob/master/returnExports.js\r\n(function(root, factory) {\r\n  if (typeof define === 'function' && define.amd) {\r\n    // AMD. Register as an anonymous module.\r\n    define([], factory);\r\n  } else if (typeof exports === 'object') {\r\n    // Node. Does not work with strict CommonJS, but\r\n    // only CommonJS-like environments that support module.exports,\r\n    // like Node.\r\n    module.exports = factory();\r\n  } else {\r\n    // Browser globals (root is window)\r\n    root.computeLayout = factory();\r\n  }\r\n}(this, function() {\r\n  /**\r\n * Copyright (c) 2014, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n */\r\n\r\nvar computeLayout = (function() {\r\n\r\n  var CSS_UNDEFINED;\r\n\r\n  var CSS_DIRECTION_INHERIT = 'inherit';\r\n  var CSS_DIRECTION_LTR = 'ltr';\r\n  var CSS_DIRECTION_RTL = 'rtl';\r\n\r\n  var CSS_FLEX_DIRECTION_ROW = 'row';\r\n  var CSS_FLEX_DIRECTION_ROW_REVERSE = 'row-reverse';\r\n  var CSS_FLEX_DIRECTION_COLUMN = 'column';\r\n  var CSS_FLEX_DIRECTION_COLUMN_REVERSE = 'column-reverse';\r\n\r\n  var CSS_JUSTIFY_FLEX_START = 'flex-start';\r\n  var CSS_JUSTIFY_CENTER = 'center';\r\n  var CSS_JUSTIFY_FLEX_END = 'flex-end';\r\n  var CSS_JUSTIFY_SPACE_BETWEEN = 'space-between';\r\n  var CSS_JUSTIFY_SPACE_AROUND = 'space-around';\r\n\r\n  var CSS_ALIGN_FLEX_START = 'flex-start';\r\n  var CSS_ALIGN_CENTER = 'center';\r\n  var CSS_ALIGN_FLEX_END = 'flex-end';\r\n  var CSS_ALIGN_STRETCH = 'stretch';\r\n\r\n  var CSS_POSITION_RELATIVE = 'relative';\r\n  var CSS_POSITION_ABSOLUTE = 'absolute';\r\n\r\n  var leading = {\r\n    'row': 'left',\r\n    'row-reverse': 'right',\r\n    'column': 'top',\r\n    'column-reverse': 'bottom'\r\n  };\r\n  var trailing = {\r\n    'row': 'right',\r\n    'row-reverse': 'left',\r\n    'column': 'bottom',\r\n    'column-reverse': 'top'\r\n  };\r\n  var pos = {\r\n    'row': 'left',\r\n    'row-reverse': 'right',\r\n    'column': 'top',\r\n    'column-reverse': 'bottom'\r\n  };\r\n  var dim = {\r\n    'row': 'width',\r\n    'row-reverse': 'width',\r\n    'column': 'height',\r\n    'column-reverse': 'height'\r\n  };\r\n\r\n  // When transpiled to Java / C the node type has layout, children and style\r\n  // properties. For the JavaScript version this function adds these properties\r\n  // if they don't already exist.\r\n  function fillNodes(node) {\r\n    if (!node.layout || node.isDirty) {\r\n      node.layout = {\r\n        width: undefined,\r\n        height: undefined,\r\n        top: 0,\r\n        left: 0,\r\n        right: 0,\r\n        bottom: 0\r\n      };\r\n    }\r\n\r\n    if (!node.style) {\r\n      node.style = {};\r\n    }\r\n\r\n    if (!node.children) {\r\n      node.children = [];\r\n    }\r\n    node.children.forEach(fillNodes);\r\n    return node;\r\n  }\r\n\r\n  function isUndefined(value) {\r\n    return value === undefined;\r\n  }\r\n\r\n  function isRowDirection(flexDirection) {\r\n    return flexDirection === CSS_FLEX_DIRECTION_ROW ||\r\n           flexDirection === CSS_FLEX_DIRECTION_ROW_REVERSE;\r\n  }\r\n\r\n  function isColumnDirection(flexDirection) {\r\n    return flexDirection === CSS_FLEX_DIRECTION_COLUMN ||\r\n           flexDirection === CSS_FLEX_DIRECTION_COLUMN_REVERSE;\r\n  }\r\n\r\n  function getLeadingMargin(node, axis) {\r\n    if (node.style.marginStart !== undefined && isRowDirection(axis)) {\r\n      return node.style.marginStart;\r\n    }\r\n\r\n    var value = null;\r\n    switch (axis) {\r\n      case 'row':            value = node.style.marginLeft;   break;\r\n      case 'row-reverse':    value = node.style.marginRight;  break;\r\n      case 'column':         value = node.style.marginTop;    break;\r\n      case 'column-reverse': value = node.style.marginBottom; break;\r\n    }\r\n\r\n    if (value !== undefined) {\r\n      return value;\r\n    }\r\n\r\n    if (node.style.margin !== undefined) {\r\n      return node.style.margin;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  function getTrailingMargin(node, axis) {\r\n    if (node.style.marginEnd !== undefined && isRowDirection(axis)) {\r\n      return node.style.marginEnd;\r\n    }\r\n\r\n    var value = null;\r\n    switch (axis) {\r\n      case 'row':            value = node.style.marginRight;  break;\r\n      case 'row-reverse':    value = node.style.marginLeft;   break;\r\n      case 'column':         value = node.style.marginBottom; break;\r\n      case 'column-reverse': value = node.style.marginTop;    break;\r\n    }\r\n\r\n    if (value != null) {\r\n      return value;\r\n    }\r\n\r\n    if (node.style.margin !== undefined) {\r\n      return node.style.margin;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  function getLeadingPadding(node, axis) {\r\n    if (node.style.paddingStart !== undefined && node.style.paddingStart >= 0\r\n        && isRowDirection(axis)) {\r\n      return node.style.paddingStart;\r\n    }\r\n\r\n    var value = null;\r\n    switch (axis) {\r\n      case 'row':            value = node.style.paddingLeft;   break;\r\n      case 'row-reverse':    value = node.style.paddingRight;  break;\r\n      case 'column':         value = node.style.paddingTop;    break;\r\n      case 'column-reverse': value = node.style.paddingBottom; break;\r\n    }\r\n\r\n    if (value != null && value >= 0) {\r\n      return value;\r\n    }\r\n\r\n    if (node.style.padding !== undefined && node.style.padding >= 0) {\r\n      return node.style.padding;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  function getTrailingPadding(node, axis) {\r\n    if (node.style.paddingEnd !== undefined && node.style.paddingEnd >= 0\r\n        && isRowDirection(axis)) {\r\n      return node.style.paddingEnd;\r\n    }\r\n\r\n    var value = null;\r\n    switch (axis) {\r\n      case 'row':            value = node.style.paddingRight;  break;\r\n      case 'row-reverse':    value = node.style.paddingLeft;   break;\r\n      case 'column':         value = node.style.paddingBottom; break;\r\n      case 'column-reverse': value = node.style.paddingTop;    break;\r\n    }\r\n\r\n    if (value != null && value >= 0) {\r\n      return value;\r\n    }\r\n\r\n    if (node.style.padding !== undefined && node.style.padding >= 0) {\r\n      return node.style.padding;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  function getLeadingBorder(node, axis) {\r\n    if (node.style.borderStartWidth !== undefined && node.style.borderStartWidth >= 0\r\n        && isRowDirection(axis)) {\r\n      return node.style.borderStartWidth;\r\n    }\r\n\r\n    var value = null;\r\n    switch (axis) {\r\n      case 'row':            value = node.style.borderLeftWidth;   break;\r\n      case 'row-reverse':    value = node.style.borderRightWidth;  break;\r\n      case 'column':         value = node.style.borderTopWidth;    break;\r\n      case 'column-reverse': value = node.style.borderBottomWidth; break;\r\n    }\r\n\r\n    if (value != null && value >= 0) {\r\n      return value;\r\n    }\r\n\r\n    if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {\r\n      return node.style.borderWidth;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  function getTrailingBorder(node, axis) {\r\n    if (node.style.borderEndWidth !== undefined && node.style.borderEndWidth >= 0\r\n        && isRowDirection(axis)) {\r\n      return node.style.borderEndWidth;\r\n    }\r\n\r\n    var value = null;\r\n    switch (axis) {\r\n      case 'row':            value = node.style.borderRightWidth;  break;\r\n      case 'row-reverse':    value = node.style.borderLeftWidth;   break;\r\n      case 'column':         value = node.style.borderBottomWidth; break;\r\n      case 'column-reverse': value = node.style.borderTopWidth;    break;\r\n    }\r\n\r\n    if (value != null && value >= 0) {\r\n      return value;\r\n    }\r\n\r\n    if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {\r\n      return node.style.borderWidth;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  function getLeadingPaddingAndBorder(node, axis) {\r\n    return getLeadingPadding(node, axis) + getLeadingBorder(node, axis);\r\n  }\r\n\r\n  function getTrailingPaddingAndBorder(node, axis) {\r\n    return getTrailingPadding(node, axis) + getTrailingBorder(node, axis);\r\n  }\r\n\r\n  function getBorderAxis(node, axis) {\r\n    return getLeadingBorder(node, axis) + getTrailingBorder(node, axis);\r\n  }\r\n\r\n  function getMarginAxis(node, axis) {\r\n    return getLeadingMargin(node, axis) + getTrailingMargin(node, axis);\r\n  }\r\n\r\n  function getPaddingAndBorderAxis(node, axis) {\r\n    return getLeadingPaddingAndBorder(node, axis) +\r\n        getTrailingPaddingAndBorder(node, axis);\r\n  }\r\n\r\n  function getJustifyContent(node) {\r\n    if (node.style.justifyContent) {\r\n      return node.style.justifyContent;\r\n    }\r\n    return 'flex-start';\r\n  }\r\n\r\n  function getAlignContent(node) {\r\n    if (node.style.alignContent) {\r\n      return node.style.alignContent;\r\n    }\r\n    return 'flex-start';\r\n  }\r\n\r\n  function getAlignItem(node, child) {\r\n    if (child.style.alignSelf) {\r\n      return child.style.alignSelf;\r\n    }\r\n    if (node.style.alignItems) {\r\n      return node.style.alignItems;\r\n    }\r\n    return 'stretch';\r\n  }\r\n\r\n  function resolveAxis(axis, direction) {\r\n    if (direction === CSS_DIRECTION_RTL) {\r\n      if (axis === CSS_FLEX_DIRECTION_ROW) {\r\n        return CSS_FLEX_DIRECTION_ROW_REVERSE;\r\n      } else if (axis === CSS_FLEX_DIRECTION_ROW_REVERSE) {\r\n        return CSS_FLEX_DIRECTION_ROW;\r\n      }\r\n    }\r\n\r\n    return axis;\r\n  }\r\n\r\n  function resolveDirection(node, parentDirection) {\r\n    var direction;\r\n    if (node.style.direction) {\r\n      direction = node.style.direction;\r\n    } else {\r\n      direction = CSS_DIRECTION_INHERIT;\r\n    }\r\n\r\n    if (direction === CSS_DIRECTION_INHERIT) {\r\n      direction = (parentDirection === undefined ? CSS_DIRECTION_LTR : parentDirection);\r\n    }\r\n\r\n    return direction;\r\n  }\r\n\r\n  function getFlexDirection(node) {\r\n    if (node.style.flexDirection) {\r\n      return node.style.flexDirection;\r\n    }\r\n    return CSS_FLEX_DIRECTION_COLUMN;\r\n  }\r\n\r\n  function getCrossFlexDirection(flexDirection, direction) {\r\n    if (isColumnDirection(flexDirection)) {\r\n      return resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);\r\n    } else {\r\n      return CSS_FLEX_DIRECTION_COLUMN;\r\n    }\r\n  }\r\n\r\n  function getPositionType(node) {\r\n    if (node.style.position) {\r\n      return node.style.position;\r\n    }\r\n    return 'relative';\r\n  }\r\n\r\n  function isFlex(node) {\r\n    return (\r\n      getPositionType(node) === CSS_POSITION_RELATIVE &&\r\n      node.style.flex > 0\r\n    );\r\n  }\r\n\r\n  function isFlexWrap(node) {\r\n    return node.style.flexWrap === 'wrap';\r\n  }\r\n\r\n  function getDimWithMargin(node, axis) {\r\n    return node.layout[dim[axis]] + getMarginAxis(node, axis);\r\n  }\r\n\r\n  function isDimDefined(node, axis) {\r\n    return node.style[dim[axis]] !== undefined && node.style[dim[axis]] >= 0;\r\n  }\r\n\r\n  function isPosDefined(node, pos) {\r\n    return node.style[pos] !== undefined;\r\n  }\r\n\r\n  function isMeasureDefined(node) {\r\n    return node.style.measure !== undefined;\r\n  }\r\n\r\n  function getPosition(node, pos) {\r\n    if (node.style[pos] !== undefined) {\r\n      return node.style[pos];\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  function boundAxis(node, axis, value) {\r\n    var min = {\r\n      'row': node.style.minWidth,\r\n      'row-reverse': node.style.minWidth,\r\n      'column': node.style.minHeight,\r\n      'column-reverse': node.style.minHeight\r\n    }[axis];\r\n\r\n    var max = {\r\n      'row': node.style.maxWidth,\r\n      'row-reverse': node.style.maxWidth,\r\n      'column': node.style.maxHeight,\r\n      'column-reverse': node.style.maxHeight\r\n    }[axis];\r\n\r\n    var boundValue = value;\r\n    if (max !== undefined && max >= 0 && boundValue > max) {\r\n      boundValue = max;\r\n    }\r\n    if (min !== undefined && min >= 0 && boundValue < min) {\r\n      boundValue = min;\r\n    }\r\n    return boundValue;\r\n  }\r\n\r\n  function fmaxf(a, b) {\r\n    if (a > b) {\r\n      return a;\r\n    }\r\n    return b;\r\n  }\r\n\r\n  // When the user specifically sets a value for width or height\r\n  function setDimensionFromStyle(node, axis) {\r\n    // The parent already computed us a width or height. We just skip it\r\n    if (node.layout[dim[axis]] !== undefined) {\r\n      return;\r\n    }\r\n    // We only run if there's a width or height defined\r\n    if (!isDimDefined(node, axis)) {\r\n      return;\r\n    }\r\n\r\n    // The dimensions can never be smaller than the padding and border\r\n    node.layout[dim[axis]] = fmaxf(\r\n      boundAxis(node, axis, node.style[dim[axis]]),\r\n      getPaddingAndBorderAxis(node, axis)\r\n    );\r\n  }\r\n\r\n  function setTrailingPosition(node, child, axis) {\r\n    child.layout[trailing[axis]] = node.layout[dim[axis]] -\r\n        child.layout[dim[axis]] - child.layout[pos[axis]];\r\n  }\r\n\r\n  // If both left and right are defined, then use left. Otherwise return\r\n  // +left or -right depending on which is defined.\r\n  function getRelativePosition(node, axis) {\r\n    if (node.style[leading[axis]] !== undefined) {\r\n      return getPosition(node, leading[axis]);\r\n    }\r\n    return -getPosition(node, trailing[axis]);\r\n  }\r\n\r\n  function layoutNodeImpl(node, parentMaxWidth, /*css_direction_t*/parentDirection) {\r\n    var/*css_direction_t*/ direction = resolveDirection(node, parentDirection);\r\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ mainAxis = resolveAxis(getFlexDirection(node), direction);\r\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ crossAxis = getCrossFlexDirection(mainAxis, direction);\r\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ resolvedRowAxis = resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);\r\n\r\n    // Handle width and height style attributes\r\n    setDimensionFromStyle(node, mainAxis);\r\n    setDimensionFromStyle(node, crossAxis);\r\n\r\n    // Set the resolved resolution in the node's layout\r\n    node.layout.direction = direction;\r\n\r\n    // The position is set by the parent, but we need to complete it with a\r\n    // delta composed of the margin and left/top/right/bottom\r\n    node.layout[leading[mainAxis]] += getLeadingMargin(node, mainAxis) +\r\n      getRelativePosition(node, mainAxis);\r\n    node.layout[trailing[mainAxis]] += getTrailingMargin(node, mainAxis) +\r\n      getRelativePosition(node, mainAxis);\r\n    node.layout[leading[crossAxis]] += getLeadingMargin(node, crossAxis) +\r\n      getRelativePosition(node, crossAxis);\r\n    node.layout[trailing[crossAxis]] += getTrailingMargin(node, crossAxis) +\r\n      getRelativePosition(node, crossAxis);\r\n\r\n    // Inline immutable values from the target node to avoid excessive method\r\n    // invocations during the layout calculation.\r\n    var/*int*/ childCount = node.children.length;\r\n    var/*float*/ paddingAndBorderAxisResolvedRow = getPaddingAndBorderAxis(node, resolvedRowAxis);\r\n\r\n    if (isMeasureDefined(node)) {\r\n      var/*bool*/ isResolvedRowDimDefined = !isUndefined(node.layout[dim[resolvedRowAxis]]);\r\n\r\n      var/*float*/ width = CSS_UNDEFINED;\r\n      if (isDimDefined(node, resolvedRowAxis)) {\r\n        width = node.style.width;\r\n      } else if (isResolvedRowDimDefined) {\r\n        width = node.layout[dim[resolvedRowAxis]];\r\n      } else {\r\n        width = parentMaxWidth -\r\n          getMarginAxis(node, resolvedRowAxis);\r\n      }\r\n      width -= paddingAndBorderAxisResolvedRow;\r\n\r\n      // We only need to give a dimension for the text if we haven't got any\r\n      // for it computed yet. It can either be from the style attribute or because\r\n      // the element is flexible.\r\n      var/*bool*/ isRowUndefined = !isDimDefined(node, resolvedRowAxis) && !isResolvedRowDimDefined;\r\n      var/*bool*/ isColumnUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN) &&\r\n        isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]]);\r\n\r\n      // Let's not measure the text if we already know both dimensions\r\n      if (isRowUndefined || isColumnUndefined) {\r\n        var/*css_dim_t*/ measureDim = node.style.measure(\r\n          /*(c)!node->context,*/\r\n          /*(java)!layoutContext.measureOutput,*/\r\n          width\r\n        );\r\n        if (isRowUndefined) {\r\n          node.layout.width = measureDim.width +\r\n            paddingAndBorderAxisResolvedRow;\r\n        }\r\n        if (isColumnUndefined) {\r\n          node.layout.height = measureDim.height +\r\n            getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);\r\n        }\r\n      }\r\n      if (childCount === 0) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    var/*bool*/ isNodeFlexWrap = isFlexWrap(node);\r\n\r\n    var/*css_justify_t*/ justifyContent = getJustifyContent(node);\r\n\r\n    var/*float*/ leadingPaddingAndBorderMain = getLeadingPaddingAndBorder(node, mainAxis);\r\n    var/*float*/ leadingPaddingAndBorderCross = getLeadingPaddingAndBorder(node, crossAxis);\r\n    var/*float*/ paddingAndBorderAxisMain = getPaddingAndBorderAxis(node, mainAxis);\r\n    var/*float*/ paddingAndBorderAxisCross = getPaddingAndBorderAxis(node, crossAxis);\r\n\r\n    var/*bool*/ isMainDimDefined = !isUndefined(node.layout[dim[mainAxis]]);\r\n    var/*bool*/ isCrossDimDefined = !isUndefined(node.layout[dim[crossAxis]]);\r\n    var/*bool*/ isMainRowDirection = isRowDirection(mainAxis);\r\n\r\n    var/*int*/ i;\r\n    var/*int*/ ii;\r\n    var/*css_node_t**/ child;\r\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ axis;\r\n\r\n    var/*css_node_t**/ firstAbsoluteChild = null;\r\n    var/*css_node_t**/ currentAbsoluteChild = null;\r\n\r\n    var/*float*/ definedMainDim = CSS_UNDEFINED;\r\n    if (isMainDimDefined) {\r\n      definedMainDim = node.layout[dim[mainAxis]] - paddingAndBorderAxisMain;\r\n    }\r\n\r\n    // We want to execute the next two loops one per line with flex-wrap\r\n    var/*int*/ startLine = 0;\r\n    var/*int*/ endLine = 0;\r\n    // var/*int*/ nextOffset = 0;\r\n    var/*int*/ alreadyComputedNextLayout = 0;\r\n    // We aggregate the total dimensions of the container in those two variables\r\n    var/*float*/ linesCrossDim = 0;\r\n    var/*float*/ linesMainDim = 0;\r\n    var/*int*/ linesCount = 0;\r\n    while (endLine < childCount) {\r\n      // <Loop A> Layout non flexible children and count children by type\r\n\r\n      // mainContentDim is accumulation of the dimensions and margin of all the\r\n      // non flexible children. This will be used in order to either set the\r\n      // dimensions of the node if none already exist, or to compute the\r\n      // remaining space left for the flexible children.\r\n      var/*float*/ mainContentDim = 0;\r\n\r\n      // There are three kind of children, non flexible, flexible and absolute.\r\n      // We need to know how many there are in order to distribute the space.\r\n      var/*int*/ flexibleChildrenCount = 0;\r\n      var/*float*/ totalFlexible = 0;\r\n      var/*int*/ nonFlexibleChildrenCount = 0;\r\n\r\n      // Use the line loop to position children in the main axis for as long\r\n      // as they are using a simple stacking behaviour. Children that are\r\n      // immediately stacked in the initial loop will not be touched again\r\n      // in <Loop C>.\r\n      var/*bool*/ isSimpleStackMain =\r\n          (isMainDimDefined && justifyContent === CSS_JUSTIFY_FLEX_START) ||\r\n          (!isMainDimDefined && justifyContent !== CSS_JUSTIFY_CENTER);\r\n      var/*int*/ firstComplexMain = (isSimpleStackMain ? childCount : startLine);\r\n\r\n      // Use the initial line loop to position children in the cross axis for\r\n      // as long as they are relatively positioned with alignment STRETCH or\r\n      // FLEX_START. Children that are immediately stacked in the initial loop\r\n      // will not be touched again in <Loop D>.\r\n      var/*bool*/ isSimpleStackCross = true;\r\n      var/*int*/ firstComplexCross = childCount;\r\n\r\n      var/*css_node_t**/ firstFlexChild = null;\r\n      var/*css_node_t**/ currentFlexChild = null;\r\n\r\n      var/*float*/ mainDim = leadingPaddingAndBorderMain;\r\n      var/*float*/ crossDim = 0;\r\n\r\n      var/*float*/ maxWidth;\r\n      for (i = startLine; i < childCount; ++i) {\r\n        child = node.children[i];\r\n        child.lineIndex = linesCount;\r\n\r\n        child.nextAbsoluteChild = null;\r\n        child.nextFlexChild = null;\r\n\r\n        var/*css_align_t*/ alignItem = getAlignItem(node, child);\r\n\r\n        // Pre-fill cross axis dimensions when the child is using stretch before\r\n        // we call the recursive layout pass\r\n        if (alignItem === CSS_ALIGN_STRETCH &&\r\n            getPositionType(child) === CSS_POSITION_RELATIVE &&\r\n            isCrossDimDefined &&\r\n            !isDimDefined(child, crossAxis)) {\r\n          child.layout[dim[crossAxis]] = fmaxf(\r\n            boundAxis(child, crossAxis, node.layout[dim[crossAxis]] -\r\n              paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),\r\n            // You never want to go smaller than padding\r\n            getPaddingAndBorderAxis(child, crossAxis)\r\n          );\r\n        } else if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {\r\n          // Store a private linked list of absolutely positioned children\r\n          // so that we can efficiently traverse them later.\r\n          if (firstAbsoluteChild === null) {\r\n            firstAbsoluteChild = child;\r\n          }\r\n          if (currentAbsoluteChild !== null) {\r\n            currentAbsoluteChild.nextAbsoluteChild = child;\r\n          }\r\n          currentAbsoluteChild = child;\r\n\r\n          // Pre-fill dimensions when using absolute position and both offsets for the axis are defined (either both\r\n          // left and right or top and bottom).\r\n          for (ii = 0; ii < 2; ii++) {\r\n            axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\r\n            if (!isUndefined(node.layout[dim[axis]]) &&\r\n                !isDimDefined(child, axis) &&\r\n                isPosDefined(child, leading[axis]) &&\r\n                isPosDefined(child, trailing[axis])) {\r\n              child.layout[dim[axis]] = fmaxf(\r\n                boundAxis(child, axis, node.layout[dim[axis]] -\r\n                  getPaddingAndBorderAxis(node, axis) -\r\n                  getMarginAxis(child, axis) -\r\n                  getPosition(child, leading[axis]) -\r\n                  getPosition(child, trailing[axis])),\r\n                // You never want to go smaller than padding\r\n                getPaddingAndBorderAxis(child, axis)\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        var/*float*/ nextContentDim = 0;\r\n\r\n        // It only makes sense to consider a child flexible if we have a computed\r\n        // dimension for the node.\r\n        if (isMainDimDefined && isFlex(child)) {\r\n          flexibleChildrenCount++;\r\n          totalFlexible += child.style.flex;\r\n\r\n          // Store a private linked list of flexible children so that we can\r\n          // efficiently traverse them later.\r\n          if (firstFlexChild === null) {\r\n            firstFlexChild = child;\r\n          }\r\n          if (currentFlexChild !== null) {\r\n            currentFlexChild.nextFlexChild = child;\r\n          }\r\n          currentFlexChild = child;\r\n\r\n          // Even if we don't know its exact size yet, we already know the padding,\r\n          // border and margin. We'll use this partial information, which represents\r\n          // the smallest possible size for the child, to compute the remaining\r\n          // available space.\r\n          nextContentDim = getPaddingAndBorderAxis(child, mainAxis) +\r\n            getMarginAxis(child, mainAxis);\r\n\r\n        } else {\r\n          maxWidth = CSS_UNDEFINED;\r\n          if (!isMainRowDirection) {\r\n            if (isDimDefined(node, resolvedRowAxis)) {\r\n              maxWidth = node.layout[dim[resolvedRowAxis]] -\r\n                paddingAndBorderAxisResolvedRow;\r\n            } else {\r\n              maxWidth = parentMaxWidth -\r\n                getMarginAxis(node, resolvedRowAxis) -\r\n                paddingAndBorderAxisResolvedRow;\r\n            }\r\n          }\r\n\r\n          // This is the main recursive call. We layout non flexible children.\r\n          if (alreadyComputedNextLayout === 0) {\r\n            layoutNode(/*(java)!layoutContext, */child, maxWidth, direction);\r\n          }\r\n\r\n          // Absolute positioned elements do not take part of the layout, so we\r\n          // don't use them to compute mainContentDim\r\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\r\n            nonFlexibleChildrenCount++;\r\n            // At this point we know the final size and margin of the element.\r\n            nextContentDim = getDimWithMargin(child, mainAxis);\r\n          }\r\n        }\r\n\r\n        // The element we are about to add would make us go to the next line\r\n        if (isNodeFlexWrap &&\r\n            isMainDimDefined &&\r\n            mainContentDim + nextContentDim > definedMainDim &&\r\n            // If there's only one element, then it's bigger than the content\r\n            // and needs its own line\r\n            i !== startLine) {\r\n          nonFlexibleChildrenCount--;\r\n          alreadyComputedNextLayout = 1;\r\n          break;\r\n        }\r\n\r\n        // Disable simple stacking in the main axis for the current line as\r\n        // we found a non-trivial child. The remaining children will be laid out\r\n        // in <Loop C>.\r\n        if (isSimpleStackMain &&\r\n            (getPositionType(child) !== CSS_POSITION_RELATIVE || isFlex(child))) {\r\n          isSimpleStackMain = false;\r\n          firstComplexMain = i;\r\n        }\r\n\r\n        // Disable simple stacking in the cross axis for the current line as\r\n        // we found a non-trivial child. The remaining children will be laid out\r\n        // in <Loop D>.\r\n        if (isSimpleStackCross &&\r\n            (getPositionType(child) !== CSS_POSITION_RELATIVE ||\r\n                (alignItem !== CSS_ALIGN_STRETCH && alignItem !== CSS_ALIGN_FLEX_START) ||\r\n                isUndefined(child.layout[dim[crossAxis]]))) {\r\n          isSimpleStackCross = false;\r\n          firstComplexCross = i;\r\n        }\r\n\r\n        if (isSimpleStackMain) {\r\n          child.layout[pos[mainAxis]] += mainDim;\r\n          if (isMainDimDefined) {\r\n            setTrailingPosition(node, child, mainAxis);\r\n          }\r\n\r\n          mainDim += getDimWithMargin(child, mainAxis);\r\n          crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));\r\n        }\r\n\r\n        if (isSimpleStackCross) {\r\n          child.layout[pos[crossAxis]] += linesCrossDim + leadingPaddingAndBorderCross;\r\n          if (isCrossDimDefined) {\r\n            setTrailingPosition(node, child, crossAxis);\r\n          }\r\n        }\r\n\r\n        alreadyComputedNextLayout = 0;\r\n        mainContentDim += nextContentDim;\r\n        endLine = i + 1;\r\n      }\r\n\r\n      // <Loop B> Layout flexible children and allocate empty space\r\n\r\n      // In order to position the elements in the main axis, we have two\r\n      // controls. The space between the beginning and the first element\r\n      // and the space between each two elements.\r\n      var/*float*/ leadingMainDim = 0;\r\n      var/*float*/ betweenMainDim = 0;\r\n\r\n      // The remaining available space that needs to be allocated\r\n      var/*float*/ remainingMainDim = 0;\r\n      if (isMainDimDefined) {\r\n        remainingMainDim = definedMainDim - mainContentDim;\r\n      } else {\r\n        remainingMainDim = fmaxf(mainContentDim, 0) - mainContentDim;\r\n      }\r\n\r\n      // If there are flexible children in the mix, they are going to fill the\r\n      // remaining space\r\n      if (flexibleChildrenCount !== 0) {\r\n        var/*float*/ flexibleMainDim = remainingMainDim / totalFlexible;\r\n        var/*float*/ baseMainDim;\r\n        var/*float*/ boundMainDim;\r\n\r\n        // If the flex share of remaining space doesn't meet min/max bounds,\r\n        // remove this child from flex calculations.\r\n        currentFlexChild = firstFlexChild;\r\n        while (currentFlexChild !== null) {\r\n          baseMainDim = flexibleMainDim * currentFlexChild.style.flex +\r\n              getPaddingAndBorderAxis(currentFlexChild, mainAxis);\r\n          boundMainDim = boundAxis(currentFlexChild, mainAxis, baseMainDim);\r\n\r\n          if (baseMainDim !== boundMainDim) {\r\n            remainingMainDim -= boundMainDim;\r\n            totalFlexible -= currentFlexChild.style.flex;\r\n          }\r\n\r\n          currentFlexChild = currentFlexChild.nextFlexChild;\r\n        }\r\n        flexibleMainDim = remainingMainDim / totalFlexible;\r\n\r\n        // The non flexible children can overflow the container, in this case\r\n        // we should just assume that there is no space available.\r\n        if (flexibleMainDim < 0) {\r\n          flexibleMainDim = 0;\r\n        }\r\n\r\n        currentFlexChild = firstFlexChild;\r\n        while (currentFlexChild !== null) {\r\n          // At this point we know the final size of the element in the main\r\n          // dimension\r\n          currentFlexChild.layout[dim[mainAxis]] = boundAxis(currentFlexChild, mainAxis,\r\n            flexibleMainDim * currentFlexChild.style.flex +\r\n                getPaddingAndBorderAxis(currentFlexChild, mainAxis)\r\n          );\r\n\r\n          maxWidth = CSS_UNDEFINED;\r\n          if (isDimDefined(node, resolvedRowAxis)) {\r\n            maxWidth = node.layout[dim[resolvedRowAxis]] -\r\n              paddingAndBorderAxisResolvedRow;\r\n          } else if (!isMainRowDirection) {\r\n            maxWidth = parentMaxWidth -\r\n              getMarginAxis(node, resolvedRowAxis) -\r\n              paddingAndBorderAxisResolvedRow;\r\n          }\r\n\r\n          // And we recursively call the layout algorithm for this child\r\n          layoutNode(/*(java)!layoutContext, */currentFlexChild, maxWidth, direction);\r\n\r\n          child = currentFlexChild;\r\n          currentFlexChild = currentFlexChild.nextFlexChild;\r\n          child.nextFlexChild = null;\r\n        }\r\n\r\n      // We use justifyContent to figure out how to allocate the remaining\r\n      // space available\r\n      } else if (justifyContent !== CSS_JUSTIFY_FLEX_START) {\r\n        if (justifyContent === CSS_JUSTIFY_CENTER) {\r\n          leadingMainDim = remainingMainDim / 2;\r\n        } else if (justifyContent === CSS_JUSTIFY_FLEX_END) {\r\n          leadingMainDim = remainingMainDim;\r\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_BETWEEN) {\r\n          remainingMainDim = fmaxf(remainingMainDim, 0);\r\n          if (flexibleChildrenCount + nonFlexibleChildrenCount - 1 !== 0) {\r\n            betweenMainDim = remainingMainDim /\r\n              (flexibleChildrenCount + nonFlexibleChildrenCount - 1);\r\n          } else {\r\n            betweenMainDim = 0;\r\n          }\r\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_AROUND) {\r\n          // Space on the edges is half of the space between elements\r\n          betweenMainDim = remainingMainDim /\r\n            (flexibleChildrenCount + nonFlexibleChildrenCount);\r\n          leadingMainDim = betweenMainDim / 2;\r\n        }\r\n      }\r\n\r\n      // <Loop C> Position elements in the main axis and compute dimensions\r\n\r\n      // At this point, all the children have their dimensions set. We need to\r\n      // find their position. In order to do that, we accumulate data in\r\n      // variables that are also useful to compute the total dimensions of the\r\n      // container!\r\n      mainDim += leadingMainDim;\r\n\r\n      for (i = firstComplexMain; i < endLine; ++i) {\r\n        child = node.children[i];\r\n\r\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\r\n            isPosDefined(child, leading[mainAxis])) {\r\n          // In case the child is position absolute and has left/top being\r\n          // defined, we override the position to whatever the user said\r\n          // (and margin/border).\r\n          child.layout[pos[mainAxis]] = getPosition(child, leading[mainAxis]) +\r\n            getLeadingBorder(node, mainAxis) +\r\n            getLeadingMargin(child, mainAxis);\r\n        } else {\r\n          // If the child is position absolute (without top/left) or relative,\r\n          // we put it at the current accumulated offset.\r\n          child.layout[pos[mainAxis]] += mainDim;\r\n\r\n          // Define the trailing position accordingly.\r\n          if (isMainDimDefined) {\r\n            setTrailingPosition(node, child, mainAxis);\r\n          }\r\n\r\n          // Now that we placed the element, we need to update the variables\r\n          // We only need to do that for relative elements. Absolute elements\r\n          // do not take part in that phase.\r\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\r\n            // The main dimension is the sum of all the elements dimension plus\r\n            // the spacing.\r\n            mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);\r\n            // The cross dimension is the max of the elements dimension since there\r\n            // can only be one element in that cross dimension.\r\n            crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));\r\n          }\r\n        }\r\n      }\r\n\r\n      var/*float*/ containerCrossAxis = node.layout[dim[crossAxis]];\r\n      if (!isCrossDimDefined) {\r\n        containerCrossAxis = fmaxf(\r\n          // For the cross dim, we add both sides at the end because the value\r\n          // is aggregate via a max function. Intermediate negative values\r\n          // can mess this computation otherwise\r\n          boundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross),\r\n          paddingAndBorderAxisCross\r\n        );\r\n      }\r\n\r\n      // <Loop D> Position elements in the cross axis\r\n      for (i = firstComplexCross; i < endLine; ++i) {\r\n        child = node.children[i];\r\n\r\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\r\n            isPosDefined(child, leading[crossAxis])) {\r\n          // In case the child is absolutely positionned and has a\r\n          // top/left/bottom/right being set, we override all the previously\r\n          // computed positions to set it correctly.\r\n          child.layout[pos[crossAxis]] = getPosition(child, leading[crossAxis]) +\r\n            getLeadingBorder(node, crossAxis) +\r\n            getLeadingMargin(child, crossAxis);\r\n\r\n        } else {\r\n          var/*float*/ leadingCrossDim = leadingPaddingAndBorderCross;\r\n\r\n          // For a relative children, we're either using alignItems (parent) or\r\n          // alignSelf (child) in order to determine the position in the cross axis\r\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\r\n            /*eslint-disable */\r\n            // This variable is intentionally re-defined as the code is transpiled to a block scope language\r\n            var/*css_align_t*/ alignItem = getAlignItem(node, child);\r\n            /*eslint-enable */\r\n            if (alignItem === CSS_ALIGN_STRETCH) {\r\n              // You can only stretch if the dimension has not already been set\r\n              // previously.\r\n              if (isUndefined(child.layout[dim[crossAxis]])) {\r\n                child.layout[dim[crossAxis]] = fmaxf(\r\n                  boundAxis(child, crossAxis, containerCrossAxis -\r\n                    paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),\r\n                  // You never want to go smaller than padding\r\n                  getPaddingAndBorderAxis(child, crossAxis)\r\n                );\r\n              }\r\n            } else if (alignItem !== CSS_ALIGN_FLEX_START) {\r\n              // The remaining space between the parent dimensions+padding and child\r\n              // dimensions+margin.\r\n              var/*float*/ remainingCrossDim = containerCrossAxis -\r\n                paddingAndBorderAxisCross - getDimWithMargin(child, crossAxis);\r\n\r\n              if (alignItem === CSS_ALIGN_CENTER) {\r\n                leadingCrossDim += remainingCrossDim / 2;\r\n              } else { // CSS_ALIGN_FLEX_END\r\n                leadingCrossDim += remainingCrossDim;\r\n              }\r\n            }\r\n          }\r\n\r\n          // And we apply the position\r\n          child.layout[pos[crossAxis]] += linesCrossDim + leadingCrossDim;\r\n\r\n          // Define the trailing position accordingly.\r\n          if (isCrossDimDefined) {\r\n            setTrailingPosition(node, child, crossAxis);\r\n          }\r\n        }\r\n      }\r\n\r\n      linesCrossDim += crossDim;\r\n      linesMainDim = fmaxf(linesMainDim, mainDim);\r\n      linesCount += 1;\r\n      startLine = endLine;\r\n    }\r\n\r\n    // <Loop E>\r\n    //\r\n    // Note(prenaux): More than one line, we need to layout the crossAxis\r\n    // according to alignContent.\r\n    //\r\n    // Note that we could probably remove <Loop D> and handle the one line case\r\n    // here too, but for the moment this is safer since it won't interfere with\r\n    // previously working code.\r\n    //\r\n    // See specs:\r\n    // http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm\r\n    // section 9.4\r\n    //\r\n    if (linesCount > 1 && isCrossDimDefined) {\r\n      var/*float*/ nodeCrossAxisInnerSize = node.layout[dim[crossAxis]] -\r\n          paddingAndBorderAxisCross;\r\n      var/*float*/ remainingAlignContentDim = nodeCrossAxisInnerSize - linesCrossDim;\r\n\r\n      var/*float*/ crossDimLead = 0;\r\n      var/*float*/ currentLead = leadingPaddingAndBorderCross;\r\n\r\n      var/*css_align_t*/ alignContent = getAlignContent(node);\r\n      if (alignContent === CSS_ALIGN_FLEX_END) {\r\n        currentLead += remainingAlignContentDim;\r\n      } else if (alignContent === CSS_ALIGN_CENTER) {\r\n        currentLead += remainingAlignContentDim / 2;\r\n      } else if (alignContent === CSS_ALIGN_STRETCH) {\r\n        if (nodeCrossAxisInnerSize > linesCrossDim) {\r\n          crossDimLead = (remainingAlignContentDim / linesCount);\r\n        }\r\n      }\r\n\r\n      var/*int*/ endIndex = 0;\r\n      for (i = 0; i < linesCount; ++i) {\r\n        var/*int*/ startIndex = endIndex;\r\n\r\n        // compute the line's height and find the endIndex\r\n        var/*float*/ lineHeight = 0;\r\n        for (ii = startIndex; ii < childCount; ++ii) {\r\n          child = node.children[ii];\r\n          if (getPositionType(child) !== CSS_POSITION_RELATIVE) {\r\n            continue;\r\n          }\r\n          if (child.lineIndex !== i) {\r\n            break;\r\n          }\r\n          if (!isUndefined(child.layout[dim[crossAxis]])) {\r\n            lineHeight = fmaxf(\r\n              lineHeight,\r\n              child.layout[dim[crossAxis]] + getMarginAxis(child, crossAxis)\r\n            );\r\n          }\r\n        }\r\n        endIndex = ii;\r\n        lineHeight += crossDimLead;\r\n\r\n        for (ii = startIndex; ii < endIndex; ++ii) {\r\n          child = node.children[ii];\r\n          if (getPositionType(child) !== CSS_POSITION_RELATIVE) {\r\n            continue;\r\n          }\r\n\r\n          var/*css_align_t*/ alignContentAlignItem = getAlignItem(node, child);\r\n          if (alignContentAlignItem === CSS_ALIGN_FLEX_START) {\r\n            child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\r\n          } else if (alignContentAlignItem === CSS_ALIGN_FLEX_END) {\r\n            child.layout[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child.layout[dim[crossAxis]];\r\n          } else if (alignContentAlignItem === CSS_ALIGN_CENTER) {\r\n            var/*float*/ childHeight = child.layout[dim[crossAxis]];\r\n            child.layout[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;\r\n          } else if (alignContentAlignItem === CSS_ALIGN_STRETCH) {\r\n            child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\r\n            // TODO(prenaux): Correctly set the height of items with undefined\r\n            //                (auto) crossAxis dimension.\r\n          }\r\n        }\r\n\r\n        currentLead += lineHeight;\r\n      }\r\n    }\r\n\r\n    var/*bool*/ needsMainTrailingPos = false;\r\n    var/*bool*/ needsCrossTrailingPos = false;\r\n\r\n    // If the user didn't specify a width or height, and it has not been set\r\n    // by the container, then we set it via the children.\r\n    if (!isMainDimDefined) {\r\n      node.layout[dim[mainAxis]] = fmaxf(\r\n        // We're missing the last padding at this point to get the final\r\n        // dimension\r\n        boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),\r\n        // We can never assign a width smaller than the padding and borders\r\n        paddingAndBorderAxisMain\r\n      );\r\n\r\n      if (mainAxis === CSS_FLEX_DIRECTION_ROW_REVERSE ||\r\n          mainAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\r\n        needsMainTrailingPos = true;\r\n      }\r\n    }\r\n\r\n    if (!isCrossDimDefined) {\r\n      node.layout[dim[crossAxis]] = fmaxf(\r\n        // For the cross dim, we add both sides at the end because the value\r\n        // is aggregate via a max function. Intermediate negative values\r\n        // can mess this computation otherwise\r\n        boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross),\r\n        paddingAndBorderAxisCross\r\n      );\r\n\r\n      if (crossAxis === CSS_FLEX_DIRECTION_ROW_REVERSE ||\r\n          crossAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\r\n        needsCrossTrailingPos = true;\r\n      }\r\n    }\r\n\r\n    // <Loop F> Set trailing position if necessary\r\n    if (needsMainTrailingPos || needsCrossTrailingPos) {\r\n      for (i = 0; i < childCount; ++i) {\r\n        child = node.children[i];\r\n\r\n        if (needsMainTrailingPos) {\r\n          setTrailingPosition(node, child, mainAxis);\r\n        }\r\n\r\n        if (needsCrossTrailingPos) {\r\n          setTrailingPosition(node, child, crossAxis);\r\n        }\r\n      }\r\n    }\r\n\r\n    // <Loop G> Calculate dimensions for absolutely positioned elements\r\n    currentAbsoluteChild = firstAbsoluteChild;\r\n    while (currentAbsoluteChild !== null) {\r\n      // Pre-fill dimensions when using absolute position and both offsets for\r\n      // the axis are defined (either both left and right or top and bottom).\r\n      for (ii = 0; ii < 2; ii++) {\r\n        axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\r\n\r\n        if (!isUndefined(node.layout[dim[axis]]) &&\r\n            !isDimDefined(currentAbsoluteChild, axis) &&\r\n            isPosDefined(currentAbsoluteChild, leading[axis]) &&\r\n            isPosDefined(currentAbsoluteChild, trailing[axis])) {\r\n          currentAbsoluteChild.layout[dim[axis]] = fmaxf(\r\n            boundAxis(currentAbsoluteChild, axis, node.layout[dim[axis]] -\r\n              getBorderAxis(node, axis) -\r\n              getMarginAxis(currentAbsoluteChild, axis) -\r\n              getPosition(currentAbsoluteChild, leading[axis]) -\r\n              getPosition(currentAbsoluteChild, trailing[axis])\r\n            ),\r\n            // You never want to go smaller than padding\r\n            getPaddingAndBorderAxis(currentAbsoluteChild, axis)\r\n          );\r\n        }\r\n\r\n        if (isPosDefined(currentAbsoluteChild, trailing[axis]) &&\r\n            !isPosDefined(currentAbsoluteChild, leading[axis])) {\r\n          currentAbsoluteChild.layout[leading[axis]] =\r\n            node.layout[dim[axis]] -\r\n            currentAbsoluteChild.layout[dim[axis]] -\r\n            getPosition(currentAbsoluteChild, trailing[axis]);\r\n        }\r\n      }\r\n\r\n      child = currentAbsoluteChild;\r\n      currentAbsoluteChild = currentAbsoluteChild.nextAbsoluteChild;\r\n      child.nextAbsoluteChild = null;\r\n    }\r\n  }\r\n\r\n  function layoutNode(node, parentMaxWidth, parentDirection) {\r\n    node.shouldUpdate = true;\r\n\r\n    var direction = node.style.direction || CSS_DIRECTION_LTR;\r\n    var skipLayout =\r\n      !node.isDirty &&\r\n      node.lastLayout &&\r\n      node.lastLayout.requestedHeight === node.layout.height &&\r\n      node.lastLayout.requestedWidth === node.layout.width &&\r\n      node.lastLayout.parentMaxWidth === parentMaxWidth &&\r\n      node.lastLayout.direction === direction;\r\n\r\n    if (skipLayout) {\r\n      node.layout.width = node.lastLayout.width;\r\n      node.layout.height = node.lastLayout.height;\r\n      node.layout.top = node.lastLayout.top;\r\n      node.layout.left = node.lastLayout.left;\r\n    } else {\r\n      if (!node.lastLayout) {\r\n        node.lastLayout = {};\r\n      }\r\n\r\n      node.lastLayout.requestedWidth = node.layout.width;\r\n      node.lastLayout.requestedHeight = node.layout.height;\r\n      node.lastLayout.parentMaxWidth = parentMaxWidth;\r\n      node.lastLayout.direction = direction;\r\n\r\n      // Reset child layouts\r\n      node.children.forEach(function(child) {\r\n        child.layout.width = undefined;\r\n        child.layout.height = undefined;\r\n        child.layout.top = 0;\r\n        child.layout.left = 0;\r\n      });\r\n\r\n      layoutNodeImpl(node, parentMaxWidth, parentDirection);\r\n\r\n      node.lastLayout.width = node.layout.width;\r\n      node.lastLayout.height = node.layout.height;\r\n      node.lastLayout.top = node.layout.top;\r\n      node.lastLayout.left = node.layout.left;\r\n    }\r\n  }\r\n\r\n  return {\r\n    layoutNodeImpl: layoutNodeImpl,\r\n    computeLayout: layoutNode,\r\n    fillNodes: fillNodes\r\n  };\r\n})();\r\n\r\n// This module export is only used for the purposes of unit testing this file. When\r\n// the library is packaged this file is included within css-layout.js which forms\r\n// the public API.\r\nif (typeof exports === 'object') {\r\n  module.exports = computeLayout;\r\n}\r\n\r\n\r\n  return function(node) {\r\n    /*eslint-disable */\r\n    // disabling ESLint because this code relies on the above include\r\n    computeLayout.fillNodes(node);\r\n    computeLayout.computeLayout(node);\r\n    /*eslint-enable */\r\n  };\r\n}));\r\n"]}