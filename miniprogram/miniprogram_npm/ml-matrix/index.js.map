{"version":3,"sources":["matrix.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\n\r\nObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\nvar isAnyArray = require('is-any-array');\r\nvar rescale = require('ml-array-rescale');\r\n\r\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\r\n\r\nvar rescale__default = /*#__PURE__*/_interopDefaultLegacy(rescale);\r\n\r\nconst indent = ' '.repeat(2);\r\nconst indentData = ' '.repeat(4);\r\n\r\nfunction inspectMatrix() {\r\n  return inspectMatrixWithOptions(this);\r\n}\r\n\r\nfunction inspectMatrixWithOptions(matrix, options = {}) {\r\n  const {\r\n    maxRows = 15,\r\n    maxColumns = 10,\r\n    maxNumSize = 8,\r\n    padMinus = 'auto',\r\n  } = options;\r\n  return `${matrix.constructor.name} {\r\n${indent}[\r\n${indentData}${inspectData(matrix, maxRows, maxColumns, maxNumSize, padMinus)}\r\n${indent}]\r\n${indent}rows: ${matrix.rows}\r\n${indent}columns: ${matrix.columns}\r\n}`;\r\n}\r\n\r\nfunction inspectData(matrix, maxRows, maxColumns, maxNumSize, padMinus) {\r\n  const { rows, columns } = matrix;\r\n  const maxI = Math.min(rows, maxRows);\r\n  const maxJ = Math.min(columns, maxColumns);\r\n  const result = [];\r\n\r\n  if (padMinus === 'auto') {\r\n    padMinus = false;\r\n    loop: for (let i = 0; i < maxI; i++) {\r\n      for (let j = 0; j < maxJ; j++) {\r\n        if (matrix.get(i, j) < 0) {\r\n          padMinus = true;\r\n          break loop;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < maxI; i++) {\r\n    let line = [];\r\n    for (let j = 0; j < maxJ; j++) {\r\n      line.push(formatNumber(matrix.get(i, j), maxNumSize, padMinus));\r\n    }\r\n    result.push(`${line.join(' ')}`);\r\n  }\r\n  if (maxJ !== columns) {\r\n    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;\r\n  }\r\n  if (maxI !== rows) {\r\n    result.push(`... ${rows - maxRows} more rows`);\r\n  }\r\n  return result.join(`\\n${indentData}`);\r\n}\r\n\r\nfunction formatNumber(num, maxNumSize, padMinus) {\r\n  return (\r\n    num >= 0 && padMinus\r\n      ? ` ${formatNumber2(num, maxNumSize - 1)}`\r\n      : formatNumber2(num, maxNumSize)\r\n  ).padEnd(maxNumSize);\r\n}\r\n\r\nfunction formatNumber2(num, len) {\r\n  // small.length numbers should be as is\r\n  let str = num.toString();\r\n  if (str.length <= len) return str;\r\n\r\n  // (7)'0.00123' is better then (7)'1.23e-2'\r\n  // (8)'0.000123' is worse then (7)'1.23e-3',\r\n  let fix = num.toFixed(len);\r\n  if (fix.length > len) {\r\n    fix = num.toFixed(Math.max(0, len - (fix.length - len)));\r\n  }\r\n  if (\r\n    fix.length <= len &&\r\n    !fix.startsWith('0.000') &&\r\n    !fix.startsWith('-0.000')\r\n  ) {\r\n    return fix;\r\n  }\r\n\r\n  // well, if it's still too long the user should've used longer numbers\r\n  let exp = num.toExponential(len);\r\n  if (exp.length > len) {\r\n    exp = num.toExponential(Math.max(0, len - (exp.length - len)));\r\n  }\r\n  return exp.slice(0);\r\n}\r\n\r\nfunction installMathOperations(AbstractMatrix, Matrix) {\r\n  AbstractMatrix.prototype.add = function add(value) {\r\n    if (typeof value === 'number') return this.addS(value);\r\n    return this.addM(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.addS = function addS(value) {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) + value);\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.prototype.addM = function addM(matrix) {\r\n    matrix = Matrix.checkMatrix(matrix);\r\n    if (this.rows !== matrix.rows ||\r\n      this.columns !== matrix.columns) {\r\n      throw new RangeError('Matrices dimensions must be equal');\r\n    }\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) + matrix.get(i, j));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.add = function add(matrix, value) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.add(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.sub = function sub(value) {\r\n    if (typeof value === 'number') return this.subS(value);\r\n    return this.subM(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.subS = function subS(value) {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) - value);\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.prototype.subM = function subM(matrix) {\r\n    matrix = Matrix.checkMatrix(matrix);\r\n    if (this.rows !== matrix.rows ||\r\n      this.columns !== matrix.columns) {\r\n      throw new RangeError('Matrices dimensions must be equal');\r\n    }\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) - matrix.get(i, j));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.sub = function sub(matrix, value) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.sub(value);\r\n  };\r\n  AbstractMatrix.prototype.subtract = AbstractMatrix.prototype.sub;\r\n  AbstractMatrix.prototype.subtractS = AbstractMatrix.prototype.subS;\r\n  AbstractMatrix.prototype.subtractM = AbstractMatrix.prototype.subM;\r\n  AbstractMatrix.subtract = AbstractMatrix.sub;\r\n\r\n  AbstractMatrix.prototype.mul = function mul(value) {\r\n    if (typeof value === 'number') return this.mulS(value);\r\n    return this.mulM(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.mulS = function mulS(value) {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) * value);\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.prototype.mulM = function mulM(matrix) {\r\n    matrix = Matrix.checkMatrix(matrix);\r\n    if (this.rows !== matrix.rows ||\r\n      this.columns !== matrix.columns) {\r\n      throw new RangeError('Matrices dimensions must be equal');\r\n    }\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) * matrix.get(i, j));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.mul = function mul(matrix, value) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.mul(value);\r\n  };\r\n  AbstractMatrix.prototype.multiply = AbstractMatrix.prototype.mul;\r\n  AbstractMatrix.prototype.multiplyS = AbstractMatrix.prototype.mulS;\r\n  AbstractMatrix.prototype.multiplyM = AbstractMatrix.prototype.mulM;\r\n  AbstractMatrix.multiply = AbstractMatrix.mul;\r\n\r\n  AbstractMatrix.prototype.div = function div(value) {\r\n    if (typeof value === 'number') return this.divS(value);\r\n    return this.divM(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.divS = function divS(value) {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) / value);\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.prototype.divM = function divM(matrix) {\r\n    matrix = Matrix.checkMatrix(matrix);\r\n    if (this.rows !== matrix.rows ||\r\n      this.columns !== matrix.columns) {\r\n      throw new RangeError('Matrices dimensions must be equal');\r\n    }\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) / matrix.get(i, j));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.div = function div(matrix, value) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.div(value);\r\n  };\r\n  AbstractMatrix.prototype.divide = AbstractMatrix.prototype.div;\r\n  AbstractMatrix.prototype.divideS = AbstractMatrix.prototype.divS;\r\n  AbstractMatrix.prototype.divideM = AbstractMatrix.prototype.divM;\r\n  AbstractMatrix.divide = AbstractMatrix.div;\r\n\r\n  AbstractMatrix.prototype.mod = function mod(value) {\r\n    if (typeof value === 'number') return this.modS(value);\r\n    return this.modM(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.modS = function modS(value) {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) % value);\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.prototype.modM = function modM(matrix) {\r\n    matrix = Matrix.checkMatrix(matrix);\r\n    if (this.rows !== matrix.rows ||\r\n      this.columns !== matrix.columns) {\r\n      throw new RangeError('Matrices dimensions must be equal');\r\n    }\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) % matrix.get(i, j));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.mod = function mod(matrix, value) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.mod(value);\r\n  };\r\n  AbstractMatrix.prototype.modulus = AbstractMatrix.prototype.mod;\r\n  AbstractMatrix.prototype.modulusS = AbstractMatrix.prototype.modS;\r\n  AbstractMatrix.prototype.modulusM = AbstractMatrix.prototype.modM;\r\n  AbstractMatrix.modulus = AbstractMatrix.mod;\r\n\r\n  AbstractMatrix.prototype.and = function and(value) {\r\n    if (typeof value === 'number') return this.andS(value);\r\n    return this.andM(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.andS = function andS(value) {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) & value);\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.prototype.andM = function andM(matrix) {\r\n    matrix = Matrix.checkMatrix(matrix);\r\n    if (this.rows !== matrix.rows ||\r\n      this.columns !== matrix.columns) {\r\n      throw new RangeError('Matrices dimensions must be equal');\r\n    }\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) & matrix.get(i, j));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.and = function and(matrix, value) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.and(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.or = function or(value) {\r\n    if (typeof value === 'number') return this.orS(value);\r\n    return this.orM(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.orS = function orS(value) {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) | value);\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.prototype.orM = function orM(matrix) {\r\n    matrix = Matrix.checkMatrix(matrix);\r\n    if (this.rows !== matrix.rows ||\r\n      this.columns !== matrix.columns) {\r\n      throw new RangeError('Matrices dimensions must be equal');\r\n    }\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) | matrix.get(i, j));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.or = function or(matrix, value) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.or(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.xor = function xor(value) {\r\n    if (typeof value === 'number') return this.xorS(value);\r\n    return this.xorM(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.xorS = function xorS(value) {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) ^ value);\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.prototype.xorM = function xorM(matrix) {\r\n    matrix = Matrix.checkMatrix(matrix);\r\n    if (this.rows !== matrix.rows ||\r\n      this.columns !== matrix.columns) {\r\n      throw new RangeError('Matrices dimensions must be equal');\r\n    }\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) ^ matrix.get(i, j));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.xor = function xor(matrix, value) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.xor(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.leftShift = function leftShift(value) {\r\n    if (typeof value === 'number') return this.leftShiftS(value);\r\n    return this.leftShiftM(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.leftShiftS = function leftShiftS(value) {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) << value);\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.prototype.leftShiftM = function leftShiftM(matrix) {\r\n    matrix = Matrix.checkMatrix(matrix);\r\n    if (this.rows !== matrix.rows ||\r\n      this.columns !== matrix.columns) {\r\n      throw new RangeError('Matrices dimensions must be equal');\r\n    }\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) << matrix.get(i, j));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.leftShift = function leftShift(matrix, value) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.leftShift(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {\r\n    if (typeof value === 'number') return this.signPropagatingRightShiftS(value);\r\n    return this.signPropagatingRightShiftM(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) >> value);\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {\r\n    matrix = Matrix.checkMatrix(matrix);\r\n    if (this.rows !== matrix.rows ||\r\n      this.columns !== matrix.columns) {\r\n      throw new RangeError('Matrices dimensions must be equal');\r\n    }\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) >> matrix.get(i, j));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.signPropagatingRightShift(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.rightShift = function rightShift(value) {\r\n    if (typeof value === 'number') return this.rightShiftS(value);\r\n    return this.rightShiftM(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.rightShiftS = function rightShiftS(value) {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) >>> value);\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.prototype.rightShiftM = function rightShiftM(matrix) {\r\n    matrix = Matrix.checkMatrix(matrix);\r\n    if (this.rows !== matrix.rows ||\r\n      this.columns !== matrix.columns) {\r\n      throw new RangeError('Matrices dimensions must be equal');\r\n    }\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) >>> matrix.get(i, j));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.rightShift = function rightShift(matrix, value) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.rightShift(value);\r\n  };\r\n  AbstractMatrix.prototype.zeroFillRightShift = AbstractMatrix.prototype.rightShift;\r\n  AbstractMatrix.prototype.zeroFillRightShiftS = AbstractMatrix.prototype.rightShiftS;\r\n  AbstractMatrix.prototype.zeroFillRightShiftM = AbstractMatrix.prototype.rightShiftM;\r\n  AbstractMatrix.zeroFillRightShift = AbstractMatrix.rightShift;\r\n\r\n  AbstractMatrix.prototype.not = function not() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, ~(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.not = function not(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.not();\r\n  };\r\n\r\n  AbstractMatrix.prototype.abs = function abs() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.abs(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.abs = function abs(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.abs();\r\n  };\r\n\r\n  AbstractMatrix.prototype.acos = function acos() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.acos(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.acos = function acos(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.acos();\r\n  };\r\n\r\n  AbstractMatrix.prototype.acosh = function acosh() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.acosh(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.acosh = function acosh(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.acosh();\r\n  };\r\n\r\n  AbstractMatrix.prototype.asin = function asin() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.asin(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.asin = function asin(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.asin();\r\n  };\r\n\r\n  AbstractMatrix.prototype.asinh = function asinh() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.asinh(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.asinh = function asinh(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.asinh();\r\n  };\r\n\r\n  AbstractMatrix.prototype.atan = function atan() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.atan(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.atan = function atan(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.atan();\r\n  };\r\n\r\n  AbstractMatrix.prototype.atanh = function atanh() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.atanh(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.atanh = function atanh(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.atanh();\r\n  };\r\n\r\n  AbstractMatrix.prototype.cbrt = function cbrt() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.cbrt(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.cbrt = function cbrt(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.cbrt();\r\n  };\r\n\r\n  AbstractMatrix.prototype.ceil = function ceil() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.ceil(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.ceil = function ceil(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.ceil();\r\n  };\r\n\r\n  AbstractMatrix.prototype.clz32 = function clz32() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.clz32(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.clz32 = function clz32(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.clz32();\r\n  };\r\n\r\n  AbstractMatrix.prototype.cos = function cos() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.cos(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.cos = function cos(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.cos();\r\n  };\r\n\r\n  AbstractMatrix.prototype.cosh = function cosh() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.cosh(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.cosh = function cosh(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.cosh();\r\n  };\r\n\r\n  AbstractMatrix.prototype.exp = function exp() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.exp(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.exp = function exp(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.exp();\r\n  };\r\n\r\n  AbstractMatrix.prototype.expm1 = function expm1() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.expm1(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.expm1 = function expm1(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.expm1();\r\n  };\r\n\r\n  AbstractMatrix.prototype.floor = function floor() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.floor(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.floor = function floor(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.floor();\r\n  };\r\n\r\n  AbstractMatrix.prototype.fround = function fround() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.fround(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.fround = function fround(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.fround();\r\n  };\r\n\r\n  AbstractMatrix.prototype.log = function log() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.log(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.log = function log(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.log();\r\n  };\r\n\r\n  AbstractMatrix.prototype.log1p = function log1p() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.log1p(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.log1p = function log1p(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.log1p();\r\n  };\r\n\r\n  AbstractMatrix.prototype.log10 = function log10() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.log10(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.log10 = function log10(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.log10();\r\n  };\r\n\r\n  AbstractMatrix.prototype.log2 = function log2() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.log2(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.log2 = function log2(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.log2();\r\n  };\r\n\r\n  AbstractMatrix.prototype.round = function round() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.round(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.round = function round(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.round();\r\n  };\r\n\r\n  AbstractMatrix.prototype.sign = function sign() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.sign(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.sign = function sign(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.sign();\r\n  };\r\n\r\n  AbstractMatrix.prototype.sin = function sin() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.sin(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.sin = function sin(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.sin();\r\n  };\r\n\r\n  AbstractMatrix.prototype.sinh = function sinh() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.sinh(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.sinh = function sinh(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.sinh();\r\n  };\r\n\r\n  AbstractMatrix.prototype.sqrt = function sqrt() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.sqrt(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.sqrt = function sqrt(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.sqrt();\r\n  };\r\n\r\n  AbstractMatrix.prototype.tan = function tan() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.tan(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.tan = function tan(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.tan();\r\n  };\r\n\r\n  AbstractMatrix.prototype.tanh = function tanh() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.tanh(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.tanh = function tanh(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.tanh();\r\n  };\r\n\r\n  AbstractMatrix.prototype.trunc = function trunc() {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.trunc(this.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.trunc = function trunc(matrix) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.trunc();\r\n  };\r\n\r\n  AbstractMatrix.pow = function pow(matrix, arg0) {\r\n    const newMatrix = new Matrix(matrix);\r\n    return newMatrix.pow(arg0);\r\n  };\r\n\r\n  AbstractMatrix.prototype.pow = function pow(value) {\r\n    if (typeof value === 'number') return this.powS(value);\r\n    return this.powM(value);\r\n  };\r\n\r\n  AbstractMatrix.prototype.powS = function powS(value) {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.pow(this.get(i, j), value));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n\r\n  AbstractMatrix.prototype.powM = function powM(matrix) {\r\n    matrix = Matrix.checkMatrix(matrix);\r\n    if (this.rows !== matrix.rows ||\r\n      this.columns !== matrix.columns) {\r\n      throw new RangeError('Matrices dimensions must be equal');\r\n    }\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, Math.pow(this.get(i, j), matrix.get(i, j)));\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n}\r\n\r\n/**\r\n * @private\r\n * Check that a row index is not out of bounds\r\n * @param {Matrix} matrix\r\n * @param {number} index\r\n * @param {boolean} [outer]\r\n */\r\nfunction checkRowIndex(matrix, index, outer) {\r\n  let max = outer ? matrix.rows : matrix.rows - 1;\r\n  if (index < 0 || index > max) {\r\n    throw new RangeError('Row index out of range');\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * Check that a column index is not out of bounds\r\n * @param {Matrix} matrix\r\n * @param {number} index\r\n * @param {boolean} [outer]\r\n */\r\nfunction checkColumnIndex(matrix, index, outer) {\r\n  let max = outer ? matrix.columns : matrix.columns - 1;\r\n  if (index < 0 || index > max) {\r\n    throw new RangeError('Column index out of range');\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * Check that the provided vector is an array with the right length\r\n * @param {Matrix} matrix\r\n * @param {Array|Matrix} vector\r\n * @return {Array}\r\n * @throws {RangeError}\r\n */\r\nfunction checkRowVector(matrix, vector) {\r\n  if (vector.to1DArray) {\r\n    vector = vector.to1DArray();\r\n  }\r\n  if (vector.length !== matrix.columns) {\r\n    throw new RangeError(\r\n      'vector size must be the same as the number of columns',\r\n    );\r\n  }\r\n  return vector;\r\n}\r\n\r\n/**\r\n * @private\r\n * Check that the provided vector is an array with the right length\r\n * @param {Matrix} matrix\r\n * @param {Array|Matrix} vector\r\n * @return {Array}\r\n * @throws {RangeError}\r\n */\r\nfunction checkColumnVector(matrix, vector) {\r\n  if (vector.to1DArray) {\r\n    vector = vector.to1DArray();\r\n  }\r\n  if (vector.length !== matrix.rows) {\r\n    throw new RangeError('vector size must be the same as the number of rows');\r\n  }\r\n  return vector;\r\n}\r\n\r\nfunction checkRowIndices(matrix, rowIndices) {\r\n  if (!isAnyArray.isAnyArray(rowIndices)) {\r\n    throw new TypeError('row indices must be an array');\r\n  }\r\n\r\n  for (let i = 0; i < rowIndices.length; i++) {\r\n    if (rowIndices[i] < 0 || rowIndices[i] >= matrix.rows) {\r\n      throw new RangeError('row indices are out of range');\r\n    }\r\n  }\r\n}\r\n\r\nfunction checkColumnIndices(matrix, columnIndices) {\r\n  if (!isAnyArray.isAnyArray(columnIndices)) {\r\n    throw new TypeError('column indices must be an array');\r\n  }\r\n\r\n  for (let i = 0; i < columnIndices.length; i++) {\r\n    if (columnIndices[i] < 0 || columnIndices[i] >= matrix.columns) {\r\n      throw new RangeError('column indices are out of range');\r\n    }\r\n  }\r\n}\r\n\r\nfunction checkRange(matrix, startRow, endRow, startColumn, endColumn) {\r\n  if (arguments.length !== 5) {\r\n    throw new RangeError('expected 4 arguments');\r\n  }\r\n  checkNumber('startRow', startRow);\r\n  checkNumber('endRow', endRow);\r\n  checkNumber('startColumn', startColumn);\r\n  checkNumber('endColumn', endColumn);\r\n  if (\r\n    startRow > endRow ||\r\n    startColumn > endColumn ||\r\n    startRow < 0 ||\r\n    startRow >= matrix.rows ||\r\n    endRow < 0 ||\r\n    endRow >= matrix.rows ||\r\n    startColumn < 0 ||\r\n    startColumn >= matrix.columns ||\r\n    endColumn < 0 ||\r\n    endColumn >= matrix.columns\r\n  ) {\r\n    throw new RangeError('Submatrix indices are out of range');\r\n  }\r\n}\r\n\r\nfunction newArray(length, value = 0) {\r\n  let array = [];\r\n  for (let i = 0; i < length; i++) {\r\n    array.push(value);\r\n  }\r\n  return array;\r\n}\r\n\r\nfunction checkNumber(name, value) {\r\n  if (typeof value !== 'number') {\r\n    throw new TypeError(`${name} must be a number`);\r\n  }\r\n}\r\n\r\nfunction checkNonEmpty(matrix) {\r\n  if (matrix.isEmpty()) {\r\n    throw new Error('Empty matrix has no elements to index');\r\n  }\r\n}\r\n\r\nfunction sumByRow(matrix) {\r\n  let sum = newArray(matrix.rows);\r\n  for (let i = 0; i < matrix.rows; ++i) {\r\n    for (let j = 0; j < matrix.columns; ++j) {\r\n      sum[i] += matrix.get(i, j);\r\n    }\r\n  }\r\n  return sum;\r\n}\r\n\r\nfunction sumByColumn(matrix) {\r\n  let sum = newArray(matrix.columns);\r\n  for (let i = 0; i < matrix.rows; ++i) {\r\n    for (let j = 0; j < matrix.columns; ++j) {\r\n      sum[j] += matrix.get(i, j);\r\n    }\r\n  }\r\n  return sum;\r\n}\r\n\r\nfunction sumAll(matrix) {\r\n  let v = 0;\r\n  for (let i = 0; i < matrix.rows; i++) {\r\n    for (let j = 0; j < matrix.columns; j++) {\r\n      v += matrix.get(i, j);\r\n    }\r\n  }\r\n  return v;\r\n}\r\n\r\nfunction productByRow(matrix) {\r\n  let sum = newArray(matrix.rows, 1);\r\n  for (let i = 0; i < matrix.rows; ++i) {\r\n    for (let j = 0; j < matrix.columns; ++j) {\r\n      sum[i] *= matrix.get(i, j);\r\n    }\r\n  }\r\n  return sum;\r\n}\r\n\r\nfunction productByColumn(matrix) {\r\n  let sum = newArray(matrix.columns, 1);\r\n  for (let i = 0; i < matrix.rows; ++i) {\r\n    for (let j = 0; j < matrix.columns; ++j) {\r\n      sum[j] *= matrix.get(i, j);\r\n    }\r\n  }\r\n  return sum;\r\n}\r\n\r\nfunction productAll(matrix) {\r\n  let v = 1;\r\n  for (let i = 0; i < matrix.rows; i++) {\r\n    for (let j = 0; j < matrix.columns; j++) {\r\n      v *= matrix.get(i, j);\r\n    }\r\n  }\r\n  return v;\r\n}\r\n\r\nfunction varianceByRow(matrix, unbiased, mean) {\r\n  const rows = matrix.rows;\r\n  const cols = matrix.columns;\r\n  const variance = [];\r\n\r\n  for (let i = 0; i < rows; i++) {\r\n    let sum1 = 0;\r\n    let sum2 = 0;\r\n    let x = 0;\r\n    for (let j = 0; j < cols; j++) {\r\n      x = matrix.get(i, j) - mean[i];\r\n      sum1 += x;\r\n      sum2 += x * x;\r\n    }\r\n    if (unbiased) {\r\n      variance.push((sum2 - (sum1 * sum1) / cols) / (cols - 1));\r\n    } else {\r\n      variance.push((sum2 - (sum1 * sum1) / cols) / cols);\r\n    }\r\n  }\r\n  return variance;\r\n}\r\n\r\nfunction varianceByColumn(matrix, unbiased, mean) {\r\n  const rows = matrix.rows;\r\n  const cols = matrix.columns;\r\n  const variance = [];\r\n\r\n  for (let j = 0; j < cols; j++) {\r\n    let sum1 = 0;\r\n    let sum2 = 0;\r\n    let x = 0;\r\n    for (let i = 0; i < rows; i++) {\r\n      x = matrix.get(i, j) - mean[j];\r\n      sum1 += x;\r\n      sum2 += x * x;\r\n    }\r\n    if (unbiased) {\r\n      variance.push((sum2 - (sum1 * sum1) / rows) / (rows - 1));\r\n    } else {\r\n      variance.push((sum2 - (sum1 * sum1) / rows) / rows);\r\n    }\r\n  }\r\n  return variance;\r\n}\r\n\r\nfunction varianceAll(matrix, unbiased, mean) {\r\n  const rows = matrix.rows;\r\n  const cols = matrix.columns;\r\n  const size = rows * cols;\r\n\r\n  let sum1 = 0;\r\n  let sum2 = 0;\r\n  let x = 0;\r\n  for (let i = 0; i < rows; i++) {\r\n    for (let j = 0; j < cols; j++) {\r\n      x = matrix.get(i, j) - mean;\r\n      sum1 += x;\r\n      sum2 += x * x;\r\n    }\r\n  }\r\n  if (unbiased) {\r\n    return (sum2 - (sum1 * sum1) / size) / (size - 1);\r\n  } else {\r\n    return (sum2 - (sum1 * sum1) / size) / size;\r\n  }\r\n}\r\n\r\nfunction centerByRow(matrix, mean) {\r\n  for (let i = 0; i < matrix.rows; i++) {\r\n    for (let j = 0; j < matrix.columns; j++) {\r\n      matrix.set(i, j, matrix.get(i, j) - mean[i]);\r\n    }\r\n  }\r\n}\r\n\r\nfunction centerByColumn(matrix, mean) {\r\n  for (let i = 0; i < matrix.rows; i++) {\r\n    for (let j = 0; j < matrix.columns; j++) {\r\n      matrix.set(i, j, matrix.get(i, j) - mean[j]);\r\n    }\r\n  }\r\n}\r\n\r\nfunction centerAll(matrix, mean) {\r\n  for (let i = 0; i < matrix.rows; i++) {\r\n    for (let j = 0; j < matrix.columns; j++) {\r\n      matrix.set(i, j, matrix.get(i, j) - mean);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getScaleByRow(matrix) {\r\n  const scale = [];\r\n  for (let i = 0; i < matrix.rows; i++) {\r\n    let sum = 0;\r\n    for (let j = 0; j < matrix.columns; j++) {\r\n      sum += Math.pow(matrix.get(i, j), 2) / (matrix.columns - 1);\r\n    }\r\n    scale.push(Math.sqrt(sum));\r\n  }\r\n  return scale;\r\n}\r\n\r\nfunction scaleByRow(matrix, scale) {\r\n  for (let i = 0; i < matrix.rows; i++) {\r\n    for (let j = 0; j < matrix.columns; j++) {\r\n      matrix.set(i, j, matrix.get(i, j) / scale[i]);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getScaleByColumn(matrix) {\r\n  const scale = [];\r\n  for (let j = 0; j < matrix.columns; j++) {\r\n    let sum = 0;\r\n    for (let i = 0; i < matrix.rows; i++) {\r\n      sum += Math.pow(matrix.get(i, j), 2) / (matrix.rows - 1);\r\n    }\r\n    scale.push(Math.sqrt(sum));\r\n  }\r\n  return scale;\r\n}\r\n\r\nfunction scaleByColumn(matrix, scale) {\r\n  for (let i = 0; i < matrix.rows; i++) {\r\n    for (let j = 0; j < matrix.columns; j++) {\r\n      matrix.set(i, j, matrix.get(i, j) / scale[j]);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getScaleAll(matrix) {\r\n  const divider = matrix.size - 1;\r\n  let sum = 0;\r\n  for (let j = 0; j < matrix.columns; j++) {\r\n    for (let i = 0; i < matrix.rows; i++) {\r\n      sum += Math.pow(matrix.get(i, j), 2) / divider;\r\n    }\r\n  }\r\n  return Math.sqrt(sum);\r\n}\r\n\r\nfunction scaleAll(matrix, scale) {\r\n  for (let i = 0; i < matrix.rows; i++) {\r\n    for (let j = 0; j < matrix.columns; j++) {\r\n      matrix.set(i, j, matrix.get(i, j) / scale);\r\n    }\r\n  }\r\n}\r\n\r\nclass AbstractMatrix {\r\n  static from1DArray(newRows, newColumns, newData) {\r\n    let length = newRows * newColumns;\r\n    if (length !== newData.length) {\r\n      throw new RangeError('data length does not match given dimensions');\r\n    }\r\n    let newMatrix = new Matrix(newRows, newColumns);\r\n    for (let row = 0; row < newRows; row++) {\r\n      for (let column = 0; column < newColumns; column++) {\r\n        newMatrix.set(row, column, newData[row * newColumns + column]);\r\n      }\r\n    }\r\n    return newMatrix;\r\n  }\r\n\r\n  static rowVector(newData) {\r\n    let vector = new Matrix(1, newData.length);\r\n    for (let i = 0; i < newData.length; i++) {\r\n      vector.set(0, i, newData[i]);\r\n    }\r\n    return vector;\r\n  }\r\n\r\n  static columnVector(newData) {\r\n    let vector = new Matrix(newData.length, 1);\r\n    for (let i = 0; i < newData.length; i++) {\r\n      vector.set(i, 0, newData[i]);\r\n    }\r\n    return vector;\r\n  }\r\n\r\n  static zeros(rows, columns) {\r\n    return new Matrix(rows, columns);\r\n  }\r\n\r\n  static ones(rows, columns) {\r\n    return new Matrix(rows, columns).fill(1);\r\n  }\r\n\r\n  static rand(rows, columns, options = {}) {\r\n    if (typeof options !== 'object') {\r\n      throw new TypeError('options must be an object');\r\n    }\r\n    const { random = Math.random } = options;\r\n    let matrix = new Matrix(rows, columns);\r\n    for (let i = 0; i < rows; i++) {\r\n      for (let j = 0; j < columns; j++) {\r\n        matrix.set(i, j, random());\r\n      }\r\n    }\r\n    return matrix;\r\n  }\r\n\r\n  static randInt(rows, columns, options = {}) {\r\n    if (typeof options !== 'object') {\r\n      throw new TypeError('options must be an object');\r\n    }\r\n    const { min = 0, max = 1000, random = Math.random } = options;\r\n    if (!Number.isInteger(min)) throw new TypeError('min must be an integer');\r\n    if (!Number.isInteger(max)) throw new TypeError('max must be an integer');\r\n    if (min >= max) throw new RangeError('min must be smaller than max');\r\n    let interval = max - min;\r\n    let matrix = new Matrix(rows, columns);\r\n    for (let i = 0; i < rows; i++) {\r\n      for (let j = 0; j < columns; j++) {\r\n        let value = min + Math.round(random() * interval);\r\n        matrix.set(i, j, value);\r\n      }\r\n    }\r\n    return matrix;\r\n  }\r\n\r\n  static eye(rows, columns, value) {\r\n    if (columns === undefined) columns = rows;\r\n    if (value === undefined) value = 1;\r\n    let min = Math.min(rows, columns);\r\n    let matrix = this.zeros(rows, columns);\r\n    for (let i = 0; i < min; i++) {\r\n      matrix.set(i, i, value);\r\n    }\r\n    return matrix;\r\n  }\r\n\r\n  static diag(data, rows, columns) {\r\n    let l = data.length;\r\n    if (rows === undefined) rows = l;\r\n    if (columns === undefined) columns = rows;\r\n    let min = Math.min(l, rows, columns);\r\n    let matrix = this.zeros(rows, columns);\r\n    for (let i = 0; i < min; i++) {\r\n      matrix.set(i, i, data[i]);\r\n    }\r\n    return matrix;\r\n  }\r\n\r\n  static min(matrix1, matrix2) {\r\n    matrix1 = this.checkMatrix(matrix1);\r\n    matrix2 = this.checkMatrix(matrix2);\r\n    let rows = matrix1.rows;\r\n    let columns = matrix1.columns;\r\n    let result = new Matrix(rows, columns);\r\n    for (let i = 0; i < rows; i++) {\r\n      for (let j = 0; j < columns; j++) {\r\n        result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  static max(matrix1, matrix2) {\r\n    matrix1 = this.checkMatrix(matrix1);\r\n    matrix2 = this.checkMatrix(matrix2);\r\n    let rows = matrix1.rows;\r\n    let columns = matrix1.columns;\r\n    let result = new this(rows, columns);\r\n    for (let i = 0; i < rows; i++) {\r\n      for (let j = 0; j < columns; j++) {\r\n        result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  static checkMatrix(value) {\r\n    return AbstractMatrix.isMatrix(value) ? value : new Matrix(value);\r\n  }\r\n\r\n  static isMatrix(value) {\r\n    return value != null && value.klass === 'Matrix';\r\n  }\r\n\r\n  get size() {\r\n    return this.rows * this.columns;\r\n  }\r\n\r\n  apply(callback) {\r\n    if (typeof callback !== 'function') {\r\n      throw new TypeError('callback must be a function');\r\n    }\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        callback.call(this, i, j);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  to1DArray() {\r\n    let array = [];\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        array.push(this.get(i, j));\r\n      }\r\n    }\r\n    return array;\r\n  }\r\n\r\n  to2DArray() {\r\n    let copy = [];\r\n    for (let i = 0; i < this.rows; i++) {\r\n      copy.push([]);\r\n      for (let j = 0; j < this.columns; j++) {\r\n        copy[i].push(this.get(i, j));\r\n      }\r\n    }\r\n    return copy;\r\n  }\r\n\r\n  toJSON() {\r\n    return this.to2DArray();\r\n  }\r\n\r\n  isRowVector() {\r\n    return this.rows === 1;\r\n  }\r\n\r\n  isColumnVector() {\r\n    return this.columns === 1;\r\n  }\r\n\r\n  isVector() {\r\n    return this.rows === 1 || this.columns === 1;\r\n  }\r\n\r\n  isSquare() {\r\n    return this.rows === this.columns;\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.rows === 0 || this.columns === 0;\r\n  }\r\n\r\n  isSymmetric() {\r\n    if (this.isSquare()) {\r\n      for (let i = 0; i < this.rows; i++) {\r\n        for (let j = 0; j <= i; j++) {\r\n          if (this.get(i, j) !== this.get(j, i)) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  isEchelonForm() {\r\n    let i = 0;\r\n    let j = 0;\r\n    let previousColumn = -1;\r\n    let isEchelonForm = true;\r\n    let checked = false;\r\n    while (i < this.rows && isEchelonForm) {\r\n      j = 0;\r\n      checked = false;\r\n      while (j < this.columns && checked === false) {\r\n        if (this.get(i, j) === 0) {\r\n          j++;\r\n        } else if (this.get(i, j) === 1 && j > previousColumn) {\r\n          checked = true;\r\n          previousColumn = j;\r\n        } else {\r\n          isEchelonForm = false;\r\n          checked = true;\r\n        }\r\n      }\r\n      i++;\r\n    }\r\n    return isEchelonForm;\r\n  }\r\n\r\n  isReducedEchelonForm() {\r\n    let i = 0;\r\n    let j = 0;\r\n    let previousColumn = -1;\r\n    let isReducedEchelonForm = true;\r\n    let checked = false;\r\n    while (i < this.rows && isReducedEchelonForm) {\r\n      j = 0;\r\n      checked = false;\r\n      while (j < this.columns && checked === false) {\r\n        if (this.get(i, j) === 0) {\r\n          j++;\r\n        } else if (this.get(i, j) === 1 && j > previousColumn) {\r\n          checked = true;\r\n          previousColumn = j;\r\n        } else {\r\n          isReducedEchelonForm = false;\r\n          checked = true;\r\n        }\r\n      }\r\n      for (let k = j + 1; k < this.rows; k++) {\r\n        if (this.get(i, k) !== 0) {\r\n          isReducedEchelonForm = false;\r\n        }\r\n      }\r\n      i++;\r\n    }\r\n    return isReducedEchelonForm;\r\n  }\r\n\r\n  echelonForm() {\r\n    let result = this.clone();\r\n    let h = 0;\r\n    let k = 0;\r\n    while (h < result.rows && k < result.columns) {\r\n      let iMax = h;\r\n      for (let i = h; i < result.rows; i++) {\r\n        if (result.get(i, k) > result.get(iMax, k)) {\r\n          iMax = i;\r\n        }\r\n      }\r\n      if (result.get(iMax, k) === 0) {\r\n        k++;\r\n      } else {\r\n        result.swapRows(h, iMax);\r\n        let tmp = result.get(h, k);\r\n        for (let j = k; j < result.columns; j++) {\r\n          result.set(h, j, result.get(h, j) / tmp);\r\n        }\r\n        for (let i = h + 1; i < result.rows; i++) {\r\n          let factor = result.get(i, k) / result.get(h, k);\r\n          result.set(i, k, 0);\r\n          for (let j = k + 1; j < result.columns; j++) {\r\n            result.set(i, j, result.get(i, j) - result.get(h, j) * factor);\r\n          }\r\n        }\r\n        h++;\r\n        k++;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  reducedEchelonForm() {\r\n    let result = this.echelonForm();\r\n    let m = result.columns;\r\n    let n = result.rows;\r\n    let h = n - 1;\r\n    while (h >= 0) {\r\n      if (result.maxRow(h) === 0) {\r\n        h--;\r\n      } else {\r\n        let p = 0;\r\n        let pivot = false;\r\n        while (p < n && pivot === false) {\r\n          if (result.get(h, p) === 1) {\r\n            pivot = true;\r\n          } else {\r\n            p++;\r\n          }\r\n        }\r\n        for (let i = 0; i < h; i++) {\r\n          let factor = result.get(i, p);\r\n          for (let j = p; j < m; j++) {\r\n            let tmp = result.get(i, j) - factor * result.get(h, j);\r\n            result.set(i, j, tmp);\r\n          }\r\n        }\r\n        h--;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  set() {\r\n    throw new Error('set method is unimplemented');\r\n  }\r\n\r\n  get() {\r\n    throw new Error('get method is unimplemented');\r\n  }\r\n\r\n  repeat(options = {}) {\r\n    if (typeof options !== 'object') {\r\n      throw new TypeError('options must be an object');\r\n    }\r\n    const { rows = 1, columns = 1 } = options;\r\n    if (!Number.isInteger(rows) || rows <= 0) {\r\n      throw new TypeError('rows must be a positive integer');\r\n    }\r\n    if (!Number.isInteger(columns) || columns <= 0) {\r\n      throw new TypeError('columns must be a positive integer');\r\n    }\r\n    let matrix = new Matrix(this.rows * rows, this.columns * columns);\r\n    for (let i = 0; i < rows; i++) {\r\n      for (let j = 0; j < columns; j++) {\r\n        matrix.setSubMatrix(this, this.rows * i, this.columns * j);\r\n      }\r\n    }\r\n    return matrix;\r\n  }\r\n\r\n  fill(value) {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, value);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  neg() {\r\n    return this.mulS(-1);\r\n  }\r\n\r\n  getRow(index) {\r\n    checkRowIndex(this, index);\r\n    let row = [];\r\n    for (let i = 0; i < this.columns; i++) {\r\n      row.push(this.get(index, i));\r\n    }\r\n    return row;\r\n  }\r\n\r\n  getRowVector(index) {\r\n    return Matrix.rowVector(this.getRow(index));\r\n  }\r\n\r\n  setRow(index, array) {\r\n    checkRowIndex(this, index);\r\n    array = checkRowVector(this, array);\r\n    for (let i = 0; i < this.columns; i++) {\r\n      this.set(index, i, array[i]);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  swapRows(row1, row2) {\r\n    checkRowIndex(this, row1);\r\n    checkRowIndex(this, row2);\r\n    for (let i = 0; i < this.columns; i++) {\r\n      let temp = this.get(row1, i);\r\n      this.set(row1, i, this.get(row2, i));\r\n      this.set(row2, i, temp);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  getColumn(index) {\r\n    checkColumnIndex(this, index);\r\n    let column = [];\r\n    for (let i = 0; i < this.rows; i++) {\r\n      column.push(this.get(i, index));\r\n    }\r\n    return column;\r\n  }\r\n\r\n  getColumnVector(index) {\r\n    return Matrix.columnVector(this.getColumn(index));\r\n  }\r\n\r\n  setColumn(index, array) {\r\n    checkColumnIndex(this, index);\r\n    array = checkColumnVector(this, array);\r\n    for (let i = 0; i < this.rows; i++) {\r\n      this.set(i, index, array[i]);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  swapColumns(column1, column2) {\r\n    checkColumnIndex(this, column1);\r\n    checkColumnIndex(this, column2);\r\n    for (let i = 0; i < this.rows; i++) {\r\n      let temp = this.get(i, column1);\r\n      this.set(i, column1, this.get(i, column2));\r\n      this.set(i, column2, temp);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  addRowVector(vector) {\r\n    vector = checkRowVector(this, vector);\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) + vector[j]);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  subRowVector(vector) {\r\n    vector = checkRowVector(this, vector);\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) - vector[j]);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  mulRowVector(vector) {\r\n    vector = checkRowVector(this, vector);\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) * vector[j]);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  divRowVector(vector) {\r\n    vector = checkRowVector(this, vector);\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) / vector[j]);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  addColumnVector(vector) {\r\n    vector = checkColumnVector(this, vector);\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) + vector[i]);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  subColumnVector(vector) {\r\n    vector = checkColumnVector(this, vector);\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) - vector[i]);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  mulColumnVector(vector) {\r\n    vector = checkColumnVector(this, vector);\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) * vector[i]);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  divColumnVector(vector) {\r\n    vector = checkColumnVector(this, vector);\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        this.set(i, j, this.get(i, j) / vector[i]);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  mulRow(index, value) {\r\n    checkRowIndex(this, index);\r\n    for (let i = 0; i < this.columns; i++) {\r\n      this.set(index, i, this.get(index, i) * value);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  mulColumn(index, value) {\r\n    checkColumnIndex(this, index);\r\n    for (let i = 0; i < this.rows; i++) {\r\n      this.set(i, index, this.get(i, index) * value);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  max(by) {\r\n    if (this.isEmpty()) {\r\n      return NaN;\r\n    }\r\n    switch (by) {\r\n      case 'row': {\r\n        const max = new Array(this.rows).fill(Number.NEGATIVE_INFINITY);\r\n        for (let row = 0; row < this.rows; row++) {\r\n          for (let column = 0; column < this.columns; column++) {\r\n            if (this.get(row, column) > max[row]) {\r\n              max[row] = this.get(row, column);\r\n            }\r\n          }\r\n        }\r\n        return max;\r\n      }\r\n      case 'column': {\r\n        const max = new Array(this.columns).fill(Number.NEGATIVE_INFINITY);\r\n        for (let row = 0; row < this.rows; row++) {\r\n          for (let column = 0; column < this.columns; column++) {\r\n            if (this.get(row, column) > max[column]) {\r\n              max[column] = this.get(row, column);\r\n            }\r\n          }\r\n        }\r\n        return max;\r\n      }\r\n      case undefined: {\r\n        let max = this.get(0, 0);\r\n        for (let row = 0; row < this.rows; row++) {\r\n          for (let column = 0; column < this.columns; column++) {\r\n            if (this.get(row, column) > max) {\r\n              max = this.get(row, column);\r\n            }\r\n          }\r\n        }\r\n        return max;\r\n      }\r\n      default:\r\n        throw new Error(`invalid option: ${by}`);\r\n    }\r\n  }\r\n\r\n  maxIndex() {\r\n    checkNonEmpty(this);\r\n    let v = this.get(0, 0);\r\n    let idx = [0, 0];\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        if (this.get(i, j) > v) {\r\n          v = this.get(i, j);\r\n          idx[0] = i;\r\n          idx[1] = j;\r\n        }\r\n      }\r\n    }\r\n    return idx;\r\n  }\r\n\r\n  min(by) {\r\n    if (this.isEmpty()) {\r\n      return NaN;\r\n    }\r\n\r\n    switch (by) {\r\n      case 'row': {\r\n        const min = new Array(this.rows).fill(Number.POSITIVE_INFINITY);\r\n        for (let row = 0; row < this.rows; row++) {\r\n          for (let column = 0; column < this.columns; column++) {\r\n            if (this.get(row, column) < min[row]) {\r\n              min[row] = this.get(row, column);\r\n            }\r\n          }\r\n        }\r\n        return min;\r\n      }\r\n      case 'column': {\r\n        const min = new Array(this.columns).fill(Number.POSITIVE_INFINITY);\r\n        for (let row = 0; row < this.rows; row++) {\r\n          for (let column = 0; column < this.columns; column++) {\r\n            if (this.get(row, column) < min[column]) {\r\n              min[column] = this.get(row, column);\r\n            }\r\n          }\r\n        }\r\n        return min;\r\n      }\r\n      case undefined: {\r\n        let min = this.get(0, 0);\r\n        for (let row = 0; row < this.rows; row++) {\r\n          for (let column = 0; column < this.columns; column++) {\r\n            if (this.get(row, column) < min) {\r\n              min = this.get(row, column);\r\n            }\r\n          }\r\n        }\r\n        return min;\r\n      }\r\n      default:\r\n        throw new Error(`invalid option: ${by}`);\r\n    }\r\n  }\r\n\r\n  minIndex() {\r\n    checkNonEmpty(this);\r\n    let v = this.get(0, 0);\r\n    let idx = [0, 0];\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        if (this.get(i, j) < v) {\r\n          v = this.get(i, j);\r\n          idx[0] = i;\r\n          idx[1] = j;\r\n        }\r\n      }\r\n    }\r\n    return idx;\r\n  }\r\n\r\n  maxRow(row) {\r\n    checkRowIndex(this, row);\r\n    if (this.isEmpty()) {\r\n      return NaN;\r\n    }\r\n    let v = this.get(row, 0);\r\n    for (let i = 1; i < this.columns; i++) {\r\n      if (this.get(row, i) > v) {\r\n        v = this.get(row, i);\r\n      }\r\n    }\r\n    return v;\r\n  }\r\n\r\n  maxRowIndex(row) {\r\n    checkRowIndex(this, row);\r\n    checkNonEmpty(this);\r\n    let v = this.get(row, 0);\r\n    let idx = [row, 0];\r\n    for (let i = 1; i < this.columns; i++) {\r\n      if (this.get(row, i) > v) {\r\n        v = this.get(row, i);\r\n        idx[1] = i;\r\n      }\r\n    }\r\n    return idx;\r\n  }\r\n\r\n  minRow(row) {\r\n    checkRowIndex(this, row);\r\n    if (this.isEmpty()) {\r\n      return NaN;\r\n    }\r\n    let v = this.get(row, 0);\r\n    for (let i = 1; i < this.columns; i++) {\r\n      if (this.get(row, i) < v) {\r\n        v = this.get(row, i);\r\n      }\r\n    }\r\n    return v;\r\n  }\r\n\r\n  minRowIndex(row) {\r\n    checkRowIndex(this, row);\r\n    checkNonEmpty(this);\r\n    let v = this.get(row, 0);\r\n    let idx = [row, 0];\r\n    for (let i = 1; i < this.columns; i++) {\r\n      if (this.get(row, i) < v) {\r\n        v = this.get(row, i);\r\n        idx[1] = i;\r\n      }\r\n    }\r\n    return idx;\r\n  }\r\n\r\n  maxColumn(column) {\r\n    checkColumnIndex(this, column);\r\n    if (this.isEmpty()) {\r\n      return NaN;\r\n    }\r\n    let v = this.get(0, column);\r\n    for (let i = 1; i < this.rows; i++) {\r\n      if (this.get(i, column) > v) {\r\n        v = this.get(i, column);\r\n      }\r\n    }\r\n    return v;\r\n  }\r\n\r\n  maxColumnIndex(column) {\r\n    checkColumnIndex(this, column);\r\n    checkNonEmpty(this);\r\n    let v = this.get(0, column);\r\n    let idx = [0, column];\r\n    for (let i = 1; i < this.rows; i++) {\r\n      if (this.get(i, column) > v) {\r\n        v = this.get(i, column);\r\n        idx[0] = i;\r\n      }\r\n    }\r\n    return idx;\r\n  }\r\n\r\n  minColumn(column) {\r\n    checkColumnIndex(this, column);\r\n    if (this.isEmpty()) {\r\n      return NaN;\r\n    }\r\n    let v = this.get(0, column);\r\n    for (let i = 1; i < this.rows; i++) {\r\n      if (this.get(i, column) < v) {\r\n        v = this.get(i, column);\r\n      }\r\n    }\r\n    return v;\r\n  }\r\n\r\n  minColumnIndex(column) {\r\n    checkColumnIndex(this, column);\r\n    checkNonEmpty(this);\r\n    let v = this.get(0, column);\r\n    let idx = [0, column];\r\n    for (let i = 1; i < this.rows; i++) {\r\n      if (this.get(i, column) < v) {\r\n        v = this.get(i, column);\r\n        idx[0] = i;\r\n      }\r\n    }\r\n    return idx;\r\n  }\r\n\r\n  diag() {\r\n    let min = Math.min(this.rows, this.columns);\r\n    let diag = [];\r\n    for (let i = 0; i < min; i++) {\r\n      diag.push(this.get(i, i));\r\n    }\r\n    return diag;\r\n  }\r\n\r\n  norm(type = 'frobenius') {\r\n    let result = 0;\r\n    if (type === 'max') {\r\n      return this.max();\r\n    } else if (type === 'frobenius') {\r\n      for (let i = 0; i < this.rows; i++) {\r\n        for (let j = 0; j < this.columns; j++) {\r\n          result = result + this.get(i, j) * this.get(i, j);\r\n        }\r\n      }\r\n      return Math.sqrt(result);\r\n    } else {\r\n      throw new RangeError(`unknown norm type: ${type}`);\r\n    }\r\n  }\r\n\r\n  cumulativeSum() {\r\n    let sum = 0;\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        sum += this.get(i, j);\r\n        this.set(i, j, sum);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  dot(vector2) {\r\n    if (AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();\r\n    let vector1 = this.to1DArray();\r\n    if (vector1.length !== vector2.length) {\r\n      throw new RangeError('vectors do not have the same size');\r\n    }\r\n    let dot = 0;\r\n    for (let i = 0; i < vector1.length; i++) {\r\n      dot += vector1[i] * vector2[i];\r\n    }\r\n    return dot;\r\n  }\r\n\r\n  mmul(other) {\r\n    other = Matrix.checkMatrix(other);\r\n\r\n    let m = this.rows;\r\n    let n = this.columns;\r\n    let p = other.columns;\r\n\r\n    let result = new Matrix(m, p);\r\n\r\n    let Bcolj = new Float64Array(n);\r\n    for (let j = 0; j < p; j++) {\r\n      for (let k = 0; k < n; k++) {\r\n        Bcolj[k] = other.get(k, j);\r\n      }\r\n\r\n      for (let i = 0; i < m; i++) {\r\n        let s = 0;\r\n        for (let k = 0; k < n; k++) {\r\n          s += this.get(i, k) * Bcolj[k];\r\n        }\r\n\r\n        result.set(i, j, s);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  strassen2x2(other) {\r\n    other = Matrix.checkMatrix(other);\r\n    let result = new Matrix(2, 2);\r\n    const a11 = this.get(0, 0);\r\n    const b11 = other.get(0, 0);\r\n    const a12 = this.get(0, 1);\r\n    const b12 = other.get(0, 1);\r\n    const a21 = this.get(1, 0);\r\n    const b21 = other.get(1, 0);\r\n    const a22 = this.get(1, 1);\r\n    const b22 = other.get(1, 1);\r\n\r\n    // Compute intermediate values.\r\n    const m1 = (a11 + a22) * (b11 + b22);\r\n    const m2 = (a21 + a22) * b11;\r\n    const m3 = a11 * (b12 - b22);\r\n    const m4 = a22 * (b21 - b11);\r\n    const m5 = (a11 + a12) * b22;\r\n    const m6 = (a21 - a11) * (b11 + b12);\r\n    const m7 = (a12 - a22) * (b21 + b22);\r\n\r\n    // Combine intermediate values into the output.\r\n    const c00 = m1 + m4 - m5 + m7;\r\n    const c01 = m3 + m5;\r\n    const c10 = m2 + m4;\r\n    const c11 = m1 - m2 + m3 + m6;\r\n\r\n    result.set(0, 0, c00);\r\n    result.set(0, 1, c01);\r\n    result.set(1, 0, c10);\r\n    result.set(1, 1, c11);\r\n    return result;\r\n  }\r\n\r\n  strassen3x3(other) {\r\n    other = Matrix.checkMatrix(other);\r\n    let result = new Matrix(3, 3);\r\n\r\n    const a00 = this.get(0, 0);\r\n    const a01 = this.get(0, 1);\r\n    const a02 = this.get(0, 2);\r\n    const a10 = this.get(1, 0);\r\n    const a11 = this.get(1, 1);\r\n    const a12 = this.get(1, 2);\r\n    const a20 = this.get(2, 0);\r\n    const a21 = this.get(2, 1);\r\n    const a22 = this.get(2, 2);\r\n\r\n    const b00 = other.get(0, 0);\r\n    const b01 = other.get(0, 1);\r\n    const b02 = other.get(0, 2);\r\n    const b10 = other.get(1, 0);\r\n    const b11 = other.get(1, 1);\r\n    const b12 = other.get(1, 2);\r\n    const b20 = other.get(2, 0);\r\n    const b21 = other.get(2, 1);\r\n    const b22 = other.get(2, 2);\r\n\r\n    const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;\r\n    const m2 = (a00 - a10) * (-b01 + b11);\r\n    const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);\r\n    const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);\r\n    const m5 = (a10 + a11) * (-b00 + b01);\r\n    const m6 = a00 * b00;\r\n    const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);\r\n    const m8 = (-a00 + a20) * (b02 - b12);\r\n    const m9 = (a20 + a21) * (-b00 + b02);\r\n    const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;\r\n    const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);\r\n    const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);\r\n    const m13 = (a02 - a22) * (b11 - b21);\r\n    const m14 = a02 * b20;\r\n    const m15 = (a21 + a22) * (-b20 + b21);\r\n    const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);\r\n    const m17 = (a02 - a12) * (b12 - b22);\r\n    const m18 = (a11 + a12) * (-b20 + b22);\r\n    const m19 = a01 * b10;\r\n    const m20 = a12 * b21;\r\n    const m21 = a10 * b02;\r\n    const m22 = a20 * b01;\r\n    const m23 = a22 * b22;\r\n\r\n    const c00 = m6 + m14 + m19;\r\n    const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;\r\n    const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;\r\n    const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;\r\n    const c11 = m2 + m4 + m5 + m6 + m20;\r\n    const c12 = m14 + m16 + m17 + m18 + m21;\r\n    const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;\r\n    const c21 = m12 + m13 + m14 + m15 + m22;\r\n    const c22 = m6 + m7 + m8 + m9 + m23;\r\n\r\n    result.set(0, 0, c00);\r\n    result.set(0, 1, c01);\r\n    result.set(0, 2, c02);\r\n    result.set(1, 0, c10);\r\n    result.set(1, 1, c11);\r\n    result.set(1, 2, c12);\r\n    result.set(2, 0, c20);\r\n    result.set(2, 1, c21);\r\n    result.set(2, 2, c22);\r\n    return result;\r\n  }\r\n\r\n  mmulStrassen(y) {\r\n    y = Matrix.checkMatrix(y);\r\n    let x = this.clone();\r\n    let r1 = x.rows;\r\n    let c1 = x.columns;\r\n    let r2 = y.rows;\r\n    let c2 = y.columns;\r\n    if (c1 !== r2) {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(\r\n        `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`,\r\n      );\r\n    }\r\n\r\n    // Put a matrix into the top left of a matrix of zeros.\r\n    // `rows` and `cols` are the dimensions of the output matrix.\r\n    function embed(mat, rows, cols) {\r\n      let r = mat.rows;\r\n      let c = mat.columns;\r\n      if (r === rows && c === cols) {\r\n        return mat;\r\n      } else {\r\n        let resultat = AbstractMatrix.zeros(rows, cols);\r\n        resultat = resultat.setSubMatrix(mat, 0, 0);\r\n        return resultat;\r\n      }\r\n    }\r\n\r\n    // Make sure both matrices are the same size.\r\n    // This is exclusively for simplicity:\r\n    // this algorithm can be implemented with matrices of different sizes.\r\n\r\n    let r = Math.max(r1, r2);\r\n    let c = Math.max(c1, c2);\r\n    x = embed(x, r, c);\r\n    y = embed(y, r, c);\r\n\r\n    // Our recursive multiplication function.\r\n    function blockMult(a, b, rows, cols) {\r\n      // For small matrices, resort to naive multiplication.\r\n      if (rows <= 512 || cols <= 512) {\r\n        return a.mmul(b); // a is equivalent to this\r\n      }\r\n\r\n      // Apply dynamic padding.\r\n      if (rows % 2 === 1 && cols % 2 === 1) {\r\n        a = embed(a, rows + 1, cols + 1);\r\n        b = embed(b, rows + 1, cols + 1);\r\n      } else if (rows % 2 === 1) {\r\n        a = embed(a, rows + 1, cols);\r\n        b = embed(b, rows + 1, cols);\r\n      } else if (cols % 2 === 1) {\r\n        a = embed(a, rows, cols + 1);\r\n        b = embed(b, rows, cols + 1);\r\n      }\r\n\r\n      let halfRows = parseInt(a.rows / 2, 10);\r\n      let halfCols = parseInt(a.columns / 2, 10);\r\n      // Subdivide input matrices.\r\n      let a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);\r\n      let b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);\r\n\r\n      let a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);\r\n      let b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);\r\n\r\n      let a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);\r\n      let b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);\r\n\r\n      let a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);\r\n      let b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);\r\n\r\n      // Compute intermediate values.\r\n      let m1 = blockMult(\r\n        AbstractMatrix.add(a11, a22),\r\n        AbstractMatrix.add(b11, b22),\r\n        halfRows,\r\n        halfCols,\r\n      );\r\n      let m2 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);\r\n      let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);\r\n      let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);\r\n      let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);\r\n      let m6 = blockMult(\r\n        AbstractMatrix.sub(a21, a11),\r\n        AbstractMatrix.add(b11, b12),\r\n        halfRows,\r\n        halfCols,\r\n      );\r\n      let m7 = blockMult(\r\n        AbstractMatrix.sub(a12, a22),\r\n        AbstractMatrix.add(b21, b22),\r\n        halfRows,\r\n        halfCols,\r\n      );\r\n\r\n      // Combine intermediate values into the output.\r\n      let c11 = AbstractMatrix.add(m1, m4);\r\n      c11.sub(m5);\r\n      c11.add(m7);\r\n      let c12 = AbstractMatrix.add(m3, m5);\r\n      let c21 = AbstractMatrix.add(m2, m4);\r\n      let c22 = AbstractMatrix.sub(m1, m2);\r\n      c22.add(m3);\r\n      c22.add(m6);\r\n\r\n      // Crop output to the desired size (undo dynamic padding).\r\n      let resultat = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);\r\n      resultat = resultat.setSubMatrix(c11, 0, 0);\r\n      resultat = resultat.setSubMatrix(c12, c11.rows, 0);\r\n      resultat = resultat.setSubMatrix(c21, 0, c11.columns);\r\n      resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);\r\n      return resultat.subMatrix(0, rows - 1, 0, cols - 1);\r\n    }\r\n\r\n    return blockMult(x, y, r, c);\r\n  }\r\n\r\n  scaleRows(options = {}) {\r\n    if (typeof options !== 'object') {\r\n      throw new TypeError('options must be an object');\r\n    }\r\n    const { min = 0, max = 1 } = options;\r\n    if (!Number.isFinite(min)) throw new TypeError('min must be a number');\r\n    if (!Number.isFinite(max)) throw new TypeError('max must be a number');\r\n    if (min >= max) throw new RangeError('min must be smaller than max');\r\n    let newMatrix = new Matrix(this.rows, this.columns);\r\n    for (let i = 0; i < this.rows; i++) {\r\n      const row = this.getRow(i);\r\n      if (row.length > 0) {\r\n        rescale__default[\"default\"](row, { min, max, output: row });\r\n      }\r\n      newMatrix.setRow(i, row);\r\n    }\r\n    return newMatrix;\r\n  }\r\n\r\n  scaleColumns(options = {}) {\r\n    if (typeof options !== 'object') {\r\n      throw new TypeError('options must be an object');\r\n    }\r\n    const { min = 0, max = 1 } = options;\r\n    if (!Number.isFinite(min)) throw new TypeError('min must be a number');\r\n    if (!Number.isFinite(max)) throw new TypeError('max must be a number');\r\n    if (min >= max) throw new RangeError('min must be smaller than max');\r\n    let newMatrix = new Matrix(this.rows, this.columns);\r\n    for (let i = 0; i < this.columns; i++) {\r\n      const column = this.getColumn(i);\r\n      if (column.length) {\r\n        rescale__default[\"default\"](column, {\r\n          min: min,\r\n          max: max,\r\n          output: column,\r\n        });\r\n      }\r\n      newMatrix.setColumn(i, column);\r\n    }\r\n    return newMatrix;\r\n  }\r\n\r\n  flipRows() {\r\n    const middle = Math.ceil(this.columns / 2);\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < middle; j++) {\r\n        let first = this.get(i, j);\r\n        let last = this.get(i, this.columns - 1 - j);\r\n        this.set(i, j, last);\r\n        this.set(i, this.columns - 1 - j, first);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  flipColumns() {\r\n    const middle = Math.ceil(this.rows / 2);\r\n    for (let j = 0; j < this.columns; j++) {\r\n      for (let i = 0; i < middle; i++) {\r\n        let first = this.get(i, j);\r\n        let last = this.get(this.rows - 1 - i, j);\r\n        this.set(i, j, last);\r\n        this.set(this.rows - 1 - i, j, first);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  kroneckerProduct(other) {\r\n    other = Matrix.checkMatrix(other);\r\n\r\n    let m = this.rows;\r\n    let n = this.columns;\r\n    let p = other.rows;\r\n    let q = other.columns;\r\n\r\n    let result = new Matrix(m * p, n * q);\r\n    for (let i = 0; i < m; i++) {\r\n      for (let j = 0; j < n; j++) {\r\n        for (let k = 0; k < p; k++) {\r\n          for (let l = 0; l < q; l++) {\r\n            result.set(p * i + k, q * j + l, this.get(i, j) * other.get(k, l));\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  kroneckerSum(other) {\r\n    other = Matrix.checkMatrix(other);\r\n    if (!this.isSquare() || !other.isSquare()) {\r\n      throw new Error('Kronecker Sum needs two Square Matrices');\r\n    }\r\n    let m = this.rows;\r\n    let n = other.rows;\r\n    let AxI = this.kroneckerProduct(Matrix.eye(n, n));\r\n    let IxB = Matrix.eye(m, m).kroneckerProduct(other);\r\n    return AxI.add(IxB);\r\n  }\r\n\r\n  transpose() {\r\n    let result = new Matrix(this.columns, this.rows);\r\n    for (let i = 0; i < this.rows; i++) {\r\n      for (let j = 0; j < this.columns; j++) {\r\n        result.set(j, i, this.get(i, j));\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  sortRows(compareFunction = compareNumbers) {\r\n    for (let i = 0; i < this.rows; i++) {\r\n      this.setRow(i, this.getRow(i).sort(compareFunction));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  sortColumns(compareFunction = compareNumbers) {\r\n    for (let i = 0; i < this.columns; i++) {\r\n      this.setColumn(i, this.getColumn(i).sort(compareFunction));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  subMatrix(startRow, endRow, startColumn, endColumn) {\r\n    checkRange(this, startRow, endRow, startColumn, endColumn);\r\n    let newMatrix = new Matrix(\r\n      endRow - startRow + 1,\r\n      endColumn - startColumn + 1,\r\n    );\r\n    for (let i = startRow; i <= endRow; i++) {\r\n      for (let j = startColumn; j <= endColumn; j++) {\r\n        newMatrix.set(i - startRow, j - startColumn, this.get(i, j));\r\n      }\r\n    }\r\n    return newMatrix;\r\n  }\r\n\r\n  subMatrixRow(indices, startColumn, endColumn) {\r\n    if (startColumn === undefined) startColumn = 0;\r\n    if (endColumn === undefined) endColumn = this.columns - 1;\r\n    if (\r\n      startColumn > endColumn ||\r\n      startColumn < 0 ||\r\n      startColumn >= this.columns ||\r\n      endColumn < 0 ||\r\n      endColumn >= this.columns\r\n    ) {\r\n      throw new RangeError('Argument out of range');\r\n    }\r\n\r\n    let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);\r\n    for (let i = 0; i < indices.length; i++) {\r\n      for (let j = startColumn; j <= endColumn; j++) {\r\n        if (indices[i] < 0 || indices[i] >= this.rows) {\r\n          throw new RangeError(`Row index out of range: ${indices[i]}`);\r\n        }\r\n        newMatrix.set(i, j - startColumn, this.get(indices[i], j));\r\n      }\r\n    }\r\n    return newMatrix;\r\n  }\r\n\r\n  subMatrixColumn(indices, startRow, endRow) {\r\n    if (startRow === undefined) startRow = 0;\r\n    if (endRow === undefined) endRow = this.rows - 1;\r\n    if (\r\n      startRow > endRow ||\r\n      startRow < 0 ||\r\n      startRow >= this.rows ||\r\n      endRow < 0 ||\r\n      endRow >= this.rows\r\n    ) {\r\n      throw new RangeError('Argument out of range');\r\n    }\r\n\r\n    let newMatrix = new Matrix(endRow - startRow + 1, indices.length);\r\n    for (let i = 0; i < indices.length; i++) {\r\n      for (let j = startRow; j <= endRow; j++) {\r\n        if (indices[i] < 0 || indices[i] >= this.columns) {\r\n          throw new RangeError(`Column index out of range: ${indices[i]}`);\r\n        }\r\n        newMatrix.set(j - startRow, i, this.get(j, indices[i]));\r\n      }\r\n    }\r\n    return newMatrix;\r\n  }\r\n\r\n  setSubMatrix(matrix, startRow, startColumn) {\r\n    matrix = Matrix.checkMatrix(matrix);\r\n    if (matrix.isEmpty()) {\r\n      return this;\r\n    }\r\n    let endRow = startRow + matrix.rows - 1;\r\n    let endColumn = startColumn + matrix.columns - 1;\r\n    checkRange(this, startRow, endRow, startColumn, endColumn);\r\n    for (let i = 0; i < matrix.rows; i++) {\r\n      for (let j = 0; j < matrix.columns; j++) {\r\n        this.set(startRow + i, startColumn + j, matrix.get(i, j));\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  selection(rowIndices, columnIndices) {\r\n    checkRowIndices(this, rowIndices);\r\n    checkColumnIndices(this, columnIndices);\r\n    let newMatrix = new Matrix(rowIndices.length, columnIndices.length);\r\n    for (let i = 0; i < rowIndices.length; i++) {\r\n      let rowIndex = rowIndices[i];\r\n      for (let j = 0; j < columnIndices.length; j++) {\r\n        let columnIndex = columnIndices[j];\r\n        newMatrix.set(i, j, this.get(rowIndex, columnIndex));\r\n      }\r\n    }\r\n    return newMatrix;\r\n  }\r\n\r\n  trace() {\r\n    let min = Math.min(this.rows, this.columns);\r\n    let trace = 0;\r\n    for (let i = 0; i < min; i++) {\r\n      trace += this.get(i, i);\r\n    }\r\n    return trace;\r\n  }\r\n\r\n  clone() {\r\n    let newMatrix = new Matrix(this.rows, this.columns);\r\n    for (let row = 0; row < this.rows; row++) {\r\n      for (let column = 0; column < this.columns; column++) {\r\n        newMatrix.set(row, column, this.get(row, column));\r\n      }\r\n    }\r\n    return newMatrix;\r\n  }\r\n\r\n  sum(by) {\r\n    switch (by) {\r\n      case 'row':\r\n        return sumByRow(this);\r\n      case 'column':\r\n        return sumByColumn(this);\r\n      case undefined:\r\n        return sumAll(this);\r\n      default:\r\n        throw new Error(`invalid option: ${by}`);\r\n    }\r\n  }\r\n\r\n  product(by) {\r\n    switch (by) {\r\n      case 'row':\r\n        return productByRow(this);\r\n      case 'column':\r\n        return productByColumn(this);\r\n      case undefined:\r\n        return productAll(this);\r\n      default:\r\n        throw new Error(`invalid option: ${by}`);\r\n    }\r\n  }\r\n\r\n  mean(by) {\r\n    const sum = this.sum(by);\r\n    switch (by) {\r\n      case 'row': {\r\n        for (let i = 0; i < this.rows; i++) {\r\n          sum[i] /= this.columns;\r\n        }\r\n        return sum;\r\n      }\r\n      case 'column': {\r\n        for (let i = 0; i < this.columns; i++) {\r\n          sum[i] /= this.rows;\r\n        }\r\n        return sum;\r\n      }\r\n      case undefined:\r\n        return sum / this.size;\r\n      default:\r\n        throw new Error(`invalid option: ${by}`);\r\n    }\r\n  }\r\n\r\n  variance(by, options = {}) {\r\n    if (typeof by === 'object') {\r\n      options = by;\r\n      by = undefined;\r\n    }\r\n    if (typeof options !== 'object') {\r\n      throw new TypeError('options must be an object');\r\n    }\r\n    const { unbiased = true, mean = this.mean(by) } = options;\r\n    if (typeof unbiased !== 'boolean') {\r\n      throw new TypeError('unbiased must be a boolean');\r\n    }\r\n    switch (by) {\r\n      case 'row': {\r\n        if (!isAnyArray.isAnyArray(mean)) {\r\n          throw new TypeError('mean must be an array');\r\n        }\r\n        return varianceByRow(this, unbiased, mean);\r\n      }\r\n      case 'column': {\r\n        if (!isAnyArray.isAnyArray(mean)) {\r\n          throw new TypeError('mean must be an array');\r\n        }\r\n        return varianceByColumn(this, unbiased, mean);\r\n      }\r\n      case undefined: {\r\n        if (typeof mean !== 'number') {\r\n          throw new TypeError('mean must be a number');\r\n        }\r\n        return varianceAll(this, unbiased, mean);\r\n      }\r\n      default:\r\n        throw new Error(`invalid option: ${by}`);\r\n    }\r\n  }\r\n\r\n  standardDeviation(by, options) {\r\n    if (typeof by === 'object') {\r\n      options = by;\r\n      by = undefined;\r\n    }\r\n    const variance = this.variance(by, options);\r\n    if (by === undefined) {\r\n      return Math.sqrt(variance);\r\n    } else {\r\n      for (let i = 0; i < variance.length; i++) {\r\n        variance[i] = Math.sqrt(variance[i]);\r\n      }\r\n      return variance;\r\n    }\r\n  }\r\n\r\n  center(by, options = {}) {\r\n    if (typeof by === 'object') {\r\n      options = by;\r\n      by = undefined;\r\n    }\r\n    if (typeof options !== 'object') {\r\n      throw new TypeError('options must be an object');\r\n    }\r\n    const { center = this.mean(by) } = options;\r\n    switch (by) {\r\n      case 'row': {\r\n        if (!isAnyArray.isAnyArray(center)) {\r\n          throw new TypeError('center must be an array');\r\n        }\r\n        centerByRow(this, center);\r\n        return this;\r\n      }\r\n      case 'column': {\r\n        if (!isAnyArray.isAnyArray(center)) {\r\n          throw new TypeError('center must be an array');\r\n        }\r\n        centerByColumn(this, center);\r\n        return this;\r\n      }\r\n      case undefined: {\r\n        if (typeof center !== 'number') {\r\n          throw new TypeError('center must be a number');\r\n        }\r\n        centerAll(this, center);\r\n        return this;\r\n      }\r\n      default:\r\n        throw new Error(`invalid option: ${by}`);\r\n    }\r\n  }\r\n\r\n  scale(by, options = {}) {\r\n    if (typeof by === 'object') {\r\n      options = by;\r\n      by = undefined;\r\n    }\r\n    if (typeof options !== 'object') {\r\n      throw new TypeError('options must be an object');\r\n    }\r\n    let scale = options.scale;\r\n    switch (by) {\r\n      case 'row': {\r\n        if (scale === undefined) {\r\n          scale = getScaleByRow(this);\r\n        } else if (!isAnyArray.isAnyArray(scale)) {\r\n          throw new TypeError('scale must be an array');\r\n        }\r\n        scaleByRow(this, scale);\r\n        return this;\r\n      }\r\n      case 'column': {\r\n        if (scale === undefined) {\r\n          scale = getScaleByColumn(this);\r\n        } else if (!isAnyArray.isAnyArray(scale)) {\r\n          throw new TypeError('scale must be an array');\r\n        }\r\n        scaleByColumn(this, scale);\r\n        return this;\r\n      }\r\n      case undefined: {\r\n        if (scale === undefined) {\r\n          scale = getScaleAll(this);\r\n        } else if (typeof scale !== 'number') {\r\n          throw new TypeError('scale must be a number');\r\n        }\r\n        scaleAll(this, scale);\r\n        return this;\r\n      }\r\n      default:\r\n        throw new Error(`invalid option: ${by}`);\r\n    }\r\n  }\r\n\r\n  toString(options) {\r\n    return inspectMatrixWithOptions(this, options);\r\n  }\r\n}\r\n\r\nAbstractMatrix.prototype.klass = 'Matrix';\r\nif (typeof Symbol !== 'undefined') {\r\n  AbstractMatrix.prototype[Symbol.for('nodejs.util.inspect.custom')] =\r\n    inspectMatrix;\r\n}\r\n\r\nfunction compareNumbers(a, b) {\r\n  return a - b;\r\n}\r\n\r\nfunction isArrayOfNumbers(array) {\r\n  return array.every((element) => {\r\n    return typeof element === 'number';\r\n  });\r\n}\r\n\r\n// Synonyms\r\nAbstractMatrix.random = AbstractMatrix.rand;\r\nAbstractMatrix.randomInt = AbstractMatrix.randInt;\r\nAbstractMatrix.diagonal = AbstractMatrix.diag;\r\nAbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;\r\nAbstractMatrix.identity = AbstractMatrix.eye;\r\nAbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;\r\nAbstractMatrix.prototype.tensorProduct =\r\n  AbstractMatrix.prototype.kroneckerProduct;\r\n\r\nclass Matrix extends AbstractMatrix {\r\n  constructor(nRows, nColumns) {\r\n    super();\r\n    if (Matrix.isMatrix(nRows)) {\r\n      // eslint-disable-next-line no-constructor-return\r\n      return nRows.clone();\r\n    } else if (Number.isInteger(nRows) && nRows >= 0) {\r\n      // Create an empty matrix\r\n      this.data = [];\r\n      if (Number.isInteger(nColumns) && nColumns >= 0) {\r\n        for (let i = 0; i < nRows; i++) {\r\n          this.data.push(new Float64Array(nColumns));\r\n        }\r\n      } else {\r\n        throw new TypeError('nColumns must be a positive integer');\r\n      }\r\n    } else if (isAnyArray.isAnyArray(nRows)) {\r\n      // Copy the values from the 2D array\r\n      const arrayData = nRows;\r\n      nRows = arrayData.length;\r\n      nColumns = nRows ? arrayData[0].length : 0;\r\n      if (typeof nColumns !== 'number') {\r\n        throw new TypeError(\r\n          'Data must be a 2D array with at least one element',\r\n        );\r\n      }\r\n      this.data = [];\r\n      for (let i = 0; i < nRows; i++) {\r\n        if (arrayData[i].length !== nColumns) {\r\n          throw new RangeError('Inconsistent array dimensions');\r\n        }\r\n        if (!isArrayOfNumbers(arrayData[i])) {\r\n          throw new TypeError('Input data contains non-numeric values');\r\n        }\r\n        this.data.push(Float64Array.from(arrayData[i]));\r\n      }\r\n    } else {\r\n      throw new TypeError(\r\n        'First argument must be a positive number or an array',\r\n      );\r\n    }\r\n    this.rows = nRows;\r\n    this.columns = nColumns;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.data[rowIndex][columnIndex] = value;\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.data[rowIndex][columnIndex];\r\n  }\r\n\r\n  removeRow(index) {\r\n    checkRowIndex(this, index);\r\n    this.data.splice(index, 1);\r\n    this.rows -= 1;\r\n    return this;\r\n  }\r\n\r\n  addRow(index, array) {\r\n    if (array === undefined) {\r\n      array = index;\r\n      index = this.rows;\r\n    }\r\n    checkRowIndex(this, index, true);\r\n    array = Float64Array.from(checkRowVector(this, array));\r\n    this.data.splice(index, 0, array);\r\n    this.rows += 1;\r\n    return this;\r\n  }\r\n\r\n  removeColumn(index) {\r\n    checkColumnIndex(this, index);\r\n    for (let i = 0; i < this.rows; i++) {\r\n      const newRow = new Float64Array(this.columns - 1);\r\n      for (let j = 0; j < index; j++) {\r\n        newRow[j] = this.data[i][j];\r\n      }\r\n      for (let j = index + 1; j < this.columns; j++) {\r\n        newRow[j - 1] = this.data[i][j];\r\n      }\r\n      this.data[i] = newRow;\r\n    }\r\n    this.columns -= 1;\r\n    return this;\r\n  }\r\n\r\n  addColumn(index, array) {\r\n    if (typeof array === 'undefined') {\r\n      array = index;\r\n      index = this.columns;\r\n    }\r\n    checkColumnIndex(this, index, true);\r\n    array = checkColumnVector(this, array);\r\n    for (let i = 0; i < this.rows; i++) {\r\n      const newRow = new Float64Array(this.columns + 1);\r\n      let j = 0;\r\n      for (; j < index; j++) {\r\n        newRow[j] = this.data[i][j];\r\n      }\r\n      newRow[j++] = array[i];\r\n      for (; j < this.columns + 1; j++) {\r\n        newRow[j] = this.data[i][j - 1];\r\n      }\r\n      this.data[i] = newRow;\r\n    }\r\n    this.columns += 1;\r\n    return this;\r\n  }\r\n}\r\n\r\ninstallMathOperations(AbstractMatrix, Matrix);\r\n\r\nclass BaseView extends AbstractMatrix {\r\n  constructor(matrix, rows, columns) {\r\n    super();\r\n    this.matrix = matrix;\r\n    this.rows = rows;\r\n    this.columns = columns;\r\n  }\r\n}\r\n\r\nclass MatrixColumnView extends BaseView {\r\n  constructor(matrix, column) {\r\n    checkColumnIndex(matrix, column);\r\n    super(matrix, matrix.rows, 1);\r\n    this.column = column;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(rowIndex, this.column, value);\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex) {\r\n    return this.matrix.get(rowIndex, this.column);\r\n  }\r\n}\r\n\r\nclass MatrixColumnSelectionView extends BaseView {\r\n  constructor(matrix, columnIndices) {\r\n    checkColumnIndices(matrix, columnIndices);\r\n    super(matrix, matrix.rows, columnIndices.length);\r\n    this.columnIndices = columnIndices;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);\r\n  }\r\n}\r\n\r\nclass MatrixFlipColumnView extends BaseView {\r\n  constructor(matrix) {\r\n    super(matrix, matrix.rows, matrix.columns);\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.matrix.get(rowIndex, this.columns - columnIndex - 1);\r\n  }\r\n}\r\n\r\nclass MatrixFlipRowView extends BaseView {\r\n  constructor(matrix) {\r\n    super(matrix, matrix.rows, matrix.columns);\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.matrix.get(this.rows - rowIndex - 1, columnIndex);\r\n  }\r\n}\r\n\r\nclass MatrixRowView extends BaseView {\r\n  constructor(matrix, row) {\r\n    checkRowIndex(matrix, row);\r\n    super(matrix, 1, matrix.columns);\r\n    this.row = row;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(this.row, columnIndex, value);\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.matrix.get(this.row, columnIndex);\r\n  }\r\n}\r\n\r\nclass MatrixRowSelectionView extends BaseView {\r\n  constructor(matrix, rowIndices) {\r\n    checkRowIndices(matrix, rowIndices);\r\n    super(matrix, rowIndices.length, matrix.columns);\r\n    this.rowIndices = rowIndices;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.matrix.get(this.rowIndices[rowIndex], columnIndex);\r\n  }\r\n}\r\n\r\nclass MatrixSelectionView extends BaseView {\r\n  constructor(matrix, rowIndices, columnIndices) {\r\n    checkRowIndices(matrix, rowIndices);\r\n    checkColumnIndices(matrix, columnIndices);\r\n    super(matrix, rowIndices.length, columnIndices.length);\r\n    this.rowIndices = rowIndices;\r\n    this.columnIndices = columnIndices;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(\r\n      this.rowIndices[rowIndex],\r\n      this.columnIndices[columnIndex],\r\n      value,\r\n    );\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.matrix.get(\r\n      this.rowIndices[rowIndex],\r\n      this.columnIndices[columnIndex],\r\n    );\r\n  }\r\n}\r\n\r\nclass MatrixSubView extends BaseView {\r\n  constructor(matrix, startRow, endRow, startColumn, endColumn) {\r\n    checkRange(matrix, startRow, endRow, startColumn, endColumn);\r\n    super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);\r\n    this.startRow = startRow;\r\n    this.startColumn = startColumn;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(\r\n      this.startRow + rowIndex,\r\n      this.startColumn + columnIndex,\r\n      value,\r\n    );\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.matrix.get(\r\n      this.startRow + rowIndex,\r\n      this.startColumn + columnIndex,\r\n    );\r\n  }\r\n}\r\n\r\nclass MatrixTransposeView extends BaseView {\r\n  constructor(matrix) {\r\n    super(matrix, matrix.columns, matrix.rows);\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(columnIndex, rowIndex, value);\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.matrix.get(columnIndex, rowIndex);\r\n  }\r\n}\r\n\r\nclass WrapperMatrix1D extends AbstractMatrix {\r\n  constructor(data, options = {}) {\r\n    const { rows = 1 } = options;\r\n\r\n    if (data.length % rows !== 0) {\r\n      throw new Error('the data length is not divisible by the number of rows');\r\n    }\r\n    super();\r\n    this.rows = rows;\r\n    this.columns = data.length / rows;\r\n    this.data = data;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    let index = this._calculateIndex(rowIndex, columnIndex);\r\n    this.data[index] = value;\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    let index = this._calculateIndex(rowIndex, columnIndex);\r\n    return this.data[index];\r\n  }\r\n\r\n  _calculateIndex(row, column) {\r\n    return row * this.columns + column;\r\n  }\r\n}\r\n\r\nclass WrapperMatrix2D extends AbstractMatrix {\r\n  constructor(data) {\r\n    super();\r\n    this.data = data;\r\n    this.rows = data.length;\r\n    this.columns = data[0].length;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.data[rowIndex][columnIndex] = value;\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.data[rowIndex][columnIndex];\r\n  }\r\n}\r\n\r\nfunction wrap(array, options) {\r\n  if (isAnyArray.isAnyArray(array)) {\r\n    if (array[0] && isAnyArray.isAnyArray(array[0])) {\r\n      return new WrapperMatrix2D(array);\r\n    } else {\r\n      return new WrapperMatrix1D(array, options);\r\n    }\r\n  } else {\r\n    throw new Error('the argument is not an array');\r\n  }\r\n}\r\n\r\nclass LuDecomposition {\r\n  constructor(matrix) {\r\n    matrix = WrapperMatrix2D.checkMatrix(matrix);\r\n\r\n    let lu = matrix.clone();\r\n    let rows = lu.rows;\r\n    let columns = lu.columns;\r\n    let pivotVector = new Float64Array(rows);\r\n    let pivotSign = 1;\r\n    let i, j, k, p, s, t, v;\r\n    let LUcolj, kmax;\r\n\r\n    for (i = 0; i < rows; i++) {\r\n      pivotVector[i] = i;\r\n    }\r\n\r\n    LUcolj = new Float64Array(rows);\r\n\r\n    for (j = 0; j < columns; j++) {\r\n      for (i = 0; i < rows; i++) {\r\n        LUcolj[i] = lu.get(i, j);\r\n      }\r\n\r\n      for (i = 0; i < rows; i++) {\r\n        kmax = Math.min(i, j);\r\n        s = 0;\r\n        for (k = 0; k < kmax; k++) {\r\n          s += lu.get(i, k) * LUcolj[k];\r\n        }\r\n        LUcolj[i] -= s;\r\n        lu.set(i, j, LUcolj[i]);\r\n      }\r\n\r\n      p = j;\r\n      for (i = j + 1; i < rows; i++) {\r\n        if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\r\n          p = i;\r\n        }\r\n      }\r\n\r\n      if (p !== j) {\r\n        for (k = 0; k < columns; k++) {\r\n          t = lu.get(p, k);\r\n          lu.set(p, k, lu.get(j, k));\r\n          lu.set(j, k, t);\r\n        }\r\n\r\n        v = pivotVector[p];\r\n        pivotVector[p] = pivotVector[j];\r\n        pivotVector[j] = v;\r\n\r\n        pivotSign = -pivotSign;\r\n      }\r\n\r\n      if (j < rows && lu.get(j, j) !== 0) {\r\n        for (i = j + 1; i < rows; i++) {\r\n          lu.set(i, j, lu.get(i, j) / lu.get(j, j));\r\n        }\r\n      }\r\n    }\r\n\r\n    this.LU = lu;\r\n    this.pivotVector = pivotVector;\r\n    this.pivotSign = pivotSign;\r\n  }\r\n\r\n  isSingular() {\r\n    let data = this.LU;\r\n    let col = data.columns;\r\n    for (let j = 0; j < col; j++) {\r\n      if (data.get(j, j) === 0) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  solve(value) {\r\n    value = Matrix.checkMatrix(value);\r\n\r\n    let lu = this.LU;\r\n    let rows = lu.rows;\r\n\r\n    if (rows !== value.rows) {\r\n      throw new Error('Invalid matrix dimensions');\r\n    }\r\n    if (this.isSingular()) {\r\n      throw new Error('LU matrix is singular');\r\n    }\r\n\r\n    let count = value.columns;\r\n    let X = value.subMatrixRow(this.pivotVector, 0, count - 1);\r\n    let columns = lu.columns;\r\n    let i, j, k;\r\n\r\n    for (k = 0; k < columns; k++) {\r\n      for (i = k + 1; i < columns; i++) {\r\n        for (j = 0; j < count; j++) {\r\n          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));\r\n        }\r\n      }\r\n    }\r\n    for (k = columns - 1; k >= 0; k--) {\r\n      for (j = 0; j < count; j++) {\r\n        X.set(k, j, X.get(k, j) / lu.get(k, k));\r\n      }\r\n      for (i = 0; i < k; i++) {\r\n        for (j = 0; j < count; j++) {\r\n          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));\r\n        }\r\n      }\r\n    }\r\n    return X;\r\n  }\r\n\r\n  get determinant() {\r\n    let data = this.LU;\r\n    if (!data.isSquare()) {\r\n      throw new Error('Matrix must be square');\r\n    }\r\n    let determinant = this.pivotSign;\r\n    let col = data.columns;\r\n    for (let j = 0; j < col; j++) {\r\n      determinant *= data.get(j, j);\r\n    }\r\n    return determinant;\r\n  }\r\n\r\n  get lowerTriangularMatrix() {\r\n    let data = this.LU;\r\n    let rows = data.rows;\r\n    let columns = data.columns;\r\n    let X = new Matrix(rows, columns);\r\n    for (let i = 0; i < rows; i++) {\r\n      for (let j = 0; j < columns; j++) {\r\n        if (i > j) {\r\n          X.set(i, j, data.get(i, j));\r\n        } else if (i === j) {\r\n          X.set(i, j, 1);\r\n        } else {\r\n          X.set(i, j, 0);\r\n        }\r\n      }\r\n    }\r\n    return X;\r\n  }\r\n\r\n  get upperTriangularMatrix() {\r\n    let data = this.LU;\r\n    let rows = data.rows;\r\n    let columns = data.columns;\r\n    let X = new Matrix(rows, columns);\r\n    for (let i = 0; i < rows; i++) {\r\n      for (let j = 0; j < columns; j++) {\r\n        if (i <= j) {\r\n          X.set(i, j, data.get(i, j));\r\n        } else {\r\n          X.set(i, j, 0);\r\n        }\r\n      }\r\n    }\r\n    return X;\r\n  }\r\n\r\n  get pivotPermutationVector() {\r\n    return Array.from(this.pivotVector);\r\n  }\r\n}\r\n\r\nfunction hypotenuse(a, b) {\r\n  let r = 0;\r\n  if (Math.abs(a) > Math.abs(b)) {\r\n    r = b / a;\r\n    return Math.abs(a) * Math.sqrt(1 + r * r);\r\n  }\r\n  if (b !== 0) {\r\n    r = a / b;\r\n    return Math.abs(b) * Math.sqrt(1 + r * r);\r\n  }\r\n  return 0;\r\n}\r\n\r\nclass QrDecomposition {\r\n  constructor(value) {\r\n    value = WrapperMatrix2D.checkMatrix(value);\r\n\r\n    let qr = value.clone();\r\n    let m = value.rows;\r\n    let n = value.columns;\r\n    let rdiag = new Float64Array(n);\r\n    let i, j, k, s;\r\n\r\n    for (k = 0; k < n; k++) {\r\n      let nrm = 0;\r\n      for (i = k; i < m; i++) {\r\n        nrm = hypotenuse(nrm, qr.get(i, k));\r\n      }\r\n      if (nrm !== 0) {\r\n        if (qr.get(k, k) < 0) {\r\n          nrm = -nrm;\r\n        }\r\n        for (i = k; i < m; i++) {\r\n          qr.set(i, k, qr.get(i, k) / nrm);\r\n        }\r\n        qr.set(k, k, qr.get(k, k) + 1);\r\n        for (j = k + 1; j < n; j++) {\r\n          s = 0;\r\n          for (i = k; i < m; i++) {\r\n            s += qr.get(i, k) * qr.get(i, j);\r\n          }\r\n          s = -s / qr.get(k, k);\r\n          for (i = k; i < m; i++) {\r\n            qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));\r\n          }\r\n        }\r\n      }\r\n      rdiag[k] = -nrm;\r\n    }\r\n\r\n    this.QR = qr;\r\n    this.Rdiag = rdiag;\r\n  }\r\n\r\n  solve(value) {\r\n    value = Matrix.checkMatrix(value);\r\n\r\n    let qr = this.QR;\r\n    let m = qr.rows;\r\n\r\n    if (value.rows !== m) {\r\n      throw new Error('Matrix row dimensions must agree');\r\n    }\r\n    if (!this.isFullRank()) {\r\n      throw new Error('Matrix is rank deficient');\r\n    }\r\n\r\n    let count = value.columns;\r\n    let X = value.clone();\r\n    let n = qr.columns;\r\n    let i, j, k, s;\r\n\r\n    for (k = 0; k < n; k++) {\r\n      for (j = 0; j < count; j++) {\r\n        s = 0;\r\n        for (i = k; i < m; i++) {\r\n          s += qr.get(i, k) * X.get(i, j);\r\n        }\r\n        s = -s / qr.get(k, k);\r\n        for (i = k; i < m; i++) {\r\n          X.set(i, j, X.get(i, j) + s * qr.get(i, k));\r\n        }\r\n      }\r\n    }\r\n    for (k = n - 1; k >= 0; k--) {\r\n      for (j = 0; j < count; j++) {\r\n        X.set(k, j, X.get(k, j) / this.Rdiag[k]);\r\n      }\r\n      for (i = 0; i < k; i++) {\r\n        for (j = 0; j < count; j++) {\r\n          X.set(i, j, X.get(i, j) - X.get(k, j) * qr.get(i, k));\r\n        }\r\n      }\r\n    }\r\n\r\n    return X.subMatrix(0, n - 1, 0, count - 1);\r\n  }\r\n\r\n  isFullRank() {\r\n    let columns = this.QR.columns;\r\n    for (let i = 0; i < columns; i++) {\r\n      if (this.Rdiag[i] === 0) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  get upperTriangularMatrix() {\r\n    let qr = this.QR;\r\n    let n = qr.columns;\r\n    let X = new Matrix(n, n);\r\n    let i, j;\r\n    for (i = 0; i < n; i++) {\r\n      for (j = 0; j < n; j++) {\r\n        if (i < j) {\r\n          X.set(i, j, qr.get(i, j));\r\n        } else if (i === j) {\r\n          X.set(i, j, this.Rdiag[i]);\r\n        } else {\r\n          X.set(i, j, 0);\r\n        }\r\n      }\r\n    }\r\n    return X;\r\n  }\r\n\r\n  get orthogonalMatrix() {\r\n    let qr = this.QR;\r\n    let rows = qr.rows;\r\n    let columns = qr.columns;\r\n    let X = new Matrix(rows, columns);\r\n    let i, j, k, s;\r\n\r\n    for (k = columns - 1; k >= 0; k--) {\r\n      for (i = 0; i < rows; i++) {\r\n        X.set(i, k, 0);\r\n      }\r\n      X.set(k, k, 1);\r\n      for (j = k; j < columns; j++) {\r\n        if (qr.get(k, k) !== 0) {\r\n          s = 0;\r\n          for (i = k; i < rows; i++) {\r\n            s += qr.get(i, k) * X.get(i, j);\r\n          }\r\n\r\n          s = -s / qr.get(k, k);\r\n\r\n          for (i = k; i < rows; i++) {\r\n            X.set(i, j, X.get(i, j) + s * qr.get(i, k));\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return X;\r\n  }\r\n}\r\n\r\nclass SingularValueDecomposition {\r\n  constructor(value, options = {}) {\r\n    value = WrapperMatrix2D.checkMatrix(value);\r\n\r\n    if (value.isEmpty()) {\r\n      throw new Error('Matrix must be non-empty');\r\n    }\r\n\r\n    let m = value.rows;\r\n    let n = value.columns;\r\n\r\n    const {\r\n      computeLeftSingularVectors = true,\r\n      computeRightSingularVectors = true,\r\n      autoTranspose = false,\r\n    } = options;\r\n\r\n    let wantu = Boolean(computeLeftSingularVectors);\r\n    let wantv = Boolean(computeRightSingularVectors);\r\n\r\n    let swapped = false;\r\n    let a;\r\n    if (m < n) {\r\n      if (!autoTranspose) {\r\n        a = value.clone();\r\n        // eslint-disable-next-line no-console\r\n        console.warn(\r\n          'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose',\r\n        );\r\n      } else {\r\n        a = value.transpose();\r\n        m = a.rows;\r\n        n = a.columns;\r\n        swapped = true;\r\n        let aux = wantu;\r\n        wantu = wantv;\r\n        wantv = aux;\r\n      }\r\n    } else {\r\n      a = value.clone();\r\n    }\r\n\r\n    let nu = Math.min(m, n);\r\n    let ni = Math.min(m + 1, n);\r\n    let s = new Float64Array(ni);\r\n    let U = new Matrix(m, nu);\r\n    let V = new Matrix(n, n);\r\n\r\n    let e = new Float64Array(n);\r\n    let work = new Float64Array(m);\r\n\r\n    let si = new Float64Array(ni);\r\n    for (let i = 0; i < ni; i++) si[i] = i;\r\n\r\n    let nct = Math.min(m - 1, n);\r\n    let nrt = Math.max(0, Math.min(n - 2, m));\r\n    let mrc = Math.max(nct, nrt);\r\n\r\n    for (let k = 0; k < mrc; k++) {\r\n      if (k < nct) {\r\n        s[k] = 0;\r\n        for (let i = k; i < m; i++) {\r\n          s[k] = hypotenuse(s[k], a.get(i, k));\r\n        }\r\n        if (s[k] !== 0) {\r\n          if (a.get(k, k) < 0) {\r\n            s[k] = -s[k];\r\n          }\r\n          for (let i = k; i < m; i++) {\r\n            a.set(i, k, a.get(i, k) / s[k]);\r\n          }\r\n          a.set(k, k, a.get(k, k) + 1);\r\n        }\r\n        s[k] = -s[k];\r\n      }\r\n\r\n      for (let j = k + 1; j < n; j++) {\r\n        if (k < nct && s[k] !== 0) {\r\n          let t = 0;\r\n          for (let i = k; i < m; i++) {\r\n            t += a.get(i, k) * a.get(i, j);\r\n          }\r\n          t = -t / a.get(k, k);\r\n          for (let i = k; i < m; i++) {\r\n            a.set(i, j, a.get(i, j) + t * a.get(i, k));\r\n          }\r\n        }\r\n        e[j] = a.get(k, j);\r\n      }\r\n\r\n      if (wantu && k < nct) {\r\n        for (let i = k; i < m; i++) {\r\n          U.set(i, k, a.get(i, k));\r\n        }\r\n      }\r\n\r\n      if (k < nrt) {\r\n        e[k] = 0;\r\n        for (let i = k + 1; i < n; i++) {\r\n          e[k] = hypotenuse(e[k], e[i]);\r\n        }\r\n        if (e[k] !== 0) {\r\n          if (e[k + 1] < 0) {\r\n            e[k] = 0 - e[k];\r\n          }\r\n          for (let i = k + 1; i < n; i++) {\r\n            e[i] /= e[k];\r\n          }\r\n          e[k + 1] += 1;\r\n        }\r\n        e[k] = -e[k];\r\n        if (k + 1 < m && e[k] !== 0) {\r\n          for (let i = k + 1; i < m; i++) {\r\n            work[i] = 0;\r\n          }\r\n          for (let i = k + 1; i < m; i++) {\r\n            for (let j = k + 1; j < n; j++) {\r\n              work[i] += e[j] * a.get(i, j);\r\n            }\r\n          }\r\n          for (let j = k + 1; j < n; j++) {\r\n            let t = -e[j] / e[k + 1];\r\n            for (let i = k + 1; i < m; i++) {\r\n              a.set(i, j, a.get(i, j) + t * work[i]);\r\n            }\r\n          }\r\n        }\r\n        if (wantv) {\r\n          for (let i = k + 1; i < n; i++) {\r\n            V.set(i, k, e[i]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let p = Math.min(n, m + 1);\r\n    if (nct < n) {\r\n      s[nct] = a.get(nct, nct);\r\n    }\r\n    if (m < p) {\r\n      s[p - 1] = 0;\r\n    }\r\n    if (nrt + 1 < p) {\r\n      e[nrt] = a.get(nrt, p - 1);\r\n    }\r\n    e[p - 1] = 0;\r\n\r\n    if (wantu) {\r\n      for (let j = nct; j < nu; j++) {\r\n        for (let i = 0; i < m; i++) {\r\n          U.set(i, j, 0);\r\n        }\r\n        U.set(j, j, 1);\r\n      }\r\n      for (let k = nct - 1; k >= 0; k--) {\r\n        if (s[k] !== 0) {\r\n          for (let j = k + 1; j < nu; j++) {\r\n            let t = 0;\r\n            for (let i = k; i < m; i++) {\r\n              t += U.get(i, k) * U.get(i, j);\r\n            }\r\n            t = -t / U.get(k, k);\r\n            for (let i = k; i < m; i++) {\r\n              U.set(i, j, U.get(i, j) + t * U.get(i, k));\r\n            }\r\n          }\r\n          for (let i = k; i < m; i++) {\r\n            U.set(i, k, -U.get(i, k));\r\n          }\r\n          U.set(k, k, 1 + U.get(k, k));\r\n          for (let i = 0; i < k - 1; i++) {\r\n            U.set(i, k, 0);\r\n          }\r\n        } else {\r\n          for (let i = 0; i < m; i++) {\r\n            U.set(i, k, 0);\r\n          }\r\n          U.set(k, k, 1);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (wantv) {\r\n      for (let k = n - 1; k >= 0; k--) {\r\n        if (k < nrt && e[k] !== 0) {\r\n          for (let j = k + 1; j < n; j++) {\r\n            let t = 0;\r\n            for (let i = k + 1; i < n; i++) {\r\n              t += V.get(i, k) * V.get(i, j);\r\n            }\r\n            t = -t / V.get(k + 1, k);\r\n            for (let i = k + 1; i < n; i++) {\r\n              V.set(i, j, V.get(i, j) + t * V.get(i, k));\r\n            }\r\n          }\r\n        }\r\n        for (let i = 0; i < n; i++) {\r\n          V.set(i, k, 0);\r\n        }\r\n        V.set(k, k, 1);\r\n      }\r\n    }\r\n\r\n    let pp = p - 1;\r\n    let eps = Number.EPSILON;\r\n    while (p > 0) {\r\n      let k, kase;\r\n      for (k = p - 2; k >= -1; k--) {\r\n        if (k === -1) {\r\n          break;\r\n        }\r\n        const alpha =\r\n          Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));\r\n        if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {\r\n          e[k] = 0;\r\n          break;\r\n        }\r\n      }\r\n      if (k === p - 2) {\r\n        kase = 4;\r\n      } else {\r\n        let ks;\r\n        for (ks = p - 1; ks >= k; ks--) {\r\n          if (ks === k) {\r\n            break;\r\n          }\r\n          let t =\r\n            (ks !== p ? Math.abs(e[ks]) : 0) +\r\n            (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\r\n          if (Math.abs(s[ks]) <= eps * t) {\r\n            s[ks] = 0;\r\n            break;\r\n          }\r\n        }\r\n        if (ks === k) {\r\n          kase = 3;\r\n        } else if (ks === p - 1) {\r\n          kase = 1;\r\n        } else {\r\n          kase = 2;\r\n          k = ks;\r\n        }\r\n      }\r\n\r\n      k++;\r\n\r\n      switch (kase) {\r\n        case 1: {\r\n          let f = e[p - 2];\r\n          e[p - 2] = 0;\r\n          for (let j = p - 2; j >= k; j--) {\r\n            let t = hypotenuse(s[j], f);\r\n            let cs = s[j] / t;\r\n            let sn = f / t;\r\n            s[j] = t;\r\n            if (j !== k) {\r\n              f = -sn * e[j - 1];\r\n              e[j - 1] = cs * e[j - 1];\r\n            }\r\n            if (wantv) {\r\n              for (let i = 0; i < n; i++) {\r\n                t = cs * V.get(i, j) + sn * V.get(i, p - 1);\r\n                V.set(i, p - 1, -sn * V.get(i, j) + cs * V.get(i, p - 1));\r\n                V.set(i, j, t);\r\n              }\r\n            }\r\n          }\r\n          break;\r\n        }\r\n        case 2: {\r\n          let f = e[k - 1];\r\n          e[k - 1] = 0;\r\n          for (let j = k; j < p; j++) {\r\n            let t = hypotenuse(s[j], f);\r\n            let cs = s[j] / t;\r\n            let sn = f / t;\r\n            s[j] = t;\r\n            f = -sn * e[j];\r\n            e[j] = cs * e[j];\r\n            if (wantu) {\r\n              for (let i = 0; i < m; i++) {\r\n                t = cs * U.get(i, j) + sn * U.get(i, k - 1);\r\n                U.set(i, k - 1, -sn * U.get(i, j) + cs * U.get(i, k - 1));\r\n                U.set(i, j, t);\r\n              }\r\n            }\r\n          }\r\n          break;\r\n        }\r\n        case 3: {\r\n          const scale = Math.max(\r\n            Math.abs(s[p - 1]),\r\n            Math.abs(s[p - 2]),\r\n            Math.abs(e[p - 2]),\r\n            Math.abs(s[k]),\r\n            Math.abs(e[k]),\r\n          );\r\n          const sp = s[p - 1] / scale;\r\n          const spm1 = s[p - 2] / scale;\r\n          const epm1 = e[p - 2] / scale;\r\n          const sk = s[k] / scale;\r\n          const ek = e[k] / scale;\r\n          const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\r\n          const c = sp * epm1 * (sp * epm1);\r\n          let shift = 0;\r\n          if (b !== 0 || c !== 0) {\r\n            if (b < 0) {\r\n              shift = 0 - Math.sqrt(b * b + c);\r\n            } else {\r\n              shift = Math.sqrt(b * b + c);\r\n            }\r\n            shift = c / (b + shift);\r\n          }\r\n          let f = (sk + sp) * (sk - sp) + shift;\r\n          let g = sk * ek;\r\n          for (let j = k; j < p - 1; j++) {\r\n            let t = hypotenuse(f, g);\r\n            if (t === 0) t = Number.MIN_VALUE;\r\n            let cs = f / t;\r\n            let sn = g / t;\r\n            if (j !== k) {\r\n              e[j - 1] = t;\r\n            }\r\n            f = cs * s[j] + sn * e[j];\r\n            e[j] = cs * e[j] - sn * s[j];\r\n            g = sn * s[j + 1];\r\n            s[j + 1] = cs * s[j + 1];\r\n            if (wantv) {\r\n              for (let i = 0; i < n; i++) {\r\n                t = cs * V.get(i, j) + sn * V.get(i, j + 1);\r\n                V.set(i, j + 1, -sn * V.get(i, j) + cs * V.get(i, j + 1));\r\n                V.set(i, j, t);\r\n              }\r\n            }\r\n            t = hypotenuse(f, g);\r\n            if (t === 0) t = Number.MIN_VALUE;\r\n            cs = f / t;\r\n            sn = g / t;\r\n            s[j] = t;\r\n            f = cs * e[j] + sn * s[j + 1];\r\n            s[j + 1] = -sn * e[j] + cs * s[j + 1];\r\n            g = sn * e[j + 1];\r\n            e[j + 1] = cs * e[j + 1];\r\n            if (wantu && j < m - 1) {\r\n              for (let i = 0; i < m; i++) {\r\n                t = cs * U.get(i, j) + sn * U.get(i, j + 1);\r\n                U.set(i, j + 1, -sn * U.get(i, j) + cs * U.get(i, j + 1));\r\n                U.set(i, j, t);\r\n              }\r\n            }\r\n          }\r\n          e[p - 2] = f;\r\n          break;\r\n        }\r\n        case 4: {\r\n          if (s[k] <= 0) {\r\n            s[k] = s[k] < 0 ? -s[k] : 0;\r\n            if (wantv) {\r\n              for (let i = 0; i <= pp; i++) {\r\n                V.set(i, k, -V.get(i, k));\r\n              }\r\n            }\r\n          }\r\n          while (k < pp) {\r\n            if (s[k] >= s[k + 1]) {\r\n              break;\r\n            }\r\n            let t = s[k];\r\n            s[k] = s[k + 1];\r\n            s[k + 1] = t;\r\n            if (wantv && k < n - 1) {\r\n              for (let i = 0; i < n; i++) {\r\n                t = V.get(i, k + 1);\r\n                V.set(i, k + 1, V.get(i, k));\r\n                V.set(i, k, t);\r\n              }\r\n            }\r\n            if (wantu && k < m - 1) {\r\n              for (let i = 0; i < m; i++) {\r\n                t = U.get(i, k + 1);\r\n                U.set(i, k + 1, U.get(i, k));\r\n                U.set(i, k, t);\r\n              }\r\n            }\r\n            k++;\r\n          }\r\n          p--;\r\n          break;\r\n        }\r\n        // no default\r\n      }\r\n    }\r\n\r\n    if (swapped) {\r\n      let tmp = V;\r\n      V = U;\r\n      U = tmp;\r\n    }\r\n\r\n    this.m = m;\r\n    this.n = n;\r\n    this.s = s;\r\n    this.U = U;\r\n    this.V = V;\r\n  }\r\n\r\n  solve(value) {\r\n    let Y = value;\r\n    let e = this.threshold;\r\n    let scols = this.s.length;\r\n    let Ls = Matrix.zeros(scols, scols);\r\n\r\n    for (let i = 0; i < scols; i++) {\r\n      if (Math.abs(this.s[i]) <= e) {\r\n        Ls.set(i, i, 0);\r\n      } else {\r\n        Ls.set(i, i, 1 / this.s[i]);\r\n      }\r\n    }\r\n\r\n    let U = this.U;\r\n    let V = this.rightSingularVectors;\r\n\r\n    let VL = V.mmul(Ls);\r\n    let vrows = V.rows;\r\n    let urows = U.rows;\r\n    let VLU = Matrix.zeros(vrows, urows);\r\n\r\n    for (let i = 0; i < vrows; i++) {\r\n      for (let j = 0; j < urows; j++) {\r\n        let sum = 0;\r\n        for (let k = 0; k < scols; k++) {\r\n          sum += VL.get(i, k) * U.get(j, k);\r\n        }\r\n        VLU.set(i, j, sum);\r\n      }\r\n    }\r\n\r\n    return VLU.mmul(Y);\r\n  }\r\n\r\n  solveForDiagonal(value) {\r\n    return this.solve(Matrix.diag(value));\r\n  }\r\n\r\n  inverse() {\r\n    let V = this.V;\r\n    let e = this.threshold;\r\n    let vrows = V.rows;\r\n    let vcols = V.columns;\r\n    let X = new Matrix(vrows, this.s.length);\r\n\r\n    for (let i = 0; i < vrows; i++) {\r\n      for (let j = 0; j < vcols; j++) {\r\n        if (Math.abs(this.s[j]) > e) {\r\n          X.set(i, j, V.get(i, j) / this.s[j]);\r\n        }\r\n      }\r\n    }\r\n\r\n    let U = this.U;\r\n\r\n    let urows = U.rows;\r\n    let ucols = U.columns;\r\n    let Y = new Matrix(vrows, urows);\r\n\r\n    for (let i = 0; i < vrows; i++) {\r\n      for (let j = 0; j < urows; j++) {\r\n        let sum = 0;\r\n        for (let k = 0; k < ucols; k++) {\r\n          sum += X.get(i, k) * U.get(j, k);\r\n        }\r\n        Y.set(i, j, sum);\r\n      }\r\n    }\r\n\r\n    return Y;\r\n  }\r\n\r\n  get condition() {\r\n    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\r\n  }\r\n\r\n  get norm2() {\r\n    return this.s[0];\r\n  }\r\n\r\n  get rank() {\r\n    let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;\r\n    let r = 0;\r\n    let s = this.s;\r\n    for (let i = 0, ii = s.length; i < ii; i++) {\r\n      if (s[i] > tol) {\r\n        r++;\r\n      }\r\n    }\r\n    return r;\r\n  }\r\n\r\n  get diagonal() {\r\n    return Array.from(this.s);\r\n  }\r\n\r\n  get threshold() {\r\n    return (Number.EPSILON / 2) * Math.max(this.m, this.n) * this.s[0];\r\n  }\r\n\r\n  get leftSingularVectors() {\r\n    return this.U;\r\n  }\r\n\r\n  get rightSingularVectors() {\r\n    return this.V;\r\n  }\r\n\r\n  get diagonalMatrix() {\r\n    return Matrix.diag(this.s);\r\n  }\r\n}\r\n\r\nfunction inverse(matrix, useSVD = false) {\r\n  matrix = WrapperMatrix2D.checkMatrix(matrix);\r\n  if (useSVD) {\r\n    return new SingularValueDecomposition(matrix).inverse();\r\n  } else {\r\n    return solve(matrix, Matrix.eye(matrix.rows));\r\n  }\r\n}\r\n\r\nfunction solve(leftHandSide, rightHandSide, useSVD = false) {\r\n  leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);\r\n  rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);\r\n  if (useSVD) {\r\n    return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);\r\n  } else {\r\n    return leftHandSide.isSquare()\r\n      ? new LuDecomposition(leftHandSide).solve(rightHandSide)\r\n      : new QrDecomposition(leftHandSide).solve(rightHandSide);\r\n  }\r\n}\r\n\r\nfunction determinant(matrix) {\r\n  matrix = Matrix.checkMatrix(matrix);\r\n  if (matrix.isSquare()) {\r\n    if (matrix.columns === 0) {\r\n      return 1;\r\n    }\r\n\r\n    let a, b, c, d;\r\n    if (matrix.columns === 2) {\r\n      // 2 x 2 matrix\r\n      a = matrix.get(0, 0);\r\n      b = matrix.get(0, 1);\r\n      c = matrix.get(1, 0);\r\n      d = matrix.get(1, 1);\r\n\r\n      return a * d - b * c;\r\n    } else if (matrix.columns === 3) {\r\n      // 3 x 3 matrix\r\n      let subMatrix0, subMatrix1, subMatrix2;\r\n      subMatrix0 = new MatrixSelectionView(matrix, [1, 2], [1, 2]);\r\n      subMatrix1 = new MatrixSelectionView(matrix, [1, 2], [0, 2]);\r\n      subMatrix2 = new MatrixSelectionView(matrix, [1, 2], [0, 1]);\r\n      a = matrix.get(0, 0);\r\n      b = matrix.get(0, 1);\r\n      c = matrix.get(0, 2);\r\n\r\n      return (\r\n        a * determinant(subMatrix0) -\r\n        b * determinant(subMatrix1) +\r\n        c * determinant(subMatrix2)\r\n      );\r\n    } else {\r\n      // general purpose determinant using the LU decomposition\r\n      return new LuDecomposition(matrix).determinant;\r\n    }\r\n  } else {\r\n    throw Error('determinant can only be calculated for a square matrix');\r\n  }\r\n}\r\n\r\nfunction xrange(n, exception) {\r\n  let range = [];\r\n  for (let i = 0; i < n; i++) {\r\n    if (i !== exception) {\r\n      range.push(i);\r\n    }\r\n  }\r\n  return range;\r\n}\r\n\r\nfunction dependenciesOneRow(\r\n  error,\r\n  matrix,\r\n  index,\r\n  thresholdValue = 10e-10,\r\n  thresholdError = 10e-10,\r\n) {\r\n  if (error > thresholdError) {\r\n    return new Array(matrix.rows + 1).fill(0);\r\n  } else {\r\n    let returnArray = matrix.addRow(index, [0]);\r\n    for (let i = 0; i < returnArray.rows; i++) {\r\n      if (Math.abs(returnArray.get(i, 0)) < thresholdValue) {\r\n        returnArray.set(i, 0, 0);\r\n      }\r\n    }\r\n    return returnArray.to1DArray();\r\n  }\r\n}\r\n\r\nfunction linearDependencies(matrix, options = {}) {\r\n  const { thresholdValue = 10e-10, thresholdError = 10e-10 } = options;\r\n  matrix = Matrix.checkMatrix(matrix);\r\n\r\n  let n = matrix.rows;\r\n  let results = new Matrix(n, n);\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    let b = Matrix.columnVector(matrix.getRow(i));\r\n    let Abis = matrix.subMatrixRow(xrange(n, i)).transpose();\r\n    let svd = new SingularValueDecomposition(Abis);\r\n    let x = svd.solve(b);\r\n    let error = Matrix.sub(b, Abis.mmul(x)).abs().max();\r\n    results.setRow(\r\n      i,\r\n      dependenciesOneRow(error, x, i, thresholdValue, thresholdError),\r\n    );\r\n  }\r\n  return results;\r\n}\r\n\r\nfunction pseudoInverse(matrix, threshold = Number.EPSILON) {\r\n  matrix = Matrix.checkMatrix(matrix);\r\n  if (matrix.isEmpty()) {\r\n    // with a zero dimension, the pseudo-inverse is the transpose, since all 0xn and nx0 matrices are singular\r\n    // (0xn)*(nx0)*(0xn) = 0xn\r\n    // (nx0)*(0xn)*(nx0) = nx0\r\n    return matrix.transpose();\r\n  }\r\n  let svdSolution = new SingularValueDecomposition(matrix, { autoTranspose: true });\r\n\r\n  let U = svdSolution.leftSingularVectors;\r\n  let V = svdSolution.rightSingularVectors;\r\n  let s = svdSolution.diagonal;\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (Math.abs(s[i]) > threshold) {\r\n      s[i] = 1.0 / s[i];\r\n    } else {\r\n      s[i] = 0.0;\r\n    }\r\n  }\r\n\r\n  return V.mmul(Matrix.diag(s).mmul(U.transpose()));\r\n}\r\n\r\nfunction covariance(xMatrix, yMatrix = xMatrix, options = {}) {\r\n  xMatrix = new Matrix(xMatrix);\r\n  let yIsSame = false;\r\n  if (\r\n    typeof yMatrix === 'object' &&\r\n    !Matrix.isMatrix(yMatrix) &&\r\n    !isAnyArray.isAnyArray(yMatrix)\r\n  ) {\r\n    options = yMatrix;\r\n    yMatrix = xMatrix;\r\n    yIsSame = true;\r\n  } else {\r\n    yMatrix = new Matrix(yMatrix);\r\n  }\r\n  if (xMatrix.rows !== yMatrix.rows) {\r\n    throw new TypeError('Both matrices must have the same number of rows');\r\n  }\r\n  const { center = true } = options;\r\n  if (center) {\r\n    xMatrix = xMatrix.center('column');\r\n    if (!yIsSame) {\r\n      yMatrix = yMatrix.center('column');\r\n    }\r\n  }\r\n  const cov = xMatrix.transpose().mmul(yMatrix);\r\n  for (let i = 0; i < cov.rows; i++) {\r\n    for (let j = 0; j < cov.columns; j++) {\r\n      cov.set(i, j, cov.get(i, j) * (1 / (xMatrix.rows - 1)));\r\n    }\r\n  }\r\n  return cov;\r\n}\r\n\r\nfunction correlation(xMatrix, yMatrix = xMatrix, options = {}) {\r\n  xMatrix = new Matrix(xMatrix);\r\n  let yIsSame = false;\r\n  if (\r\n    typeof yMatrix === 'object' &&\r\n    !Matrix.isMatrix(yMatrix) &&\r\n    !isAnyArray.isAnyArray(yMatrix)\r\n  ) {\r\n    options = yMatrix;\r\n    yMatrix = xMatrix;\r\n    yIsSame = true;\r\n  } else {\r\n    yMatrix = new Matrix(yMatrix);\r\n  }\r\n  if (xMatrix.rows !== yMatrix.rows) {\r\n    throw new TypeError('Both matrices must have the same number of rows');\r\n  }\r\n\r\n  const { center = true, scale = true } = options;\r\n  if (center) {\r\n    xMatrix.center('column');\r\n    if (!yIsSame) {\r\n      yMatrix.center('column');\r\n    }\r\n  }\r\n  if (scale) {\r\n    xMatrix.scale('column');\r\n    if (!yIsSame) {\r\n      yMatrix.scale('column');\r\n    }\r\n  }\r\n\r\n  const sdx = xMatrix.standardDeviation('column', { unbiased: true });\r\n  const sdy = yIsSame\r\n    ? sdx\r\n    : yMatrix.standardDeviation('column', { unbiased: true });\r\n\r\n  const corr = xMatrix.transpose().mmul(yMatrix);\r\n  for (let i = 0; i < corr.rows; i++) {\r\n    for (let j = 0; j < corr.columns; j++) {\r\n      corr.set(\r\n        i,\r\n        j,\r\n        corr.get(i, j) * (1 / (sdx[i] * sdy[j])) * (1 / (xMatrix.rows - 1)),\r\n      );\r\n    }\r\n  }\r\n  return corr;\r\n}\r\n\r\nclass EigenvalueDecomposition {\r\n  constructor(matrix, options = {}) {\r\n    const { assumeSymmetric = false } = options;\r\n\r\n    matrix = WrapperMatrix2D.checkMatrix(matrix);\r\n    if (!matrix.isSquare()) {\r\n      throw new Error('Matrix is not a square matrix');\r\n    }\r\n\r\n    if (matrix.isEmpty()) {\r\n      throw new Error('Matrix must be non-empty');\r\n    }\r\n\r\n    let n = matrix.columns;\r\n    let V = new Matrix(n, n);\r\n    let d = new Float64Array(n);\r\n    let e = new Float64Array(n);\r\n    let value = matrix;\r\n    let i, j;\r\n\r\n    let isSymmetric = false;\r\n    if (assumeSymmetric) {\r\n      isSymmetric = true;\r\n    } else {\r\n      isSymmetric = matrix.isSymmetric();\r\n    }\r\n\r\n    if (isSymmetric) {\r\n      for (i = 0; i < n; i++) {\r\n        for (j = 0; j < n; j++) {\r\n          V.set(i, j, value.get(i, j));\r\n        }\r\n      }\r\n      tred2(n, e, d, V);\r\n      tql2(n, e, d, V);\r\n    } else {\r\n      let H = new Matrix(n, n);\r\n      let ort = new Float64Array(n);\r\n      for (j = 0; j < n; j++) {\r\n        for (i = 0; i < n; i++) {\r\n          H.set(i, j, value.get(i, j));\r\n        }\r\n      }\r\n      orthes(n, H, ort, V);\r\n      hqr2(n, e, d, V, H);\r\n    }\r\n\r\n    this.n = n;\r\n    this.e = e;\r\n    this.d = d;\r\n    this.V = V;\r\n  }\r\n\r\n  get realEigenvalues() {\r\n    return Array.from(this.d);\r\n  }\r\n\r\n  get imaginaryEigenvalues() {\r\n    return Array.from(this.e);\r\n  }\r\n\r\n  get eigenvectorMatrix() {\r\n    return this.V;\r\n  }\r\n\r\n  get diagonalMatrix() {\r\n    let n = this.n;\r\n    let e = this.e;\r\n    let d = this.d;\r\n    let X = new Matrix(n, n);\r\n    let i, j;\r\n    for (i = 0; i < n; i++) {\r\n      for (j = 0; j < n; j++) {\r\n        X.set(i, j, 0);\r\n      }\r\n      X.set(i, i, d[i]);\r\n      if (e[i] > 0) {\r\n        X.set(i, i + 1, e[i]);\r\n      } else if (e[i] < 0) {\r\n        X.set(i, i - 1, e[i]);\r\n      }\r\n    }\r\n    return X;\r\n  }\r\n}\r\n\r\nfunction tred2(n, e, d, V) {\r\n  let f, g, h, i, j, k, hh, scale;\r\n\r\n  for (j = 0; j < n; j++) {\r\n    d[j] = V.get(n - 1, j);\r\n  }\r\n\r\n  for (i = n - 1; i > 0; i--) {\r\n    scale = 0;\r\n    h = 0;\r\n    for (k = 0; k < i; k++) {\r\n      scale = scale + Math.abs(d[k]);\r\n    }\r\n\r\n    if (scale === 0) {\r\n      e[i] = d[i - 1];\r\n      for (j = 0; j < i; j++) {\r\n        d[j] = V.get(i - 1, j);\r\n        V.set(i, j, 0);\r\n        V.set(j, i, 0);\r\n      }\r\n    } else {\r\n      for (k = 0; k < i; k++) {\r\n        d[k] /= scale;\r\n        h += d[k] * d[k];\r\n      }\r\n\r\n      f = d[i - 1];\r\n      g = Math.sqrt(h);\r\n      if (f > 0) {\r\n        g = -g;\r\n      }\r\n\r\n      e[i] = scale * g;\r\n      h = h - f * g;\r\n      d[i - 1] = f - g;\r\n      for (j = 0; j < i; j++) {\r\n        e[j] = 0;\r\n      }\r\n\r\n      for (j = 0; j < i; j++) {\r\n        f = d[j];\r\n        V.set(j, i, f);\r\n        g = e[j] + V.get(j, j) * f;\r\n        for (k = j + 1; k <= i - 1; k++) {\r\n          g += V.get(k, j) * d[k];\r\n          e[k] += V.get(k, j) * f;\r\n        }\r\n        e[j] = g;\r\n      }\r\n\r\n      f = 0;\r\n      for (j = 0; j < i; j++) {\r\n        e[j] /= h;\r\n        f += e[j] * d[j];\r\n      }\r\n\r\n      hh = f / (h + h);\r\n      for (j = 0; j < i; j++) {\r\n        e[j] -= hh * d[j];\r\n      }\r\n\r\n      for (j = 0; j < i; j++) {\r\n        f = d[j];\r\n        g = e[j];\r\n        for (k = j; k <= i - 1; k++) {\r\n          V.set(k, j, V.get(k, j) - (f * e[k] + g * d[k]));\r\n        }\r\n        d[j] = V.get(i - 1, j);\r\n        V.set(i, j, 0);\r\n      }\r\n    }\r\n    d[i] = h;\r\n  }\r\n\r\n  for (i = 0; i < n - 1; i++) {\r\n    V.set(n - 1, i, V.get(i, i));\r\n    V.set(i, i, 1);\r\n    h = d[i + 1];\r\n    if (h !== 0) {\r\n      for (k = 0; k <= i; k++) {\r\n        d[k] = V.get(k, i + 1) / h;\r\n      }\r\n\r\n      for (j = 0; j <= i; j++) {\r\n        g = 0;\r\n        for (k = 0; k <= i; k++) {\r\n          g += V.get(k, i + 1) * V.get(k, j);\r\n        }\r\n        for (k = 0; k <= i; k++) {\r\n          V.set(k, j, V.get(k, j) - g * d[k]);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (k = 0; k <= i; k++) {\r\n      V.set(k, i + 1, 0);\r\n    }\r\n  }\r\n\r\n  for (j = 0; j < n; j++) {\r\n    d[j] = V.get(n - 1, j);\r\n    V.set(n - 1, j, 0);\r\n  }\r\n\r\n  V.set(n - 1, n - 1, 1);\r\n  e[0] = 0;\r\n}\r\n\r\nfunction tql2(n, e, d, V) {\r\n  let g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2;\r\n\r\n  for (i = 1; i < n; i++) {\r\n    e[i - 1] = e[i];\r\n  }\r\n\r\n  e[n - 1] = 0;\r\n\r\n  let f = 0;\r\n  let tst1 = 0;\r\n  let eps = Number.EPSILON;\r\n\r\n  for (l = 0; l < n; l++) {\r\n    tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\r\n    m = l;\r\n    while (m < n) {\r\n      if (Math.abs(e[m]) <= eps * tst1) {\r\n        break;\r\n      }\r\n      m++;\r\n    }\r\n\r\n    if (m > l) {\r\n      do {\r\n\r\n        g = d[l];\r\n        p = (d[l + 1] - g) / (2 * e[l]);\r\n        r = hypotenuse(p, 1);\r\n        if (p < 0) {\r\n          r = -r;\r\n        }\r\n\r\n        d[l] = e[l] / (p + r);\r\n        d[l + 1] = e[l] * (p + r);\r\n        dl1 = d[l + 1];\r\n        h = g - d[l];\r\n        for (i = l + 2; i < n; i++) {\r\n          d[i] -= h;\r\n        }\r\n\r\n        f = f + h;\r\n\r\n        p = d[m];\r\n        c = 1;\r\n        c2 = c;\r\n        c3 = c;\r\n        el1 = e[l + 1];\r\n        s = 0;\r\n        s2 = 0;\r\n        for (i = m - 1; i >= l; i--) {\r\n          c3 = c2;\r\n          c2 = c;\r\n          s2 = s;\r\n          g = c * e[i];\r\n          h = c * p;\r\n          r = hypotenuse(p, e[i]);\r\n          e[i + 1] = s * r;\r\n          s = e[i] / r;\r\n          c = p / r;\r\n          p = c * d[i] - s * g;\r\n          d[i + 1] = h + s * (c * g + s * d[i]);\r\n\r\n          for (k = 0; k < n; k++) {\r\n            h = V.get(k, i + 1);\r\n            V.set(k, i + 1, s * V.get(k, i) + c * h);\r\n            V.set(k, i, c * V.get(k, i) - s * h);\r\n          }\r\n        }\r\n\r\n        p = (-s * s2 * c3 * el1 * e[l]) / dl1;\r\n        e[l] = s * p;\r\n        d[l] = c * p;\r\n      } while (Math.abs(e[l]) > eps * tst1);\r\n    }\r\n    d[l] = d[l] + f;\r\n    e[l] = 0;\r\n  }\r\n\r\n  for (i = 0; i < n - 1; i++) {\r\n    k = i;\r\n    p = d[i];\r\n    for (j = i + 1; j < n; j++) {\r\n      if (d[j] < p) {\r\n        k = j;\r\n        p = d[j];\r\n      }\r\n    }\r\n\r\n    if (k !== i) {\r\n      d[k] = d[i];\r\n      d[i] = p;\r\n      for (j = 0; j < n; j++) {\r\n        p = V.get(j, i);\r\n        V.set(j, i, V.get(j, k));\r\n        V.set(j, k, p);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction orthes(n, H, ort, V) {\r\n  let low = 0;\r\n  let high = n - 1;\r\n  let f, g, h, i, j, m;\r\n  let scale;\r\n\r\n  for (m = low + 1; m <= high - 1; m++) {\r\n    scale = 0;\r\n    for (i = m; i <= high; i++) {\r\n      scale = scale + Math.abs(H.get(i, m - 1));\r\n    }\r\n\r\n    if (scale !== 0) {\r\n      h = 0;\r\n      for (i = high; i >= m; i--) {\r\n        ort[i] = H.get(i, m - 1) / scale;\r\n        h += ort[i] * ort[i];\r\n      }\r\n\r\n      g = Math.sqrt(h);\r\n      if (ort[m] > 0) {\r\n        g = -g;\r\n      }\r\n\r\n      h = h - ort[m] * g;\r\n      ort[m] = ort[m] - g;\r\n\r\n      for (j = m; j < n; j++) {\r\n        f = 0;\r\n        for (i = high; i >= m; i--) {\r\n          f += ort[i] * H.get(i, j);\r\n        }\r\n\r\n        f = f / h;\r\n        for (i = m; i <= high; i++) {\r\n          H.set(i, j, H.get(i, j) - f * ort[i]);\r\n        }\r\n      }\r\n\r\n      for (i = 0; i <= high; i++) {\r\n        f = 0;\r\n        for (j = high; j >= m; j--) {\r\n          f += ort[j] * H.get(i, j);\r\n        }\r\n\r\n        f = f / h;\r\n        for (j = m; j <= high; j++) {\r\n          H.set(i, j, H.get(i, j) - f * ort[j]);\r\n        }\r\n      }\r\n\r\n      ort[m] = scale * ort[m];\r\n      H.set(m, m - 1, scale * g);\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < n; i++) {\r\n    for (j = 0; j < n; j++) {\r\n      V.set(i, j, i === j ? 1 : 0);\r\n    }\r\n  }\r\n\r\n  for (m = high - 1; m >= low + 1; m--) {\r\n    if (H.get(m, m - 1) !== 0) {\r\n      for (i = m + 1; i <= high; i++) {\r\n        ort[i] = H.get(i, m - 1);\r\n      }\r\n\r\n      for (j = m; j <= high; j++) {\r\n        g = 0;\r\n        for (i = m; i <= high; i++) {\r\n          g += ort[i] * V.get(i, j);\r\n        }\r\n\r\n        g = g / ort[m] / H.get(m, m - 1);\r\n        for (i = m; i <= high; i++) {\r\n          V.set(i, j, V.get(i, j) + g * ort[i]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction hqr2(nn, e, d, V, H) {\r\n  let n = nn - 1;\r\n  let low = 0;\r\n  let high = nn - 1;\r\n  let eps = Number.EPSILON;\r\n  let exshift = 0;\r\n  let norm = 0;\r\n  let p = 0;\r\n  let q = 0;\r\n  let r = 0;\r\n  let s = 0;\r\n  let z = 0;\r\n  let iter = 0;\r\n  let i, j, k, l, m, t, w, x, y;\r\n  let ra, sa, vr, vi;\r\n  let notlast, cdivres;\r\n\r\n  for (i = 0; i < nn; i++) {\r\n    if (i < low || i > high) {\r\n      d[i] = H.get(i, i);\r\n      e[i] = 0;\r\n    }\r\n\r\n    for (j = Math.max(i - 1, 0); j < nn; j++) {\r\n      norm = norm + Math.abs(H.get(i, j));\r\n    }\r\n  }\r\n\r\n  while (n >= low) {\r\n    l = n;\r\n    while (l > low) {\r\n      s = Math.abs(H.get(l - 1, l - 1)) + Math.abs(H.get(l, l));\r\n      if (s === 0) {\r\n        s = norm;\r\n      }\r\n      if (Math.abs(H.get(l, l - 1)) < eps * s) {\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    if (l === n) {\r\n      H.set(n, n, H.get(n, n) + exshift);\r\n      d[n] = H.get(n, n);\r\n      e[n] = 0;\r\n      n--;\r\n      iter = 0;\r\n    } else if (l === n - 1) {\r\n      w = H.get(n, n - 1) * H.get(n - 1, n);\r\n      p = (H.get(n - 1, n - 1) - H.get(n, n)) / 2;\r\n      q = p * p + w;\r\n      z = Math.sqrt(Math.abs(q));\r\n      H.set(n, n, H.get(n, n) + exshift);\r\n      H.set(n - 1, n - 1, H.get(n - 1, n - 1) + exshift);\r\n      x = H.get(n, n);\r\n\r\n      if (q >= 0) {\r\n        z = p >= 0 ? p + z : p - z;\r\n        d[n - 1] = x + z;\r\n        d[n] = d[n - 1];\r\n        if (z !== 0) {\r\n          d[n] = x - w / z;\r\n        }\r\n        e[n - 1] = 0;\r\n        e[n] = 0;\r\n        x = H.get(n, n - 1);\r\n        s = Math.abs(x) + Math.abs(z);\r\n        p = x / s;\r\n        q = z / s;\r\n        r = Math.sqrt(p * p + q * q);\r\n        p = p / r;\r\n        q = q / r;\r\n\r\n        for (j = n - 1; j < nn; j++) {\r\n          z = H.get(n - 1, j);\r\n          H.set(n - 1, j, q * z + p * H.get(n, j));\r\n          H.set(n, j, q * H.get(n, j) - p * z);\r\n        }\r\n\r\n        for (i = 0; i <= n; i++) {\r\n          z = H.get(i, n - 1);\r\n          H.set(i, n - 1, q * z + p * H.get(i, n));\r\n          H.set(i, n, q * H.get(i, n) - p * z);\r\n        }\r\n\r\n        for (i = low; i <= high; i++) {\r\n          z = V.get(i, n - 1);\r\n          V.set(i, n - 1, q * z + p * V.get(i, n));\r\n          V.set(i, n, q * V.get(i, n) - p * z);\r\n        }\r\n      } else {\r\n        d[n - 1] = x + p;\r\n        d[n] = x + p;\r\n        e[n - 1] = z;\r\n        e[n] = -z;\r\n      }\r\n\r\n      n = n - 2;\r\n      iter = 0;\r\n    } else {\r\n      x = H.get(n, n);\r\n      y = 0;\r\n      w = 0;\r\n      if (l < n) {\r\n        y = H.get(n - 1, n - 1);\r\n        w = H.get(n, n - 1) * H.get(n - 1, n);\r\n      }\r\n\r\n      if (iter === 10) {\r\n        exshift += x;\r\n        for (i = low; i <= n; i++) {\r\n          H.set(i, i, H.get(i, i) - x);\r\n        }\r\n        s = Math.abs(H.get(n, n - 1)) + Math.abs(H.get(n - 1, n - 2));\r\n        x = y = 0.75 * s;\r\n        w = -0.4375 * s * s;\r\n      }\r\n\r\n      if (iter === 30) {\r\n        s = (y - x) / 2;\r\n        s = s * s + w;\r\n        if (s > 0) {\r\n          s = Math.sqrt(s);\r\n          if (y < x) {\r\n            s = -s;\r\n          }\r\n          s = x - w / ((y - x) / 2 + s);\r\n          for (i = low; i <= n; i++) {\r\n            H.set(i, i, H.get(i, i) - s);\r\n          }\r\n          exshift += s;\r\n          x = y = w = 0.964;\r\n        }\r\n      }\r\n\r\n      iter = iter + 1;\r\n\r\n      m = n - 2;\r\n      while (m >= l) {\r\n        z = H.get(m, m);\r\n        r = x - z;\r\n        s = y - z;\r\n        p = (r * s - w) / H.get(m + 1, m) + H.get(m, m + 1);\r\n        q = H.get(m + 1, m + 1) - z - r - s;\r\n        r = H.get(m + 2, m + 1);\r\n        s = Math.abs(p) + Math.abs(q) + Math.abs(r);\r\n        p = p / s;\r\n        q = q / s;\r\n        r = r / s;\r\n        if (m === l) {\r\n          break;\r\n        }\r\n        if (\r\n          Math.abs(H.get(m, m - 1)) * (Math.abs(q) + Math.abs(r)) <\r\n          eps *\r\n            (Math.abs(p) *\r\n              (Math.abs(H.get(m - 1, m - 1)) +\r\n                Math.abs(z) +\r\n                Math.abs(H.get(m + 1, m + 1))))\r\n        ) {\r\n          break;\r\n        }\r\n        m--;\r\n      }\r\n\r\n      for (i = m + 2; i <= n; i++) {\r\n        H.set(i, i - 2, 0);\r\n        if (i > m + 2) {\r\n          H.set(i, i - 3, 0);\r\n        }\r\n      }\r\n\r\n      for (k = m; k <= n - 1; k++) {\r\n        notlast = k !== n - 1;\r\n        if (k !== m) {\r\n          p = H.get(k, k - 1);\r\n          q = H.get(k + 1, k - 1);\r\n          r = notlast ? H.get(k + 2, k - 1) : 0;\r\n          x = Math.abs(p) + Math.abs(q) + Math.abs(r);\r\n          if (x !== 0) {\r\n            p = p / x;\r\n            q = q / x;\r\n            r = r / x;\r\n          }\r\n        }\r\n\r\n        if (x === 0) {\r\n          break;\r\n        }\r\n\r\n        s = Math.sqrt(p * p + q * q + r * r);\r\n        if (p < 0) {\r\n          s = -s;\r\n        }\r\n\r\n        if (s !== 0) {\r\n          if (k !== m) {\r\n            H.set(k, k - 1, -s * x);\r\n          } else if (l !== m) {\r\n            H.set(k, k - 1, -H.get(k, k - 1));\r\n          }\r\n\r\n          p = p + s;\r\n          x = p / s;\r\n          y = q / s;\r\n          z = r / s;\r\n          q = q / p;\r\n          r = r / p;\r\n\r\n          for (j = k; j < nn; j++) {\r\n            p = H.get(k, j) + q * H.get(k + 1, j);\r\n            if (notlast) {\r\n              p = p + r * H.get(k + 2, j);\r\n              H.set(k + 2, j, H.get(k + 2, j) - p * z);\r\n            }\r\n\r\n            H.set(k, j, H.get(k, j) - p * x);\r\n            H.set(k + 1, j, H.get(k + 1, j) - p * y);\r\n          }\r\n\r\n          for (i = 0; i <= Math.min(n, k + 3); i++) {\r\n            p = x * H.get(i, k) + y * H.get(i, k + 1);\r\n            if (notlast) {\r\n              p = p + z * H.get(i, k + 2);\r\n              H.set(i, k + 2, H.get(i, k + 2) - p * r);\r\n            }\r\n\r\n            H.set(i, k, H.get(i, k) - p);\r\n            H.set(i, k + 1, H.get(i, k + 1) - p * q);\r\n          }\r\n\r\n          for (i = low; i <= high; i++) {\r\n            p = x * V.get(i, k) + y * V.get(i, k + 1);\r\n            if (notlast) {\r\n              p = p + z * V.get(i, k + 2);\r\n              V.set(i, k + 2, V.get(i, k + 2) - p * r);\r\n            }\r\n\r\n            V.set(i, k, V.get(i, k) - p);\r\n            V.set(i, k + 1, V.get(i, k + 1) - p * q);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (norm === 0) {\r\n    return;\r\n  }\r\n\r\n  for (n = nn - 1; n >= 0; n--) {\r\n    p = d[n];\r\n    q = e[n];\r\n\r\n    if (q === 0) {\r\n      l = n;\r\n      H.set(n, n, 1);\r\n      for (i = n - 1; i >= 0; i--) {\r\n        w = H.get(i, i) - p;\r\n        r = 0;\r\n        for (j = l; j <= n; j++) {\r\n          r = r + H.get(i, j) * H.get(j, n);\r\n        }\r\n\r\n        if (e[i] < 0) {\r\n          z = w;\r\n          s = r;\r\n        } else {\r\n          l = i;\r\n          if (e[i] === 0) {\r\n            H.set(i, n, w !== 0 ? -r / w : -r / (eps * norm));\r\n          } else {\r\n            x = H.get(i, i + 1);\r\n            y = H.get(i + 1, i);\r\n            q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\r\n            t = (x * s - z * r) / q;\r\n            H.set(i, n, t);\r\n            H.set(\r\n              i + 1,\r\n              n,\r\n              Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z,\r\n            );\r\n          }\r\n\r\n          t = Math.abs(H.get(i, n));\r\n          if (eps * t * t > 1) {\r\n            for (j = i; j <= n; j++) {\r\n              H.set(j, n, H.get(j, n) / t);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else if (q < 0) {\r\n      l = n - 1;\r\n\r\n      if (Math.abs(H.get(n, n - 1)) > Math.abs(H.get(n - 1, n))) {\r\n        H.set(n - 1, n - 1, q / H.get(n, n - 1));\r\n        H.set(n - 1, n, -(H.get(n, n) - p) / H.get(n, n - 1));\r\n      } else {\r\n        cdivres = cdiv(0, -H.get(n - 1, n), H.get(n - 1, n - 1) - p, q);\r\n        H.set(n - 1, n - 1, cdivres[0]);\r\n        H.set(n - 1, n, cdivres[1]);\r\n      }\r\n\r\n      H.set(n, n - 1, 0);\r\n      H.set(n, n, 1);\r\n      for (i = n - 2; i >= 0; i--) {\r\n        ra = 0;\r\n        sa = 0;\r\n        for (j = l; j <= n; j++) {\r\n          ra = ra + H.get(i, j) * H.get(j, n - 1);\r\n          sa = sa + H.get(i, j) * H.get(j, n);\r\n        }\r\n\r\n        w = H.get(i, i) - p;\r\n\r\n        if (e[i] < 0) {\r\n          z = w;\r\n          r = ra;\r\n          s = sa;\r\n        } else {\r\n          l = i;\r\n          if (e[i] === 0) {\r\n            cdivres = cdiv(-ra, -sa, w, q);\r\n            H.set(i, n - 1, cdivres[0]);\r\n            H.set(i, n, cdivres[1]);\r\n          } else {\r\n            x = H.get(i, i + 1);\r\n            y = H.get(i + 1, i);\r\n            vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\r\n            vi = (d[i] - p) * 2 * q;\r\n            if (vr === 0 && vi === 0) {\r\n              vr =\r\n                eps *\r\n                norm *\r\n                (Math.abs(w) +\r\n                  Math.abs(q) +\r\n                  Math.abs(x) +\r\n                  Math.abs(y) +\r\n                  Math.abs(z));\r\n            }\r\n            cdivres = cdiv(\r\n              x * r - z * ra + q * sa,\r\n              x * s - z * sa - q * ra,\r\n              vr,\r\n              vi,\r\n            );\r\n            H.set(i, n - 1, cdivres[0]);\r\n            H.set(i, n, cdivres[1]);\r\n            if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {\r\n              H.set(\r\n                i + 1,\r\n                n - 1,\r\n                (-ra - w * H.get(i, n - 1) + q * H.get(i, n)) / x,\r\n              );\r\n              H.set(\r\n                i + 1,\r\n                n,\r\n                (-sa - w * H.get(i, n) - q * H.get(i, n - 1)) / x,\r\n              );\r\n            } else {\r\n              cdivres = cdiv(\r\n                -r - y * H.get(i, n - 1),\r\n                -s - y * H.get(i, n),\r\n                z,\r\n                q,\r\n              );\r\n              H.set(i + 1, n - 1, cdivres[0]);\r\n              H.set(i + 1, n, cdivres[1]);\r\n            }\r\n          }\r\n\r\n          t = Math.max(Math.abs(H.get(i, n - 1)), Math.abs(H.get(i, n)));\r\n          if (eps * t * t > 1) {\r\n            for (j = i; j <= n; j++) {\r\n              H.set(j, n - 1, H.get(j, n - 1) / t);\r\n              H.set(j, n, H.get(j, n) / t);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < nn; i++) {\r\n    if (i < low || i > high) {\r\n      for (j = i; j < nn; j++) {\r\n        V.set(i, j, H.get(i, j));\r\n      }\r\n    }\r\n  }\r\n\r\n  for (j = nn - 1; j >= low; j--) {\r\n    for (i = low; i <= high; i++) {\r\n      z = 0;\r\n      for (k = low; k <= Math.min(j, high); k++) {\r\n        z = z + V.get(i, k) * H.get(k, j);\r\n      }\r\n      V.set(i, j, z);\r\n    }\r\n  }\r\n}\r\n\r\nfunction cdiv(xr, xi, yr, yi) {\r\n  let r, d;\r\n  if (Math.abs(yr) > Math.abs(yi)) {\r\n    r = yi / yr;\r\n    d = yr + r * yi;\r\n    return [(xr + r * xi) / d, (xi - r * xr) / d];\r\n  } else {\r\n    r = yr / yi;\r\n    d = yi + r * yr;\r\n    return [(r * xr + xi) / d, (r * xi - xr) / d];\r\n  }\r\n}\r\n\r\nclass CholeskyDecomposition {\r\n  constructor(value) {\r\n    value = WrapperMatrix2D.checkMatrix(value);\r\n    if (!value.isSymmetric()) {\r\n      throw new Error('Matrix is not symmetric');\r\n    }\r\n\r\n    let a = value;\r\n    let dimension = a.rows;\r\n    let l = new Matrix(dimension, dimension);\r\n    let positiveDefinite = true;\r\n    let i, j, k;\r\n\r\n    for (j = 0; j < dimension; j++) {\r\n      let d = 0;\r\n      for (k = 0; k < j; k++) {\r\n        let s = 0;\r\n        for (i = 0; i < k; i++) {\r\n          s += l.get(k, i) * l.get(j, i);\r\n        }\r\n        s = (a.get(j, k) - s) / l.get(k, k);\r\n        l.set(j, k, s);\r\n        d = d + s * s;\r\n      }\r\n\r\n      d = a.get(j, j) - d;\r\n\r\n      positiveDefinite &= d > 0;\r\n      l.set(j, j, Math.sqrt(Math.max(d, 0)));\r\n      for (k = j + 1; k < dimension; k++) {\r\n        l.set(j, k, 0);\r\n      }\r\n    }\r\n\r\n    this.L = l;\r\n    this.positiveDefinite = Boolean(positiveDefinite);\r\n  }\r\n\r\n  isPositiveDefinite() {\r\n    return this.positiveDefinite;\r\n  }\r\n\r\n  solve(value) {\r\n    value = WrapperMatrix2D.checkMatrix(value);\r\n\r\n    let l = this.L;\r\n    let dimension = l.rows;\r\n\r\n    if (value.rows !== dimension) {\r\n      throw new Error('Matrix dimensions do not match');\r\n    }\r\n    if (this.isPositiveDefinite() === false) {\r\n      throw new Error('Matrix is not positive definite');\r\n    }\r\n\r\n    let count = value.columns;\r\n    let B = value.clone();\r\n    let i, j, k;\r\n\r\n    for (k = 0; k < dimension; k++) {\r\n      for (j = 0; j < count; j++) {\r\n        for (i = 0; i < k; i++) {\r\n          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(k, i));\r\n        }\r\n        B.set(k, j, B.get(k, j) / l.get(k, k));\r\n      }\r\n    }\r\n\r\n    for (k = dimension - 1; k >= 0; k--) {\r\n      for (j = 0; j < count; j++) {\r\n        for (i = k + 1; i < dimension; i++) {\r\n          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(i, k));\r\n        }\r\n        B.set(k, j, B.get(k, j) / l.get(k, k));\r\n      }\r\n    }\r\n\r\n    return B;\r\n  }\r\n\r\n  get lowerTriangularMatrix() {\r\n    return this.L;\r\n  }\r\n}\r\n\r\nclass nipals {\r\n  constructor(X, options = {}) {\r\n    X = WrapperMatrix2D.checkMatrix(X);\r\n    let { Y } = options;\r\n    const {\r\n      scaleScores = false,\r\n      maxIterations = 1000,\r\n      terminationCriteria = 1e-10,\r\n    } = options;\r\n\r\n    let u;\r\n    if (Y) {\r\n      if (isAnyArray.isAnyArray(Y) && typeof Y[0] === 'number') {\r\n        Y = Matrix.columnVector(Y);\r\n      } else {\r\n        Y = WrapperMatrix2D.checkMatrix(Y);\r\n      }\r\n      if (Y.rows !== X.rows) {\r\n        throw new Error('Y should have the same number of rows as X');\r\n      }\r\n      u = Y.getColumnVector(0);\r\n    } else {\r\n      u = X.getColumnVector(0);\r\n    }\r\n\r\n    let diff = 1;\r\n    let t, q, w, tOld;\r\n\r\n    for (\r\n      let counter = 0;\r\n      counter < maxIterations && diff > terminationCriteria;\r\n      counter++\r\n    ) {\r\n      w = X.transpose().mmul(u).div(u.transpose().mmul(u).get(0, 0));\r\n      w = w.div(w.norm());\r\n\r\n      t = X.mmul(w).div(w.transpose().mmul(w).get(0, 0));\r\n\r\n      if (counter > 0) {\r\n        diff = t.clone().sub(tOld).pow(2).sum();\r\n      }\r\n      tOld = t.clone();\r\n\r\n      if (Y) {\r\n        q = Y.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));\r\n        q = q.div(q.norm());\r\n\r\n        u = Y.mmul(q).div(q.transpose().mmul(q).get(0, 0));\r\n      } else {\r\n        u = t;\r\n      }\r\n    }\r\n\r\n    if (Y) {\r\n      let p = X.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));\r\n      p = p.div(p.norm());\r\n      let xResidual = X.clone().sub(t.clone().mmul(p.transpose()));\r\n      let residual = u.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));\r\n      let yResidual = Y.clone().sub(\r\n        t.clone().mulS(residual.get(0, 0)).mmul(q.transpose()),\r\n      );\r\n\r\n      this.t = t;\r\n      this.p = p.transpose();\r\n      this.w = w.transpose();\r\n      this.q = q;\r\n      this.u = u;\r\n      this.s = t.transpose().mmul(t);\r\n      this.xResidual = xResidual;\r\n      this.yResidual = yResidual;\r\n      this.betas = residual;\r\n    } else {\r\n      this.w = w.transpose();\r\n      this.s = t.transpose().mmul(t).sqrt();\r\n      if (scaleScores) {\r\n        this.t = t.clone().div(this.s.get(0, 0));\r\n      } else {\r\n        this.t = t;\r\n      }\r\n      this.xResidual = X.sub(t.mmul(w.transpose()));\r\n    }\r\n  }\r\n}\r\n\r\nexports.AbstractMatrix = AbstractMatrix;\r\nexports.CHO = CholeskyDecomposition;\r\nexports.CholeskyDecomposition = CholeskyDecomposition;\r\nexports.EVD = EigenvalueDecomposition;\r\nexports.EigenvalueDecomposition = EigenvalueDecomposition;\r\nexports.LU = LuDecomposition;\r\nexports.LuDecomposition = LuDecomposition;\r\nexports.Matrix = Matrix;\r\nexports.MatrixColumnSelectionView = MatrixColumnSelectionView;\r\nexports.MatrixColumnView = MatrixColumnView;\r\nexports.MatrixFlipColumnView = MatrixFlipColumnView;\r\nexports.MatrixFlipRowView = MatrixFlipRowView;\r\nexports.MatrixRowSelectionView = MatrixRowSelectionView;\r\nexports.MatrixRowView = MatrixRowView;\r\nexports.MatrixSelectionView = MatrixSelectionView;\r\nexports.MatrixSubView = MatrixSubView;\r\nexports.MatrixTransposeView = MatrixTransposeView;\r\nexports.NIPALS = nipals;\r\nexports.Nipals = nipals;\r\nexports.QR = QrDecomposition;\r\nexports.QrDecomposition = QrDecomposition;\r\nexports.SVD = SingularValueDecomposition;\r\nexports.SingularValueDecomposition = SingularValueDecomposition;\r\nexports.WrapperMatrix1D = WrapperMatrix1D;\r\nexports.WrapperMatrix2D = WrapperMatrix2D;\r\nexports.correlation = correlation;\r\nexports.covariance = covariance;\r\nexports[\"default\"] = Matrix;\r\nexports.determinant = determinant;\r\nexports.inverse = inverse;\r\nexports.linearDependencies = linearDependencies;\r\nexports.pseudoInverse = pseudoInverse;\r\nexports.solve = solve;\r\nexports.wrap = wrap;\r\n"]}