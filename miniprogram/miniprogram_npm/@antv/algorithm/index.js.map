{"version":3,"sources":["index.js","adjacent-matrix.js","bfs.js","structs/queue.js","structs/linked-list.js","util.js","connected-component.js","degree.js","detect-cycle.js","dfs.js","dijkstra.js","find-path.js","floydWarshall.js","label-propagation.js","louvain.js","utils/vector.js","utils/node-properties.js","constants/time.js","utils/data-preprocessing.js","types.js","i-louvain.js","k-core.js","k-means.js","cosine-similarity.js","nodes-cosine-similarity.js","mts.js","structs/union-find.js","structs/binary-heap.js","pageRank.js","gaddi.js","gSpan/gSpan.js","gSpan/struct.js","structs/stack.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AIZA,ADGA;AFOA,ACHA,AFMA,AIZA,ADGA;AFOA,ACHA,AFMA,AIZA,ADGA;AFOA,ACHA,AFMA,AIZA,ADGA,AENA;AJaA,ACHA,AFMA,AIZA,ADGA,AENA;AJaA,ACHA,AFMA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ANkBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ANkBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ANkBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,APqBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,APqBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,APqBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ARwBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ARwBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ARwBA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,AT2BA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,AT2BA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,AT2BA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AV8BA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AV8BA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,AV8BA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AXiCA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AXiCA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,AXiCA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AIZA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,AT2BA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,AT2BA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,AT2BA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA;AJaA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA,AU9BA;Ad2CA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA,AU9BA;Ad2CA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA,AU9BA;Ad2CA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA,AWjCA,ADGA;AbwCA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA,AWjCA,ADGA;AbwCA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA,AWjCA,ADGA;AbwCA,AIZA,AWjCA,AV8BA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA,AWjCA,ADGA;AbwCA,AIZA,AWjCA,AV8BA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA,AWjCA,ADGA;AbwCA,AIZA,AWjCA,AV8BA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA,AWjCA,ADGA;AbwCA,AIZA,AWjCA,AV8BA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA,AavCA,AFMA,ADGA;AbwCA,AIZA,AWjCA,AV8BA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA,AavCA,AFMA,ADGA;AbwCA,AIZA,AWjCA,AV8BA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AENA,AavCA,AFMA,ADGA;AbwCA,AIZA,AWjCA,AV8BA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AgBhDA,Ad0CA,AavCA,AFMA,ADGA;AbwCA,AIZA,AWjCA,AV8BA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AgBhDA,Ad0CA,AavCA,AFMA,ADGA;AbwCA,AIZA,AWjCA,AV8BA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,AavCA,ACHA,AV8BA,ADGA,AgBhDA,Ad0CA,AavCA,AFMA,ADGA;AbwCA,AIZA,AWjCA,AV8BA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AavCA,ACHA,AV8BA,ADGA,AgBhDA,Ad0CA,AavCA,AFMA,ADGA;AbwCA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AavCA,ACHA,AV8BA,ADGA,AgBhDA,Ad0CA,AavCA,AFMA,ADGA;AbwCA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AavCA,ACHA,AV8BA,ADGA,AgBhDA,Ad0CA,AavCA,AFMA,ADGA;AbwCA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ARwBA,ACHA,AV8BA,ADGA,AgBhDA,Ad0CA,AavCA,AFMA,ADGA;AbwCA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ARwBA,ACHA,AV8BA,ADGA,AgBhDA,Ad0CA,AavCA,AFMA,ADGA;AbwCA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ARwBA,ACHA,AV8BA,ADGA,AgBhDA,Ad0CA,AavCA,AFMA,ADGA;AbwCA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AV8BA,ADGA,AgBhDA,Ad0CA,AavCA,AFMA,ADGA;AbwCA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AV8BA,ADGA,AgBhDA,Ad0CA,AavCA,AFMA,ADGA;AbwCA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AV8BA,ADGA,AgBhDA,Ad0CA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AV8BA,ADGA,AENA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AV8BA,ADGA,AENA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AV8BA,ADGA,AENA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AU9BA,ApB4DA,ADGA,AENA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AU9BA,ApB4DA,ADGA,AENA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AU9BA,ApB4DA,ACHA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,ApB4DA,ACHA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,ApB4DA,ACHA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,ApB4DA,ACHA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,ApB4DA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,ApB4DA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,ApB4DA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,ACHA,AQxBA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AGTA,AvBqEA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,AS3BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AGTA,AvBqEA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,AS3BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AGTA,AvBqEA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,AS3BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,AS3BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,AS3BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,AhBgDA,ACHA,ACHA,ACHA,ACHA,AkBtDA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,Af6CA,ACHA,ACHA,ACHA,AkBtDA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,Af6CA,ACHA,ACHA,ACHA,AkBtDA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,Af6CA,ACHA,ACHA,ACHA,AmBzDA,ADGA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,Af6CA,ACHA,ACHA,ACHA,AmBzDA,ADGA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,Af6CA,ACHA,ACHA,ACHA,AmBzDA,ADGA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,Af6CA,ACHA,ACHA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,Af6CA,ACHA,ACHA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,Af6CA,ACHA,ACHA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,AsBlEA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,Af6CA,ACHA,ACHA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,Af6CA,ACHA,ACHA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,Af6CA,ACHA,ACHA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,Af6CA,ACHA,ACHA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,Af6CA,ACHA,ACHA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,Af6CA,ACHA,ACHA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,Af6CA,ACHA,ACHA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AiBnDA,Af6CA,ACHA,ACHA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AENA,AENA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AENA,AENA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AENA,AENA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AbwCA,AIZA,AENA,AENA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AT4BA,AENA,AENA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AT4BA,AENA,AENA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AT4BA,AENA,AENA,ACHA,AmBzDA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ArB+DA,AavCA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,AT2BA,ApB4DA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,ANkBA,ARwBA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AqB/DA,ACHA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ADGA,AIZA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AENA,AoB5DA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AFMA,ADGA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AGTA,ADGA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,A4BpFA,Ad0CA,AHSA;AT4BA,AENA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,A4BpFA,Ad0CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,A4BpFA,Ad0CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,A4BpFA,Ad0CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,A4BpFA,Ad0CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,A4BpFA,Ad0CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,A4BpFA,Ad0CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,Ac1CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,Ac1CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,Ac1CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,Ac1CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,AENA,AvBqEA,Ac1CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,Ac1CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,Ac1CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,Ac1CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,Ac1CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,Ac1CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,Ac1CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,Ac1CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,Ac1CA,AHSA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,AT2BA,ACHA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AWjCA,ArB+DA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ACHA,AFMA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,A7BuFA,AsBlEA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA,AWjCA;APsBA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA,AV8BA;AIXA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,APqBA,ARwBA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;ANmBA,AsBlEA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA,Af6CA;AgB/CA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\n\r\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nObject.defineProperty(exports, \"GADDI\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _gaddi.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"Stack\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _stack.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"breadthFirstSearch\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _bfs.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"connectedComponent\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _connectedComponent.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"cosineSimilarity\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _cosineSimilarity.default;\r\n  }\r\n});\r\nexports.default = void 0;\r\nObject.defineProperty(exports, \"depthFirstSearch\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _dfs.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"detectAllCycles\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _detectCycle.detectAllCycles;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"detectAllDirectedCycle\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _detectCycle.detectAllDirectedCycle;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"detectAllUndirectedCycle\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _detectCycle.detectAllUndirectedCycle;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"detectCycle\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _detectCycle.default;\r\n  }\r\n});\r\nexports.detectDirectedCycle = void 0;\r\nObject.defineProperty(exports, \"dijkstra\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _dijkstra.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"findAllPath\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _findPath.findAllPath;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"findShortestPath\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _findPath.findShortestPath;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"floydWarshall\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _floydWarshall.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"getAdjMatrix\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _adjacentMatrix.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"getDegree\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _degree.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"getInDegree\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _degree.getInDegree;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"getNeighbors\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _util.getNeighbors;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"getOutDegree\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _degree.getOutDegree;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"iLouvain\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _iLouvain.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"kCore\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _kCore.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"kMeans\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _kMeans.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"labelPropagation\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _labelPropagation.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"louvain\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _louvain.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"minimumSpanningTree\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _mts.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"nodesCosineSimilarity\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _nodesCosineSimilarity.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"pageRank\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _pageRank.default;\r\n  }\r\n});\r\n\r\nvar _adjacentMatrix = _interopRequireDefault(require(\"./adjacent-matrix\"));\r\n\r\nvar _bfs = _interopRequireDefault(require(\"./bfs\"));\r\n\r\nvar _connectedComponent = _interopRequireDefault(require(\"./connected-component\"));\r\n\r\nvar _degree = _interopRequireWildcard(require(\"./degree\"));\r\n\r\nvar _detectCycle = _interopRequireWildcard(require(\"./detect-cycle\"));\r\n\r\nvar _dfs = _interopRequireDefault(require(\"./dfs\"));\r\n\r\nvar _dijkstra = _interopRequireDefault(require(\"./dijkstra\"));\r\n\r\nvar _findPath = require(\"./find-path\");\r\n\r\nvar _floydWarshall = _interopRequireDefault(require(\"./floydWarshall\"));\r\n\r\nvar _labelPropagation = _interopRequireDefault(require(\"./label-propagation\"));\r\n\r\nvar _louvain = _interopRequireDefault(require(\"./louvain\"));\r\n\r\nvar _iLouvain = _interopRequireDefault(require(\"./i-louvain\"));\r\n\r\nvar _kCore = _interopRequireDefault(require(\"./k-core\"));\r\n\r\nvar _kMeans = _interopRequireDefault(require(\"./k-means\"));\r\n\r\nvar _cosineSimilarity = _interopRequireDefault(require(\"./cosine-similarity\"));\r\n\r\nvar _nodesCosineSimilarity = _interopRequireDefault(require(\"./nodes-cosine-similarity\"));\r\n\r\nvar _mts = _interopRequireDefault(require(\"./mts\"));\r\n\r\nvar _pageRank = _interopRequireDefault(require(\"./pageRank\"));\r\n\r\nvar _gaddi = _interopRequireDefault(require(\"./gaddi\"));\r\n\r\nvar _stack = _interopRequireDefault(require(\"./structs/stack\"));\r\n\r\nvar _util = require(\"./util\");\r\n\r\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\r\n\r\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar detectDirectedCycle = _detectCycle.default;\r\nexports.detectDirectedCycle = detectDirectedCycle;\r\nvar _default = {\r\n  getAdjMatrix: _adjacentMatrix.default,\r\n  breadthFirstSearch: _bfs.default,\r\n  connectedComponent: _connectedComponent.default,\r\n  getDegree: _degree.default,\r\n  getInDegree: _degree.getInDegree,\r\n  getOutDegree: _degree.getOutDegree,\r\n  detectCycle: _detectCycle.default,\r\n  detectDirectedCycle: detectDirectedCycle,\r\n  detectAllCycles: _detectCycle.detectAllCycles,\r\n  detectAllDirectedCycle: _detectCycle.detectAllDirectedCycle,\r\n  detectAllUndirectedCycle: _detectCycle.detectAllUndirectedCycle,\r\n  depthFirstSearch: _dfs.default,\r\n  dijkstra: _dijkstra.default,\r\n  findAllPath: _findPath.findAllPath,\r\n  findShortestPath: _findPath.findShortestPath,\r\n  floydWarshall: _floydWarshall.default,\r\n  labelPropagation: _labelPropagation.default,\r\n  louvain: _louvain.default,\r\n  iLouvain: _iLouvain.default,\r\n  kCore: _kCore.default,\r\n  kMeans: _kMeans.default,\r\n  cosineSimilarity: _cosineSimilarity.default,\r\n  nodesCosineSimilarity: _nodesCosineSimilarity.default,\r\n  minimumSpanningTree: _mts.default,\r\n  pageRank: _pageRank.default,\r\n  getNeighbors: _util.getNeighbors,\r\n  Stack: _stack.default,\r\n  GADDI: _gaddi.default\r\n};\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar adjMatrix = function adjMatrix(graphData, directed) {\r\n  var nodes = graphData.nodes,\r\n      edges = graphData.edges;\r\n  var matrix = []; // map node with index in data.nodes\r\n\r\n  var nodeMap = {};\r\n\r\n  if (!nodes) {\r\n    throw new Error(\"invalid nodes data!\");\r\n  }\r\n\r\n  if (nodes) {\r\n    nodes.forEach(function (node, i) {\r\n      nodeMap[node.id] = i;\r\n      var row = [];\r\n      matrix.push(row);\r\n    });\r\n  }\r\n\r\n  if (edges) {\r\n    edges.forEach(function (edge) {\r\n      var source = edge.source,\r\n          target = edge.target;\r\n      var sIndex = nodeMap[source];\r\n      var tIndex = nodeMap[target];\r\n      if (!sIndex && sIndex !== 0 || !tIndex && tIndex !== 0) return;\r\n      matrix[sIndex][tIndex] = 1;\r\n\r\n      if (!directed) {\r\n        matrix[tIndex][sIndex] = 1;\r\n      }\r\n    });\r\n  }\r\n\r\n  return matrix;\r\n};\r\n\r\nvar _default = adjMatrix;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _queue = _interopRequireDefault(require(\"./structs/queue\"));\r\n\r\nvar _util = require(\"./util\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n *\r\n * @param callbacks\r\n * allowTraversal: 确定 BFS 是否从顶点沿着边遍历到其邻居，默认情况下，同一个节点只能遍历一次\r\n * enterNode: 当 BFS 访问某个节点时调用\r\n * leaveNode: 当 BFS 访问访问结束某个节点时调用\r\n */\r\nfunction initCallbacks(callbacks) {\r\n  if (callbacks === void 0) {\r\n    callbacks = {};\r\n  }\r\n\r\n  var initiatedCallback = callbacks;\r\n\r\n  var stubCallback = function stubCallback() {};\r\n\r\n  var allowTraversalCallback = function () {\r\n    var seen = {};\r\n    return function (_a) {\r\n      var next = _a.next;\r\n      var id = next;\r\n\r\n      if (!seen[id]) {\r\n        seen[id] = true;\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    };\r\n  }();\r\n\r\n  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;\r\n  initiatedCallback.enter = callbacks.enter || stubCallback;\r\n  initiatedCallback.leave = callbacks.leave || stubCallback;\r\n  return initiatedCallback;\r\n}\r\n/**\r\n * 广度优先遍历图\r\n * @param graph Graph 图实例\r\n * @param startNode 开始遍历的节点\r\n * @param originalCallbacks 回调\r\n */\r\n\r\n\r\nvar breadthFirstSearch = function breadthFirstSearch(graphData, startNodeId, originalCallbacks, directed) {\r\n  if (directed === void 0) {\r\n    directed = true;\r\n  }\r\n\r\n  var callbacks = initCallbacks(originalCallbacks);\r\n  var nodeQueue = new _queue.default();\r\n  var _a = graphData.edges,\r\n      edges = _a === void 0 ? [] : _a; // 初始化队列元素\r\n\r\n  nodeQueue.enqueue(startNodeId);\r\n  var previousNode = '';\r\n\r\n  var _loop_1 = function _loop_1() {\r\n    var currentNode = nodeQueue.dequeue();\r\n    callbacks.enter({\r\n      current: currentNode,\r\n      previous: previousNode\r\n    }); // 将所有邻居添加到队列中以便遍历\r\n\r\n    (0, _util.getNeighbors)(currentNode, edges, directed ? 'target' : undefined).forEach(function (nextNode) {\r\n      if (callbacks.allowTraversal({\r\n        previous: previousNode,\r\n        current: currentNode,\r\n        next: nextNode\r\n      })) {\r\n        nodeQueue.enqueue(nextNode);\r\n      }\r\n    });\r\n    callbacks.leave({\r\n      current: currentNode,\r\n      previous: previousNode\r\n    }); // 下一次循环之前存储当前顶点\r\n\r\n    previousNode = currentNode;\r\n  }; // 遍历队列中的所有顶点\r\n\r\n\r\n  while (!nodeQueue.isEmpty()) {\r\n    _loop_1();\r\n  }\r\n};\r\n\r\nvar _default = breadthFirstSearch;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _linkedList = _interopRequireDefault(require(\"./linked-list\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar Queue =\r\n/** @class */\r\nfunction () {\r\n  function Queue() {\r\n    this.linkedList = new _linkedList.default();\r\n  }\r\n  /**\r\n   * 队列是否为空\r\n   */\r\n\r\n\r\n  Queue.prototype.isEmpty = function () {\r\n    return !this.linkedList.head;\r\n  };\r\n  /**\r\n   * 读取队列头部的元素， 不删除队列中的元素\r\n   */\r\n\r\n\r\n  Queue.prototype.peek = function () {\r\n    if (!this.linkedList.head) {\r\n      return null;\r\n    }\r\n\r\n    return this.linkedList.head.value;\r\n  };\r\n  /**\r\n   * 在队列的尾部新增一个元素\r\n   * @param value\r\n   */\r\n\r\n\r\n  Queue.prototype.enqueue = function (value) {\r\n    this.linkedList.append(value);\r\n  };\r\n  /**\r\n   * 删除队列中的头部元素，如果队列为空，则返回 null\r\n   */\r\n\r\n\r\n  Queue.prototype.dequeue = function () {\r\n    var removeHead = this.linkedList.deleteHead();\r\n    return removeHead ? removeHead.value : null;\r\n  };\r\n\r\n  Queue.prototype.toString = function (callback) {\r\n    return this.linkedList.toString(callback);\r\n  };\r\n\r\n  return Queue;\r\n}();\r\n\r\nvar _default = Queue;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = exports.LinkedListNode = void 0;\r\n\r\nvar defaultComparator = function defaultComparator(a, b) {\r\n  if (a === b) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n/**\r\n * 链表中单个元素节点\r\n */\r\n\r\n\r\nvar LinkedListNode =\r\n/** @class */\r\nfunction () {\r\n  function LinkedListNode(value, next) {\r\n    if (next === void 0) {\r\n      next = null;\r\n    }\r\n\r\n    this.value = value;\r\n    this.next = next;\r\n  }\r\n\r\n  LinkedListNode.prototype.toString = function (callback) {\r\n    return callback ? callback(this.value) : \"\".concat(this.value);\r\n  };\r\n\r\n  return LinkedListNode;\r\n}();\r\n\r\nexports.LinkedListNode = LinkedListNode;\r\n\r\nvar LinkedList =\r\n/** @class */\r\nfunction () {\r\n  function LinkedList(comparator) {\r\n    if (comparator === void 0) {\r\n      comparator = defaultComparator;\r\n    }\r\n\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.compare = comparator;\r\n  }\r\n  /**\r\n   * 将指定元素添加到链表头部\r\n   * @param value\r\n   */\r\n\r\n\r\n  LinkedList.prototype.prepend = function (value) {\r\n    // 在头部添加一个节点\r\n    var newNode = new LinkedListNode(value, this.head);\r\n    this.head = newNode;\r\n\r\n    if (!this.tail) {\r\n      this.tail = newNode;\r\n    }\r\n\r\n    return this;\r\n  };\r\n  /**\r\n   * 将指定元素添加到链表中\r\n   * @param value\r\n   */\r\n\r\n\r\n  LinkedList.prototype.append = function (value) {\r\n    var newNode = new LinkedListNode(value); // 如果不存在头节点，则将创建的新节点作为头节点\r\n\r\n    if (!this.head) {\r\n      this.head = newNode;\r\n      this.tail = newNode;\r\n      return this;\r\n    } // 将新节点附加到链表末尾\r\n\r\n\r\n    this.tail.next = newNode;\r\n    this.tail = newNode;\r\n    return this;\r\n  };\r\n  /**\r\n   * 删除指定元素\r\n   * @param value 要删除的元素\r\n   */\r\n\r\n\r\n  LinkedList.prototype.delete = function (value) {\r\n    if (!this.head) {\r\n      return null;\r\n    }\r\n\r\n    var deleteNode = null; // 如果删除的是头部元素，则将next作为头元素\r\n\r\n    while (this.head && this.compare(this.head.value, value)) {\r\n      deleteNode = this.head;\r\n      this.head = this.head.next;\r\n    }\r\n\r\n    var currentNode = this.head;\r\n\r\n    if (currentNode !== null) {\r\n      // 如果删除了节点以后，将next节点前移\r\n      while (currentNode.next) {\r\n        if (this.compare(currentNode.next.value, value)) {\r\n          deleteNode = currentNode.next;\r\n          currentNode.next = currentNode.next.next;\r\n        } else {\r\n          currentNode = currentNode.next;\r\n        }\r\n      }\r\n    } // 检查尾部节点是否被删除\r\n\r\n\r\n    if (this.compare(this.tail.value, value)) {\r\n      this.tail = currentNode;\r\n    }\r\n\r\n    return deleteNode;\r\n  };\r\n  /**\r\n   * 查找指定的元素\r\n   * @param param0\r\n   */\r\n\r\n\r\n  LinkedList.prototype.find = function (_a) {\r\n    var _b = _a.value,\r\n        value = _b === void 0 ? undefined : _b,\r\n        _c = _a.callback,\r\n        callback = _c === void 0 ? undefined : _c;\r\n\r\n    if (!this.head) {\r\n      return null;\r\n    }\r\n\r\n    var currentNode = this.head;\r\n\r\n    while (currentNode) {\r\n      // 如果指定了 callback，则按指定的 callback 查找\r\n      if (callback && callback(currentNode.value)) {\r\n        return currentNode;\r\n      } // 如果指定了 value，则按 value 查找\r\n\r\n\r\n      if (value !== undefined && this.compare(currentNode.value, value)) {\r\n        return currentNode;\r\n      }\r\n\r\n      currentNode = currentNode.next;\r\n    }\r\n\r\n    return null;\r\n  };\r\n  /**\r\n   * 删除尾部节点\r\n   */\r\n\r\n\r\n  LinkedList.prototype.deleteTail = function () {\r\n    var deletedTail = this.tail;\r\n\r\n    if (this.head === this.tail) {\r\n      // 链表中只有一个元素\r\n      this.head = null;\r\n      this.tail = null;\r\n      return deletedTail;\r\n    }\r\n\r\n    var currentNode = this.head;\r\n\r\n    while (currentNode.next) {\r\n      if (!currentNode.next.next) {\r\n        currentNode.next = null;\r\n      } else {\r\n        currentNode = currentNode.next;\r\n      }\r\n    }\r\n\r\n    this.tail = currentNode;\r\n    return deletedTail;\r\n  };\r\n  /**\r\n   * 删除头部节点\r\n   */\r\n\r\n\r\n  LinkedList.prototype.deleteHead = function () {\r\n    if (!this.head) {\r\n      return null;\r\n    }\r\n\r\n    var deletedHead = this.head;\r\n\r\n    if (this.head.next) {\r\n      this.head = this.head.next;\r\n    } else {\r\n      this.head = null;\r\n      this.tail = null;\r\n    }\r\n\r\n    return deletedHead;\r\n  };\r\n  /**\r\n   * 将一组元素转成链表中的节点\r\n   * @param values 链表中的元素\r\n   */\r\n\r\n\r\n  LinkedList.prototype.fromArray = function (values) {\r\n    var _this = this;\r\n\r\n    values.forEach(function (value) {\r\n      return _this.append(value);\r\n    });\r\n    return this;\r\n  };\r\n  /**\r\n   * 将链表中的节点转成数组元素\r\n   */\r\n\r\n\r\n  LinkedList.prototype.toArray = function () {\r\n    var nodes = [];\r\n    var currentNode = this.head;\r\n\r\n    while (currentNode) {\r\n      nodes.push(currentNode);\r\n      currentNode = currentNode.next;\r\n    }\r\n\r\n    return nodes;\r\n  };\r\n  /**\r\n   * 反转链表中的元素节点\r\n   */\r\n\r\n\r\n  LinkedList.prototype.reverse = function () {\r\n    var currentNode = this.head;\r\n    var prevNode = null;\r\n    var nextNode = null;\r\n\r\n    while (currentNode) {\r\n      // 存储下一个元素节点\r\n      nextNode = currentNode.next; // 更改当前节点的下一个节点，以便将它连接到上一个节点上\r\n\r\n      currentNode.next = prevNode; // 将 prevNode 和 currentNode 向前移动一步\r\n\r\n      prevNode = currentNode;\r\n      currentNode = nextNode;\r\n    }\r\n\r\n    this.tail = this.head;\r\n    this.head = prevNode;\r\n  };\r\n\r\n  LinkedList.prototype.toString = function (callback) {\r\n    if (callback === void 0) {\r\n      callback = undefined;\r\n    }\r\n\r\n    return this.toArray().map(function (node) {\r\n      return node.toString(callback);\r\n    }).toString();\r\n  };\r\n\r\n  return LinkedList;\r\n}();\r\n\r\nvar _default = LinkedList;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.uniqueId = exports.getOutEdgesNodeId = exports.getNeighbors = exports.getEdgesByNodeId = void 0;\r\n\r\n/**\r\n * 获取指定节点的所有邻居\r\n * @param nodeId 节点 ID\r\n * @param edges 图中的所有边数据\r\n * @param type 邻居类型\r\n */\r\nvar getNeighbors = function getNeighbors(nodeId, edges, type) {\r\n  if (edges === void 0) {\r\n    edges = [];\r\n  }\r\n\r\n  var currentEdges = edges.filter(function (edge) {\r\n    return edge.source === nodeId || edge.target === nodeId;\r\n  });\r\n\r\n  if (type === 'target') {\r\n    // 当前节点为 source，它所指向的目标节点\r\n    var neighhborsConverter_1 = function neighhborsConverter_1(edge) {\r\n      return edge.source === nodeId;\r\n    };\r\n\r\n    return currentEdges.filter(neighhborsConverter_1).map(function (edge) {\r\n      return edge.target;\r\n    });\r\n  }\r\n\r\n  if (type === 'source') {\r\n    // 当前节点为 target，它所指向的源节点\r\n    var neighhborsConverter_2 = function neighhborsConverter_2(edge) {\r\n      return edge.target === nodeId;\r\n    };\r\n\r\n    return currentEdges.filter(neighhborsConverter_2).map(function (edge) {\r\n      return edge.source;\r\n    });\r\n  } // 若未指定 type ，则返回所有邻居\r\n\r\n\r\n  var neighhborsConverter = function neighhborsConverter(edge) {\r\n    return edge.source === nodeId ? edge.target : edge.source;\r\n  };\r\n\r\n  return currentEdges.map(neighhborsConverter);\r\n};\r\n/**\r\n * 获取指定节点的出边\r\n * @param nodeId 节点 ID\r\n * @param edges 图中的所有边数据\r\n */\r\n\r\n\r\nexports.getNeighbors = getNeighbors;\r\n\r\nvar getOutEdgesNodeId = function getOutEdgesNodeId(nodeId, edges) {\r\n  return edges.filter(function (edge) {\r\n    return edge.source === nodeId;\r\n  });\r\n};\r\n/**\r\n * 获取指定节点的边，包括出边和入边\r\n * @param nodeId 节点 ID\r\n * @param edges 图中的所有边数据\r\n */\r\n\r\n\r\nexports.getOutEdgesNodeId = getOutEdgesNodeId;\r\n\r\nvar getEdgesByNodeId = function getEdgesByNodeId(nodeId, edges) {\r\n  return edges.filter(function (edge) {\r\n    return edge.source === nodeId || edge.target === nodeId;\r\n  });\r\n};\r\n/**\r\n * 生成唯一的 ID，规则是序号 + 时间戳\r\n * @param index 序号\r\n */\r\n\r\n\r\nexports.getEdgesByNodeId = getEdgesByNodeId;\r\n\r\nvar uniqueId = function uniqueId(index) {\r\n  if (index === void 0) {\r\n    index = 0;\r\n  }\r\n\r\n  var random1 = \"\".concat(Math.random()).split('.')[1].substr(0, 5);\r\n  var random2 = \"\".concat(Math.random()).split('.')[1].substr(0, 5);\r\n  return \"\".concat(index, \"-\").concat(random1).concat(random2);\r\n};\r\n\r\nexports.uniqueId = uniqueId;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = getConnectedComponents;\r\nexports.detectStrongConnectComponents = exports.detectConnectedComponents = void 0;\r\n\r\nvar _util = require(\"./util\");\r\n\r\n/**\r\n * Generate all connected components for an undirected graph\r\n * @param graph\r\n */\r\nvar detectConnectedComponents = function detectConnectedComponents(graphData) {\r\n  var _a = graphData.nodes,\r\n      nodes = _a === void 0 ? [] : _a,\r\n      _b = graphData.edges,\r\n      edges = _b === void 0 ? [] : _b;\r\n  var allComponents = [];\r\n  var visited = {};\r\n  var nodeStack = [];\r\n\r\n  var getComponent = function getComponent(node) {\r\n    nodeStack.push(node);\r\n    visited[node.id] = true;\r\n    var neighbors = (0, _util.getNeighbors)(node.id, edges);\r\n\r\n    var _loop_1 = function _loop_1(i) {\r\n      var neighbor = neighbors[i];\r\n\r\n      if (!visited[neighbor]) {\r\n        var targetNode = nodes.filter(function (node) {\r\n          return node.id === neighbor;\r\n        });\r\n\r\n        if (targetNode.length > 0) {\r\n          getComponent(targetNode[0]);\r\n        }\r\n      }\r\n    };\r\n\r\n    for (var i = 0; i < neighbors.length; ++i) {\r\n      _loop_1(i);\r\n    }\r\n  };\r\n\r\n  for (var i = 0; i < nodes.length; i++) {\r\n    var node = nodes[i];\r\n\r\n    if (!visited[node.id]) {\r\n      // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量\r\n      getComponent(node);\r\n      var component = [];\r\n\r\n      while (nodeStack.length > 0) {\r\n        component.push(nodeStack.pop());\r\n      }\r\n\r\n      allComponents.push(component);\r\n    }\r\n  }\r\n\r\n  return allComponents;\r\n};\r\n/**\r\n * Tarjan's Algorithm 复杂度  O(|V|+|E|)\r\n * For directed graph only\r\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\r\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\r\n * @param graph\r\n * @return a list of strongly connected components\r\n */\r\n\r\n\r\nexports.detectConnectedComponents = detectConnectedComponents;\r\n\r\nvar detectStrongConnectComponents = function detectStrongConnectComponents(graphData) {\r\n  var _a = graphData.nodes,\r\n      nodes = _a === void 0 ? [] : _a,\r\n      _b = graphData.edges,\r\n      edges = _b === void 0 ? [] : _b;\r\n  var nodeStack = [];\r\n  var inStack = {}; // 辅助判断是否已经在stack中，减少查找开销\r\n\r\n  var indices = {};\r\n  var lowLink = {};\r\n  var allComponents = [];\r\n  var index = 0;\r\n\r\n  var getComponent = function getComponent(node) {\r\n    // Set the depth index for v to the smallest unused index\r\n    indices[node.id] = index;\r\n    lowLink[node.id] = index;\r\n    index += 1;\r\n    nodeStack.push(node);\r\n    inStack[node.id] = true; // 考虑每个邻接点\r\n\r\n    var neighbors = (0, _util.getNeighbors)(node.id, edges, 'target').filter(function (n) {\r\n      return nodes.map(function (node) {\r\n        return node.id;\r\n      }).indexOf(n) > -1;\r\n    });\r\n\r\n    var _loop_2 = function _loop_2(i) {\r\n      var targetNodeID = neighbors[i];\r\n\r\n      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {\r\n        var targetNode = nodes.filter(function (node) {\r\n          return node.id === targetNodeID;\r\n        });\r\n\r\n        if (targetNode.length > 0) {\r\n          getComponent(targetNode[0]);\r\n        } // tree edge\r\n\r\n\r\n        lowLink[node.id] = Math.min(lowLink[node.id], lowLink[targetNodeID]);\r\n      } else if (inStack[targetNodeID]) {\r\n        // back edge, target node is in the current SCC\r\n        lowLink[node.id] = Math.min(lowLink[node.id], indices[targetNodeID]);\r\n      }\r\n    };\r\n\r\n    for (var i = 0; i < neighbors.length; i++) {\r\n      _loop_2(i);\r\n    } // If node is a root node, generate an SCC\r\n\r\n\r\n    if (lowLink[node.id] === indices[node.id]) {\r\n      var component = [];\r\n\r\n      while (nodeStack.length > 0) {\r\n        var tmpNode = nodeStack.pop();\r\n        inStack[tmpNode.id] = false;\r\n        component.push(tmpNode);\r\n        if (tmpNode === node) break;\r\n      }\r\n\r\n      if (component.length > 0) {\r\n        allComponents.push(component);\r\n      }\r\n    }\r\n  };\r\n\r\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\r\n    var node = nodes_1[_i];\r\n\r\n    if (!indices[node.id] && indices[node.id] !== 0) {\r\n      getComponent(node);\r\n    }\r\n  }\r\n\r\n  return allComponents;\r\n};\r\n\r\nexports.detectStrongConnectComponents = detectStrongConnectComponents;\r\n\r\nfunction getConnectedComponents(graphData, directed) {\r\n  if (directed) return detectStrongConnectComponents(graphData);\r\n  return detectConnectedComponents(graphData);\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.getOutDegree = exports.getInDegree = exports.default = void 0;\r\n\r\nvar degree = function degree(graphData) {\r\n  var degrees = {};\r\n  var _a = graphData.nodes,\r\n      nodes = _a === void 0 ? [] : _a,\r\n      _b = graphData.edges,\r\n      edges = _b === void 0 ? [] : _b;\r\n  nodes.forEach(function (node) {\r\n    degrees[node.id] = {\r\n      degree: 0,\r\n      inDegree: 0,\r\n      outDegree: 0\r\n    };\r\n  });\r\n  edges.forEach(function (edge) {\r\n    degrees[edge.source].degree++;\r\n    degrees[edge.source].outDegree++;\r\n    degrees[edge.target].degree++;\r\n    degrees[edge.target].inDegree++;\r\n  });\r\n  return degrees;\r\n};\r\n\r\nvar _default = degree;\r\n/**\r\n * 获取指定节点的入度\r\n * @param graphData 图数据\r\n * @param nodeId 节点ID\r\n */\r\n\r\nexports.default = _default;\r\n\r\nvar getInDegree = function getInDegree(graphData, nodeId) {\r\n  var nodeDegree = degree(graphData);\r\n\r\n  if (nodeDegree[nodeId]) {\r\n    return degree(graphData)[nodeId].inDegree;\r\n  }\r\n\r\n  return 0;\r\n};\r\n/**\r\n * 获取指定节点的出度\r\n * @param graphData 图数据\r\n * @param nodeId 节点ID\r\n */\r\n\r\n\r\nexports.getInDegree = getInDegree;\r\n\r\nvar getOutDegree = function getOutDegree(graphData, nodeId) {\r\n  var nodeDegree = degree(graphData);\r\n\r\n  if (nodeDegree[nodeId]) {\r\n    return degree(graphData)[nodeId].outDegree;\r\n  }\r\n\r\n  return 0;\r\n};\r\n\r\nexports.getOutDegree = getOutDegree;","\r\n\r\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.detectAllUndirectedCycle = exports.detectAllDirectedCycle = exports.detectAllCycles = exports.default = void 0;\r\n\r\nvar _dfs = _interopRequireDefault(require(\"./dfs\"));\r\n\r\nvar _connectedComponent = _interopRequireWildcard(require(\"./connected-component\"));\r\n\r\nvar _util = require(\"./util\");\r\n\r\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\r\n\r\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar detectDirectedCycle = function detectDirectedCycle(graphData) {\r\n  var cycle = null;\r\n  var _a = graphData.nodes,\r\n      nodes = _a === void 0 ? [] : _a;\r\n  var dfsParentMap = {}; // 所有没有被访问的节点集合\r\n\r\n  var unvisitedSet = {}; // 正在被访问的节点集合\r\n\r\n  var visitingSet = {}; // 所有已经被访问过的节点集合\r\n\r\n  var visitedSet = {}; // 初始化 unvisitedSet\r\n\r\n  nodes.forEach(function (node) {\r\n    unvisitedSet[node.id] = node;\r\n  });\r\n  var callbacks = {\r\n    enter: function enter(_a) {\r\n      var currentNode = _a.current,\r\n          previousNode = _a.previous;\r\n\r\n      if (visitingSet[currentNode]) {\r\n        // 如果当前节点正在访问中，则说明检测到环路了\r\n        cycle = {};\r\n        var currentCycleNode = currentNode;\r\n        var previousCycleNode = previousNode;\r\n\r\n        while (previousCycleNode !== currentNode) {\r\n          cycle[currentCycleNode] = previousCycleNode;\r\n          currentCycleNode = previousCycleNode;\r\n          previousCycleNode = dfsParentMap[previousCycleNode];\r\n        }\r\n\r\n        cycle[currentCycleNode] = previousCycleNode;\r\n      } else {\r\n        // 如果不存在正在访问集合中，则将其放入正在访问集合，并从未访问集合中删除\r\n        visitingSet[currentNode] = currentNode;\r\n        delete unvisitedSet[currentNode]; // 更新 DSF parents 列表\r\n\r\n        dfsParentMap[currentNode] = previousNode;\r\n      }\r\n    },\r\n    leave: function leave(_a) {\r\n      var currentNode = _a.current; // 如果所有的节点的子节点都已经访问过了，则从正在访问集合中删除掉，并将其移入到已访问集合中，\r\n      // 同时也意味着当前节点的所有邻居节点都被访问过了\r\n\r\n      visitedSet[currentNode] = currentNode;\r\n      delete visitingSet[currentNode];\r\n    },\r\n    allowTraversal: function allowTraversal(_a) {\r\n      var nextNode = _a.next; // 如果检测到环路则需要终止所有进一步的遍历，否则会导致无限循环遍历\r\n\r\n      if (cycle) {\r\n        return false;\r\n      } // 仅允许遍历没有访问的节点，visitedSet 中的都已经访问过了\r\n\r\n\r\n      return !visitedSet[nextNode];\r\n    }\r\n  }; // 开始遍历节点\r\n\r\n  while (Object.keys(unvisitedSet).length) {\r\n    // 从第一个节点开始进行 DFS 遍历\r\n    var firsetUnVisitedKey = Object.keys(unvisitedSet)[0];\r\n    (0, _dfs.default)(graphData, firsetUnVisitedKey, callbacks);\r\n  }\r\n\r\n  return cycle;\r\n};\r\n/**\r\n * 检测无向图中的所有Base cycles\r\n * refer: https://www.codeproject.com/Articles/1158232/Enumerating-All-Cycles-in-an-Undirected-Graph\r\n * @param graph\r\n * @param nodeIds 节点 ID 的数组\r\n * @param include 包含或排除指定的节点\r\n * @return [{[key: string]: INode}] 返回一组base cycles\r\n */\r\n\r\n\r\nvar detectAllUndirectedCycle = function detectAllUndirectedCycle(graphData, nodeIds, include) {\r\n  var _a, _b;\r\n\r\n  if (include === void 0) {\r\n    include = true;\r\n  }\r\n\r\n  var allCycles = [];\r\n  var components = (0, _connectedComponent.default)(graphData, false); // loop through all connected components\r\n\r\n  for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {\r\n    var component = components_1[_i];\r\n    if (!component.length) continue;\r\n    var root = component[0];\r\n    var rootId = root.id;\r\n    var stack = [root];\r\n    var parent_1 = (_a = {}, _a[rootId] = root, _a);\r\n    var used = (_b = {}, _b[rootId] = new Set(), _b); // walk a spanning tree to find cycles\r\n\r\n    while (stack.length > 0) {\r\n      var curNode = stack.pop();\r\n      var curNodeId = curNode.id;\r\n      var neighbors = (0, _util.getNeighbors)(curNodeId, graphData.edges);\r\n\r\n      var _loop_1 = function _loop_1(i) {\r\n        var _c;\r\n\r\n        var neighborId = neighbors[i];\r\n        var neighbor = graphData.nodes.find(function (node) {\r\n          return node.id === neighborId;\r\n        }); // const neighborId = neighbor.get('id');\r\n\r\n        if (neighborId === curNodeId) {\r\n          // 自环\r\n          allCycles.push((_c = {}, _c[neighborId] = curNode, _c));\r\n        } else if (!(neighborId in used)) {\r\n          // visit a new node\r\n          parent_1[neighborId] = curNode;\r\n          stack.push(neighbor);\r\n          used[neighborId] = new Set([curNode]);\r\n        } else if (!used[curNodeId].has(neighbor)) {\r\n          // a cycle found\r\n          var cycleValid = true;\r\n          var cyclePath = [neighbor, curNode];\r\n          var p = parent_1[curNodeId];\r\n\r\n          while (used[neighborId].size && !used[neighborId].has(p)) {\r\n            cyclePath.push(p);\r\n            if (p === parent_1[p.id]) break;else p = parent_1[p.id];\r\n          }\r\n\r\n          cyclePath.push(p);\r\n\r\n          if (nodeIds && include) {\r\n            // 如果有指定包含的节点\r\n            cycleValid = false;\r\n\r\n            if (cyclePath.findIndex(function (node) {\r\n              return nodeIds.indexOf(node.id) > -1;\r\n            }) > -1) {\r\n              cycleValid = true;\r\n            }\r\n          } else if (nodeIds && !include) {\r\n            // 如果有指定不包含的节点\r\n            if (cyclePath.findIndex(function (node) {\r\n              return nodeIds.indexOf(node.id) > -1;\r\n            }) > -1) {\r\n              cycleValid = false;\r\n            }\r\n          } // 把 node list 形式转换为 cycle 的格式\r\n\r\n\r\n          if (cycleValid) {\r\n            var cycle = {};\r\n\r\n            for (var index = 1; index < cyclePath.length; index += 1) {\r\n              cycle[cyclePath[index - 1].id] = cyclePath[index];\r\n            }\r\n\r\n            if (cyclePath.length) {\r\n              cycle[cyclePath[cyclePath.length - 1].id] = cyclePath[0];\r\n            }\r\n\r\n            allCycles.push(cycle);\r\n          }\r\n\r\n          used[neighborId].add(curNode);\r\n        }\r\n      };\r\n\r\n      for (var i = 0; i < neighbors.length; i += 1) {\r\n        _loop_1(i);\r\n      }\r\n    }\r\n  }\r\n\r\n  return allCycles;\r\n};\r\n/**\r\n * Johnson's algorithm, 时间复杂度 O((V + E)(C + 1))$ and space bounded by O(V + E)\r\n * refer: https://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF\r\n * refer: https://networkx.github.io/documentation/stable/_modules/networkx/algorithms/cycles.html#simple_cycles\r\n * @param graph\r\n * @param nodeIds 节点 ID 的数组\r\n * @param include 包含或排除指定的节点\r\n * @return [{[key: string]: INode}] 返回所有的 simple cycles\r\n */\r\n\r\n\r\nexports.detectAllUndirectedCycle = detectAllUndirectedCycle;\r\n\r\nvar detectAllDirectedCycle = function detectAllDirectedCycle(graphData, nodeIds, include) {\r\n  if (include === void 0) {\r\n    include = true;\r\n  }\r\n\r\n  var path = []; // stack of nodes in current path\r\n\r\n  var blocked = new Set();\r\n  var B = []; // remember portions of the graph that yield no elementary circuit\r\n\r\n  var allCycles = [];\r\n  var idx2Node = {};\r\n  var node2Idx = {}; // 辅助函数： unblock all blocked nodes\r\n\r\n  var unblock = function unblock(thisNode) {\r\n    var stack = [thisNode];\r\n\r\n    while (stack.length > 0) {\r\n      var node = stack.pop();\r\n\r\n      if (blocked.has(node)) {\r\n        blocked.delete(node);\r\n        B[node.id].forEach(function (n) {\r\n          stack.push(n);\r\n        });\r\n        B[node.id].clear();\r\n      }\r\n    }\r\n  };\r\n\r\n  var circuit = function circuit(node, start, adjList) {\r\n    var closed = false; // whether a path is closed\r\n\r\n    if (nodeIds && include === false && nodeIds.indexOf(node.id) > -1) return closed;\r\n    path.push(node);\r\n    blocked.add(node);\r\n    var neighbors = adjList[node.id];\r\n\r\n    for (var i = 0; i < neighbors.length; i += 1) {\r\n      var neighbor = idx2Node[neighbors[i]];\r\n\r\n      if (neighbor === start) {\r\n        var cycle = {};\r\n\r\n        for (var index = 1; index < path.length; index += 1) {\r\n          cycle[path[index - 1].id] = path[index];\r\n        }\r\n\r\n        if (path.length) {\r\n          cycle[path[path.length - 1].id] = path[0];\r\n        }\r\n\r\n        allCycles.push(cycle);\r\n        closed = true;\r\n      } else if (!blocked.has(neighbor)) {\r\n        if (circuit(neighbor, start, adjList)) {\r\n          closed = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (closed) {\r\n      unblock(node);\r\n    } else {\r\n      for (var i = 0; i < neighbors.length; i += 1) {\r\n        var neighbor = idx2Node[neighbors[i]];\r\n\r\n        if (!B[neighbor.id].has(node)) {\r\n          B[neighbor.id].add(node);\r\n        }\r\n      }\r\n    }\r\n\r\n    path.pop();\r\n    return closed;\r\n  };\r\n\r\n  var _a = graphData.nodes,\r\n      nodes = _a === void 0 ? [] : _a; // Johnson's algorithm 要求给节点赋顺序，先按节点在数组中的顺序\r\n\r\n  for (var i = 0; i < nodes.length; i += 1) {\r\n    var node = nodes[i];\r\n    var nodeId = node.id;\r\n    node2Idx[nodeId] = i;\r\n    idx2Node[i] = node;\r\n  } // 如果有指定包含的节点，则把指定节点排序在前，以便提早结束搜索\r\n\r\n\r\n  if (nodeIds && include) {\r\n    var _loop_2 = function _loop_2(i) {\r\n      var nodeId = nodeIds[i];\r\n      node2Idx[nodes[i].id] = node2Idx[nodeId];\r\n      node2Idx[nodeId] = 0;\r\n      idx2Node[0] = nodes.find(function (node) {\r\n        return node.id === nodeId;\r\n      });\r\n      idx2Node[node2Idx[nodes[i].id]] = nodes[i];\r\n    };\r\n\r\n    for (var i = 0; i < nodeIds.length; i++) {\r\n      _loop_2(i);\r\n    }\r\n  } // 返回 节点顺序 >= nodeOrder 的强连通分量的adjList\r\n\r\n\r\n  var getMinComponentAdj = function getMinComponentAdj(components) {\r\n    var _a;\r\n\r\n    var minCompIdx;\r\n    var minIdx = Infinity; // Find least component and the lowest node\r\n\r\n    for (var i = 0; i < components.length; i += 1) {\r\n      var comp = components[i];\r\n\r\n      for (var j = 0; j < comp.length; j++) {\r\n        var nodeIdx_1 = node2Idx[comp[j].id];\r\n\r\n        if (nodeIdx_1 < minIdx) {\r\n          minIdx = nodeIdx_1;\r\n          minCompIdx = i;\r\n        }\r\n      }\r\n    }\r\n\r\n    var component = components[minCompIdx];\r\n    var adjList = [];\r\n\r\n    for (var i = 0; i < component.length; i += 1) {\r\n      var node = component[i];\r\n      adjList[node.id] = [];\r\n\r\n      for (var _i = 0, _b = (0, _util.getNeighbors)(node.id, graphData.edges, 'target').filter(function (n) {\r\n        return component.map(function (c) {\r\n          return c.id;\r\n        }).indexOf(n) > -1;\r\n      }); _i < _b.length; _i++) {\r\n        var neighbor = _b[_i]; // 对自环情况 (点连向自身) 特殊处理：记录自环，但不加入adjList\r\n\r\n        if (neighbor === node.id && !(include === false && nodeIds.indexOf(node.id) > -1)) {\r\n          allCycles.push((_a = {}, _a[node.id] = node, _a));\r\n        } else {\r\n          adjList[node.id].push(node2Idx[neighbor]);\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      component: component,\r\n      adjList: adjList,\r\n      minIdx: minIdx\r\n    };\r\n  };\r\n\r\n  var nodeIdx = 0;\r\n\r\n  while (nodeIdx < nodes.length) {\r\n    var subgraphNodes = nodes.filter(function (n) {\r\n      return node2Idx[n.id] >= nodeIdx;\r\n    });\r\n    var sccs = (0, _connectedComponent.detectStrongConnectComponents)({\r\n      nodes: subgraphNodes,\r\n      edges: graphData.edges\r\n    }).filter(function (component) {\r\n      return component.length > 1;\r\n    });\r\n    if (sccs.length === 0) break;\r\n    var scc = getMinComponentAdj(sccs);\r\n    var minIdx = scc.minIdx,\r\n        adjList = scc.adjList,\r\n        component = scc.component;\r\n\r\n    if (component.length > 1) {\r\n      component.forEach(function (node) {\r\n        B[node.id] = new Set();\r\n      });\r\n      var startNode = idx2Node[minIdx]; // startNode 不在指定要包含的节点中，提前结束搜索\r\n\r\n      if (nodeIds && include && nodeIds.indexOf(startNode.id) === -1) return allCycles;\r\n      circuit(startNode, startNode, adjList);\r\n      nodeIdx = minIdx + 1;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return allCycles;\r\n};\r\n/**\r\n * 查找图中所有满足要求的圈\r\n * @param graph\r\n * @param directed 是否为有向图\r\n * @param nodeIds 节点 ID 的数组，若不指定，则返回图中所有的圈\r\n * @param include 包含或排除指定的节点\r\n * @return [{[key: string]: Node}] 包含所有环的数组，每个环用一个Object表示，其中key为节点id，value为该节点在环中指向的下一个节点\r\n */\r\n\r\n\r\nexports.detectAllDirectedCycle = detectAllDirectedCycle;\r\n\r\nvar detectAllCycles = function detectAllCycles(graphData, directed, nodeIds, include) {\r\n  if (include === void 0) {\r\n    include = true;\r\n  }\r\n\r\n  if (directed) return detectAllDirectedCycle(graphData, nodeIds, include);\r\n  return detectAllUndirectedCycle(graphData, nodeIds, include);\r\n};\r\n\r\nexports.detectAllCycles = detectAllCycles;\r\nvar _default = detectDirectedCycle;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = depthFirstSearch;\r\n\r\nvar _util = require(\"./util\");\r\n\r\nfunction initCallbacks(callbacks) {\r\n  if (callbacks === void 0) {\r\n    callbacks = {};\r\n  }\r\n\r\n  var initiatedCallback = callbacks;\r\n\r\n  var stubCallback = function stubCallback() {};\r\n\r\n  var allowTraversalCallback = function () {\r\n    var seen = {};\r\n    return function (_a) {\r\n      var next = _a.next;\r\n\r\n      if (!seen[next]) {\r\n        seen[next] = true;\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    };\r\n  }();\r\n\r\n  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;\r\n  initiatedCallback.enter = callbacks.enter || stubCallback;\r\n  initiatedCallback.leave = callbacks.leave || stubCallback;\r\n  return initiatedCallback;\r\n}\r\n/**\r\n * @param {Graph} graph\r\n * @param {GraphNode} currentNode\r\n * @param {GraphNode} previousNode\r\n * @param {Callbacks} callbacks\r\n */\r\n\r\n\r\nfunction depthFirstSearchRecursive(graphData, currentNode, previousNode, callbacks) {\r\n  callbacks.enter({\r\n    current: currentNode,\r\n    previous: previousNode\r\n  });\r\n  var _a = graphData.edges,\r\n      edges = _a === void 0 ? [] : _a;\r\n  (0, _util.getNeighbors)(currentNode, edges, 'target').forEach(function (nextNode) {\r\n    if (callbacks.allowTraversal({\r\n      previous: previousNode,\r\n      current: currentNode,\r\n      next: nextNode\r\n    })) {\r\n      depthFirstSearchRecursive(graphData, nextNode, currentNode, callbacks);\r\n    }\r\n  });\r\n  callbacks.leave({\r\n    current: currentNode,\r\n    previous: previousNode\r\n  });\r\n}\r\n/**\r\n * 深度优先遍历图\r\n * @param data GraphData 图数据\r\n * @param startNodeId 开始遍历的节点的 ID\r\n * @param originalCallbacks 回调\r\n */\r\n\r\n\r\nfunction depthFirstSearch(graphData, startNodeId, callbacks) {\r\n  depthFirstSearchRecursive(graphData, startNodeId, '', initCallbacks(callbacks));\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _util2 = require(\"./util\");\r\n\r\nvar minVertex = function minVertex(D, nodes, marks) {\r\n  // 找出最小的点\r\n  var minDis = Infinity;\r\n  var minNode;\r\n\r\n  for (var i = 0; i < nodes.length; i++) {\r\n    var nodeId = nodes[i].id;\r\n\r\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\r\n      minDis = D[nodeId];\r\n      minNode = nodes[i];\r\n    }\r\n  }\r\n\r\n  return minNode;\r\n};\r\n\r\nvar dijkstra = function dijkstra(graphData, source, directed, weightPropertyName) {\r\n  var _a = graphData.nodes,\r\n      nodes = _a === void 0 ? [] : _a,\r\n      _b = graphData.edges,\r\n      edges = _b === void 0 ? [] : _b;\r\n  var nodeIds = [];\r\n  var marks = {};\r\n  var D = {};\r\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\r\n\r\n  nodes.forEach(function (node, i) {\r\n    var id = node.id;\r\n    nodeIds.push(id);\r\n    D[id] = Infinity;\r\n    if (id === source) D[id] = 0;\r\n  });\r\n  var nodeNum = nodes.length;\r\n\r\n  var _loop_1 = function _loop_1(i) {\r\n    // Process the vertices\r\n    var minNode = minVertex(D, nodes, marks);\r\n    var minNodeId = minNode.id;\r\n    marks[minNodeId] = true;\r\n    if (D[minNodeId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\r\n\r\n    var relatedEdges = [];\r\n    if (directed) relatedEdges = (0, _util2.getOutEdgesNodeId)(minNodeId, edges);else relatedEdges = (0, _util2.getEdgesByNodeId)(minNodeId, edges);\r\n    relatedEdges.forEach(function (edge) {\r\n      var edgeTarget = edge.target;\r\n      var edgeSource = edge.source;\r\n      var w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\r\n      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\r\n\r\n      if (D[w] > D[minNode.id] + weight) {\r\n        D[w] = D[minNode.id] + weight;\r\n        prevs[w] = [minNode.id];\r\n      } else if (D[w] === D[minNode.id] + weight) {\r\n        prevs[w].push(minNode.id);\r\n      }\r\n    });\r\n  };\r\n\r\n  for (var i = 0; i < nodeNum; i++) {\r\n    _loop_1(i);\r\n  }\r\n\r\n  prevs[source] = [source]; // 每个节点存可能存在多条最短路径\r\n\r\n  var paths = {};\r\n\r\n  for (var target in D) {\r\n    if (D[target] !== Infinity) {\r\n      findAllPaths(source, target, prevs, paths);\r\n    }\r\n  } // 兼容之前单路径\r\n\r\n\r\n  var path = {};\r\n\r\n  for (var target in paths) {\r\n    path[target] = paths[target][0];\r\n  }\r\n\r\n  return {\r\n    length: D,\r\n    path: path,\r\n    allPath: paths\r\n  };\r\n};\r\n\r\nvar _default = dijkstra;\r\nexports.default = _default;\r\n\r\nfunction findAllPaths(source, target, prevs, foundPaths) {\r\n  if (source === target) {\r\n    return [source];\r\n  }\r\n\r\n  if (foundPaths[target]) {\r\n    return foundPaths[target];\r\n  }\r\n\r\n  var paths = [];\r\n\r\n  for (var _i = 0, _a = prevs[target]; _i < _a.length; _i++) {\r\n    var prev = _a[_i];\r\n    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);\r\n    if (!prevPaths) return;\r\n\r\n    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {\r\n      var prePath = prevPaths_1[_b];\r\n      if ((0, _util.isArray)(prePath)) paths.push((0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], prePath, true), [target], false));else paths.push([prePath, target]);\r\n    }\r\n  }\r\n\r\n  foundPaths[target] = paths;\r\n  return foundPaths[target];\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.findShortestPath = exports.findAllPath = void 0;\r\n\r\nvar _dijkstra = _interopRequireDefault(require(\"./dijkstra\"));\r\n\r\nvar _util = require(\"./util\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar findShortestPath = function findShortestPath(graphData, start, end, directed, weightPropertyName) {\r\n  var _a = (0, _dijkstra.default)(graphData, start, directed, weightPropertyName),\r\n      length = _a.length,\r\n      path = _a.path,\r\n      allPath = _a.allPath;\r\n\r\n  return {\r\n    length: length[end],\r\n    path: path[end],\r\n    allPath: allPath[end]\r\n  };\r\n};\r\n\r\nexports.findShortestPath = findShortestPath;\r\n\r\nvar findAllPath = function findAllPath(graphData, start, end, directed) {\r\n  var _a;\r\n\r\n  if (start === end) return [[start]];\r\n  var _b = graphData.edges,\r\n      edges = _b === void 0 ? [] : _b;\r\n  var visited = [start];\r\n  var isVisited = (_a = {}, _a[start] = true, _a);\r\n  var stack = []; // 辅助栈，用于存储访问过的节点的邻居节点\r\n\r\n  var allPath = [];\r\n  var neighbors = directed ? (0, _util.getNeighbors)(start, edges, 'target') : (0, _util.getNeighbors)(start, edges);\r\n  stack.push(neighbors);\r\n\r\n  while (visited.length > 0 && stack.length > 0) {\r\n    var children = stack[stack.length - 1];\r\n\r\n    if (children.length) {\r\n      var child = children.shift();\r\n\r\n      if (child) {\r\n        visited.push(child);\r\n        isVisited[child] = true;\r\n        neighbors = directed ? (0, _util.getNeighbors)(child, edges, 'target') : (0, _util.getNeighbors)(child, edges);\r\n        stack.push(neighbors.filter(function (neighbor) {\r\n          return !isVisited[neighbor];\r\n        }));\r\n      }\r\n    } else {\r\n      var node = visited.pop();\r\n      isVisited[node] = false;\r\n      stack.pop();\r\n      continue;\r\n    }\r\n\r\n    if (visited[visited.length - 1] === end) {\r\n      var path = visited.map(function (node) {\r\n        return node;\r\n      });\r\n      allPath.push(path);\r\n      var node = visited.pop();\r\n      isVisited[node] = false;\r\n      stack.pop();\r\n    }\r\n  }\r\n\r\n  return allPath;\r\n};\r\n\r\nexports.findAllPath = findAllPath;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _adjacentMatrix = _interopRequireDefault(require(\"./adjacent-matrix\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar floydWarshall = function floydWarshall(graphData, directed) {\r\n  var adjacentMatrix = (0, _adjacentMatrix.default)(graphData, directed);\r\n  var dist = [];\r\n  var size = adjacentMatrix.length;\r\n\r\n  for (var i = 0; i < size; i += 1) {\r\n    dist[i] = [];\r\n\r\n    for (var j = 0; j < size; j += 1) {\r\n      if (i === j) {\r\n        dist[i][j] = 0;\r\n      } else if (adjacentMatrix[i][j] === 0 || !adjacentMatrix[i][j]) {\r\n        dist[i][j] = Infinity;\r\n      } else {\r\n        dist[i][j] = adjacentMatrix[i][j];\r\n      }\r\n    }\r\n  } // floyd\r\n\r\n\r\n  for (var k = 0; k < size; k += 1) {\r\n    for (var i = 0; i < size; i += 1) {\r\n      for (var j = 0; j < size; j += 1) {\r\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\r\n          dist[i][j] = dist[i][k] + dist[k][j];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return dist;\r\n};\r\n\r\nvar _default = floydWarshall;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _adjacentMatrix = _interopRequireDefault(require(\"./adjacent-matrix\"));\r\n\r\nvar _util = require(\"./util\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * 标签传播算法\r\n * @param graphData 图数据\r\n * @param directed 是否有向图，默认为 false\r\n * @param weightPropertyName 权重的属性字段\r\n * @param maxIteration 最大迭代次数\r\n */\r\nvar labelPropagation = function labelPropagation(graphData, directed, weightPropertyName, maxIteration) {\r\n  if (directed === void 0) {\r\n    directed = false;\r\n  }\r\n\r\n  if (weightPropertyName === void 0) {\r\n    weightPropertyName = 'weight';\r\n  }\r\n\r\n  if (maxIteration === void 0) {\r\n    maxIteration = 1000;\r\n  } // the origin data\r\n\r\n\r\n  var _a = graphData.nodes,\r\n      nodes = _a === void 0 ? [] : _a,\r\n      _b = graphData.edges,\r\n      edges = _b === void 0 ? [] : _b;\r\n  var clusters = {};\r\n  var nodeMap = {}; // init the clusters and nodeMap\r\n\r\n  nodes.forEach(function (node, i) {\r\n    var cid = (0, _util.uniqueId)();\r\n    node.clusterId = cid;\r\n    clusters[cid] = {\r\n      id: cid,\r\n      nodes: [node]\r\n    };\r\n    nodeMap[node.id] = {\r\n      node: node,\r\n      idx: i\r\n    };\r\n  }); // the adjacent matrix of calNodes inside clusters\r\n\r\n  var adjMatrix = (0, _adjacentMatrix.default)(graphData, directed); // the sum of each row in adjacent matrix\r\n\r\n  var ks = [];\r\n  /**\r\n   * neighbor nodes (id for key and weight for value) for each node\r\n   * neighbors = {\r\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\r\n   *  ...\r\n   * }\r\n   */\r\n\r\n  var neighbors = {};\r\n  adjMatrix.forEach(function (row, i) {\r\n    var k = 0;\r\n    var iid = nodes[i].id;\r\n    neighbors[iid] = {};\r\n    row.forEach(function (entry, j) {\r\n      if (!entry) return;\r\n      k += entry;\r\n      var jid = nodes[j].id;\r\n      neighbors[iid][jid] = entry;\r\n    });\r\n    ks.push(k);\r\n  });\r\n  var iter = 0;\r\n\r\n  var _loop_1 = function _loop_1() {\r\n    var changed = false;\r\n    nodes.forEach(function (node) {\r\n      var neighborClusters = {};\r\n      Object.keys(neighbors[node.id]).forEach(function (neighborId) {\r\n        var neighborWeight = neighbors[node.id][neighborId];\r\n        var neighborNode = nodeMap[neighborId].node;\r\n        var neighborClusterId = neighborNode.clusterId;\r\n        if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;\r\n        neighborClusters[neighborClusterId] += neighborWeight;\r\n      }); // find the cluster with max weight\r\n\r\n      var maxWeight = -Infinity;\r\n      var bestClusterIds = [];\r\n      Object.keys(neighborClusters).forEach(function (clusterId) {\r\n        if (maxWeight < neighborClusters[clusterId]) {\r\n          maxWeight = neighborClusters[clusterId];\r\n          bestClusterIds = [clusterId];\r\n        } else if (maxWeight === neighborClusters[clusterId]) {\r\n          bestClusterIds.push(clusterId);\r\n        }\r\n      });\r\n      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;\r\n      var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);\r\n      if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);\r\n\r\n      if (bestClusterIds && bestClusterIds.length) {\r\n        changed = true; // remove from origin cluster\r\n\r\n        var selfCluster = clusters[node.clusterId];\r\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\r\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1); // move the node to the best cluster\r\n\r\n        var randomIdx = Math.floor(Math.random() * bestClusterIds.length);\r\n        var bestCluster = clusters[bestClusterIds[randomIdx]];\r\n        bestCluster.nodes.push(node);\r\n        node.clusterId = bestCluster.id;\r\n      }\r\n    });\r\n    if (!changed) return \"break\";\r\n    iter++;\r\n  };\r\n\r\n  while (iter < maxIteration) {\r\n    var state_1 = _loop_1();\r\n\r\n    if (state_1 === \"break\") break;\r\n  } // delete the empty clusters\r\n\r\n\r\n  Object.keys(clusters).forEach(function (clusterId) {\r\n    var cluster = clusters[clusterId];\r\n\r\n    if (!cluster.nodes || !cluster.nodes.length) {\r\n      delete clusters[clusterId];\r\n    }\r\n  }); // get the cluster edges\r\n\r\n  var clusterEdges = [];\r\n  var clusterEdgeMap = {};\r\n  edges.forEach(function (edge) {\r\n    var source = edge.source,\r\n        target = edge.target;\r\n    var weight = edge[weightPropertyName] || 1;\r\n    var sourceClusterId = nodeMap[source].node.clusterId;\r\n    var targetClusterId = nodeMap[target].node.clusterId;\r\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\r\n\r\n    if (clusterEdgeMap[newEdgeId]) {\r\n      clusterEdgeMap[newEdgeId].weight += weight;\r\n      clusterEdgeMap[newEdgeId].count++;\r\n    } else {\r\n      var newEdge = {\r\n        source: sourceClusterId,\r\n        target: targetClusterId,\r\n        weight: weight,\r\n        count: 1\r\n      };\r\n      clusterEdgeMap[newEdgeId] = newEdge;\r\n      clusterEdges.push(newEdge);\r\n    }\r\n  });\r\n  var clustersArray = [];\r\n  Object.keys(clusters).forEach(function (clusterId) {\r\n    clustersArray.push(clusters[clusterId]);\r\n  });\r\n  return {\r\n    clusters: clustersArray,\r\n    clusterEdges: clusterEdges\r\n  };\r\n};\r\n\r\nvar _default = labelPropagation;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _adjacentMatrix = _interopRequireDefault(require(\"./adjacent-matrix\"));\r\n\r\nvar _vector = _interopRequireDefault(require(\"./utils/vector\"));\r\n\r\nvar _nodeProperties = require(\"./utils/node-properties\");\r\n\r\nvar _dataPreprocessing = require(\"./utils/data-preprocessing\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar getModularity = function getModularity(nodes, adjMatrix, ks, m) {\r\n  var length = adjMatrix.length;\r\n  var param = 2 * m;\r\n  var modularity = 0;\r\n\r\n  for (var i = 0; i < length; i++) {\r\n    var clusteri = nodes[i].clusterId;\r\n\r\n    for (var j = 0; j < length; j++) {\r\n      var clusterj = nodes[j].clusterId;\r\n      if (clusteri !== clusterj) continue;\r\n      var entry = adjMatrix[i][j] || 0;\r\n      var ki = ks[i] || 0;\r\n      var kj = ks[j] || 0;\r\n      modularity += entry - ki * kj / param;\r\n    }\r\n  }\r\n\r\n  modularity *= 1 / param;\r\n  return modularity;\r\n}; // 模块惯性度，衡量属性相似度\r\n\r\n\r\nvar getInertialModularity = function getInertialModularity(nodes, allPropertiesWeight) {\r\n  if (nodes === void 0) {\r\n    nodes = [];\r\n  }\r\n\r\n  var length = nodes.length;\r\n  var totalProperties = new _vector.default([]);\r\n\r\n  for (var i = 0; i < length; i++) {\r\n    totalProperties = totalProperties.add(new _vector.default(allPropertiesWeight[i]));\r\n  } // 均值向量\r\n\r\n\r\n  var avgProperties = totalProperties.avg(length);\r\n  avgProperties.normalize(); // 节点集合的方差: 节点v与均值向量的平方欧式距离之和\r\n\r\n  var variance = 0;\r\n\r\n  for (var i = 0; i < length; i++) {\r\n    var propertiesi = new _vector.default(allPropertiesWeight[i]);\r\n    var squareEuclideanDistance = propertiesi.squareEuclideanDistance(avgProperties);\r\n    variance += squareEuclideanDistance;\r\n  } // 任意两点间的欧式平方距离\r\n\r\n\r\n  var squareEuclideanDistanceInfo = [];\r\n  nodes.forEach(function () {\r\n    squareEuclideanDistanceInfo.push([]);\r\n  });\r\n\r\n  for (var i = 0; i < length; i++) {\r\n    var propertiesi = new _vector.default(allPropertiesWeight[i]);\r\n    nodes[i]['clusterInertial'] = 0;\r\n\r\n    for (var j = 0; j < length; j++) {\r\n      if (i === j) {\r\n        squareEuclideanDistanceInfo[i][j] = 0;\r\n        continue;\r\n      }\r\n\r\n      var propertiesj = new _vector.default(allPropertiesWeight[j]);\r\n      squareEuclideanDistanceInfo[i][j] = propertiesi.squareEuclideanDistance(propertiesj);\r\n      nodes[i]['clusterInertial'] += squareEuclideanDistanceInfo[i][j];\r\n    }\r\n  } // 计算模块惯性度\r\n\r\n\r\n  var inertialModularity = 0;\r\n  var param = 2 * length * variance;\r\n\r\n  for (var i = 0; i < length; i++) {\r\n    var clusteri = nodes[i].clusterId;\r\n\r\n    for (var j = 0; j < length; j++) {\r\n      var clusterj = nodes[j].clusterId;\r\n      if (i === j || clusteri !== clusterj) continue;\r\n      var inertial = nodes[i].clusterInertial * nodes[j].clusterInertial / Math.pow(param, 2) - squareEuclideanDistanceInfo[i][j] / param;\r\n      inertialModularity += inertial;\r\n    }\r\n  }\r\n\r\n  return Number(inertialModularity.toFixed(4));\r\n};\r\n/**\r\n * 社区发现 louvain 算法\r\n * @param graphData 图数据\r\n * @param directed 是否有向图，默认为 false\r\n * @param weightPropertyName 权重的属性字段\r\n * @param threshold 差值阈值\r\n * @param inertialModularity 是否使用惯性模块度（即节点属性相似性）\r\n * @param propertyKey 属性的字段名\r\n * @param involvedKeys 参与计算的key集合\r\n * @param uninvolvedKeys 不参与计算的key集合\r\n * @param inertialWeight 惯性模块度权重\r\n */\r\n\r\n\r\nvar louvain = function louvain(graphData, directed, weightPropertyName, threshold, inertialModularity, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {\r\n  if (directed === void 0) {\r\n    directed = false;\r\n  }\r\n\r\n  if (weightPropertyName === void 0) {\r\n    weightPropertyName = 'weight';\r\n  }\r\n\r\n  if (threshold === void 0) {\r\n    threshold = 0.0001;\r\n  }\r\n\r\n  if (inertialModularity === void 0) {\r\n    inertialModularity = false;\r\n  }\r\n\r\n  if (propertyKey === void 0) {\r\n    propertyKey = undefined;\r\n  }\r\n\r\n  if (involvedKeys === void 0) {\r\n    involvedKeys = [];\r\n  }\r\n\r\n  if (uninvolvedKeys === void 0) {\r\n    uninvolvedKeys = ['id'];\r\n  }\r\n\r\n  if (inertialWeight === void 0) {\r\n    inertialWeight = 1;\r\n  } // the origin data\r\n\r\n\r\n  var _a = graphData.nodes,\r\n      nodes = _a === void 0 ? [] : _a,\r\n      _b = graphData.edges,\r\n      edges = _b === void 0 ? [] : _b;\r\n  var allPropertiesWeight = [];\r\n\r\n  if (inertialModularity) {\r\n    nodes.forEach(function (node, index) {\r\n      node.properties = node.properties || {};\r\n      node.originIndex = index;\r\n    });\r\n    var nodeTypeInfo_1 = [];\r\n\r\n    if (nodes.every(function (node) {\r\n      return node.hasOwnProperty('nodeType');\r\n    })) {\r\n      nodeTypeInfo_1 = Array.from(new Set(nodes.map(function (node) {\r\n        return node.nodeType;\r\n      })));\r\n      nodes.forEach(function (node) {\r\n        node.properties.nodeType = nodeTypeInfo_1.findIndex(function (nodeType) {\r\n          return nodeType === node.nodeType;\r\n        });\r\n      });\r\n    } // 所有节点属性集合\r\n\r\n\r\n    var properties = (0, _nodeProperties.getAllProperties)(nodes, propertyKey); // 所有节点属性one-hot特征向量集合\r\n\r\n    allPropertiesWeight = (0, _dataPreprocessing.oneHot)(properties, involvedKeys, uninvolvedKeys);\r\n  }\r\n\r\n  var uniqueId = 1;\r\n  var clusters = {};\r\n  var nodeMap = {}; // init the clusters and nodeMap\r\n\r\n  nodes.forEach(function (node, i) {\r\n    var cid = String(uniqueId++);\r\n    node.clusterId = cid;\r\n    clusters[cid] = {\r\n      id: cid,\r\n      nodes: [node]\r\n    };\r\n    nodeMap[node.id] = {\r\n      node: node,\r\n      idx: i\r\n    };\r\n  }); // the adjacent matrix of calNodes inside clusters\r\n\r\n  var adjMatrix = (0, _adjacentMatrix.default)(graphData, directed); // the sum of each row in adjacent matrix\r\n\r\n  var ks = [];\r\n  /**\r\n   * neighbor nodes (id for key and weight for value) for each node\r\n   * neighbors = {\r\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\r\n   *  ...\r\n   * }\r\n   */\r\n\r\n  var neighbors = {}; // the sum of the weights of all edges in the graph\r\n\r\n  var m = 0;\r\n  adjMatrix.forEach(function (row, i) {\r\n    var k = 0;\r\n    var iid = nodes[i].id;\r\n    neighbors[iid] = {};\r\n    row.forEach(function (entry, j) {\r\n      if (!entry) return;\r\n      k += entry;\r\n      var jid = nodes[j].id;\r\n      neighbors[iid][jid] = entry;\r\n      m += entry;\r\n    });\r\n    ks.push(k);\r\n  });\r\n  m /= 2;\r\n  var totalModularity = Infinity;\r\n  var previousModularity = Infinity;\r\n  var iter = 0;\r\n  var finalNodes = [];\r\n  var finalClusters = {};\r\n\r\n  while (true) {\r\n    if (inertialModularity && nodes.every(function (node) {\r\n      return node.hasOwnProperty('properties');\r\n    })) {\r\n      totalModularity = getModularity(nodes, adjMatrix, ks, m) + getInertialModularity(nodes, allPropertiesWeight) * inertialWeight;\r\n    } else {\r\n      totalModularity = getModularity(nodes, adjMatrix, ks, m);\r\n    } // 第一次迭代previousModularity直接赋值\r\n\r\n\r\n    if (iter === 0) {\r\n      previousModularity = totalModularity;\r\n      finalNodes = nodes;\r\n      finalClusters = clusters;\r\n    }\r\n\r\n    var increaseWithinThreshold = totalModularity > 0 && totalModularity > previousModularity && totalModularity - previousModularity < threshold; // 总模块度增加才更新最优解\r\n\r\n    if (totalModularity > previousModularity) {\r\n      finalNodes = nodes.map(function (node) {\r\n        return {\r\n          node: node,\r\n          clusterId: node.clusterId\r\n        };\r\n      });\r\n      finalClusters = (0, _util.clone)(clusters);\r\n      previousModularity = totalModularity;\r\n    } // whether to terminate the iterations\r\n\r\n\r\n    if (increaseWithinThreshold || iter > 100) {\r\n      break;\r\n    }\r\n\r\n    ;\r\n    iter++; // pre compute some values for current clusters\r\n\r\n    Object.keys(clusters).forEach(function (clusterId) {\r\n      // sum of weights of edges to nodes in cluster\r\n      var sumTot = 0;\r\n      edges.forEach(function (edge) {\r\n        var source = edge.source,\r\n            target = edge.target;\r\n        var sourceClusterId = nodeMap[source].node.clusterId;\r\n        var targetClusterId = nodeMap[target].node.clusterId;\r\n\r\n        if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {\r\n          sumTot = sumTot + (edge[weightPropertyName] || 1);\r\n        }\r\n      });\r\n      clusters[clusterId].sumTot = sumTot;\r\n    }); // move the nodes to increase the delta modularity\r\n\r\n    nodes.forEach(function (node, i) {\r\n      var selfCluster = clusters[node.clusterId];\r\n      var bestIncrease = 0;\r\n      var bestCluster;\r\n      var commonParam = ks[i] / (2 * m); // sum of weights of edges from node to nodes in cluster\r\n\r\n      var kiin = 0;\r\n      var selfClusterNodes = selfCluster.nodes;\r\n      selfClusterNodes.forEach(function (scNode) {\r\n        var scNodeIdx = nodeMap[scNode.id].idx;\r\n        kiin += adjMatrix[i][scNodeIdx] || 0;\r\n      }); // the modurarity for **removing** the node i from the origin cluster of node i\r\n\r\n      var removeModurarity = kiin - selfCluster.sumTot * commonParam; // nodes for **removing** node i into this neighbor cluster\r\n\r\n      var selfClusterNodesAfterRemove = selfClusterNodes.filter(function (scNode) {\r\n        return scNode.id !== node.id;\r\n      });\r\n      var propertiesWeightRemove = [];\r\n      selfClusterNodesAfterRemove.forEach(function (nodeRemove, index) {\r\n        propertiesWeightRemove[index] = allPropertiesWeight[nodeRemove.originIndex];\r\n      }); // the inertialModularity for **removing** the node i from the origin cluster of node i\r\n\r\n      var removeInertialModularity = getInertialModularity(selfClusterNodesAfterRemove, allPropertiesWeight) * inertialWeight; // the neightbors of the node\r\n\r\n      var nodeNeighborIds = neighbors[node.id];\r\n      Object.keys(nodeNeighborIds).forEach(function (neighborNodeId) {\r\n        var neighborNode = nodeMap[neighborNodeId].node;\r\n        var neighborClusterId = neighborNode.clusterId; // if the node and the neighbor of node are in the same cluster, reutrn\r\n\r\n        if (neighborClusterId === node.clusterId) return;\r\n        var neighborCluster = clusters[neighborClusterId];\r\n        var clusterNodes = neighborCluster.nodes; // if the cluster is empty, remove the cluster and return\r\n\r\n        if (!clusterNodes || !clusterNodes.length) return; // sum of weights of edges from node to nodes in cluster\r\n\r\n        var neighborClusterKiin = 0;\r\n        clusterNodes.forEach(function (cNode) {\r\n          var cNodeIdx = nodeMap[cNode.id].idx;\r\n          neighborClusterKiin += adjMatrix[i][cNodeIdx] || 0;\r\n        }); // the modurarity for **adding** node i into this neighbor cluster\r\n\r\n        var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam; // nodes for **adding** node i into this neighbor cluster\r\n\r\n        var clusterNodesAfterAdd = clusterNodes.concat([node]);\r\n        var propertiesWeightAdd = [];\r\n        clusterNodesAfterAdd.forEach(function (nodeAdd, index) {\r\n          propertiesWeightAdd[index] = allPropertiesWeight[nodeAdd.originIndex];\r\n        }); // the inertialModularity for **adding** node i into this neighbor cluster\r\n\r\n        var addInertialModularity = getInertialModularity(clusterNodesAfterAdd, allPropertiesWeight) * inertialWeight; // the increase modurarity is the difference between addModurarity and removeModurarity\r\n\r\n        var increase = addModurarity - removeModurarity;\r\n\r\n        if (inertialModularity) {\r\n          increase = addModurarity + addInertialModularity - (removeModurarity + removeInertialModularity);\r\n        } // find the best cluster to move node i into\r\n\r\n\r\n        if (increase > bestIncrease) {\r\n          bestIncrease = increase;\r\n          bestCluster = neighborCluster;\r\n        }\r\n      }); // if found a best cluster to move into\r\n\r\n      if (bestIncrease > 0) {\r\n        bestCluster.nodes.push(node);\r\n        var previousClusterId_1 = node.clusterId;\r\n        node.clusterId = bestCluster.id; // move the node to the best cluster\r\n\r\n        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node); // remove from origin cluster\r\n\r\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1); // update sumTot for clusters\r\n        // sum of weights of edges to nodes in cluster\r\n\r\n        var neighborClusterSumTot_1 = 0;\r\n        var selfClusterSumTot_1 = 0;\r\n        edges.forEach(function (edge) {\r\n          var source = edge.source,\r\n              target = edge.target;\r\n          var sourceClusterId = nodeMap[source].node.clusterId;\r\n          var targetClusterId = nodeMap[target].node.clusterId;\r\n\r\n          if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {\r\n            neighborClusterSumTot_1 = neighborClusterSumTot_1 + (edge[weightPropertyName] || 1);\r\n          }\r\n\r\n          if (sourceClusterId === previousClusterId_1 && targetClusterId !== previousClusterId_1 || targetClusterId === previousClusterId_1 && sourceClusterId !== previousClusterId_1) {\r\n            selfClusterSumTot_1 = selfClusterSumTot_1 + (edge[weightPropertyName] || 1);\r\n          }\r\n        }); // the nodes of the clusters to move into and remove are changed, update their sumTot\r\n\r\n        bestCluster.sumTot = neighborClusterSumTot_1;\r\n        selfCluster.sumTot = selfClusterSumTot_1;\r\n      }\r\n    });\r\n  } // delete the empty clusters, assign increasing clusterId\r\n\r\n\r\n  var newClusterIdMap = {};\r\n  var clusterIdx = 0;\r\n  Object.keys(finalClusters).forEach(function (clusterId) {\r\n    var cluster = finalClusters[clusterId];\r\n\r\n    if (!cluster.nodes || !cluster.nodes.length) {\r\n      delete finalClusters[clusterId];\r\n      return;\r\n    }\r\n\r\n    var newId = String(clusterIdx + 1);\r\n\r\n    if (newId === clusterId) {\r\n      return;\r\n    }\r\n\r\n    cluster.id = newId;\r\n    cluster.nodes = cluster.nodes.map(function (item) {\r\n      return {\r\n        id: item.id,\r\n        clusterId: newId\r\n      };\r\n    });\r\n    finalClusters[newId] = cluster;\r\n    newClusterIdMap[clusterId] = newId;\r\n    delete finalClusters[clusterId];\r\n    clusterIdx++;\r\n  }); // restore node clusterId\r\n\r\n  finalNodes.forEach(function (nodeInfo) {\r\n    var node = nodeInfo.node,\r\n        clusterId = nodeInfo.clusterId;\r\n    if (!node) return;\r\n    node.clusterId = clusterId;\r\n    if (node.clusterId && newClusterIdMap[node.clusterId]) node.clusterId = newClusterIdMap[node.clusterId];\r\n  }); // get the cluster edges\r\n\r\n  var clusterEdges = [];\r\n  var clusterEdgeMap = {};\r\n  edges.forEach(function (edge) {\r\n    var source = edge.source,\r\n        target = edge.target;\r\n    var weight = edge[weightPropertyName] || 1;\r\n    var sourceClusterId = nodeMap[source].node.clusterId;\r\n    var targetClusterId = nodeMap[target].node.clusterId;\r\n    if (!sourceClusterId || !targetClusterId) return;\r\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\r\n\r\n    if (clusterEdgeMap[newEdgeId]) {\r\n      clusterEdgeMap[newEdgeId].weight += weight;\r\n      clusterEdgeMap[newEdgeId].count++;\r\n    } else {\r\n      var newEdge = {\r\n        source: sourceClusterId,\r\n        target: targetClusterId,\r\n        weight: weight,\r\n        count: 1\r\n      };\r\n      clusterEdgeMap[newEdgeId] = newEdge;\r\n      clusterEdges.push(newEdge);\r\n    }\r\n  });\r\n  var clustersArray = [];\r\n  Object.keys(finalClusters).forEach(function (clusterId) {\r\n    clustersArray.push(finalClusters[clusterId]);\r\n  });\r\n  return {\r\n    clusters: clustersArray,\r\n    clusterEdges: clusterEdges\r\n  };\r\n};\r\n\r\nvar _default = louvain;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\n/**\r\n * 向量运算\r\n */\r\nvar Vector =\r\n/** @class */\r\nfunction () {\r\n  function Vector(arr) {\r\n    this.arr = arr;\r\n  }\r\n\r\n  Vector.prototype.getArr = function () {\r\n    return this.arr || [];\r\n  };\r\n\r\n  Vector.prototype.add = function (otherVector) {\r\n    var _a;\r\n\r\n    var otherArr = otherVector.arr;\r\n\r\n    if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length)) {\r\n      return new Vector(otherArr);\r\n    }\r\n\r\n    if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {\r\n      return new Vector(this.arr);\r\n    }\r\n\r\n    if (this.arr.length === otherArr.length) {\r\n      var res = [];\r\n\r\n      for (var index in this.arr) {\r\n        res[index] = this.arr[index] + otherArr[index];\r\n      }\r\n\r\n      return new Vector(res);\r\n    }\r\n  };\r\n\r\n  Vector.prototype.subtract = function (otherVector) {\r\n    var _a;\r\n\r\n    var otherArr = otherVector.arr;\r\n\r\n    if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length)) {\r\n      return new Vector(otherArr);\r\n    }\r\n\r\n    if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {\r\n      return new Vector(this.arr);\r\n    }\r\n\r\n    if (this.arr.length === otherArr.length) {\r\n      var res = [];\r\n\r\n      for (var index in this.arr) {\r\n        res[index] = this.arr[index] - otherArr[index];\r\n      }\r\n\r\n      return new Vector(res);\r\n    }\r\n  };\r\n\r\n  Vector.prototype.avg = function (length) {\r\n    var res = [];\r\n\r\n    if (length !== 0) {\r\n      for (var index in this.arr) {\r\n        res[index] = this.arr[index] / length;\r\n      }\r\n    }\r\n\r\n    return new Vector(res);\r\n  };\r\n\r\n  Vector.prototype.negate = function () {\r\n    var res = [];\r\n\r\n    for (var index in this.arr) {\r\n      res[index] = -this.arr[index];\r\n    }\r\n\r\n    return new Vector(res);\r\n  }; // 平方欧式距离\r\n\r\n\r\n  Vector.prototype.squareEuclideanDistance = function (otherVector) {\r\n    var _a;\r\n\r\n    var otherArr = otherVector.arr;\r\n\r\n    if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {\r\n      return 0;\r\n    }\r\n\r\n    if (this.arr.length === otherArr.length) {\r\n      var res = 0;\r\n\r\n      for (var index in this.arr) {\r\n        res += Math.pow(this.arr[index] - otherVector.arr[index], 2);\r\n      }\r\n\r\n      return res;\r\n    }\r\n  }; // 欧式距离\r\n\r\n\r\n  Vector.prototype.euclideanDistance = function (otherVector) {\r\n    var _a;\r\n\r\n    var otherArr = otherVector.arr;\r\n\r\n    if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {\r\n      return 0;\r\n    }\r\n\r\n    if (this.arr.length === otherArr.length) {\r\n      var res = 0;\r\n\r\n      for (var index in this.arr) {\r\n        res += Math.pow(this.arr[index] - otherVector.arr[index], 2);\r\n      }\r\n\r\n      return Math.sqrt(res);\r\n    } else {\r\n      console.error('The two vectors are unequal in length.');\r\n    }\r\n  }; // 归一化处理\r\n\r\n\r\n  Vector.prototype.normalize = function () {\r\n    var res = [];\r\n    var cloneArr = (0, _util.clone)(this.arr);\r\n    cloneArr.sort(function (a, b) {\r\n      return a - b;\r\n    });\r\n    var max = cloneArr[cloneArr.length - 1];\r\n    var min = cloneArr[0];\r\n\r\n    for (var index in this.arr) {\r\n      res[index] = (this.arr[index] - min) / (max - min);\r\n    }\r\n\r\n    return new Vector(res);\r\n  }; // 2范数 or 模长\r\n\r\n\r\n  Vector.prototype.norm2 = function () {\r\n    var _a;\r\n\r\n    if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length)) {\r\n      return 0;\r\n    }\r\n\r\n    var res = 0;\r\n\r\n    for (var index in this.arr) {\r\n      res += Math.pow(this.arr[index], 2);\r\n    }\r\n\r\n    return Math.sqrt(res);\r\n  }; // 两个向量的点积\r\n\r\n\r\n  Vector.prototype.dot = function (otherVector) {\r\n    var _a;\r\n\r\n    var otherArr = otherVector.arr;\r\n\r\n    if (!((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {\r\n      return 0;\r\n    }\r\n\r\n    if (this.arr.length === otherArr.length) {\r\n      var res = 0;\r\n\r\n      for (var index in this.arr) {\r\n        res += this.arr[index] * otherVector.arr[index];\r\n      }\r\n\r\n      return res;\r\n    } else {\r\n      console.error('The two vectors are unequal in length.');\r\n    }\r\n  }; // 两个向量比较\r\n\r\n\r\n  Vector.prototype.equal = function (otherVector) {\r\n    var _a;\r\n\r\n    var otherArr = otherVector.arr;\r\n\r\n    if (((_a = this.arr) === null || _a === void 0 ? void 0 : _a.length) !== (otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {\r\n      return false;\r\n    }\r\n\r\n    for (var index in this.arr) {\r\n      if (this.arr[index] !== otherArr[index]) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  return Vector;\r\n}();\r\n\r\nvar _default = Vector;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.getPropertyWeight = exports.getAllSortProperties = exports.getAllProperties = exports.default = void 0;\r\n\r\nvar _time = require(\"../constants/time\");\r\n\r\n// 获取所有属性并排序\r\nvar getAllSortProperties = function getAllSortProperties(nodes, n) {\r\n  if (nodes === void 0) {\r\n    nodes = [];\r\n  }\r\n\r\n  if (n === void 0) {\r\n    n = 100;\r\n  }\r\n\r\n  var propertyKeyInfo = {};\r\n  nodes.forEach(function (node) {\r\n    if (!node.properties) {\r\n      return;\r\n    }\r\n\r\n    Object.keys(node.properties).forEach(function (propertyKey) {\r\n      // 目前过滤只保留可以转成数值型的或日期型的, todo: 统一转成one-hot特征向量或者embedding\r\n      if (propertyKey === 'id' || !\"\".concat(node.properties[propertyKey]).match(_time.secondReg) && !\"\".concat(node.properties[propertyKey]).match(_time.dateReg) && isNaN(Number(node.properties[propertyKey]))) {\r\n        if (propertyKeyInfo.hasOwnProperty(propertyKey)) {\r\n          delete propertyKeyInfo[propertyKey];\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      if (propertyKeyInfo.hasOwnProperty(propertyKey)) {\r\n        propertyKeyInfo[propertyKey] += 1;\r\n      } else {\r\n        propertyKeyInfo[propertyKey] = 1;\r\n      }\r\n    });\r\n  }); // 取top50的属性\r\n\r\n  var sortKeys = Object.keys(propertyKeyInfo).sort(function (a, b) {\r\n    return propertyKeyInfo[b] - propertyKeyInfo[a];\r\n  });\r\n  return sortKeys.length < n ? sortKeys : sortKeys.slice(0, n);\r\n};\r\n\r\nexports.getAllSortProperties = getAllSortProperties;\r\n\r\nvar processProperty = function processProperty(properties, propertyKeys) {\r\n  return propertyKeys.map(function (key) {\r\n    if (properties.hasOwnProperty(key)) {\r\n      // // 可以转成数值的直接转成数值\r\n      // if (!isNaN(Number(properties[key]))) {\r\n      //   return Number(properties[key]);\r\n      // }\r\n      // // 时间型的转成时间戳\r\n      // if (properties[key].match(secondReg) || properties[key].match(dateReg)) {\r\n      //   // @ts-ignore\r\n      //   return Number(Date.parse(new Date(properties[key]))) / 1000;\r\n      // }\r\n      return properties[key];\r\n    }\r\n\r\n    return 0;\r\n  });\r\n}; // 获取属性特征权重\r\n\r\n\r\nvar getPropertyWeight = function getPropertyWeight(nodes) {\r\n  var propertyKeys = getAllSortProperties(nodes);\r\n  var allPropertiesWeight = [];\r\n\r\n  for (var i = 0; i < nodes.length; i++) {\r\n    allPropertiesWeight[i] = processProperty(nodes[i].properties, propertyKeys);\r\n  }\r\n\r\n  return allPropertiesWeight;\r\n}; // 获取所有节点的属性集合\r\n\r\n\r\nexports.getPropertyWeight = getPropertyWeight;\r\n\r\nvar getAllProperties = function getAllProperties(nodes, key) {\r\n  if (key === void 0) {\r\n    key = undefined;\r\n  }\r\n\r\n  var allProperties = [];\r\n  nodes.forEach(function (node) {\r\n    if (key === undefined) {\r\n      allProperties.push(node);\r\n    }\r\n\r\n    if (node[key] !== undefined) {\r\n      allProperties.push(node[key]);\r\n    }\r\n  });\r\n  return allProperties;\r\n};\r\n\r\nexports.getAllProperties = getAllProperties;\r\nvar _default = {\r\n  getAllSortProperties: getAllSortProperties,\r\n  getPropertyWeight: getPropertyWeight,\r\n  getAllProperties: getAllProperties\r\n};\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.secondReg = exports.dateReg = void 0;\r\nvar secondReg = /^(\\d{1,4})(-|\\/)(\\d{1,2})\\2(\\d{1,2})$/;\r\nexports.secondReg = secondReg;\r\nvar dateReg = /^(\\d{1,4})(-|\\/)(\\d{1,2})\\2(\\d{1,2}) (\\d{1,2}):(\\d{1,2}):(\\d{1,2})$/;\r\nexports.dateReg = dateReg;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.oneHot = exports.getDistance = exports.getAllKeyValueMap = exports.default = void 0;\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _types = require(\"../types\");\r\n\r\nvar _vector = _interopRequireDefault(require(\"./vector\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * 获取数据中所有的属性及其对应的值\r\n * @param dataList 数据集\r\n * @param involvedKeys 参与计算的key集合\r\n * @param uninvolvedKeys 不参与计算的key集合\r\n */\r\nvar getAllKeyValueMap = function getAllKeyValueMap(dataList, involvedKeys, uninvolvedKeys) {\r\n  var keys = []; // 指定了参与计算的keys时，使用指定的keys\r\n\r\n  if (involvedKeys === null || involvedKeys === void 0 ? void 0 : involvedKeys.length) {\r\n    keys = involvedKeys;\r\n  } else {\r\n    // 未指定抽取的keys时，提取数据中所有的key\r\n    dataList.forEach(function (data) {\r\n      keys = keys.concat(Object.keys(data));\r\n    });\r\n    keys = (0, _util.uniq)(keys);\r\n  } // 获取所有值非空的key的value数组\r\n\r\n\r\n  var allKeyValueMap = {};\r\n  keys.forEach(function (key) {\r\n    var value = [];\r\n    dataList.forEach(function (data) {\r\n      if (data[key] !== undefined && data[key] !== '') {\r\n        value.push(data[key]);\r\n      }\r\n    });\r\n\r\n    if (value.length && !(uninvolvedKeys === null || uninvolvedKeys === void 0 ? void 0 : uninvolvedKeys.includes(key))) {\r\n      allKeyValueMap[key] = (0, _util.uniq)(value);\r\n    }\r\n  });\r\n  return allKeyValueMap;\r\n};\r\n/**\r\n * one-hot编码：数据特征提取\r\n * @param dataList 数据集\r\n * @param involvedKeys 参与计算的的key集合\r\n * @param uninvolvedKeys 不参与计算的key集合\r\n */\r\n\r\n\r\nexports.getAllKeyValueMap = getAllKeyValueMap;\r\n\r\nvar oneHot = function oneHot(dataList, involvedKeys, uninvolvedKeys) {\r\n  // 获取数据中所有的属性/特征及其对应的值\r\n  var allKeyValueMap = getAllKeyValueMap(dataList, involvedKeys, uninvolvedKeys);\r\n  var oneHotCode = [];\r\n\r\n  if (!Object.keys(allKeyValueMap).length) {\r\n    return oneHotCode;\r\n  } // 获取所有的属性/特征值\r\n\r\n\r\n  var allValue = Object.values(allKeyValueMap); // 是否所有属性/特征的值都是数值型\r\n\r\n  var isAllNumber = allValue.every(function (value) {\r\n    return value.every(function (item) {\r\n      return typeof item === 'number';\r\n    });\r\n  }); // 对数据进行one-hot编码\r\n\r\n  dataList.forEach(function (data, index) {\r\n    var code = [];\r\n    Object.keys(allKeyValueMap).forEach(function (key) {\r\n      var keyValue = data[key];\r\n      var allKeyValue = allKeyValueMap[key];\r\n      var valueIndex = allKeyValue.findIndex(function (value) {\r\n        return keyValue === value;\r\n      });\r\n      var subCode = []; // 如果属性/特征所有的值都能转成数值型，不满足分箱，则直接用值（todo: 为了收敛更快，需做归一化处理）\r\n\r\n      if (isAllNumber) {\r\n        subCode.push(keyValue);\r\n      } else {\r\n        // 进行one-hot编码\r\n        for (var i = 0; i < allKeyValue.length; i++) {\r\n          if (i === valueIndex) {\r\n            subCode.push(1);\r\n          } else {\r\n            subCode.push(0);\r\n          }\r\n        }\r\n      }\r\n\r\n      code = code.concat(subCode);\r\n    });\r\n    oneHotCode[index] = code;\r\n  });\r\n  return oneHotCode;\r\n};\r\n/**\r\n * getDistance：获取两个元素之间的距离\r\n * @param item\r\n * @param otherItem\r\n * @param distanceType 距离类型\r\n * @param graphData 图数据\r\n */\r\n\r\n\r\nexports.oneHot = oneHot;\r\n\r\nvar getDistance = function getDistance(item, otherItem, distanceType, graphData) {\r\n  if (distanceType === void 0) {\r\n    distanceType = _types.DistanceType.EuclideanDistance;\r\n  }\r\n\r\n  var distance = 0;\r\n\r\n  switch (distanceType) {\r\n    case _types.DistanceType.EuclideanDistance:\r\n      distance = new _vector.default(item).euclideanDistance(new _vector.default(otherItem));\r\n      break;\r\n\r\n    default:\r\n      break;\r\n  }\r\n\r\n  return distance;\r\n};\r\n\r\nexports.getDistance = getDistance;\r\nvar _default = {\r\n  getAllKeyValueMap: getAllKeyValueMap,\r\n  oneHot: oneHot,\r\n  getDistance: getDistance\r\n};\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.DistanceType = void 0;\r\nvar DistanceType;\r\nexports.DistanceType = DistanceType;\r\n\r\n(function (DistanceType) {\r\n  DistanceType[\"EuclideanDistance\"] = \"euclideanDistance\";\r\n})(DistanceType || (exports.DistanceType = DistanceType = {}));","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _louvain = _interopRequireDefault(require(\"./louvain\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * 社区发现 i-louvain 算法：模块度 + 惯性模块度（即节点属性相似性）\r\n * @param graphData 图数据\r\n * @param directed 是否有向图，默认为 false\r\n * @param weightPropertyName 权重的属性字段\r\n * @param threshold 差值阈值\r\n * @param propertyKey 属性的字段名\r\n * @param involvedKeys 参与计算的key集合\r\n * @param uninvolvedKeys 不参与计算的key集合\r\n * @param inertialWeight 惯性模块度权重\r\n */\r\nvar iLouvain = function iLouvain(graphData, directed, weightPropertyName, threshold, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {\r\n  if (directed === void 0) {\r\n    directed = false;\r\n  }\r\n\r\n  if (weightPropertyName === void 0) {\r\n    weightPropertyName = 'weight';\r\n  }\r\n\r\n  if (threshold === void 0) {\r\n    threshold = 0.0001;\r\n  }\r\n\r\n  if (propertyKey === void 0) {\r\n    propertyKey = undefined;\r\n  }\r\n\r\n  if (involvedKeys === void 0) {\r\n    involvedKeys = [];\r\n  }\r\n\r\n  if (uninvolvedKeys === void 0) {\r\n    uninvolvedKeys = ['id'];\r\n  }\r\n\r\n  if (inertialWeight === void 0) {\r\n    inertialWeight = 1;\r\n  }\r\n\r\n  return (0, _louvain.default)(graphData, directed, weightPropertyName, threshold, true, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight);\r\n};\r\n\r\nvar _default = iLouvain;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _degree = _interopRequireDefault(require(\"./degree\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n *  k-core算法 找出符合指定核心度的紧密关联的子图结构\r\n * @param graphData 图数据\r\n * @param k 核心度数\r\n */\r\nvar kCore = function kCore(graphData, k) {\r\n  var _a;\r\n\r\n  if (k === void 0) {\r\n    k = 1;\r\n  }\r\n\r\n  var data = (0, _util.clone)(graphData);\r\n  var _b = data.nodes,\r\n      nodes = _b === void 0 ? [] : _b;\r\n  var _c = data.edges,\r\n      edges = _c === void 0 ? [] : _c;\r\n\r\n  var _loop_1 = function _loop_1() {\r\n    // 获取图中节点的度数\r\n    var degrees = (0, _degree.default)({\r\n      nodes: nodes,\r\n      edges: edges\r\n    });\r\n    var nodeIds = Object.keys(degrees); // 按照度数进行排序\r\n\r\n    nodeIds.sort(function (a, b) {\r\n      var _a, _b;\r\n\r\n      return ((_a = degrees[a]) === null || _a === void 0 ? void 0 : _a.degree) - ((_b = degrees[b]) === null || _b === void 0 ? void 0 : _b.degree);\r\n    });\r\n    var minIndexId = nodeIds[0];\r\n\r\n    if (!nodes.length || ((_a = degrees[minIndexId]) === null || _a === void 0 ? void 0 : _a.degree) >= k) {\r\n      return \"break\";\r\n    }\r\n\r\n    var originIndex = nodes.findIndex(function (node) {\r\n      return node.id === minIndexId;\r\n    }); // 移除度数小于k的节点\r\n\r\n    nodes.splice(originIndex, 1); // 移除度数小于k的节点相关的边\r\n\r\n    edges = edges.filter(function (edge) {\r\n      return !(edge.source === minIndexId || edge.target === minIndexId);\r\n    });\r\n  };\r\n\r\n  while (true) {\r\n    var state_1 = _loop_1();\r\n\r\n    if (state_1 === \"break\") break;\r\n  }\r\n\r\n  return {\r\n    nodes: nodes,\r\n    edges: edges\r\n  };\r\n};\r\n\r\nvar _default = kCore;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _nodeProperties = require(\"./utils/node-properties\");\r\n\r\nvar _dataPreprocessing = require(\"./utils/data-preprocessing\");\r\n\r\nvar _vector = _interopRequireDefault(require(\"./utils/vector\"));\r\n\r\nvar _types = require(\"./types\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n// 获取质心\r\nvar getCentroid = function getCentroid(distanceType, allPropertiesWeight, index) {\r\n  var centroid = [];\r\n\r\n  switch (distanceType) {\r\n    case _types.DistanceType.EuclideanDistance:\r\n      centroid = allPropertiesWeight[index];\r\n      break;\r\n\r\n    default:\r\n      centroid = [];\r\n      break;\r\n  }\r\n\r\n  return centroid;\r\n};\r\n/**\r\n *  k-means算法 根据节点之间的距离将节点聚类为K个簇\r\n * @param data 图数据\r\n * @param k 质心（聚类中心）个数\r\n * @param propertyKey 属性的字段名\r\n * @param involvedKeys 参与计算的key集合\r\n * @param uninvolvedKeys 不参与计算的key集合\r\n * @param distanceType 距离类型 默认节点属性的欧式距离\r\n */\r\n\r\n\r\nvar kMeans = function kMeans(data, k, propertyKey, involvedKeys, uninvolvedKeys, distanceType) {\r\n  if (k === void 0) {\r\n    k = 3;\r\n  }\r\n\r\n  if (propertyKey === void 0) {\r\n    propertyKey = undefined;\r\n  }\r\n\r\n  if (involvedKeys === void 0) {\r\n    involvedKeys = [];\r\n  }\r\n\r\n  if (uninvolvedKeys === void 0) {\r\n    uninvolvedKeys = ['id'];\r\n  }\r\n\r\n  if (distanceType === void 0) {\r\n    distanceType = _types.DistanceType.EuclideanDistance;\r\n  }\r\n\r\n  var _a = data.nodes,\r\n      nodes = _a === void 0 ? [] : _a,\r\n      _b = data.edges,\r\n      edges = _b === void 0 ? [] : _b;\r\n  var defaultClusterInfo = {\r\n    clusters: [{\r\n      id: \"0\",\r\n      nodes: nodes\r\n    }],\r\n    clusterEdges: []\r\n  }; // 距离类型为欧式距离且没有属性时，直接return\r\n\r\n  if (distanceType === _types.DistanceType.EuclideanDistance && !nodes.every(function (node) {\r\n    return node.hasOwnProperty(propertyKey);\r\n  })) {\r\n    return defaultClusterInfo;\r\n  } // 所有节点属性集合\r\n\r\n\r\n  var properties = []; // 所有节点属性one-hot特征向量集合\r\n\r\n  var allPropertiesWeight = [];\r\n\r\n  if (distanceType === _types.DistanceType.EuclideanDistance) {\r\n    properties = (0, _nodeProperties.getAllProperties)(nodes, propertyKey);\r\n    allPropertiesWeight = (0, _dataPreprocessing.oneHot)(properties, involvedKeys, uninvolvedKeys);\r\n  }\r\n\r\n  if (!allPropertiesWeight.length) {\r\n    return defaultClusterInfo;\r\n  }\r\n\r\n  var allPropertiesWeightUniq = (0, _util.uniq)(allPropertiesWeight.map(function (item) {\r\n    return item.join('');\r\n  })); // 当输入节点数量或者属性集合的长度小于k时，k调整为其中最小的值\r\n\r\n  var finalK = Math.min(k, nodes.length, allPropertiesWeightUniq.length); // 记录节点的原始index，与allPropertiesWeight对应\r\n\r\n  for (var i = 0; i < nodes.length; i++) {\r\n    nodes[i].originIndex = i;\r\n  } // 初始化质心（聚类中心）\r\n\r\n\r\n  var centroids = [];\r\n  var centroidIndexList = [];\r\n  var clusters = [];\r\n\r\n  for (var i = 0; i < finalK; i++) {\r\n    if (i === 0) {\r\n      // 随机选取质心（聚类中心）\r\n      var randomIndex = Math.floor(Math.random() * nodes.length);\r\n\r\n      switch (distanceType) {\r\n        case _types.DistanceType.EuclideanDistance:\r\n          centroids[i] = allPropertiesWeight[randomIndex];\r\n          break;\r\n\r\n        default:\r\n          centroids[i] = [];\r\n          break;\r\n      }\r\n\r\n      centroidIndexList.push(randomIndex);\r\n      clusters[i] = [nodes[randomIndex]];\r\n      nodes[randomIndex].clusterId = String(i);\r\n    } else {\r\n      var maxDistance = -Infinity;\r\n      var maxDistanceNodeIndex = 0;\r\n\r\n      var _loop_1 = function _loop_1(m) {\r\n        if (!centroidIndexList.includes(m)) {\r\n          var totalDistance = 0;\r\n\r\n          for (var j = 0; j < centroids.length; j++) {\r\n            // 求节点到质心的距离（默认节点属性的欧式距离）\r\n            var distance = 0;\r\n\r\n            switch (distanceType) {\r\n              case _types.DistanceType.EuclideanDistance:\r\n                distance = (0, _dataPreprocessing.getDistance)(allPropertiesWeight[nodes[m].originIndex], centroids[j], distanceType);\r\n                break;\r\n\r\n              default:\r\n                break;\r\n            }\r\n\r\n            totalDistance += distance;\r\n          } // 节点到各质心的平均距离（默认欧式距离）\r\n\r\n\r\n          var avgDistance = totalDistance / centroids.length; // 记录到已有质心最远的的距离和节点索引\r\n\r\n          if (avgDistance > maxDistance && !centroids.find(function (centroid) {\r\n            return (0, _util.isEqual)(centroid, getCentroid(distanceType, allPropertiesWeight, nodes[m].originIndex));\r\n          })) {\r\n            maxDistance = avgDistance;\r\n            maxDistanceNodeIndex = m;\r\n          }\r\n        }\r\n      }; // 选取与已有质心平均距离最远的点做为新的质心\r\n\r\n\r\n      for (var m = 0; m < nodes.length; m++) {\r\n        _loop_1(m);\r\n      }\r\n\r\n      centroids[i] = getCentroid(distanceType, allPropertiesWeight, maxDistanceNodeIndex);\r\n      centroidIndexList.push(maxDistanceNodeIndex);\r\n      clusters[i] = [nodes[maxDistanceNodeIndex]];\r\n      nodes[maxDistanceNodeIndex].clusterId = String(i);\r\n    }\r\n  }\r\n\r\n  var iterations = 0;\r\n\r\n  while (true) {\r\n    for (var i = 0; i < nodes.length; i++) {\r\n      var minDistanceIndex = 0;\r\n      var minDistance = Infinity;\r\n\r\n      if (!(iterations === 0 && centroidIndexList.includes(i))) {\r\n        for (var j = 0; j < centroids.length; j++) {\r\n          // 求节点到质心的距离（默认节点属性的欧式距离）\r\n          var distance = 0;\r\n\r\n          switch (distanceType) {\r\n            case _types.DistanceType.EuclideanDistance:\r\n              distance = (0, _dataPreprocessing.getDistance)(allPropertiesWeight[i], centroids[j], distanceType);\r\n              break;\r\n\r\n            default:\r\n              break;\r\n          } // 记录节点最近的质心的索引\r\n\r\n\r\n          if (distance < minDistance) {\r\n            minDistance = distance;\r\n            minDistanceIndex = j;\r\n          }\r\n        } // 从原来的类别删除节点\r\n\r\n\r\n        if (nodes[i].clusterId !== undefined) {\r\n          for (var n = clusters[Number(nodes[i].clusterId)].length - 1; n >= 0; n--) {\r\n            if (clusters[Number(nodes[i].clusterId)][n].id === nodes[i].id) {\r\n              clusters[Number(nodes[i].clusterId)].splice(n, 1);\r\n            }\r\n          }\r\n        } // 将节点划分到距离最小的质心（聚类中心）所对应的类中\r\n\r\n\r\n        nodes[i].clusterId = String(minDistanceIndex);\r\n        clusters[minDistanceIndex].push(nodes[i]);\r\n      }\r\n    } // 是否存在质心（聚类中心）移动\r\n\r\n\r\n    var centroidsEqualAvg = false;\r\n\r\n    for (var i = 0; i < clusters.length; i++) {\r\n      var clusterNodes = clusters[i];\r\n      var totalVector = new _vector.default([]);\r\n\r\n      for (var j = 0; j < clusterNodes.length; j++) {\r\n        totalVector = totalVector.add(new _vector.default(allPropertiesWeight[clusterNodes[j].originIndex]));\r\n      } // 计算每个类别的均值向量\r\n\r\n\r\n      var avgVector = totalVector.avg(clusterNodes.length); // 如果均值向量不等于质心向量\r\n\r\n      if (!avgVector.equal(new _vector.default(centroids[i]))) {\r\n        centroidsEqualAvg = true; // 移动/更新每个类别的质心（聚类中心）到该均值向量\r\n\r\n        centroids[i] = avgVector.getArr();\r\n      }\r\n    }\r\n\r\n    iterations++; // 如果每个节点都归属了类别，且不存在质心（聚类中心）移动或者迭代次数超过1000，则停止\r\n\r\n    if (nodes.every(function (node) {\r\n      return node.clusterId !== undefined;\r\n    }) && centroidsEqualAvg || iterations >= 1000) {\r\n      break;\r\n    }\r\n  } // get the cluster edges\r\n\r\n\r\n  var clusterEdges = [];\r\n  var clusterEdgeMap = {};\r\n  edges.forEach(function (edge) {\r\n    var _a, _b;\r\n\r\n    var source = edge.source,\r\n        target = edge.target;\r\n    var sourceClusterId = (_a = nodes.find(function (node) {\r\n      return node.id === source;\r\n    })) === null || _a === void 0 ? void 0 : _a.clusterId;\r\n    var targetClusterId = (_b = nodes.find(function (node) {\r\n      return node.id === target;\r\n    })) === null || _b === void 0 ? void 0 : _b.clusterId;\r\n    var newEdgeId = \"\".concat(sourceClusterId, \"---\").concat(targetClusterId);\r\n\r\n    if (clusterEdgeMap[newEdgeId]) {\r\n      clusterEdgeMap[newEdgeId].count++;\r\n    } else {\r\n      var newEdge = {\r\n        source: sourceClusterId,\r\n        target: targetClusterId,\r\n        count: 1\r\n      };\r\n      clusterEdgeMap[newEdgeId] = newEdge;\r\n      clusterEdges.push(newEdge);\r\n    }\r\n  });\r\n  return {\r\n    clusters: clusters,\r\n    clusterEdges: clusterEdges\r\n  };\r\n};\r\n\r\nvar _default = kMeans;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _vector = _interopRequireDefault(require(\"./utils/vector\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * cosine-similarity算法 计算余弦相似度\r\n * @param item 元素\r\n * @param targetItem 目标元素\r\n */\r\nvar cosineSimilarity = function cosineSimilarity(item, targetItem) {\r\n  // 目标元素向量\r\n  var targetItemVector = new _vector.default(targetItem); // 目标元素向量的模长\r\n\r\n  var targetNodeNorm2 = targetItemVector.norm2(); // 元素向量\r\n\r\n  var itemVector = new _vector.default(item); // 元素向量的模长\r\n\r\n  var itemNorm2 = itemVector.norm2(); // 计算元素向量和目标元素向量的点积\r\n\r\n  var dot = targetItemVector.dot(itemVector);\r\n  var norm2Product = targetNodeNorm2 * itemNorm2; // 计算元素向量和目标元素向量的余弦相似度\r\n\r\n  var cosineSimilarity = norm2Product ? dot / norm2Product : 0;\r\n  return cosineSimilarity;\r\n};\r\n\r\nvar _default = cosineSimilarity;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _nodeProperties = require(\"./utils/node-properties\");\r\n\r\nvar _dataPreprocessing = require(\"./utils/data-preprocessing\");\r\n\r\nvar _cosineSimilarity = _interopRequireDefault(require(\"./cosine-similarity\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n *  nodes-cosine-similarity算法 基于节点属性计算余弦相似度(基于种子节点寻找相似节点)\r\n * @param nodes 图节点数据\r\n * @param seedNode 种子节点\r\n * @param propertyKey 属性的字段名\r\n * @param involvedKeys 参与计算的key集合\r\n * @param uninvolvedKeys 不参与计算的key集合\r\n */\r\nvar nodesCosineSimilarity = function nodesCosineSimilarity(nodes, seedNode, propertyKey, involvedKeys, uninvolvedKeys) {\r\n  if (nodes === void 0) {\r\n    nodes = [];\r\n  }\r\n\r\n  if (propertyKey === void 0) {\r\n    propertyKey = undefined;\r\n  }\r\n\r\n  if (involvedKeys === void 0) {\r\n    involvedKeys = [];\r\n  }\r\n\r\n  if (uninvolvedKeys === void 0) {\r\n    uninvolvedKeys = [];\r\n  }\r\n\r\n  var similarNodes = (0, _util.clone)(nodes.filter(function (node) {\r\n    return node.id !== seedNode.id;\r\n  }));\r\n  var seedNodeIndex = nodes.findIndex(function (node) {\r\n    return node.id === seedNode.id;\r\n  }); // 所有节点属性集合\r\n\r\n  var properties = (0, _nodeProperties.getAllProperties)(nodes, propertyKey); // 所有节点属性one-hot特征向量集合\r\n\r\n  var allPropertiesWeight = (0, _dataPreprocessing.oneHot)(properties, involvedKeys, uninvolvedKeys); // 种子节点属性\r\n\r\n  var seedNodeProperties = allPropertiesWeight[seedNodeIndex];\r\n  var allCosineSimilarity = [];\r\n  similarNodes.forEach(function (node, index) {\r\n    if (node.id !== seedNode.id) {\r\n      // 节点属性\r\n      var nodeProperties = allPropertiesWeight[index]; // 计算节点向量和种子节点向量的余弦相似度\r\n\r\n      var cosineSimilarityValue = (0, _cosineSimilarity.default)(nodeProperties, seedNodeProperties);\r\n      allCosineSimilarity.push(cosineSimilarityValue);\r\n      node.cosineSimilarity = cosineSimilarityValue;\r\n    }\r\n  }); // 将返回的节点按照余弦相似度大小排序\r\n\r\n  similarNodes.sort(function (a, b) {\r\n    return b.cosineSimilarity - a.cosineSimilarity;\r\n  });\r\n  return {\r\n    allCosineSimilarity: allCosineSimilarity,\r\n    similarNodes: similarNodes\r\n  };\r\n};\r\n\r\nvar _default = nodesCosineSimilarity;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _unionFind = _interopRequireDefault(require(\"./structs/union-find\"));\r\n\r\nvar _binaryHeap = _interopRequireDefault(require(\"./structs/binary-heap\"));\r\n\r\nvar _util = require(\"./util\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * Prim algorithm，use priority queue，复杂度 O(E+V*logV), V: 节点数量，E: 边的数量\r\n * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm\r\n * @param graph\r\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\r\n */\r\nvar primMST = function primMST(graphData, weight) {\r\n  var selectedEdges = [];\r\n  var _a = graphData.nodes,\r\n      nodes = _a === void 0 ? [] : _a,\r\n      _b = graphData.edges,\r\n      edges = _b === void 0 ? [] : _b;\r\n\r\n  if (nodes.length === 0) {\r\n    return selectedEdges;\r\n  } // 从nodes[0]开始\r\n\r\n\r\n  var currNode = nodes[0];\r\n  var visited = new Set();\r\n  visited.add(currNode); // 用二叉堆维护距已加入节点的其他节点的边的权值\r\n\r\n  var compareWeight = function compareWeight(a, b) {\r\n    if (weight) {\r\n      return a.weight - b.weight;\r\n    }\r\n\r\n    return 0;\r\n  };\r\n\r\n  var edgeQueue = new _binaryHeap.default(compareWeight);\r\n  (0, _util.getEdgesByNodeId)(currNode.id, edges).forEach(function (edge) {\r\n    edgeQueue.insert(edge);\r\n  });\r\n\r\n  while (!edgeQueue.isEmpty()) {\r\n    // 选取与已加入的结点之间边权最小的结点\r\n    var currEdge = edgeQueue.delMin();\r\n    var source = currEdge.source;\r\n    var target = currEdge.target;\r\n    if (visited.has(source) && visited.has(target)) continue;\r\n    selectedEdges.push(currEdge);\r\n\r\n    if (!visited.has(source)) {\r\n      visited.add(source);\r\n      (0, _util.getEdgesByNodeId)(source, edges).forEach(function (edge) {\r\n        edgeQueue.insert(edge);\r\n      });\r\n    }\r\n\r\n    if (!visited.has(target)) {\r\n      visited.add(target);\r\n      (0, _util.getEdgesByNodeId)(target, edges).forEach(function (edge) {\r\n        edgeQueue.insert(edge);\r\n      });\r\n    }\r\n  }\r\n\r\n  return selectedEdges;\r\n};\r\n/**\r\n * Kruskal algorithm，复杂度 O(E*logE), E: 边的数量\r\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\r\n * @param graph\r\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\r\n * @return IEdge[] 返回构成MST的边的数组\r\n */\r\n\r\n\r\nvar kruskalMST = function kruskalMST(graphData, weight) {\r\n  var selectedEdges = [];\r\n  var _a = graphData.nodes,\r\n      nodes = _a === void 0 ? [] : _a,\r\n      _b = graphData.edges,\r\n      edges = _b === void 0 ? [] : _b;\r\n\r\n  if (nodes.length === 0) {\r\n    return selectedEdges;\r\n  } // 若指定weight，则将所有的边按权值从小到大排序\r\n\r\n\r\n  var weightEdges = edges.map(function (edge) {\r\n    return edge;\r\n  });\r\n\r\n  if (weight) {\r\n    weightEdges.sort(function (a, b) {\r\n      return a.weight - b.weight;\r\n    });\r\n  }\r\n\r\n  var disjointSet = new _unionFind.default(nodes.map(function (n) {\r\n    return n.id;\r\n  })); // 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边\r\n  // 直到遍历完所有点或边\r\n\r\n  while (weightEdges.length > 0) {\r\n    var curEdge = weightEdges.shift();\r\n    var source = curEdge.source;\r\n    var target = curEdge.target;\r\n\r\n    if (!disjointSet.connected(source, target)) {\r\n      selectedEdges.push(curEdge);\r\n      disjointSet.union(source, target);\r\n    }\r\n  }\r\n\r\n  return selectedEdges;\r\n};\r\n/**\r\n * 最小生成树\r\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\r\n * @param graph\r\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\r\n * @param algo 'prim' | 'kruskal' 算法类型\r\n * @return EdgeConfig[] 返回构成MST的边的数组\r\n */\r\n\r\n\r\nvar minimumSpanningTree = function minimumSpanningTree(graphData, weight, algo) {\r\n  var algos = {\r\n    prim: primMST,\r\n    kruskal: kruskalMST\r\n  };\r\n  if (!algo) return kruskalMST(graphData, weight);\r\n  return algos[algo](graphData, weight);\r\n};\r\n\r\nvar _default = minimumSpanningTree;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\n/**\r\n * 并查集 Disjoint set to support quick union\r\n */\r\nvar UnionFind =\r\n/** @class */\r\nfunction () {\r\n  function UnionFind(items) {\r\n    this.count = items.length;\r\n    this.parent = {};\r\n\r\n    for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\r\n      var i = items_1[_i];\r\n      this.parent[i] = i;\r\n    }\r\n  } // find the root of the item\r\n\r\n\r\n  UnionFind.prototype.find = function (item) {\r\n    while (this.parent[item] !== item) {\r\n      item = this.parent[item];\r\n    }\r\n\r\n    return item;\r\n  };\r\n\r\n  UnionFind.prototype.union = function (a, b) {\r\n    var rootA = this.find(a);\r\n    var rootB = this.find(b);\r\n    if (rootA === rootB) return; // make the element with smaller root the parent\r\n\r\n    if (rootA < rootB) {\r\n      if (this.parent[b] !== b) this.union(this.parent[b], a);\r\n      this.parent[b] = this.parent[a];\r\n    } else {\r\n      if (this.parent[a] !== a) this.union(this.parent[a], b);\r\n      this.parent[a] = this.parent[b];\r\n    }\r\n  }; // whether a and b are connected, i.e. a and b have the same root\r\n\r\n\r\n  UnionFind.prototype.connected = function (a, b) {\r\n    return this.find(a) === this.find(b);\r\n  };\r\n\r\n  return UnionFind;\r\n}();\r\n\r\nvar _default = UnionFind;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar defaultCompare = function defaultCompare(a, b) {\r\n  return a - b;\r\n};\r\n\r\nvar MinBinaryHeap =\r\n/** @class */\r\nfunction () {\r\n  function MinBinaryHeap(compareFn) {\r\n    if (compareFn === void 0) {\r\n      compareFn = defaultCompare;\r\n    }\r\n\r\n    this.compareFn = compareFn;\r\n    this.list = [];\r\n  }\r\n\r\n  MinBinaryHeap.prototype.getLeft = function (index) {\r\n    return 2 * index + 1;\r\n  };\r\n\r\n  MinBinaryHeap.prototype.getRight = function (index) {\r\n    return 2 * index + 2;\r\n  };\r\n\r\n  MinBinaryHeap.prototype.getParent = function (index) {\r\n    if (index === 0) {\r\n      return null;\r\n    }\r\n\r\n    return Math.floor((index - 1) / 2);\r\n  };\r\n\r\n  MinBinaryHeap.prototype.isEmpty = function () {\r\n    return this.list.length <= 0;\r\n  };\r\n\r\n  MinBinaryHeap.prototype.top = function () {\r\n    return this.isEmpty() ? undefined : this.list[0];\r\n  };\r\n\r\n  MinBinaryHeap.prototype.delMin = function () {\r\n    var top = this.top();\r\n    var bottom = this.list.pop();\r\n\r\n    if (this.list.length > 0) {\r\n      this.list[0] = bottom;\r\n      this.moveDown(0);\r\n    }\r\n\r\n    return top;\r\n  };\r\n\r\n  MinBinaryHeap.prototype.insert = function (value) {\r\n    if (value !== null) {\r\n      this.list.push(value);\r\n      var index = this.list.length - 1;\r\n      this.moveUp(index);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  MinBinaryHeap.prototype.moveUp = function (index) {\r\n    var parent = this.getParent(index);\r\n\r\n    while (index && index > 0 && this.compareFn(this.list[parent], this.list[index]) > 0) {\r\n      // swap\r\n      var tmp = this.list[parent];\r\n      this.list[parent] = this.list[index];\r\n      this.list[index] = tmp; // [this.list[index], this.list[parent]] = [this.list[parent], this.list[index]]\r\n\r\n      index = parent;\r\n      parent = this.getParent(index);\r\n    }\r\n  };\r\n\r\n  MinBinaryHeap.prototype.moveDown = function (index) {\r\n    var _a;\r\n\r\n    var element = index;\r\n    var left = this.getLeft(index);\r\n    var right = this.getRight(index);\r\n    var size = this.list.length;\r\n\r\n    if (left !== null && left < size && this.compareFn(this.list[element], this.list[left]) > 0) {\r\n      element = left;\r\n    } else if (right !== null && right < size && this.compareFn(this.list[element], this.list[right]) > 0) {\r\n      element = right;\r\n    }\r\n\r\n    if (index !== element) {\r\n      _a = [this.list[element], this.list[index]], this.list[index] = _a[0], this.list[element] = _a[1];\r\n      this.moveDown(element);\r\n    }\r\n  };\r\n\r\n  return MinBinaryHeap;\r\n}();\r\n\r\nvar _default = MinBinaryHeap;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _degree = _interopRequireDefault(require(\"./degree\"));\r\n\r\nvar _util = require(\"./util\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * PageRank https://en.wikipedia.org/wiki/PageRank\r\n * refer: https://github.com/anvaka/ngraph.pagerank\r\n * @param graph\r\n * @param epsilon 判断是否收敛的精度值，默认 0.000001\r\n * @param linkProb 阻尼系数（dumping factor），指任意时刻，用户访问到某节点后继续访问该节点链接的下一个节点的概率，经验值 0.85\r\n */\r\nvar pageRank = function pageRank(graphData, epsilon, linkProb) {\r\n  if (typeof epsilon !== 'number') epsilon = 0.000001;\r\n  if (typeof linkProb !== 'number') linkProb = 0.85;\r\n  var distance = 1;\r\n  var leakedRank = 0;\r\n  var maxIterations = 1000;\r\n  var _a = graphData.nodes,\r\n      nodes = _a === void 0 ? [] : _a,\r\n      _b = graphData.edges,\r\n      edges = _b === void 0 ? [] : _b;\r\n  var nodesCount = nodes.length;\r\n  var currentRank;\r\n  var curRanks = {};\r\n  var prevRanks = {}; // Initialize pageranks 初始化\r\n\r\n  for (var j = 0; j < nodesCount; ++j) {\r\n    var node = nodes[j];\r\n    var nodeId = node.id;\r\n    curRanks[nodeId] = 1 / nodesCount;\r\n    prevRanks[nodeId] = 1 / nodesCount;\r\n  }\r\n\r\n  var nodeDegree = (0, _degree.default)(graphData);\r\n\r\n  while (maxIterations > 0 && distance > epsilon) {\r\n    leakedRank = 0;\r\n\r\n    for (var j = 0; j < nodesCount; ++j) {\r\n      var node = nodes[j];\r\n      var nodeId = node.id;\r\n      currentRank = 0;\r\n\r\n      if (nodeDegree[node.id].inDegree === 0) {\r\n        curRanks[nodeId] = 0;\r\n      } else {\r\n        var neighbors = (0, _util.getNeighbors)(nodeId, edges, 'source');\r\n\r\n        for (var i = 0; i < neighbors.length; ++i) {\r\n          var neighbor = neighbors[i];\r\n          var outDegree = nodeDegree[neighbor].outDegree;\r\n          if (outDegree > 0) currentRank += prevRanks[neighbor] / outDegree;\r\n        }\r\n\r\n        curRanks[nodeId] = linkProb * currentRank;\r\n        leakedRank += curRanks[nodeId];\r\n      }\r\n    }\r\n\r\n    leakedRank = (1 - leakedRank) / nodesCount;\r\n    distance = 0;\r\n\r\n    for (var j = 0; j < nodesCount; ++j) {\r\n      var node = nodes[j];\r\n      var nodeId = node.id;\r\n      currentRank = curRanks[nodeId] + leakedRank;\r\n      distance += Math.abs(currentRank - prevRanks[nodeId]);\r\n      prevRanks[nodeId] = currentRank;\r\n    }\r\n\r\n    maxIterations -= 1;\r\n  }\r\n\r\n  return prevRanks;\r\n};\r\n\r\nvar _default = pageRank;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _floydWarshall = _interopRequireDefault(require(\"./floydWarshall\"));\r\n\r\nvar _gSpan = _interopRequireDefault(require(\"./gSpan/gSpan\"));\r\n\r\nvar _dijkstra = _interopRequireDefault(require(\"./dijkstra\"));\r\n\r\nvar _util = require(\"./util\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * 为 graphData 中每个节点生成邻居单元数组\r\n * @param graphData\r\n * @param spm\r\n * @param nodeLabelProp\r\n * @param k k-近邻\r\n */\r\nvar findKNeighborUnits = function findKNeighborUnits(graphData, spm, nodeLabelProp, k) {\r\n  if (nodeLabelProp === void 0) {\r\n    nodeLabelProp = 'cluster';\r\n  }\r\n\r\n  if (k === void 0) {\r\n    k = 2;\r\n  }\r\n\r\n  var units = [];\r\n  var nodes = graphData.nodes;\r\n  spm.forEach(function (row, i) {\r\n    units.push(findKNeighborUnit(nodes, row, i, nodeLabelProp, k));\r\n  });\r\n  return units;\r\n};\r\n\r\nvar findKNeighborUnit = function findKNeighborUnit(nodes, row, i, nodeLabelProp, k) {\r\n  var unitNodeIdxs = [i];\r\n  var neighbors = [];\r\n  var labelCountMap = {};\r\n  row.forEach(function (v, j) {\r\n    if (v <= k && i !== j) {\r\n      unitNodeIdxs.push(j);\r\n      neighbors.push(nodes[j]);\r\n      var label = nodes[j][nodeLabelProp];\r\n      if (!labelCountMap[label]) labelCountMap[label] = {\r\n        count: 1,\r\n        dists: [v]\r\n      };else {\r\n        labelCountMap[label].count++;\r\n        labelCountMap[label].dists.push(v);\r\n      }\r\n    }\r\n  }); // 将 labelCountMap 中的 dists 按照从小到大排序，方便后面使用\r\n\r\n  Object.keys(labelCountMap).forEach(function (label) {\r\n    labelCountMap[label].dists = labelCountMap[label].dists.sort(function (a, b) {\r\n      return a - b;\r\n    });\r\n  });\r\n  return {\r\n    nodeIdx: i,\r\n    nodeId: nodes[i].id,\r\n    nodeIdxs: unitNodeIdxs,\r\n    neighbors: neighbors,\r\n    neighborNum: unitNodeIdxs.length - 1,\r\n    nodeLabelCountMap: labelCountMap\r\n  };\r\n};\r\n/**\r\n * 随机寻找点对，满足距离小于 k\r\n * @param k 参数 k，表示 k-近邻\r\n * @param nodeNum 参数 length\r\n * @param maxNodePairNum 寻找点对的数量不超过 maxNodePairNum\r\n * @param spm 最短路径矩阵\r\n */\r\n\r\n\r\nvar findNodePairsRandomly = function findNodePairsRandomly(k, nodeNum, maxNodePairNum, kNeighborUnits, spm) {\r\n  // 每个节点需要随机找出的点对数\r\n  var nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);\r\n  var nodePairMap = {};\r\n  var foundNodePairCount = 0; // 遍历节点，为每个节点随机找出 nodePairNumEachNode 个点对，满足距离小于 k。找到的点对数量超过 maxNodePairNum 或所有节点遍历结束时终止\r\n\r\n  kNeighborUnits.forEach(function (unit, i) {\r\n    // 若未达到 nodePairNumEachNode，或循环次数小于最大循环次数(2 * nodeNum)，继续循环\r\n    var nodePairForICount = 0;\r\n    var outerLoopCount = 0;\r\n    var neighbors = unit.nodeIdxs; // the first one is the center node\r\n\r\n    var neighborNum = unit.neighborNum - 1;\r\n\r\n    while (nodePairForICount < nodePairNumEachNode) {\r\n      // 另一端节点在节点数组中的的 index\r\n      var oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];\r\n      var innerLoopCount = 0; // 若随机得到的另一端 idx 不符合条件，则继续 random。条件是不是同一个节点、这个点对没有被记录过、距离小于 k\r\n\r\n      while (nodePairMap[\"\".concat(i, \"-\").concat(oidx)] || nodePairMap[\"\".concat(oidx, \"-\").concat(i)]) {\r\n        oidx = Math.floor(Math.random() * nodeNum);\r\n        innerLoopCount++;\r\n        if (innerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\r\n      }\r\n\r\n      if (innerLoopCount < 2 * nodeNum) {\r\n        // 未达到最大循环次数，说明找到了合适的另一端\r\n        nodePairMap[\"\".concat(i, \"-\").concat(oidx)] = {\r\n          start: i,\r\n          end: oidx,\r\n          distance: spm[i][oidx]\r\n        };\r\n        nodePairForICount++;\r\n        foundNodePairCount++; // 如果当前找到的点对数量达到了上限，返回结果\r\n\r\n        if (foundNodePairCount >= maxNodePairNum) return nodePairMap;\r\n      }\r\n\r\n      outerLoopCount++;\r\n      if (outerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\r\n    } // 这个节点没有找到足够 nodePairNumEachNode 的点对。更新 nodePairNumEachNode，让后续节点找更多的点对\r\n\r\n\r\n    if (nodePairForICount < nodePairNumEachNode) {\r\n      var gap = nodePairNumEachNode - nodePairForICount;\r\n      nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i - 1);\r\n    }\r\n  });\r\n  return nodePairMap;\r\n};\r\n/**\r\n * 计算所有 nodePairMap 中节点对的相交邻居诱导子图\r\n * @param nodePairMap 节点对 map，key 为 node1.id-node2.id，value 为 { startNodeIdx, endNodeIdx, distance }\r\n * @param neighborUnits 每个节点的邻居元数组\r\n * @param graphData 原图数据\r\n * @param edgeMap 边的 map，方便检索\r\n * @param cachedInducedGraphMap 缓存的结果，下次进入该函数将继续更新该缓存，若 key 在缓存中存在则不需要重复计算\r\n */\r\n\r\n\r\nvar getIntersectNeighborInducedGraph = function getIntersectNeighborInducedGraph(nodePairMap, neighborUnits, graphData, cachedInducedGraphMap) {\r\n  var nodes = graphData.nodes;\r\n  if (!cachedInducedGraphMap) cachedInducedGraphMap = {};\r\n  Object.keys(nodePairMap).forEach(function (key) {\r\n    var _a, _b;\r\n\r\n    if (cachedInducedGraphMap && cachedInducedGraphMap[key]) return;\r\n    cachedInducedGraphMap[key] = {\r\n      nodes: [],\r\n      edges: []\r\n    };\r\n    var pair = nodePairMap[key];\r\n    var startUnitNodeIds = (_a = neighborUnits[pair.start]) === null || _a === void 0 ? void 0 : _a.nodeIdxs;\r\n    var endUnitNodeIds = (_b = neighborUnits[pair.end]) === null || _b === void 0 ? void 0 : _b.nodeIdxs;\r\n    if (!startUnitNodeIds || !endUnitNodeIds) return; // 不存在邻元，返回空图\r\n\r\n    var endSet = new Set(endUnitNodeIds);\r\n    var intersect = startUnitNodeIds.filter(function (x) {\r\n      return endSet.has(x);\r\n    }); // 可能会爆栈（在 1580 + 6 nodes full-connected 时出现）\r\n\r\n    if (!intersect || !intersect.length) return; // 没有交集，返回空图\r\n\r\n    var intersectIdMap = {};\r\n    var intersectLength = intersect.length;\r\n\r\n    for (var i = 0; i < intersectLength; i++) {\r\n      var node = nodes[intersect[i]];\r\n      cachedInducedGraphMap[key].nodes.push(node); // 将交集中的点加入诱导子图\r\n\r\n      intersectIdMap[node.id] = true;\r\n    } // 遍历所有边数据，如果边的两端都在交集中，将该边加入诱导子图\r\n\r\n\r\n    graphData.edges.forEach(function (edge) {\r\n      if (intersectIdMap[edge.source] && intersectIdMap[edge.target]) cachedInducedGraphMap[key].edges.push(edge);\r\n    });\r\n  });\r\n  return cachedInducedGraphMap;\r\n};\r\n/**\r\n * 计算 strcutre 在 graph 上的匹配数量\r\n * @param graph 图数据\r\n * @param structure 目前支持只有两个节点一条边的最简单结构\r\n * @param nodeLabelProp 节点类型字段名\r\n * @param edgeLabelProp 边类型字段名\r\n */\r\n\r\n\r\nvar getMatchedCount = function getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp) {\r\n  var _a, _b;\r\n\r\n  var nodeMap = {};\r\n  graph.nodes.forEach(function (node) {\r\n    nodeMap[node.id] = node;\r\n  });\r\n  var count = 0;\r\n  if (!((_a = structure === null || structure === void 0 ? void 0 : structure.edges) === null || _a === void 0 ? void 0 : _a.length) || ((_b = structure === null || structure === void 0 ? void 0 : structure.nodes) === null || _b === void 0 ? void 0 : _b.length) < 2) return 0;\r\n  graph.edges.forEach(function (e) {\r\n    var sourceLabel = nodeMap[e.source][nodeLabelProp];\r\n    var targetLabel = nodeMap[e.target][nodeLabelProp];\r\n    var strNodeLabel1 = structure === null || structure === void 0 ? void 0 : structure.nodes[0][nodeLabelProp];\r\n    var strNodeLabel2 = structure === null || structure === void 0 ? void 0 : structure.nodes[1][nodeLabelProp];\r\n    var strEdgeLabel = structure === null || structure === void 0 ? void 0 : structure.edges[0][edgeLabelProp];\r\n    if (e[edgeLabelProp] !== strEdgeLabel) return;\r\n\r\n    if (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2 || sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1) {\r\n      count++;\r\n    }\r\n  });\r\n  return count;\r\n};\r\n/**\r\n * structures 中寻找最具有代表性的一个。这个结构是使得 matchedCountMap 的分组方式类内间距最小，类间间距最大\r\n * @param matchedCountMap 每个 structure 分类后的各图匹配数量，格式 { [strcture.idx]: { [interInducedGraphKey]: count } }\r\n * @param structureNum strcuture 个数，与 matchedCountMap.length 对应\r\n * @param structures\r\n */\r\n\r\n\r\nvar findRepresentStructure = function findRepresentStructure(matchedCountMap, structureNum, structures) {\r\n  var maxOffset = Infinity,\r\n      representClusterType = 0;\r\n\r\n  var _loop_1 = function _loop_1(i) {\r\n    // 一种分组的 map，key 是 intGraph 的 key，value 是 structures[i] 的匹配个数\r\n    var countMapI = matchedCountMap[i]; // 按照 value 为该组排序，生成 keys 的数组：\r\n\r\n    var sortedGraphKeys = Object.keys(countMapI).sort(function (a, b) {\r\n      return countMapI[a] - countMapI[b];\r\n    }); // 共 100 个 graphKeys，将 graphKeys 按顺序分为 groupNum 组\r\n\r\n    var groupNum = 10;\r\n    var clusters = []; // 总共有 groupNum 个项\r\n\r\n    sortedGraphKeys.forEach(function (key, j) {\r\n      if (!clusters[j % groupNum]) clusters[j % groupNum] = {\r\n        graphs: [],\r\n        totalCount: 0,\r\n        aveCount: 0\r\n      };\r\n      clusters[j % groupNum].graphs.push(key);\r\n      clusters[j % groupNum].totalCount += countMapI[key];\r\n    }); // 计算 cluster 与 cluster 之间的距离 innerDist，每个 cluster 内部的距离 intraDist\r\n\r\n    var aveIntraDist = 0; // 该类的类内平均值\r\n\r\n    var aveCounts = []; // 类内平均匹配数量，将用于计算类间距离\r\n\r\n    clusters.forEach(function (graphsInCluster) {\r\n      // 类内均值\r\n      var aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;\r\n      graphsInCluster.aveCount = aveCount;\r\n      aveCounts.push(aveCount); // 对于每类，计算类内间距平均值\r\n\r\n      var aveIntraPerCluster = 0;\r\n      var graphsNum = graphsInCluster.length;\r\n      graphsInCluster.graphs.forEach(function (graphKey1, j) {\r\n        var graph1Count = countMapI[graphKey1];\r\n        graphsInCluster.graphs.forEach(function (graphKey2, k) {\r\n          if (j === k) return;\r\n          aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);\r\n        });\r\n      });\r\n      aveIntraPerCluster /= graphsNum * (graphsNum - 1) / 2;\r\n      aveIntraDist += aveIntraPerCluster;\r\n    });\r\n    aveIntraDist /= clusters.length; // 用类内均值计算类间距\r\n\r\n    var aveInterDist = 0; // 类间间距平均值\r\n\r\n    aveCounts.forEach(function (aveCount1, j) {\r\n      aveCounts.forEach(function (aveCount2, k) {\r\n        if (j === k) return;\r\n        aveInterDist += Math.abs(aveCount1 - aveCount2);\r\n      });\r\n      aveInterDist /= aveCounts.length * (aveCounts.length - 1) / 2;\r\n    }); // 寻找 (类间间距均值-类内间距均值) 最大的一种分组方式（对应的 structure 就是最终要找的唯一 DS(G)）\r\n\r\n    var offset = aveInterDist - aveIntraDist;\r\n\r\n    if (maxOffset < offset) {\r\n      maxOffset = offset;\r\n      representClusterType = i;\r\n    }\r\n  };\r\n\r\n  for (var i = 0; i < structureNum; i++) {\r\n    _loop_1(i);\r\n  }\r\n\r\n  return {\r\n    structure: structures[representClusterType],\r\n    structureCountMap: matchedCountMap[representClusterType]\r\n  };\r\n};\r\n\r\nvar getNodeMaps = function getNodeMaps(nodes, nodeLabelProp) {\r\n  var nodeMap = {},\r\n      nodeLabelMap = {};\r\n  nodes.forEach(function (node, i) {\r\n    nodeMap[node.id] = {\r\n      idx: i,\r\n      node: node,\r\n      degree: 0,\r\n      inDegree: 0,\r\n      outDegree: 0\r\n    };\r\n    var label = node[nodeLabelProp];\r\n    if (!nodeLabelMap[label]) nodeLabelMap[label] = [];\r\n    nodeLabelMap[label].push(node);\r\n  });\r\n  return {\r\n    nodeMap: nodeMap,\r\n    nodeLabelMap: nodeLabelMap\r\n  };\r\n};\r\n\r\nvar getEdgeMaps = function getEdgeMaps(edges, edgeLabelProp, nodeMap) {\r\n  var edgeMap = {},\r\n      edgeLabelMap = {};\r\n  edges.forEach(function (edge, i) {\r\n    edgeMap[\"\".concat(_util.uniqueId)] = {\r\n      idx: i,\r\n      edge: edge\r\n    };\r\n    var label = edge[edgeLabelProp];\r\n    if (!edgeLabelMap[label]) edgeLabelMap[label] = [];\r\n    edgeLabelMap[label].push(edge);\r\n    var sourceNode = nodeMap[edge.source];\r\n\r\n    if (sourceNode) {\r\n      sourceNode.degree++;\r\n      sourceNode.outDegree++;\r\n    }\r\n\r\n    var targetNode = nodeMap[edge.target];\r\n\r\n    if (targetNode) {\r\n      targetNode.degree++;\r\n      targetNode.inDegree++;\r\n    }\r\n  });\r\n  return {\r\n    edgeMap: edgeMap,\r\n    edgeLabelMap: edgeLabelMap\r\n  };\r\n};\r\n/**\r\n * 输出最短路径的 map，key 为 sourceNode.id-targetNode.id，value 为这两个节点的最短路径长度\r\n * @param nodes\r\n * @param spm\r\n * @param directed\r\n */\r\n\r\n\r\nvar getSpmMap = function getSpmMap(nodes, spm, directed) {\r\n  var length = spm.length;\r\n  var map = {};\r\n  spm.forEach(function (row, i) {\r\n    var start = directed ? 0 : i + 1;\r\n    var iId = nodes[i].id;\r\n\r\n    for (var j = start; j < length; j++) {\r\n      if (i === j) continue;\r\n      var jId = nodes[j].id;\r\n      var dist = row[j];\r\n      map[\"\".concat(iId, \"-\").concat(jId)] = dist;\r\n      if (!directed) map[\"\".concat(jId, \"-\").concat(iId)] = dist;\r\n    }\r\n  });\r\n  return map;\r\n};\r\n/**\r\n * 计算一对节点（node1，node2）的 NDS 距离\r\n * @param graph 原图数据\r\n * @param node1\r\n * @param node2\r\n */\r\n\r\n\r\nvar getNDSDist = function getNDSDist(graph, node1, node2, nodeMap, spDist, kNeighborUnits, structure, nodeLabelProp, edgeLabelProp, cachedNDSMap, cachedInterInducedGraph) {\r\n  var _a;\r\n\r\n  var key = \"\".concat(node1.id, \"-\").concat(node2.id);\r\n  if (cachedNDSMap && cachedNDSMap[key]) return cachedNDSMap[key];\r\n  var interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : undefined; // 若没有缓存相交邻居诱导子图，计算\r\n\r\n  if (!interInducedGraph) {\r\n    var pairMap = (_a = {}, _a[key] = {\r\n      start: nodeMap[node1.id].idx,\r\n      end: nodeMap[node2.id].idx,\r\n      distance: spDist\r\n    }, _a);\r\n    cachedInterInducedGraph = getIntersectNeighborInducedGraph(pairMap, kNeighborUnits, graph, cachedInterInducedGraph);\r\n    interInducedGraph = cachedInterInducedGraph[key];\r\n  }\r\n\r\n  return getMatchedCount(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);\r\n};\r\n/**\r\n * 计算 pattern 上绩点的度数并存储到 minPatternNodeLabelDegreeMap\r\n */\r\n\r\n\r\nvar stashPatternNodeLabelDegreeMap = function stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap) {\r\n  var _a, _b, _c;\r\n\r\n  var minPatternNodeLabelDegree = (_a = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _a === void 0 ? void 0 : _a.degree;\r\n  var minPatternNodeLabelInDegree = (_b = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _b === void 0 ? void 0 : _b.inDegree;\r\n  var minPatternNodeLabelOutDegree = (_c = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _c === void 0 ? void 0 : _c.outDegree;\r\n\r\n  if (minPatternNodeLabelDegreeMap[neighborLabel] === undefined) {\r\n    minPatternNodeLabelDegree = Infinity;\r\n    minPatternNodeLabelInDegree = Infinity;\r\n    minPatternNodeLabelOutDegree = Infinity;\r\n    patternNodeLabelMap[neighborLabel].forEach(function (patternNodeWithLabel) {\r\n      var patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;\r\n      if (minPatternNodeLabelDegree > patternNodeDegree) minPatternNodeLabelDegree = patternNodeDegree;\r\n      var patternNodeInDegree = patternNodeMap[patternNodeWithLabel.id].inDegree;\r\n      if (minPatternNodeLabelInDegree > patternNodeInDegree) minPatternNodeLabelInDegree = patternNodeInDegree;\r\n      var patternNodeOutDegree = patternNodeMap[patternNodeWithLabel.id].outDegree;\r\n      if (minPatternNodeLabelOutDegree > patternNodeOutDegree) minPatternNodeLabelOutDegree = patternNodeOutDegree;\r\n    });\r\n    minPatternNodeLabelDegreeMap[neighborLabel] = {\r\n      degree: minPatternNodeLabelDegree,\r\n      inDegree: minPatternNodeLabelInDegree,\r\n      outDegree: minPatternNodeLabelOutDegree\r\n    };\r\n  }\r\n\r\n  return {\r\n    minPatternNodeLabelDegree: minPatternNodeLabelDegree,\r\n    minPatternNodeLabelInDegree: minPatternNodeLabelInDegree,\r\n    minPatternNodeLabelOutDegree: minPatternNodeLabelOutDegree\r\n  };\r\n};\r\n/**\r\n * GADDI 模式匹配\r\n * @param graphData 原图数据\r\n * @param pattern 搜索图（需要在原图上搜索的模式）数据\r\n * @param directed 是否计算有向图，默认 false\r\n * @param k 参数 k，表示 k-近邻\r\n * @param length 参数 length\r\n * @param nodeLabelProp 节点数据中代表节点标签（分类信息）的属性名。默认为 cluster\r\n * @param edgeLabelProp 边数据中代表边标签（分类信息）的属性名。默认为 cluster\r\n */\r\n\r\n\r\nvar GADDI = function GADDI(graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp) {\r\n  var _a;\r\n\r\n  if (directed === void 0) {\r\n    directed = false;\r\n  }\r\n\r\n  if (nodeLabelProp === void 0) {\r\n    nodeLabelProp = 'cluster';\r\n  }\r\n\r\n  if (edgeLabelProp === void 0) {\r\n    edgeLabelProp = 'cluster';\r\n  }\r\n\r\n  if (!graphData || !graphData.nodes) return; // 分为三步：\r\n  // 0. 预计算：节点/边数，邻接矩阵、最短路径矩阵\r\n  // 1. 处理原图 graphData。再分为 1~5 小步\r\n  // 2. 匹配\r\n  // console.log(\"----- stage-pre: preprocessing -------\");\r\n  // -------- 第零步，预计算：节点/边数，邻接矩阵、最短路径矩阵-------\r\n\r\n  var nodeNum = graphData.nodes.length;\r\n  if (!nodeNum) return; // console.log(\"----- stage-pre.1: calc shortest path matrix for graph -------\");\r\n\r\n  var spm = (0, _floydWarshall.default)(graphData, directed); // console.log(\r\n  //   \"----- stage-pre.2: calc shortest path matrix for pattern -------\"\r\n  // );\r\n\r\n  var patternSpm = (0, _floydWarshall.default)(pattern, directed); // console.log(\r\n  //   \"----- stage-pre.3: calc shortest path matrix map for graph -------\"\r\n  // );\r\n\r\n  var spmMap = getSpmMap(graphData.nodes, spm, directed); // console.log(\r\n  //   \"----- stage-pre.4: calc shortest path matrix map for pattern -------\"\r\n  // );\r\n\r\n  var patternSpmMap = getSpmMap(pattern.nodes, patternSpm, directed); // console.log(\"----- stage-pre.5: establish maps -------\");\r\n  // 节点的 map，以 id 为 id 映射，方便后续快速检索\r\n\r\n  var _b = getNodeMaps(graphData.nodes, nodeLabelProp),\r\n      nodeMap = _b.nodeMap,\r\n      nodeLabelMap = _b.nodeLabelMap;\r\n\r\n  var _c = getNodeMaps(pattern.nodes, nodeLabelProp),\r\n      patternNodeMap = _c.nodeMap,\r\n      patternNodeLabelMap = _c.nodeLabelMap; // 计算节点度数\r\n\r\n\r\n  getEdgeMaps(graphData.edges, edgeLabelProp, nodeMap);\r\n  var patternEdgeLabelMap = getEdgeMaps(pattern.edges, edgeLabelProp, patternNodeMap).edgeLabelMap; // 若未指定 length，自动计算 pattern 半径（最短路径最大值）\r\n\r\n  var patternSpmSpread = [];\r\n  patternSpm === null || patternSpm === void 0 ? void 0 : patternSpm.forEach(function (row) {\r\n    patternSpmSpread = patternSpmSpread.concat(row);\r\n  });\r\n  if (!length) length = Math.max.apply(Math, (0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], patternSpmSpread, false), [2], false));\r\n  if (!k) k = length; // console.log(\"params\", directed, length, k);\r\n  // console.log(\"----- stage-pre.6: calc k neighbor units -------\");\r\n  // 计算每个节点的 k 邻元集合\r\n\r\n  var kNeighborUnits = findKNeighborUnits(graphData, spm, nodeLabelProp, k);\r\n  var patternKNeighborUnits = findKNeighborUnits(pattern, patternSpm, nodeLabelProp, k); // console.log(\r\n  //   \"----- stage0: going to processing graph and find intersect neighbor induced graphs -------\"\r\n  // );\r\n  // console.log(\"----- stage0.1: going to select random node pairs -------\");\r\n  // -------- 第一步，处理原图 graphData-------\r\n  // 1.1. 随机选择最多 100 个点对，满足距离小于 Length 和 k\r\n  // 当 graphData 少于 20 个节点，则不能找出 100 个点对，只找出不多于 n(n-1)/2 个点对\r\n\r\n  var maxNodePairNum = Math.min(100, nodeNum * (nodeNum - 1) / 2);\r\n  var nodePairsMap = findNodePairsRandomly(k, nodeNum, maxNodePairNum, kNeighborUnits, spm); // console.log(\r\n  //   \"----- stage0.2: going to calculate intersect neighbor induced graphs -------\"\r\n  // );\r\n  // 1.2. 生成上面节点对的相应相交邻居诱导子图。格式为 {'beginNodeIdx-endNodeIdx': {nodes: [], edges: []}}\r\n\r\n  var intGMap = getIntersectNeighborInducedGraph(nodePairsMap, kNeighborUnits, graphData); // 1.3. 使用 gSpan 算法（frequent graph mining）计算 ISIntG 的前 10 个频率最高的子结构（3-4条边）\r\n\r\n  var top = 10,\r\n      minSupport = 1,\r\n      minNodeNum = 1,\r\n      maxNodeNum = 4;\r\n  var params = {\r\n    graphs: intGMap,\r\n    nodeLabelProp: nodeLabelProp,\r\n    edgeLabelProp: edgeLabelProp,\r\n    minSupport: minSupport,\r\n    minNodeNum: minNodeNum,\r\n    maxNodeNum: maxNodeNum,\r\n    directed: directed\r\n  }; // console.log(\r\n  //   \"----- stage1: (gSpan) going to find frequent structure dsG -------\"\r\n  // );\r\n  // console.log(\"----- stage1.1: going to run gSpan -------\");\r\n  // 暂时假设生成的 sub structure 都只有一条边\r\n\r\n  var freStructures = (0, _gSpan.default)(params).slice(0, top); // structureNum 可能小于 top\r\n\r\n  var structureNum = freStructures.length; // 1.4. 计算上述 10 个子结构在 intGMap 中每个诱导子图的匹配个数\r\n\r\n  var matchedCountMap = [];\r\n  freStructures.forEach(function (structure, i) {\r\n    matchedCountMap[i] = {};\r\n    Object.keys(intGMap).forEach(function (key) {\r\n      var graph = intGMap[key];\r\n      var subStructureCount = getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp);\r\n      matchedCountMap[i][key] = subStructureCount;\r\n    });\r\n  }); // console.log(\r\n  //   \"----- stage1.1: going to find the most represent strucutre -------\"\r\n  // );\r\n  // 1.5. 对于每个子结构，根据匹配个数为 intGMap 中的诱导子图分组，生成 structureNum 种分组\r\n  // 计算每种分组的类间距和类内间距，找到类间距最大、类内间距最小的一种分组，这种分组对应的子结构被选为唯一代表性子结构 DS(G)\r\n\r\n  var _d = findRepresentStructure(matchedCountMap, structureNum, freStructures),\r\n      dsG = _d.structure,\r\n      ndsDist = _d.structureCountMap; // -------- 第二步，匹配-------\r\n  // 2.1 找到从 Q 中的一个节点作为起始节点，寻找 G 中的匹配。这个其实节点的标签可以在 G 中找到最多的节点\r\n\r\n\r\n  var beginPNode = pattern.nodes[0],\r\n      candidates = [],\r\n      label = (_a = pattern.nodes[0]) === null || _a === void 0 ? void 0 : _a[nodeLabelProp],\r\n      maxNodeNumWithSameLabel = -Infinity;\r\n  pattern.nodes.forEach(function (node) {\r\n    var pLabel = node[nodeLabelProp];\r\n    var nodesWithSameLabel = nodeLabelMap[pLabel];\r\n\r\n    if ((nodesWithSameLabel === null || nodesWithSameLabel === void 0 ? void 0 : nodesWithSameLabel.length) > maxNodeNumWithSameLabel) {\r\n      maxNodeNumWithSameLabel = nodesWithSameLabel.length;\r\n      candidates = nodesWithSameLabel;\r\n      label = pLabel;\r\n      beginPNode = node;\r\n    }\r\n  }); // console.log(\"----- stage2: going to find candidates -------\");\r\n  // 全局缓存，避免重复计算\r\n\r\n  var minPatternNodeLabelDegreeMap = {}; // key 是 label，value 是该 label 节点的最小度数\r\n\r\n  var patternIntGraphMap = {},\r\n      patternNDSDist = {},\r\n      // key 为 node.id-node.id\r\n  patternNDSDistMap = {}; // key 为 node.id-label2，value nds距离值数组（按从大到小排序，无需关心具体对应哪个 node2）\r\n  // 2.2.2 对于 Q 中的另一个标签的 k 个节点，计算它们到 node 的最短路径以及 NDS 距离\r\n\r\n  var patternSpDist = {};\r\n  var patternSpDistBack = {};\r\n  Object.keys(patternNodeLabelMap).forEach(function (label2, j) {\r\n    patternSpDist[label2] = [];\r\n\r\n    if (directed) {\r\n      patternSpDistBack[label2] = [];\r\n    }\r\n\r\n    var maxDist = -Infinity;\r\n    var patternNodesWithLabel2 = patternNodeLabelMap[label2];\r\n    var patternNodePairMap = {};\r\n    patternNodesWithLabel2.forEach(function (nodeWithLabel2) {\r\n      var dist = patternSpmMap[\"\".concat(beginPNode.id, \"-\").concat(nodeWithLabel2.id)];\r\n      dist && patternSpDist[label2].push(dist);\r\n      if (maxDist < dist) maxDist = dist;\r\n      patternNodePairMap[\"\".concat(beginPNode.id, \"-\").concat(nodeWithLabel2.id)] = {\r\n        start: 0,\r\n        end: patternNodeMap[nodeWithLabel2.id].idx,\r\n        distance: dist\r\n      };\r\n\r\n      if (directed) {\r\n        var distBack = patternSpmMap[\"\".concat(nodeWithLabel2.id, \"-\").concat(beginPNode.id)];\r\n        distBack && patternSpDistBack[label2].push(distBack);\r\n      }\r\n    }); // spDist[label2] 按照从小到大排序\r\n\r\n    patternSpDist[label2] = patternSpDist[label2].sort(function (a, b) {\r\n      return a - b;\r\n    });\r\n    if (directed) patternSpDistBack[label2] = patternSpDistBack[label2].sort(function (a, b) {\r\n      return a - b;\r\n    }); // 计算 Q 中所有 label2 节点到 beginPNode 的 NDS 距离\r\n    // 所有 label2 节点到 beginPNode 的邻居相交诱导子图：\r\n    // key: node1.id-node2.id\r\n\r\n    patternIntGraphMap = getIntersectNeighborInducedGraph(patternNodePairMap, patternKNeighborUnits, pattern, patternIntGraphMap); // pattern 中 beginNode 到当前 label2 节点 的 NDS 距离（数组，无需关心具体对应到哪个节点）\r\n\r\n    var currentPatternNDSDistArray = [];\r\n    Object.keys(patternNodePairMap).forEach(function (key) {\r\n      if (patternNDSDist[key]) {\r\n        currentPatternNDSDistArray.push(patternNDSDist[key]);\r\n        return; // 缓存过则不需要再次计算\r\n      }\r\n\r\n      var patternIntGraph = patternIntGraphMap[key];\r\n      patternNDSDist[key] = getMatchedCount(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);\r\n      currentPatternNDSDistArray.push(patternNDSDist[key]);\r\n    }); // 根据值为 currentPatternNDSDist 从大到小排序\r\n\r\n    currentPatternNDSDistArray = currentPatternNDSDistArray.sort(function (a, b) {\r\n      return b - a;\r\n    });\r\n    patternNDSDistMap[\"\".concat(beginPNode.id, \"-\").concat(label2)] = currentPatternNDSDistArray;\r\n    if (label2 === label) return;\r\n    var candidatesNum = (candidates === null || candidates === void 0 ? void 0 : candidates.length) || 0;\r\n\r\n    var _loop_4 = function _loop_4(m) {\r\n      var cNode = candidates[m]; // prune1：若 candidates 中节点 cNode 的 kNeighborUnits 中标签为 label2 的节点个数少于 pattern 中 label2 个数，删去它\r\n\r\n      var graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];\r\n      var graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];\r\n      var patternLabel2Num = patternNodeLabelMap[label2].length;\r\n\r\n      if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {\r\n        candidates.splice(m, 1);\r\n        return \"continue\";\r\n      } // prune2：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点最短路径大于 patternSpDist[label2]，删去它\r\n      // (prune2 规则即：candidate 相关的最短路径的最大 spDist[label2].length 个，按照大小顺序依次和 patternSpDist[label2] 中的值比较，只要遇到一个是 G > Q 的，就删去这个 candidate)\r\n\r\n\r\n      var prune2Invalid = false;\r\n\r\n      for (var n = 0; n < patternLabel2Num; n++) {\r\n        if (graphNeighborUnitCountMap.dists[n] > patternSpDist[label2][n]) {\r\n          prune2Invalid = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (prune2Invalid) {\r\n        candidates.splice(m, 1);\r\n        return \"continue\";\r\n      } // prune3：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点 NDS 距离小于 patternNDSDist[beginNode.id-label2]，删去它\r\n      // TODO：prune3，currentPatternNDSDistArray 与 currentNDSDist 的比较\r\n      // 计算 G 中所有 label2 节点到 cNode 的 NDS 距离\r\n      // 所有 label2 节点到 cNode 的邻居相交诱导子图：\r\n\r\n\r\n      var cNodePairMap = {};\r\n      graphNeighborUnit.neighbors.forEach(function (neighborNode) {\r\n        var dist = spmMap[\"\".concat(cNode.id, \"-\").concat(neighborNode.id)];\r\n        cNodePairMap[\"\".concat(cNode.id, \"-\").concat(neighborNode.id)] = {\r\n          start: nodeMap[cNode.id].idx,\r\n          end: nodeMap[neighborNode.id].idx,\r\n          distance: dist\r\n        };\r\n      }); // 更新 intGMap\r\n\r\n      intGMap = getIntersectNeighborInducedGraph(cNodePairMap, kNeighborUnits, graphData, intGMap); // candidate 到它周围 label2 节点的 NDS 距离, key 是 node.id-node.id\r\n\r\n      var currentNDSDistArray = [];\r\n      Object.keys(cNodePairMap).forEach(function (key) {\r\n        if (ndsDist[key]) {\r\n          currentNDSDistArray.push(ndsDist[key]);\r\n          return; // 缓存过则不需要再次计算\r\n        }\r\n\r\n        var intGraph = intGMap[key];\r\n        ndsDist[key] = getMatchedCount(intGraph, dsG, nodeLabelProp, edgeLabelProp);\r\n        currentNDSDistArray.push(ndsDist[key]);\r\n      }); // 根据值为 currentNDSDistArray 从大到小排序\r\n\r\n      currentNDSDistArray = currentNDSDistArray.sort(function (a, b) {\r\n        return b - a;\r\n      });\r\n      var prune3Invalid = false;\r\n\r\n      for (var n = 0; n < patternLabel2Num; n++) {\r\n        if (currentNDSDistArray[n] < currentPatternNDSDistArray[n]) {\r\n          prune3Invalid = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (prune3Invalid) {\r\n        candidates.splice(m, 1);\r\n        return \"continue\";\r\n      }\r\n    };\r\n\r\n    for (var m = candidatesNum - 1; m >= 0; m--) {\r\n      _loop_4(m);\r\n    }\r\n  });\r\n  var candidateGraphs = []; // console.log(\r\n  //   \"----- stage3: going to splice neighbors for each candidate graph -------\"\r\n  // );\r\n  // candidates 经过筛选后，以每个 candidate 为中心，生成 Length-neighbor 的邻居诱导子图\r\n  // 并在诱导子图中去除不可能在 Q 上找到匹配的点：在 Q 上不存在的 label，其他 label 到 candidate 的最大最短距离符合 Q、NDS 距离符合 Q\r\n\r\n  candidates === null || candidates === void 0 ? void 0 : candidates.forEach(function (candidate) {\r\n    var nodeIdx = nodeMap[candidate.id].idx;\r\n    var lengthNeighborUnit = findKNeighborUnit(graphData.nodes, spm[nodeIdx], nodeIdx, nodeLabelProp, length);\r\n    var neighborNodes = lengthNeighborUnit.neighbors; // 删除不可能找到匹配的邻居点\r\n\r\n    var neighborNum = neighborNodes.length;\r\n    var unmatched = false;\r\n\r\n    for (var i = neighborNum - 1; i >= 0; i--) {\r\n      // 如果通过裁剪，符合条件的节点数量已过少，说明不能匹配这个 candidate 相关的图\r\n      if (neighborNodes.length + 1 < pattern.nodes.length) {\r\n        unmatched = true;\r\n        return;\r\n      }\r\n\r\n      var neighborNode = neighborNodes[i];\r\n      var neighborLabel = neighborNode[nodeLabelProp]; // prune1: 若该邻居点的 label 不存在于 pattern 中，移除这个点\r\n\r\n      if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {\r\n        neighborNodes.splice(i, 1);\r\n        continue;\r\n      } // prune2: 若该邻居点到 candidate 的最短路径比和它有相同 label 的节点到 beginPNode 的最大最短路径长度长，移除这个点\r\n      // prune2.1: 如果没有这个标签到 beginPNode 的距离记录，说明 pattern 上（可能 beginPNode 是这个 label）没有其他这个 label 的节点\r\n\r\n\r\n      if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {\r\n        neighborNodes.splice(i, 1);\r\n        continue;\r\n      }\r\n\r\n      var key = \"\".concat(candidate.id, \"-\").concat(neighborNode.id); // prune2.2\r\n\r\n      var distToCandidate = spmMap[key];\r\n      var idx = patternSpDist[neighborLabel].length - 1;\r\n      var maxDistWithLabelInPattern = patternSpDist[neighborLabel][idx]; // patternSpDist[neighborLabel] 已经按照从小到大排序\r\n\r\n      if (distToCandidate > maxDistWithLabelInPattern) {\r\n        neighborNodes.splice(i, 1);\r\n        continue;\r\n      }\r\n\r\n      if (directed) {\r\n        var keyBack = \"\".concat(neighborNode.id, \"-\").concat(candidate.id);\r\n        var distFromCandidate = spmMap[keyBack];\r\n        idx = patternSpDistBack[neighborLabel].length - 1;\r\n        var maxBackDistWithLabelInPattern = patternSpDistBack[neighborLabel][idx];\r\n\r\n        if (distFromCandidate > maxBackDistWithLabelInPattern) {\r\n          neighborNodes.splice(i, 1);\r\n          continue;\r\n        }\r\n      } // prune3: 若该邻居点到 candidate 的 NDS 距离比和它有相同 label 的节点到 beginPNode 的最小 NDS 距离小，移除这个点\r\n\r\n\r\n      var ndsToCandidate = ndsDist[key] ? ndsDist[key] : getNDSDist(graphData, candidate, neighborNode, nodeMap, distToCandidate, kNeighborUnits, dsG, nodeLabelProp, edgeLabelProp, ndsDist, intGMap);\r\n      var patternKey = \"\".concat(beginPNode.id, \"-\").concat(neighborLabel);\r\n      var minNdsWithLabelInPattern = patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1]; // patternNDSDist[key] 一定存在\r\n\r\n      if (ndsToCandidate < minNdsWithLabelInPattern) {\r\n        neighborNodes.splice(i, 1);\r\n        continue;\r\n      } // prune4: 若该邻居点的度数小于 pattern 同 label 节点最小度数，删去该点\r\n\r\n\r\n      var _a = stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap),\r\n          minPatternNodeLabelDegree = _a.minPatternNodeLabelDegree,\r\n          minPatternNodeLabelInDegree = _a.minPatternNodeLabelInDegree,\r\n          minPatternNodeLabelOutDegree = _a.minPatternNodeLabelOutDegree;\r\n\r\n      if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {\r\n        neighborNodes.splice(i, 1);\r\n        continue;\r\n      }\r\n    } // 节点在个数上符合匹配（不少于 pattern 的节点个数），现在筛选相关边\r\n\r\n\r\n    if (!unmatched) {\r\n      candidateGraphs.push({\r\n        nodes: [candidate].concat(neighborNodes)\r\n      });\r\n    }\r\n  }); // console.log(\r\n  //   \"----- stage4: going to splice edges and neighbors for each candidate graph -------\"\r\n  // );\r\n\r\n  var undirectedLengthsToBeginPNode = (0, _dijkstra.default)(pattern, beginPNode.id, false).length;\r\n  var undirectedLengthsToBeginPNodeLabelMap = {};\r\n\r\n  if (directed) {\r\n    Object.keys(undirectedLengthsToBeginPNode).forEach(function (nodeId) {\r\n      var nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];\r\n      if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel]) undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];else undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(undirectedLengthsToBeginPNode[nodeId]);\r\n    });\r\n    Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(function (pLabel) {\r\n      undirectedLengthsToBeginPNodeLabelMap[pLabel].sort(function (a, b) {\r\n        return a - b;\r\n      });\r\n    });\r\n  } else {\r\n    undirectedLengthsToBeginPNodeLabelMap = patternSpDist;\r\n  } // 现在 candidateGraphs 里面只有节点，进行边的筛选\r\n\r\n\r\n  var candidateGraphNum = candidateGraphs.length;\r\n\r\n  var _loop_2 = function _loop_2(i) {\r\n    var candidateGraph = candidateGraphs[i];\r\n    var candidate = candidateGraph.nodes[0];\r\n    var candidateNodeLabelCountMap = {};\r\n    var candidateNodeMap = {};\r\n    candidateGraph.nodes.forEach(function (node, q) {\r\n      candidateNodeMap[node.id] = {\r\n        idx: q,\r\n        node: node,\r\n        degree: 0,\r\n        inDegree: 0,\r\n        outDegree: 0\r\n      };\r\n      var cNodeLabel = node[nodeLabelProp];\r\n      if (!candidateNodeLabelCountMap[cNodeLabel]) candidateNodeLabelCountMap[cNodeLabel] = 1;else candidateNodeLabelCountMap[cNodeLabel]++;\r\n    }); // 根据 candidate 和 neighborNodes 中的节点生成 G 的诱导子图\r\n    // 即，将 graphData 上两端都在 candidateGraph.nodes 中的边放入 candidateEdges\r\n\r\n    var candidateEdges = [];\r\n    var edgeLabelCountMap = {};\r\n    graphData.edges.forEach(function (edge) {\r\n      if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {\r\n        candidateEdges.push(edge);\r\n        if (!edgeLabelCountMap[edge[edgeLabelProp]]) edgeLabelCountMap[edge[edgeLabelProp]] = 1;else edgeLabelCountMap[edge[edgeLabelProp]]++;\r\n        candidateNodeMap[edge.source].degree++;\r\n        candidateNodeMap[edge.target].degree++;\r\n        candidateNodeMap[edge.source].outDegree++;\r\n        candidateNodeMap[edge.target].inDegree++;\r\n      }\r\n    }); // prune：若有一个 edgeLabel 在 candidateGraph 上的个数少于 pattern，去除该图\r\n\r\n    var pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;\r\n    var prunedByEdgeLabel = false;\r\n\r\n    for (var e = 0; e < pattenrEdgeLabelNum; e++) {\r\n      var label_1 = Object.keys(patternEdgeLabelMap)[e];\r\n\r\n      if (!edgeLabelCountMap[label_1] || edgeLabelCountMap[label_1] < patternEdgeLabelMap[label_1].length) {\r\n        prunedByEdgeLabel = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (prunedByEdgeLabel) {\r\n      candidateGraphs.splice(i, 1);\r\n      return \"continue\";\r\n    } // 遍历 candidateEdges，进行边的筛选\r\n\r\n\r\n    var candidateEdgeNum = candidateEdges.length; // prune：若边数过少，去除该图\r\n\r\n    if (candidateEdgeNum < pattern.edges.length) {\r\n      candidateGraphs.splice(i, 1);\r\n      return \"break\";\r\n    }\r\n\r\n    var candidateGraphInvalid = false;\r\n\r\n    var _loop_5 = function _loop_5(e) {\r\n      var edge = candidateEdges[e];\r\n      var edgeLabel = edge[edgeLabelProp];\r\n      var patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel]; // prune 1: 若边的 label 不存在于 pattern 边 label 中，去除该边\r\n\r\n      if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {\r\n        edgeLabelCountMap[edgeLabel]--; // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\r\n\r\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\r\n          candidateGraphInvalid = true;\r\n          return \"break\";\r\n        }\r\n\r\n        candidateEdges.splice(e, 1);\r\n        candidateNodeMap[edge.source].degree--;\r\n        candidateNodeMap[edge.target].degree--;\r\n        candidateNodeMap[edge.source].outDegree--;\r\n        candidateNodeMap[edge.target].inDegree--;\r\n        return \"continue\";\r\n      } // prune 2: 若边的 label +两端 label 的三元组关系不能在 pattern 中找到，去除该边\r\n\r\n\r\n      var sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];\r\n      var targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];\r\n      var edgeMatched = false;\r\n      patternEdgesWithLabel.forEach(function (patternEdge) {\r\n        var patternSource = patternNodeMap[patternEdge.source].node;\r\n        var patternTarget = patternNodeMap[patternEdge.target].node;\r\n        if (patternSource[nodeLabelProp] === sourceLabel && patternTarget[nodeLabelProp] === targetLabel) edgeMatched = true;\r\n        if (!directed && patternSource[nodeLabelProp] === targetLabel && patternTarget[nodeLabelProp] === sourceLabel) edgeMatched = true;\r\n      });\r\n\r\n      if (!edgeMatched) {\r\n        edgeLabelCountMap[edgeLabel]--; // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\r\n\r\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\r\n          candidateGraphInvalid = true;\r\n          return \"break\";\r\n        }\r\n\r\n        candidateEdges.splice(e, 1);\r\n        candidateNodeMap[edge.source].degree--;\r\n        candidateNodeMap[edge.target].degree--;\r\n        candidateNodeMap[edge.source].outDegree--;\r\n        candidateNodeMap[edge.target].inDegree--;\r\n        return \"continue\";\r\n      }\r\n    };\r\n\r\n    for (var e = candidateEdgeNum - 1; e >= 0; e--) {\r\n      var state_2 = _loop_5(e);\r\n\r\n      if (state_2 === \"break\") break;\r\n    } // prune2: 删除边的过程中，发现边数过少/边 label 数过少时，去除该图\r\n\r\n\r\n    if (candidateGraphInvalid) {\r\n      candidateGraphs.splice(i, 1);\r\n      return \"continue\";\r\n    }\r\n\r\n    candidateGraph.edges = candidateEdges;\r\n    var lengthsToCandidate = (0, _dijkstra.default)(candidateGraph, candidateGraph.nodes[0].id, false).length;\r\n    Object.keys(lengthsToCandidate).reverse().forEach(function (targetId) {\r\n      if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid) return; // prune4: 通过上述裁剪，可能导致该邻居子图变为不连通。裁剪掉目前在这个邻居子图中和 candidate（第一个节点）不连通的节点\r\n\r\n      if (lengthsToCandidate[targetId] === Infinity) {\r\n        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\r\n        candidateNodeLabelCountMap[targetNodeLabel]--;\r\n\r\n        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {\r\n          candidateGraphInvalid = true;\r\n          return;\r\n        }\r\n\r\n        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\r\n        candidateGraph.nodes.splice(idx, 1);\r\n        candidateNodeMap[targetId] = undefined;\r\n        return;\r\n      } // prune5: 经过边裁剪后，可能又出现了最短路径过长的节点 （比 pattern 中同 label 的节点到 beginNode 最大最短距离远），删去这些节点\r\n\r\n\r\n      var nLabel = nodeMap[targetId].node[nodeLabelProp];\r\n\r\n      if (!undirectedLengthsToBeginPNodeLabelMap[nLabel] || !undirectedLengthsToBeginPNodeLabelMap[nLabel].length || lengthsToCandidate[targetId] > undirectedLengthsToBeginPNodeLabelMap[nLabel][undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1]) {\r\n        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\r\n        candidateNodeLabelCountMap[targetNodeLabel]--;\r\n\r\n        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {\r\n          candidateGraphInvalid = true;\r\n          return;\r\n        }\r\n\r\n        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\r\n        candidateGraph.nodes.splice(idx, 1);\r\n        candidateNodeMap[targetId] = undefined;\r\n      }\r\n    });\r\n\r\n    if (candidateGraphInvalid) {\r\n      candidateGraphs.splice(i, 1);\r\n      return \"continue\";\r\n    }\r\n\r\n    var degreeChanged = true;\r\n    var loopCount = 0;\r\n\r\n    while (degreeChanged && !candidateGraphInvalid) {\r\n      degreeChanged = false; // candidate 度数不足，删去该图\r\n\r\n      var condition = directed ? candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree || candidateNodeMap[candidate.id].inDegree < patternNodeMap[beginPNode.id].inDegree || candidateNodeMap[candidate.id].outDegree < patternNodeMap[beginPNode.id].outDegree : candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree;\r\n\r\n      if (condition) {\r\n        candidateGraphInvalid = true;\r\n        break;\r\n      } // candidate label 个数不足，删去该图\r\n\r\n\r\n      if (candidateNodeLabelCountMap[candidate[nodeLabelProp]] < patternNodeLabelMap[candidate[nodeLabelProp]].length) {\r\n        candidateGraphInvalid = true;\r\n        break;\r\n      } // prune6：去除度数过小的节点\r\n\r\n\r\n      var currentCandidateNodeNum = candidateGraph.nodes.length;\r\n\r\n      for (var o = currentCandidateNodeNum - 1; o >= 0; o--) {\r\n        var cgNode = candidateGraph.nodes[o];\r\n        var nodeDegree = candidateNodeMap[cgNode.id].degree;\r\n        var nodeInDegree = candidateNodeMap[cgNode.id].inDegree;\r\n        var nodeOutDegree = candidateNodeMap[cgNode.id].outDegree;\r\n        var cNodeLabel = cgNode[nodeLabelProp];\r\n\r\n        var _e = stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, cNodeLabel, patternNodeMap, patternNodeLabelMap),\r\n            minPatternNodeLabelDegree = _e.minPatternNodeLabelDegree,\r\n            minPatternNodeLabelInDegree = _e.minPatternNodeLabelInDegree,\r\n            minPatternNodeLabelOutDegree = _e.minPatternNodeLabelOutDegree;\r\n\r\n        var deleteCondition = directed ? nodeDegree < minPatternNodeLabelDegree || nodeInDegree < minPatternNodeLabelInDegree || nodeOutDegree < minPatternNodeLabelOutDegree : nodeDegree < minPatternNodeLabelDegree;\r\n\r\n        if (deleteCondition) {\r\n          candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--; // 节点 label 个数不足\r\n\r\n          if (candidateNodeLabelCountMap[cgNode[nodeLabelProp]] < patternNodeLabelMap[cgNode[nodeLabelProp]].length) {\r\n            candidateGraphInvalid = true;\r\n            break;\r\n          }\r\n\r\n          candidateGraph.nodes.splice(o, 1);\r\n          candidateNodeMap[cgNode.id] = undefined;\r\n          degreeChanged = true;\r\n        }\r\n      }\r\n\r\n      if (candidateGraphInvalid || !degreeChanged && loopCount !== 0) break; // 经过 prune5 节点裁剪，删去端点已经不在 candidateGraph 中的边\r\n\r\n      candidateEdgeNum = candidateEdges.length;\r\n\r\n      for (var y = candidateEdgeNum - 1; y >= 0; y--) {\r\n        var cedge = candidateEdges[y];\r\n\r\n        if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {\r\n          candidateEdges.splice(y, 1);\r\n          var edgeLabel = cedge[edgeLabelProp];\r\n          edgeLabelCountMap[edgeLabel]--;\r\n\r\n          if (candidateNodeMap[cedge.source]) {\r\n            candidateNodeMap[cedge.source].degree--;\r\n            candidateNodeMap[cedge.source].outDegree--;\r\n          }\r\n\r\n          if (candidateNodeMap[cedge.target]) {\r\n            candidateNodeMap[cedge.target].degree--;\r\n            candidateNodeMap[cedge.target].inDegree--;\r\n          } // 边 label 数量不足\r\n\r\n\r\n          if (patternEdgeLabelMap[edgeLabel] && edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length) {\r\n            candidateGraphInvalid = true;\r\n            break;\r\n          }\r\n\r\n          degreeChanged = true;\r\n        }\r\n      }\r\n\r\n      loopCount++;\r\n    }\r\n\r\n    if (candidateGraphInvalid) {\r\n      candidateGraphs.splice(i, 1);\r\n      return \"continue\";\r\n    } // prune: 若节点/边数过少，节点/边 label 过少，去掉这个图\r\n\r\n\r\n    if (candidateGraphInvalid || candidateGraph.nodes.length < pattern.nodes.length || candidateEdges.length < pattern.edges.length) {\r\n      candidateGraphs.splice(i, 1);\r\n      return \"continue\";\r\n    }\r\n  };\r\n\r\n  for (var i = candidateGraphNum - 1; i >= 0; i--) {\r\n    var state_1 = _loop_2(i);\r\n\r\n    if (state_1 === \"break\") break;\r\n  } // 此时已经生成的多个 candidateGraphs，可能有重复\r\n  // console.log(\r\n  //   \"----- stage5: going to splice dulplicated candidate graphs -------\"\r\n  // );\r\n  // 删去 candidateGraphs 中一模一样的子图，通过边的 node-node-edgeLabel 作为 key，这类边个数作为 value，进行匹配\r\n\r\n\r\n  var currentLength = candidateGraphs.length;\r\n\r\n  var _loop_3 = function _loop_3(i) {\r\n    var cg1 = candidateGraphs[i];\r\n    var cg1EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\r\n\r\n    cg1.edges.forEach(function (edge) {\r\n      var key = \"\".concat(edge.source, \"-\").concat(edge.target, \"-\").concat(edge.label);\r\n      if (!cg1EdgeMap[key]) cg1EdgeMap[key] = 1;else cg1EdgeMap[key]++;\r\n    });\r\n\r\n    var _loop_6 = function _loop_6(j) {\r\n      var cg2 = candidateGraphs[j];\r\n      var cg2EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\r\n\r\n      cg2.edges.forEach(function (edge) {\r\n        var key = \"\".concat(edge.source, \"-\").concat(edge.target, \"-\").concat(edge.label);\r\n        if (!cg2EdgeMap[key]) cg2EdgeMap[key] = 1;else cg2EdgeMap[key]++;\r\n      });\r\n      var same = true;\r\n\r\n      if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {\r\n        same = false;\r\n      } else {\r\n        Object.keys(cg1EdgeMap).forEach(function (key) {\r\n          if (cg2EdgeMap[key] !== cg1EdgeMap[key]) same = false;\r\n        });\r\n      }\r\n\r\n      if (same) {\r\n        candidateGraphs.splice(j, 1);\r\n      }\r\n    };\r\n\r\n    for (var j = currentLength - 1; j > i; j--) {\r\n      _loop_6(j);\r\n    }\r\n\r\n    currentLength = candidateGraphs.length;\r\n  };\r\n\r\n  for (var i = 0; i <= currentLength - 1; i++) {\r\n    _loop_3(i);\r\n  }\r\n\r\n  return candidateGraphs;\r\n};\r\n\r\nvar _default = GADDI;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _struct = require(\"./struct\");\r\n\r\nvar DFSedge =\r\n/** @class */\r\nfunction () {\r\n  function DFSedge(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {\r\n    this.fromNode = fromNode;\r\n    this.toNode = toNode;\r\n    this.nodeEdgeNodeLabel = {\r\n      nodeLabel1: fromNodeLabel || _struct.VACANT_NODE_LABEL,\r\n      edgeLabel: edgeLabel || _struct.VACANT_EDGE_LABEL,\r\n      nodeLabel2: toNodeLabel || _struct.VACANT_NODE_LABEL\r\n    };\r\n  }\r\n\r\n  DFSedge.prototype.equalTo = function (other) {\r\n    return this.fromNode === other.formNode && this.toNode === other.toNode && this.nodeEdgeNodeLabel === other.nodeEdgeNodeLabel;\r\n  };\r\n\r\n  DFSedge.prototype.notEqualTo = function (other) {\r\n    return !this.equalTo(other);\r\n  };\r\n\r\n  return DFSedge;\r\n}(); // DFScode 是 DESedge 的数组\r\n\r\n\r\nvar DFScode =\r\n/** @class */\r\nfunction () {\r\n  function DFScode() {\r\n    this.rmpath = [];\r\n    this.dfsEdgeList = [];\r\n  }\r\n\r\n  DFScode.prototype.equalTo = function (other) {\r\n    var aLength = this.dfsEdgeList.length;\r\n    var bLength = other.length;\r\n    if (aLength !== bLength) return false;\r\n\r\n    for (var i = 0; i < aLength; i++) {\r\n      if (this.dfsEdgeList[i] !== other[i]) return false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n  DFScode.prototype.notEqualTo = function (other) {\r\n    return !this.equalTo(other);\r\n  };\r\n  /** 增加一条 edge 到 DFScode */\r\n\r\n\r\n  DFScode.prototype.pushBack = function (fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {\r\n    this.dfsEdgeList.push(new DFSedge(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel));\r\n    return this.dfsEdgeList;\r\n  };\r\n  /** 根据 dfs 构建图 */\r\n\r\n\r\n  DFScode.prototype.toGraph = function (graphId, directed) {\r\n    if (graphId === void 0) {\r\n      graphId = _struct.VACANT_GRAPH_ID;\r\n    }\r\n\r\n    if (directed === void 0) {\r\n      directed = false;\r\n    }\r\n\r\n    var graph = new _struct.Graph(graphId, true, directed);\r\n    this.dfsEdgeList.forEach(function (dfsEdge) {\r\n      var fromNodeId = dfsEdge.fromNode;\r\n      var toNodeId = dfsEdge.toNode;\r\n      var _a = dfsEdge.nodeEdgeNodeLabel,\r\n          nodeLabel1 = _a.nodeLabel1,\r\n          edgeLabel = _a.edgeLabel,\r\n          nodeLabel2 = _a.nodeLabel2;\r\n      if (nodeLabel1 !== _struct.VACANT_NODE_LABEL) graph.addNode(fromNodeId, nodeLabel1);\r\n      if (nodeLabel2 !== _struct.VACANT_NODE_LABEL) graph.addNode(toNodeId, nodeLabel2);\r\n      if (nodeLabel1 !== _struct.VACANT_NODE_LABEL && nodeLabel2 !== nodeLabel1) graph.addEdge(undefined, fromNodeId, toNodeId, edgeLabel);\r\n    });\r\n    return graph;\r\n  }; // 建立 rightmost path\r\n\r\n\r\n  DFScode.prototype.buildRmpath = function () {\r\n    this.rmpath = [];\r\n    var oldFrom = undefined;\r\n    var selfLength = this.dfsEdgeList.length;\r\n\r\n    for (var i = selfLength - 1; i >= 0; i--) {\r\n      var dfsEdge = this.dfsEdgeList[i];\r\n      var fromNodeIdx = dfsEdge.fromNode;\r\n      var toNodeIdx = dfsEdge.toNode;\r\n\r\n      if (fromNodeIdx < toNodeIdx && (oldFrom === undefined || toNodeIdx === oldFrom)) {\r\n        this.rmpath.push(i);\r\n        oldFrom = fromNodeIdx;\r\n      }\r\n    }\r\n\r\n    return this.rmpath;\r\n  };\r\n\r\n  DFScode.prototype.getNodeNum = function () {\r\n    var nodeMap = {};\r\n    this.dfsEdgeList.forEach(function (dfsEdge) {\r\n      if (!nodeMap[dfsEdge.fromNode]) nodeMap[dfsEdge.fromNode] = true;\r\n      if (!nodeMap[dfsEdge.toNode]) nodeMap[dfsEdge.toNode] = true;\r\n    });\r\n    return Object.keys(nodeMap).length;\r\n  };\r\n\r\n  return DFScode;\r\n}();\r\n\r\nvar History =\r\n/** @class */\r\nfunction () {\r\n  function History(pdfs) {\r\n    this.his = {};\r\n    this.nodesUsed = {};\r\n    this.edgesUsed = {};\r\n    this.edges = [];\r\n    if (!pdfs) return;\r\n\r\n    while (pdfs) {\r\n      var e = pdfs.edge;\r\n      this.edges.push(e);\r\n      this.nodesUsed[e.from] = 1;\r\n      this.nodesUsed[e.to] = 1;\r\n      this.edgesUsed[e.id] = 1;\r\n      pdfs = pdfs.preNode;\r\n    } // 倒序\r\n\r\n\r\n    this.edges = this.edges.reverse();\r\n  }\r\n\r\n  History.prototype.hasNode = function (node) {\r\n    return this.nodesUsed[node.id] === 1;\r\n  };\r\n\r\n  History.prototype.hasEdge = function (edge) {\r\n    return this.edgesUsed[edge.id] === 1;\r\n  };\r\n\r\n  return History;\r\n}();\r\n\r\nvar GSpan =\r\n/** @class */\r\nfunction () {\r\n  function GSpan(_a) {\r\n    var graphs = _a.graphs,\r\n        _b = _a.minSupport,\r\n        minSupport = _b === void 0 ? 2 : _b,\r\n        _c = _a.minNodeNum,\r\n        minNodeNum = _c === void 0 ? 1 : _c,\r\n        _d = _a.maxNodeNum,\r\n        maxNodeNum = _d === void 0 ? 4 : _d,\r\n        _e = _a.top,\r\n        top = _e === void 0 ? 10 : _e,\r\n        _f = _a.directed,\r\n        directed = _f === void 0 ? false : _f,\r\n        _g = _a.verbose,\r\n        verbose = _g === void 0 ? false : _g; // -------- 第零步，初始化-------\r\n\r\n    this.graphs = graphs;\r\n    this.dfsCode = new DFScode();\r\n    this.support = 0;\r\n    this.frequentSize1Subgraphs = [];\r\n    this.frequentSubgraphs = [];\r\n    this.minSupport = minSupport;\r\n    this.top = top;\r\n    this.directed = directed;\r\n    this.counter = 0; // TODO? timestamp = {}\r\n\r\n    this.maxNodeNum = maxNodeNum;\r\n    this.minNodeNum = minNodeNum;\r\n    this.verbose = verbose;\r\n    if (this.maxNodeNum < this.minNodeNum) this.maxNodeNum = this.minNodeNum;\r\n    this.reportDF = []; // matrix\r\n  } // Line 352\r\n\r\n\r\n  GSpan.prototype.findForwardRootEdges = function (graph, fromNode) {\r\n    var _this = this;\r\n\r\n    var result = [];\r\n    var nodeMap = graph.nodeMap;\r\n    fromNode.edges.forEach(function (edge) {\r\n      if (_this.directed || fromNode.label <= nodeMap[edge.to].label) result.push(edge);\r\n    });\r\n    return result;\r\n  };\r\n\r\n  GSpan.prototype.findBackwardEdge = function (graph, edge1, edge2, history) {\r\n    if (!this.directed && edge1 === edge2) return null;\r\n    var nodeMap = graph.nodeMap;\r\n    var edge2To = nodeMap[edge2.to];\r\n    var edge2ToEdges = edge2To.edges;\r\n    var edgeLength = edge2ToEdges.length;\r\n\r\n    for (var i = 0; i < edgeLength; i++) {\r\n      var edge = edge2ToEdges[i];\r\n      if (history.hasEdge(edge) || edge.to !== edge1.from) continue;\r\n\r\n      if (!this.directed) {\r\n        if (edge1.label < edge.label || edge1.label === edge.label && nodeMap[edge1.to].label <= nodeMap[edge2.to].label) {\r\n          return edge;\r\n        }\r\n      } else {\r\n        if (nodeMap[edge1.from].label < nodeMap[edge2.to].label || nodeMap[edge1.from].label === nodeMap[edge2.to].label && edge1.label <= edge.label) {\r\n          return edge;\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  GSpan.prototype.findForwardPureEdges = function (graph, rightmostEdge, minNodeLabel, history) {\r\n    var result = [];\r\n    var rightmostEdgeToId = rightmostEdge.to;\r\n    var edges = graph.nodeMap[rightmostEdgeToId].edges;\r\n    var edgeLength = edges.length;\r\n\r\n    for (var i = 0; i < edgeLength; i++) {\r\n      var edge = edges[i];\r\n      var toNode = graph.nodeMap[edge.to];\r\n\r\n      if (minNodeLabel <= toNode.label && !history.hasNode(toNode)) {\r\n        result.push(edge);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  GSpan.prototype.findForwardRmpathEdges = function (graph, rightmostEdge, minNodeLabel, history) {\r\n    var result = [];\r\n    var nodeMap = graph.nodeMap;\r\n    var toNodeLabel = nodeMap[rightmostEdge.to].label;\r\n    var fromNode = nodeMap[rightmostEdge.from];\r\n    var edges = fromNode.edges;\r\n    var edgeLength = edges.length;\r\n\r\n    for (var i = 0; i < edgeLength; i++) {\r\n      var edge = edges[i];\r\n      var newToNodeLabel = nodeMap[edge.to].label;\r\n\r\n      if (rightmostEdge.to === edge.to || minNodeLabel > newToNodeLabel || history.hasNode(nodeMap[edge.to])) {\r\n        continue;\r\n      }\r\n\r\n      if (rightmostEdge.label < edge.label || rightmostEdge.label === edge.label && toNodeLabel <= newToNodeLabel) {\r\n        result.push(edge);\r\n      }\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  GSpan.prototype.getSupport = function (projected) {\r\n    var graphMap = {};\r\n    projected.forEach(function (pro) {\r\n      if (!graphMap[pro.graphId]) graphMap[pro.graphId] = true;\r\n    });\r\n    return Object.keys(graphMap).length;\r\n  };\r\n\r\n  GSpan.prototype.findMinLabel = function (obj) {\r\n    var minLabel = undefined;\r\n    Object.keys(obj).forEach(function (nodeEdgeNodeLabel) {\r\n      var _a = obj[nodeEdgeNodeLabel],\r\n          nodeLabel1 = _a.nodeLabel1,\r\n          edgeLabel = _a.edgeLabel,\r\n          nodeLabel2 = _a.nodeLabel2;\r\n\r\n      if (!minLabel) {\r\n        minLabel = {\r\n          nodeLabel1: nodeLabel1,\r\n          edgeLabel: edgeLabel,\r\n          nodeLabel2: nodeLabel2\r\n        };\r\n        return;\r\n      }\r\n\r\n      if (nodeLabel1 < minLabel.nodeLabel1 || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel < minLabel.edgeLabel || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel === minLabel.edgeLabel && nodeLabel2 < minLabel.nodeLabel2) {\r\n        minLabel = {\r\n          nodeLabel1: nodeLabel1,\r\n          edgeLabel: edgeLabel,\r\n          nodeLabel2: nodeLabel2\r\n        };\r\n      }\r\n    });\r\n    return minLabel;\r\n  };\r\n\r\n  GSpan.prototype.isMin = function () {\r\n    var _this = this;\r\n\r\n    var dfsCode = this.dfsCode;\r\n    if (this.verbose) console.log(\"isMin checking\", dfsCode);\r\n    if (dfsCode.dfsEdgeList.length === 1) return true;\r\n    var directed = this.directed;\r\n    var graph = dfsCode.toGraph(_struct.VACANT_GRAPH_ID, directed);\r\n    var nodeMap = graph.nodeMap;\r\n    var dfsCodeMin = new DFScode();\r\n    var root = {};\r\n    graph.nodes.forEach(function (node) {\r\n      var forwardEdges = _this.findForwardRootEdges(graph, node);\r\n\r\n      forwardEdges.forEach(function (edge) {\r\n        var otherNode = nodeMap[edge.to];\r\n        var nodeEdgeNodeLabel = \"\".concat(node.label, \"-\").concat(edge.label, \"-\").concat(otherNode.label);\r\n        if (!root[nodeEdgeNodeLabel]) root[nodeEdgeNodeLabel] = {\r\n          projected: [],\r\n          nodeLabel1: node.label,\r\n          edgeLabel: edge.label,\r\n          nodeLabel2: otherNode.label\r\n        };\r\n        var pdfs = {\r\n          graphId: graph.id,\r\n          edge: edge,\r\n          preNode: null\r\n        };\r\n        root[nodeEdgeNodeLabel].projected.push(pdfs);\r\n      });\r\n    }); // 比较 root 中每一项的 nodeEdgeNodeLabel 大小，按照 nodeLabel1、edgeLabe、nodeLabel2 的顺序比较\r\n\r\n    var minLabel = this.findMinLabel(root); // line 419\r\n\r\n    if (!minLabel) return;\r\n    dfsCodeMin.dfsEdgeList.push(new DFSedge(0, 1, minLabel.nodeLabel1, minLabel.edgeLabel, minLabel.nodeLabel2)); // line 423\r\n\r\n    var projectIsMin = function projectIsMin(projected) {\r\n      // right most path\r\n      var rmpath = dfsCodeMin.buildRmpath();\r\n      var minNodeLabel = dfsCodeMin.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;\r\n      var maxToC = dfsCodeMin.dfsEdgeList[rmpath[0]].toNode; // node id\r\n\r\n      var backwardRoot = {};\r\n      var flag = false,\r\n          newTo = 0;\r\n      var end = directed ? -1 : 0; // 遍历到 1 还是到 0\r\n\r\n      var _loop_1 = function _loop_1(i) {\r\n        if (flag) return \"break\"; // line 435\r\n\r\n        projected.forEach(function (p) {\r\n          var history = new History(p);\r\n\r\n          var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i]], history.edges[rmpath[0]], history);\r\n\r\n          if (backwardEdge) {\r\n            // Line 441\r\n            if (!backwardRoot[backwardEdge.label]) {\r\n              backwardRoot[backwardEdge.label] = {\r\n                projected: [],\r\n                edgeLabel: backwardEdge.label\r\n              };\r\n            }\r\n\r\n            backwardRoot[backwardEdge.label].projected.push({\r\n              graphId: graph.id,\r\n              edge: backwardRoot,\r\n              preNode: p\r\n            });\r\n            newTo = dfsCodeMin.dfsEdgeList[rmpath[i]].fromNode;\r\n            flag = true;\r\n          }\r\n        });\r\n      };\r\n\r\n      for (var i = rmpath.length - 1; i > end; i--) {\r\n        var state_1 = _loop_1(i);\r\n\r\n        if (state_1 === \"break\") break;\r\n      }\r\n\r\n      if (flag) {\r\n        var minBackwardEdgeLabel = _this.findMinLabel(backwardRoot);\r\n\r\n        dfsCodeMin.dfsEdgeList.push(new DFSedge(maxToC, newTo, _struct.VACANT_NODE_LABEL, minBackwardEdgeLabel.edgeLabel, _struct.VACANT_NODE_LABEL));\r\n        var idx_1 = dfsCodeMin.dfsEdgeList.length - 1;\r\n        if (_this.dfsCode.dfsEdgeList[idx_1] !== dfsCodeMin.dfsEdgeList[idx_1]) return false;\r\n        return projectIsMin(backwardRoot[minBackwardEdgeLabel.edgeLabel].projected);\r\n      }\r\n\r\n      var forwardRoot = {};\r\n      flag = false;\r\n      var newFrom = 0;\r\n      projected.forEach(function (p) {\r\n        var history = new History(p);\r\n\r\n        var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);\r\n\r\n        if (forwardPureEdges.length > 0) {\r\n          flag = true;\r\n          newFrom = maxToC;\r\n          forwardPureEdges.forEach(function (edge) {\r\n            var key = \"\".concat(edge.label, \"-\").concat(nodeMap[edge.to].label);\r\n            if (!forwardRoot[key]) forwardRoot[key] = {\r\n              projected: [],\r\n              edgeLabel: edge.label,\r\n              nodeLabel2: nodeMap[edge.to].label\r\n            };\r\n            forwardRoot[key].projected.push({\r\n              graphId: graph.id,\r\n              edge: edge,\r\n              preNode: p\r\n            });\r\n          });\r\n        }\r\n      });\r\n      var pathLength = rmpath.length;\r\n\r\n      var _loop_2 = function _loop_2(i) {\r\n        if (flag) return \"break\";\r\n        var value = rmpath[i];\r\n        projected.forEach(function (p) {\r\n          var history = new History(p);\r\n\r\n          var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[value], minNodeLabel, history);\r\n\r\n          if (forwardRmpathEdges.length > 0) {\r\n            flag = true;\r\n            newFrom = dfsCodeMin.dfsEdgeList[value].fromNode;\r\n            forwardRmpathEdges.forEach(function (edge) {\r\n              var key = \"\".concat(edge.label, \"-\").concat(nodeMap[edge.to].label);\r\n              if (!forwardRoot[key]) forwardRoot[key] = {\r\n                projected: [],\r\n                edgeLabel: edge.label,\r\n                nodeLabel2: nodeMap[edge.to].label\r\n              };\r\n              forwardRoot[key].projected.push({\r\n                graphId: graph.id,\r\n                edge: edge,\r\n                preNode: p\r\n              });\r\n            });\r\n          }\r\n        });\r\n      };\r\n\r\n      for (var i = 0; i < pathLength; i++) {\r\n        var state_2 = _loop_2(i);\r\n\r\n        if (state_2 === \"break\") break;\r\n      }\r\n\r\n      if (!flag) return true;\r\n\r\n      var forwardMinEdgeNodeLabel = _this.findMinLabel(forwardRoot);\r\n\r\n      dfsCodeMin.dfsEdgeList.push(new DFSedge(newFrom, maxToC + 1, _struct.VACANT_NODE_LABEL, forwardMinEdgeNodeLabel.edgeLabel, forwardMinEdgeNodeLabel.nodeLabel2));\r\n      var idx = dfsCodeMin.dfsEdgeList.length - 1;\r\n      if (dfsCode.dfsEdgeList[idx] !== dfsCodeMin.dfsEdgeList[idx]) return false;\r\n      return projectIsMin(forwardRoot[\"\".concat(forwardMinEdgeNodeLabel.edgeLabel, \"-\").concat(forwardMinEdgeNodeLabel.nodeLabel2)].projected);\r\n    };\r\n\r\n    var key = \"\".concat(minLabel.nodeLabel1, \"-\").concat(minLabel.edgeLabel, \"-\").concat(minLabel.nodeLabel2);\r\n    return projectIsMin(root[key].projected);\r\n  };\r\n\r\n  GSpan.prototype.report = function () {\r\n    if (this.dfsCode.getNodeNum() < this.minNodeNum) return;\r\n    this.counter++;\r\n    var graph = this.dfsCode.toGraph(this.counter, this.directed);\r\n    this.frequentSubgraphs.push((0, _util.clone)(graph));\r\n  };\r\n\r\n  GSpan.prototype.subGraphMining = function (projected) {\r\n    var _this = this;\r\n\r\n    var support = this.getSupport(projected);\r\n    if (support < this.minSupport) return;\r\n    if (!this.isMin()) return;\r\n    this.report();\r\n    var nodeNum = this.dfsCode.getNodeNum();\r\n    var rmpath = this.dfsCode.buildRmpath();\r\n    var maxToC = this.dfsCode.dfsEdgeList[rmpath[0]].toNode;\r\n    var minNodeLabel = this.dfsCode.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;\r\n    var forwardRoot = {};\r\n    var backwardRoot = {};\r\n    projected.forEach(function (p) {\r\n      var graph = _this.graphs[p.graphId];\r\n      var nodeMap = graph.nodeMap;\r\n      var history = new History(p); // backward Line 526\r\n\r\n      for (var i = rmpath.length - 1; i >= 0; i--) {\r\n        var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i]], history.edges[rmpath[0]], history);\r\n\r\n        if (backwardEdge) {\r\n          var key = \"\".concat(_this.dfsCode.dfsEdgeList[rmpath[i]].fromNode, \"-\").concat(backwardEdge.label);\r\n          if (!backwardRoot[key]) backwardRoot[key] = {\r\n            projected: [],\r\n            toNodeId: _this.dfsCode.dfsEdgeList[rmpath[i]].fromNode,\r\n            edgeLabel: backwardEdge.label\r\n          };\r\n          backwardRoot[key].projected.push({\r\n            graphId: p.graphId,\r\n            edge: backwardEdge,\r\n            preNode: p\r\n          });\r\n        }\r\n      } // pure forward\r\n\r\n\r\n      if (nodeNum >= _this.maxNodeNum) return;\r\n\r\n      var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);\r\n\r\n      forwardPureEdges.forEach(function (edge) {\r\n        var key = \"\".concat(maxToC, \"-\").concat(edge.label, \"-\").concat(nodeMap[edge.to].label);\r\n        if (!forwardRoot[key]) forwardRoot[key] = {\r\n          projected: [],\r\n          fromNodeId: maxToC,\r\n          edgeLabel: edge.label,\r\n          nodeLabel2: nodeMap[edge.to].label\r\n        };\r\n        forwardRoot[key].projected.push({\r\n          graphId: p.graphId,\r\n          edge: edge,\r\n          preNode: p\r\n        });\r\n      });\r\n\r\n      var _loop_3 = function _loop_3(i) {\r\n        var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[rmpath[i]], minNodeLabel, history);\r\n\r\n        forwardRmpathEdges.forEach(function (edge) {\r\n          var key = \"\".concat(_this.dfsCode.dfsEdgeList[rmpath[i]].fromNode, \"-\").concat(edge.label, \"-\").concat(nodeMap[edge.to].label);\r\n          if (!forwardRoot[key]) forwardRoot[key] = {\r\n            projected: [],\r\n            fromNodeId: _this.dfsCode.dfsEdgeList[rmpath[i]].fromNode,\r\n            edgeLabel: edge.label,\r\n            nodeLabel2: nodeMap[edge.to].label\r\n          };\r\n          forwardRoot[key].projected.push({\r\n            graphId: p.graphId,\r\n            edge: edge,\r\n            preNode: p\r\n          });\r\n        });\r\n      }; // rmpath forward\r\n\r\n\r\n      for (var i = 0; i < rmpath.length; i++) {\r\n        _loop_3(i);\r\n      }\r\n    }); // backward\r\n\r\n    Object.keys(backwardRoot).forEach(function (key) {\r\n      var _a = backwardRoot[key],\r\n          toNodeId = _a.toNodeId,\r\n          edgeLabel = _a.edgeLabel;\r\n\r\n      _this.dfsCode.dfsEdgeList.push(new DFSedge(maxToC, toNodeId, \"-1\", edgeLabel, \"-1\"));\r\n\r\n      _this.subGraphMining(backwardRoot[key].projected);\r\n\r\n      _this.dfsCode.dfsEdgeList.pop();\r\n    }); // forward\r\n\r\n    Object.keys(forwardRoot).forEach(function (key) {\r\n      var _a = forwardRoot[key],\r\n          fromNodeId = _a.fromNodeId,\r\n          edgeLabel = _a.edgeLabel,\r\n          nodeLabel2 = _a.nodeLabel2;\r\n\r\n      _this.dfsCode.dfsEdgeList.push(new DFSedge(fromNodeId, maxToC + 1, _struct.VACANT_NODE_LABEL, edgeLabel, nodeLabel2));\r\n\r\n      _this.subGraphMining(forwardRoot[key].projected);\r\n\r\n      _this.dfsCode.dfsEdgeList.pop();\r\n    });\r\n  };\r\n\r\n  GSpan.prototype.generate1EdgeFrequentSubGraphs = function () {\r\n    var graphs = this.graphs;\r\n    var directed = this.directed;\r\n    var minSupport = this.minSupport;\r\n    var frequentSize1Subgraphs = this.frequentSize1Subgraphs;\r\n    var nodeLabelCounter = {},\r\n        nodeEdgeNodeCounter = {}; // 保存各个图和各自节点的关系 map，key 格式为 graphKey-node类型\r\n\r\n    var nodeLableCounted = {}; // 保存各个图和各自边的关系 map，key 格式为 graphKey-fromNode类型-edge类型-toNode类型\r\n\r\n    var nodeEdgeNodeLabelCounted = {};\r\n    Object.keys(graphs).forEach(function (key) {\r\n      // Line 271\r\n      var graph = graphs[key];\r\n      var nodeMap = graph.nodeMap; // 遍历节点，记录对应图 与 每个节点的 label 到 nodeLableCounted\r\n\r\n      graph.nodes.forEach(function (node, i) {\r\n        // Line 272\r\n        var nodeLabel = node.label;\r\n        var graphNodeKey = \"\".concat(key, \"-\").concat(nodeLabel);\r\n\r\n        if (!nodeLableCounted[graphNodeKey]) {\r\n          var counter = nodeLabelCounter[nodeLabel] || 0;\r\n          counter++;\r\n          nodeLabelCounter[nodeLabel] = counter;\r\n        }\r\n\r\n        nodeLableCounted[graphNodeKey] = {\r\n          graphKey: key,\r\n          label: nodeLabel\r\n        }; // 遍历该节点的所有边，记录各个图和各自边的关系到 nodeEdgeNodeLabelCounted. Line 276\r\n\r\n        node.edges.forEach(function (edge) {\r\n          var nodeLabel1 = nodeLabel;\r\n          var nodeLabel2 = nodeMap[edge.to].label;\r\n\r\n          if (!directed && nodeLabel1 > nodeLabel2) {\r\n            var tmp = nodeLabel2;\r\n            nodeLabel2 = nodeLabel1;\r\n            nodeLabel1 = tmp;\r\n          }\r\n\r\n          var edgeLabel = edge.label;\r\n          var graphNodeEdgeNodeKey = \"\".concat(key, \"-\").concat(nodeLabel1, \"-\").concat(edgeLabel, \"-\").concat(nodeLabel2);\r\n          var nodeEdgeNodeKey = \"\".concat(nodeLabel1, \"-\").concat(edgeLabel, \"-\").concat(nodeLabel2);\r\n\r\n          if (!nodeEdgeNodeCounter[nodeEdgeNodeKey]) {\r\n            var counter = nodeEdgeNodeCounter[nodeEdgeNodeKey] || 0;\r\n            counter++;\r\n            nodeEdgeNodeCounter[nodeEdgeNodeKey] = counter; // Line281\r\n          }\r\n\r\n          nodeEdgeNodeLabelCounted[graphNodeEdgeNodeKey] = {\r\n            graphId: key,\r\n            nodeLabel1: nodeLabel1,\r\n            edgeLabel: edgeLabel,\r\n            nodeLabel2: nodeLabel2\r\n          };\r\n        });\r\n      });\r\n    }); // 计算频繁的节点\r\n\r\n    Object.keys(nodeLabelCounter).forEach(function (label) {\r\n      var count = nodeLabelCounter[label];\r\n      if (count < minSupport) return;\r\n      var g = {\r\n        nodes: [],\r\n        edges: []\r\n      };\r\n      g.nodes.push({\r\n        id: \"0\",\r\n        label: label\r\n      });\r\n      frequentSize1Subgraphs.push(g); // if (minNodeNum <= 1) reportSize1 TODO\r\n    });\r\n    return frequentSize1Subgraphs;\r\n  };\r\n\r\n  GSpan.prototype.run = function () {\r\n    var _this = this; // -------- 第一步, _generate_1edge_frequent_subgraphs：频繁的单个节点-------\r\n\r\n\r\n    this.frequentSize1Subgraphs = this.generate1EdgeFrequentSubGraphs();\r\n    if (this.maxNodeNum < 2) return;\r\n    var graphs = this.graphs;\r\n    var directed = this.directed; // PDFS 数组的 map Line 304\r\n\r\n    var root = {};\r\n    Object.keys(graphs).forEach(function (graphId) {\r\n      var graph = graphs[graphId];\r\n      var nodeMap = graph.nodeMap; // Line 306\r\n\r\n      graph.nodes.forEach(function (node) {\r\n        var forwardRootEdges = _this.findForwardRootEdges(graph, node); // Line 308\r\n\r\n\r\n        forwardRootEdges.forEach(function (edge) {\r\n          var toNode = nodeMap[edge.to];\r\n          var nodeEdgeNodeLabel = \"\".concat(node.label, \"-\").concat(edge.label, \"-\").concat(toNode.label);\r\n          if (!root[nodeEdgeNodeLabel]) root[nodeEdgeNodeLabel] = {\r\n            projected: [],\r\n            nodeLabel1: node.label,\r\n            edgeLabel: edge.label,\r\n            nodeLabel2: toNode.label\r\n          };\r\n          var pdfs = {\r\n            graphId: graphId,\r\n            edge: edge,\r\n            preNode: null\r\n          };\r\n          root[nodeEdgeNodeLabel].projected.push(pdfs);\r\n        });\r\n      });\r\n    }); // Line 313\r\n\r\n    Object.keys(root).forEach(function (nodeEdgeNodeLabel) {\r\n      var _a = root[nodeEdgeNodeLabel],\r\n          projected = _a.projected,\r\n          nodeLabel1 = _a.nodeLabel1,\r\n          edgeLabel = _a.edgeLabel,\r\n          nodeLabel2 = _a.nodeLabel2;\r\n\r\n      _this.dfsCode.dfsEdgeList.push(new DFSedge(0, 1, nodeLabel1, edgeLabel, nodeLabel2));\r\n\r\n      _this.subGraphMining(projected);\r\n\r\n      _this.dfsCode.dfsEdgeList.pop();\r\n    });\r\n  };\r\n\r\n  return GSpan;\r\n}();\r\n\r\nvar formatGraphs = function formatGraphs(graphs, directed, nodeLabelProp, edgeLabelProp) {\r\n  var result = {};\r\n  Object.keys(graphs).forEach(function (key, i) {\r\n    var graph = graphs[key];\r\n    var fGraph = new _struct.Graph(i, true, directed);\r\n    var nodeIdxMap = {};\r\n    graph.nodes.forEach(function (node, j) {\r\n      fGraph.addNode(j, node[nodeLabelProp]);\r\n      nodeIdxMap[node.id] = j;\r\n    });\r\n    graph.edges.forEach(function (edge, k) {\r\n      var sourceIdx = nodeIdxMap[edge.source];\r\n      var targetIdx = nodeIdxMap[edge.target];\r\n      fGraph.addEdge(-1, sourceIdx, targetIdx, edge[edgeLabelProp]);\r\n    });\r\n    if (fGraph && fGraph.getNodeNum()) result[fGraph.id] = fGraph;\r\n  });\r\n  return result;\r\n};\r\n\r\nvar toGraphDatas = function toGraphDatas(graphs, nodeLabelProp, edgeLabelProp) {\r\n  var result = [];\r\n  graphs.forEach(function (graph) {\r\n    var graphData = {\r\n      nodes: [],\r\n      edges: []\r\n    };\r\n    graph.nodes.forEach(function (node) {\r\n      var _a;\r\n\r\n      graphData.nodes.push((_a = {\r\n        id: \"\".concat(node.id)\r\n      }, _a[nodeLabelProp] = node.label, _a));\r\n    });\r\n    graph.edges.forEach(function (edge) {\r\n      var _a;\r\n\r\n      graphData.edges.push((_a = {\r\n        source: \"\".concat(edge.from),\r\n        target: \"\".concat(edge.to)\r\n      }, _a[edgeLabelProp] = edge.label, _a));\r\n    });\r\n    result.push(graphData);\r\n  });\r\n  return result;\r\n};\r\n\r\nvar DEFAULT_LABEL_NAME = \"cluster\";\r\n/**\r\n * gSpan 频繁子图计算算法（frequent graph mining）\r\n * @param params 参数\r\n */\r\n\r\nvar gSpan = function gSpan(params) {\r\n  // ------- 将图数据 GraphData 的 map 转换为格式 -------\r\n  var graphs = params.graphs,\r\n      _a = params.directed,\r\n      directed = _a === void 0 ? false : _a,\r\n      _b = params.nodeLabelProp,\r\n      nodeLabelProp = _b === void 0 ? DEFAULT_LABEL_NAME : _b,\r\n      _c = params.edgeLabelProp,\r\n      edgeLabelProp = _c === void 0 ? DEFAULT_LABEL_NAME : _c;\r\n  var formattedGraphs = formatGraphs(graphs, directed, nodeLabelProp, edgeLabelProp);\r\n  var minSupport = params.minSupport,\r\n      maxNodeNum = params.maxNodeNum,\r\n      minNodeNum = params.minNodeNum,\r\n      verbose = params.verbose,\r\n      top = params.top; // ------- 初始化与执行算法 -------\r\n\r\n  var algoParams = {\r\n    graphs: formattedGraphs,\r\n    minSupport: minSupport,\r\n    maxNodeNum: maxNodeNum,\r\n    minNodeNum: minNodeNum,\r\n    top: top,\r\n    verbose: verbose,\r\n    directed: directed\r\n  };\r\n  var calculator = new GSpan(algoParams);\r\n  calculator.run();\r\n  var result = toGraphDatas(calculator.frequentSubgraphs, nodeLabelProp, edgeLabelProp);\r\n  return result;\r\n};\r\n\r\nvar _default = gSpan;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.VACANT_NODE_LABEL = exports.VACANT_NODE_ID = exports.VACANT_GRAPH_ID = exports.VACANT_EDGE_LABEL = exports.VACANT_EDGE_ID = exports.Node = exports.Graph = exports.Edge = exports.AUTO_EDGE_ID = void 0;\r\nvar VACANT_EDGE_ID = -1;\r\nexports.VACANT_EDGE_ID = VACANT_EDGE_ID;\r\nvar VACANT_NODE_ID = -1;\r\nexports.VACANT_NODE_ID = VACANT_NODE_ID;\r\nvar VACANT_EDGE_LABEL = \"-1\";\r\nexports.VACANT_EDGE_LABEL = VACANT_EDGE_LABEL;\r\nvar VACANT_NODE_LABEL = \"-1\";\r\nexports.VACANT_NODE_LABEL = VACANT_NODE_LABEL;\r\nvar VACANT_GRAPH_ID = -1;\r\nexports.VACANT_GRAPH_ID = VACANT_GRAPH_ID;\r\nvar AUTO_EDGE_ID = \"-1\";\r\nexports.AUTO_EDGE_ID = AUTO_EDGE_ID;\r\n\r\nvar Edge =\r\n/** @class */\r\nfunction () {\r\n  function Edge(id, from, to, label) {\r\n    if (id === void 0) {\r\n      id = VACANT_EDGE_ID;\r\n    }\r\n\r\n    if (from === void 0) {\r\n      from = VACANT_NODE_ID;\r\n    }\r\n\r\n    if (to === void 0) {\r\n      to = VACANT_NODE_ID;\r\n    }\r\n\r\n    if (label === void 0) {\r\n      label = VACANT_EDGE_LABEL;\r\n    }\r\n\r\n    this.id = id;\r\n    this.from = from;\r\n    this.to = to;\r\n    this.label = label;\r\n  }\r\n\r\n  return Edge;\r\n}();\r\n\r\nexports.Edge = Edge;\r\n\r\nvar Node =\r\n/** @class */\r\nfunction () {\r\n  function Node(id, label) {\r\n    if (id === void 0) {\r\n      id = VACANT_NODE_ID;\r\n    }\r\n\r\n    if (label === void 0) {\r\n      label = VACANT_NODE_LABEL;\r\n    }\r\n\r\n    this.id = id;\r\n    this.label = label;\r\n    this.edges = [];\r\n    this.edgeMap = {};\r\n  }\r\n\r\n  Node.prototype.addEdge = function (edge) {\r\n    this.edges.push(edge);\r\n    this.edgeMap[edge.id] = edge;\r\n  };\r\n\r\n  return Node;\r\n}();\r\n\r\nexports.Node = Node;\r\n\r\nvar Graph =\r\n/** @class */\r\nfunction () {\r\n  function Graph(id, edgeIdAutoIncrease, directed) {\r\n    if (id === void 0) {\r\n      id = VACANT_NODE_ID;\r\n    }\r\n\r\n    if (edgeIdAutoIncrease === void 0) {\r\n      edgeIdAutoIncrease = true;\r\n    }\r\n\r\n    if (directed === void 0) {\r\n      directed = false;\r\n    }\r\n\r\n    this.id = id;\r\n    this.edgeIdAutoIncrease = edgeIdAutoIncrease;\r\n    this.edges = [];\r\n    this.nodes = [];\r\n    this.nodeMap = {};\r\n    this.edgeMap = {};\r\n    this.nodeLabelMap = {};\r\n    this.edgeLabelMap = {};\r\n    this.counter = 0;\r\n    this.directed = directed;\r\n  }\r\n\r\n  Graph.prototype.getNodeNum = function () {\r\n    return this.nodes.length;\r\n  };\r\n\r\n  Graph.prototype.addNode = function (id, label) {\r\n    if (this.nodeMap[id]) return;\r\n    var node = new Node(id, label);\r\n    this.nodes.push(node);\r\n    this.nodeMap[id] = node;\r\n    if (!this.nodeLabelMap[label]) this.nodeLabelMap[label] = [];\r\n    this.nodeLabelMap[label].push(id);\r\n  };\r\n\r\n  Graph.prototype.addEdge = function (id, from, to, label) {\r\n    if (this.edgeIdAutoIncrease || id === undefined) id = this.counter++;\r\n    if (this.nodeMap[from] && this.nodeMap[to] && this.nodeMap[to].edgeMap[id]) return;\r\n    var edge = new Edge(id, from, to, label);\r\n    this.edges.push(edge);\r\n    this.edgeMap[id] = edge;\r\n    this.nodeMap[from].addEdge(edge);\r\n    if (!this.edgeLabelMap[label]) this.edgeLabelMap[label] = [];\r\n    this.edgeLabelMap[label].push(edge);\r\n\r\n    if (!this.directed) {\r\n      var rEdge = new Edge(id, to, from, label);\r\n      this.nodeMap[to].addEdge(rEdge);\r\n      this.edgeLabelMap[label].push(rEdge);\r\n    }\r\n  };\r\n\r\n  return Graph;\r\n}();\r\n\r\nexports.Graph = Graph;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _linkedList = _interopRequireDefault(require(\"./linked-list\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar Stack =\r\n/** @class */\r\nfunction () {\r\n  function Stack(maxStep) {\r\n    if (maxStep === void 0) {\r\n      maxStep = 10;\r\n    }\r\n\r\n    this.linkedList = new _linkedList.default();\r\n    this.maxStep = maxStep;\r\n  }\r\n\r\n  Object.defineProperty(Stack.prototype, \"length\", {\r\n    get: function get() {\r\n      return this.linkedList.toArray().length;\r\n    },\r\n    enumerable: false,\r\n    configurable: true\r\n  });\r\n  /**\r\n   * 判断栈是否为空，如果链表中没有头部元素，则栈为空\r\n   */\r\n\r\n  Stack.prototype.isEmpty = function () {\r\n    return !this.linkedList.head;\r\n  };\r\n  /**\r\n   * 是否到定义的栈的最大长度，如果达到最大长度后，不再允许入栈\r\n   */\r\n\r\n\r\n  Stack.prototype.isMaxStack = function () {\r\n    return this.toArray().length >= this.maxStep;\r\n  };\r\n  /**\r\n   * 访问顶端元素\r\n   */\r\n\r\n\r\n  Stack.prototype.peek = function () {\r\n    if (this.isEmpty()) {\r\n      return null;\r\n    } // 返回头部元素，不删除元素\r\n\r\n\r\n    return this.linkedList.head.value;\r\n  };\r\n\r\n  Stack.prototype.push = function (value) {\r\n    this.linkedList.prepend(value);\r\n\r\n    if (this.length > this.maxStep) {\r\n      this.linkedList.deleteTail();\r\n    }\r\n  };\r\n\r\n  Stack.prototype.pop = function () {\r\n    var removeHead = this.linkedList.deleteHead();\r\n    return removeHead ? removeHead.value : null;\r\n  };\r\n\r\n  Stack.prototype.toArray = function () {\r\n    return this.linkedList.toArray().map(function (node) {\r\n      return node.value;\r\n    });\r\n  };\r\n\r\n  Stack.prototype.clear = function () {\r\n    while (!this.isEmpty()) {\r\n      this.pop();\r\n    }\r\n  };\r\n\r\n  return Stack;\r\n}();\r\n\r\nvar _default = Stack;\r\nexports.default = _default;"]}