{"version":3,"sources":["index.js","hammer.js","utils/if-undefined.js","touchactionjs/touchaction-Consts.js","utils/utils-consts.js","touchactionjs/get-touchaction-props.js","inputjs/input-consts.js","recognizers/rotate.js","recognizers/attribute.js","recognizerjs/recognizer-constructor.js","recognizerjs/recognizer-consts.js","utils/assign.js","utils/unique-id.js","utils/invoke-array-arg.js","utils/each.js","utils/in-array.js","utils/bool-or-fn.js","recognizerjs/get-recognizer-by-name-if-manager.js","recognizerjs/state-str.js","recognizers/pinch.js","recognizers/swipe.js","recognizers/pan.js","recognizerjs/direction-str.js","recognizers/tap.js","utils/set-timeout-context.js","utils/bind-fn.js","inputjs/get-distance.js","recognizers/press.js","manager.js","touchactionjs/touchaction-constructor.js","utils/in-str.js","touchactionjs/clean-touch-actions.js","inputjs/create-input-instance.js","inputjs/input-handler.js","inputjs/compute-input-data.js","utils/has-parent.js","inputjs/simple-clone-input-data.js","inputjs/get-center.js","inputjs/get-angle.js","inputjs/get-direction.js","inputjs/compute-delta-xy.js","inputjs/get-velocity.js","inputjs/get-scale.js","inputjs/get-rotation.js","inputjs/compute-interval-input-data.js","input/touch.js","inputjs/input-constructor.js","utils/add-event-listeners.js","utils/split-str.js","utils/to-array.js","utils/unique-array.js","input/pointerevent.js","utils/remove-event-listeners.js","utils/merge.js","utils/deprecate.js","utils/extend.js","utils/inherit.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AGTA,ADGA;ADIA,ADGA,AGTA,ADGA;ADIA,ADGA,AGTA,ADGA;ADIA,ADGA,AGTA,ADGA,AENA;AHUA,ADGA,AGTA,ADGA,AENA;AHUA,ADGA,AGTA,ADGA,AENA;AHUA,ADGA,AKfA,AFMA,ADGA,AENA;AHUA,ADGA,AKfA,AFMA,ADGA,AENA;AHUA,ADGA,AKfA,AFMA,ADGA,AENA;AHUA,ADGA,AMlBA,ADGA,AFMA,ADGA,AENA;AHUA,ADGA,AMlBA,ADGA,AFMA,ADGA,AENA;AHUA,ADGA,AMlBA,ADGA,AFMA,ADGA,AENA;AHUA,ADGA,AMlBA,ACHA,AFMA,AFMA,ADGA,AENA;AHUA,ADGA,AMlBA,ACHA,AFMA,AFMA,ADGA,AENA;AHUA,ADGA,AMlBA,ACHA,AFMA,AFMA,ACHA;AHUA,ADGA,AMlBA,AENA,ADGA,AFMA,AFMA,ACHA;AHUA,ADGA,AMlBA,AENA,ADGA,AFMA,AFMA,ACHA;AHUA,ADGA,AMlBA,AENA,ADGA,AFMA,AFMA,ACHA;AHUA,ADGA,AMlBA,AGTA,ADGA,ADGA,AFMA,AFMA,ACHA;AHUA,ADGA,AMlBA,AGTA,ADGA,ADGA,AFMA,AFMA,ACHA;AHUA,ADGA,AMlBA,AGTA,ADGA,ADGA,AFMA,AFMA,ACHA;AHUA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AFMA,AFMA;AFOA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AJYA;AFOA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AJYA;AFOA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AJYA,AQxBA;AV+BA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AJYA,AQxBA;AV+BA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AJYA,AQxBA;AV+BA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AJYA,AQxBA,ACHA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AJYA,AQxBA,ACHA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,ACHA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AENA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AENA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AENA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AGTA,ADGA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AGTA,ADGA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AGTA,ADGA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AGTA,ACHA,AFMA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AGTA,ACHA,AFMA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AGTA,ACHA,AFMA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ACHA,AFMA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA,ADGA;AXkCA,ADGA,AMlBA,AGTA,ADGA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA,ADGA;AXkCA,ADGA,AMlBA,AWjCA,ARwBA,ADGA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA,ADGA;AXkCA,ADGA,AMlBA,AWjCA,ARwBA,ADGA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA,ADGA;AXkCA,ADGA,AMlBA,AWjCA,ARwBA,ADGA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AMlBA,AWjCA,ARwBA,AS3BA,AV8BA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AMlBA,AWjCA,ARwBA,AS3BA,AV8BA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AMlBA,AWjCA,ARwBA,AS3BA,AV8BA,ADGA,AIZA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AMlBA,AWjCA,ARwBA,AS3BA,AV8BA,AWjCA,AZoCA,AIZA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AMlBA,AWjCA,ARwBA,AS3BA,AV8BA,AWjCA,AZoCA,AIZA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AMlBA,AWjCA,ARwBA,AS3BA,AV8BA,AWjCA,AZoCA,AIZA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AMlBA,AWjCA,ARwBA,AS3BA,AV8BA,AWjCA,AZoCA,AavCA,AT2BA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AMlBA,AWjCA,ARwBA,AS3BA,AV8BA,AWjCA,AZoCA,AavCA,AT2BA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AiBnDA,ARwBA,AS3BA,AV8BA,AWjCA,AZoCA,AavCA,AT2BA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AiBnDA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,AZoCA,AavCA,AT2BA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AiBnDA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AT2BA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AiBnDA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AT2BA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AT2BA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AT2BA,AKfA,AFMA,ACHA,AFMA;AZqCA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AT2BA,AKfA,AFMA,ACHA;Ad2CA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,AKfA,AFMA,ACHA;Ad2CA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,AKfA,AFMA,ACHA;Ad2CA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,AKfA,AFMA,ACHA;Ad2CA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,AGTA,ACHA,AS3BA;AvBsEA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,AGTA,ACHA,AS3BA;AvBsEA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,AGTA,ACHA,AS3BA;AvBsEA,ADGA,AsBlEA,ALeA,ARwBA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,Ac1CA,AXiCA,ACHA,AS3BA;AvBsEA,ADGA,AsBlEA,AbuCA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,Ac1CA,AXiCA,ACHA,AS3BA;AvBsEA,ADGA,AsBlEA,AbuCA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AZoCA,Ac1CA,AXiCA,ACHA,AS3BA;AvBsEA,ADGA,A0B9EA,AJYA,AbuCA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AJYA,AbuCA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AJYA,AbuCA,AS3BA,AV8BA,AavCA,AFMA,ACHA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AJYA,AbuCA,AS3BA,AV8BA,AavCA,AFMA,AQxBA,APqBA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AJYA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AJYA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AENA,ADGA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AMlBA,AJYA,ADGA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AMlBA,AJYA,ADGA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AMlBA,AJYA,ADGA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AMlBA,AJYA,AKfA,ANkBA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AMlBA,AJYA,AKfA,ANkBA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AMlBA,AJYA,AKfA,ANkBA;AvBsEA,ADGA,A0B9EA,AENA,ANkBA,AbuCA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,AJYA,AKfA,ANkBA;AvBsEA,ADGA,A0B9EA,AENA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,A0B9EA,AENA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AgChGA,ANkBA,AENA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AgChGA,ANkBA,AENA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AgChGA,ANkBA,AENA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AgChGA,ANkBA,AOrBA,ALeA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AgChGA,ANkBA,AOrBA,ALeA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AgChGA,ANkBA,AOrBA,ALeA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AkCtGA,AFMA,ANkBA,AOrBA,ALeA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AkCtGA,AFMA,ANkBA,AOrBA,ALeA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AkCtGA,AFMA,ACHA,ALeA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,ACHA;A7BwFA,ADGA,AkCtGA,AFMA,ACHA,ALeA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,AMlBA,ALeA;A7BwFA,ADGA,AkCtGA,AFMA,ACHA,ALeA,AnByDA,ADGA,AavCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,AMlBA,ALeA;A7BwFA,ADGA,AkCtGA,AFMA,ACHA,ALeA,AnByDA,AYpCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,ACHA,AGTA,ARwBA,AnByDA,AYpCA,AFMA,AQxBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,ACHA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,ACHA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AKfA,AJYA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AKfA,AJYA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AKfA,AJYA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AMlBA,ADGA,AJYA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AMlBA,ADGA,AJYA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AMlBA,ADGA,AJYA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AMlBA,ADGA,AENA,ANkBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AMlBA,ADGA,AENA,ANkBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AkCtGA,AFMA,AMlBA,ADGA,AENA,ANkBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AwCxHA,ANkBA,AFMA,AMlBA,ADGA,AENA,ANkBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AwCxHA,ANkBA,AFMA,AMlBA,ADGA,AENA,ANkBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AnC0GA,AwCxHA,ANkBA,AFMA,AMlBA,ADGA,AENA,ANkBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AFMA,AMlBA,ADGA,AENA,AENA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AFMA,AMlBA,ADGA,AENA,AENA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AIZA,ADGA,AENA,AENA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AIZA,ADGA,AENA,AGTA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AIZA,ADGA,AENA,AGTA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AIZA,ADGA,AENA,AGTA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AIZA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AIZA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA,AMlBA;AKdA,ANkBA,AIZA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,APqBA,AGTA,AQxBA,AFMA;AWhCA,ANkBA,AU9BA,ANkBA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AQxBA,AFMA;AWhCA,ANkBA,AU9BA,ANkBA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AQxBA,AFMA;AWhCA,ANkBA,AU9BA,ANkBA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AQxBA,AFMA;AgB/CA,ALeA,ANkBA,AU9BA,ANkBA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AQxBA,AFMA;AgB/CA,ALeA,ANkBA,AU9BA,ANkBA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AQxBA,AFMA;AgB/CA,ALeA,ANkBA,AU9BA,ANkBA,ADGA,AENA,AIZA,ADGA,ADGA,ARwBA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AQxBA,AFMA;AgB/CA,ALeA,ANkBA,AU9BA,ANkBA,ADGA,AENA,AIZA,ADGA,ADGA,AKfA,AbuCA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AQxBA,AFMA;AgB/CA,ALeA,ANkBA,AU9BA,ANkBA,ADGA,AENA,AIZA,ADGA,ADGA,AKfA,AbuCA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AQxBA,AFMA;AgB/CA,ALeA,ANkBA,AU9BA,APqBA,AENA,AIZA,ADGA,ADGA,AKfA,AbuCA,AGTA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA;AgB/CA,ALeA,ANkBA,AU9BA,APqBA,AENA,AIZA,ADGA,ADGA,AKfA,AV8BA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA;AFOA,ALeA,ANkBA,AU9BA,APqBA,AENA,AIZA,ADGA,ADGA,AKfA,AV8BA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA;AFOA,ALeA,ANkBA,AU9BA,APqBA,AENA,AIZA,ADGA,ADGA,AKfA,AV8BA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA;AFOA,ALeA,ANkBA,AU9BA,APqBA,AENA,AIZA,ADGA,AIZA,AV8BA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA;AHUA,ALeA,ANkBA,AU9BA,APqBA,AENA,AIZA,ADGA,AIZA,AV8BA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA;AHUA,ALeA,ANkBA,AU9BA,APqBA,AMlBA,ADGA,AIZA,AV8BA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA;AHUA,ALeA,ANkBA,AU9BA,APqBA,AMlBA,ADGA,AIZA,AV8BA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA;AJaA,ALeA,ANkBA,AU9BA,APqBA,AMlBA,ADGA,AIZA,AV8BA,ARwBA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA;AJaA,ALeA,ANkBA,AU9BA,APqBA,AMlBA,ADGA,AIZA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA;AJaA,ALeA,ANkBA,AU9BA,APqBA,AMlBA,AGTA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA,ACHA;ALgBA,ALeA,ANkBA,AU9BA,ADGA,AGTA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA,ACHA;ALgBA,ALeA,ANkBA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,ACHA,ACHA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AKfA,AJYA,ACHA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AKfA,AJYA,ACHA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AKfA,AJYA,ACHA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AMlBA,ADGA,AJYA,ACHA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AMlBA,ADGA,AHSA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AMlBA,ADGA,AHSA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ADGA,ADGA,AHSA,ACHA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ADGA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ADGA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ACHA,AFMA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ACHA,AFMA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ACHA,AFMA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AYpCA,AMlBA,AJYA,AMlBA,AkBtDA,AOrBA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AkBtDA,AJYA,AMlBA,AkBtDA,AOrBA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AkBtDA,AJYA,AMlBA,AkBtDA,AOrBA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,AkBtDA,AJYA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,AXiCA,AU9BA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,ADGA,AENA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AHSA,ADGA,AFMA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AJYA,AFMA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AJYA,AFMA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,AJYA,AFMA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,AyB3EA,ACHA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA,ACHA,ANkBA;ACFA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA;AJaA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA;AJaA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA;AJaA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA,A0B9EA;AJaA,ANkBA,ACHA,AlBsDA,AnByDA,Ac1CA,AMlBA;AsBjEA,ANkBA,AjBmDA,AnByDA,Ac1CA,AMlBA;AsBjEA,ANkBA,AjBmDA,AnByDA,Ac1CA,AMlBA;AsBjEA,ANkBA,AjBmDA,AnByDA,Ac1CA,AMlBA;AsBjEA,ANkBA,AjBmDA,AnByDA,Ac1CA,AMlBA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA,AoB5DA;AsBjEA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;A0C7HA,ANkBA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AoC3GA,AjBmDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA,AnByDA;AmBxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _hammer = _interopRequireDefault(require(\"./hammer\"));\r\n\r\nvar _assign = _interopRequireDefault(require(\"./utils/assign\"));\r\n\r\nvar _inputConsts = require(\"./inputjs/input-consts\");\r\n\r\nvar _recognizerConsts = require(\"./recognizerjs/recognizer-consts\");\r\n\r\nvar _manager = _interopRequireDefault(require(\"./manager\"));\r\n\r\nvar _inputConstructor = _interopRequireDefault(require(\"./inputjs/input-constructor\"));\r\n\r\nvar _touchactionConstructor = _interopRequireDefault(require(\"./touchactionjs/touchaction-constructor\"));\r\n\r\nvar _touch = _interopRequireDefault(require(\"./input/touch\"));\r\n\r\nvar _pointerevent = _interopRequireDefault(require(\"./input/pointerevent\"));\r\n\r\nvar _recognizerConstructor = _interopRequireDefault(require(\"./recognizerjs/recognizer-constructor\"));\r\n\r\nvar _attribute = _interopRequireDefault(require(\"./recognizers/attribute\"));\r\n\r\nvar _tap = _interopRequireDefault(require(\"./recognizers/tap\"));\r\n\r\nvar _pan = _interopRequireDefault(require(\"./recognizers/pan\"));\r\n\r\nvar _swipe = _interopRequireDefault(require(\"./recognizers/swipe\"));\r\n\r\nvar _pinch = _interopRequireDefault(require(\"./recognizers/pinch\"));\r\n\r\nvar _rotate = _interopRequireDefault(require(\"./recognizers/rotate\"));\r\n\r\nvar _press = _interopRequireDefault(require(\"./recognizers/press\"));\r\n\r\nvar _addEventListeners = _interopRequireDefault(require(\"./utils/add-event-listeners\"));\r\n\r\nvar _removeEventListeners = _interopRequireDefault(require(\"./utils/remove-event-listeners\"));\r\n\r\nvar _each = _interopRequireDefault(require(\"./utils/each\"));\r\n\r\nvar _merge = _interopRequireDefault(require(\"./utils/merge\"));\r\n\r\nvar _extend = _interopRequireDefault(require(\"./utils/extend\"));\r\n\r\nvar _inherit = _interopRequireDefault(require(\"./utils/inherit\"));\r\n\r\nvar _bindFn = _interopRequireDefault(require(\"./utils/bind-fn\"));\r\n\r\nvar _toArray = _interopRequireDefault(require(\"./utils/to-array\"));\r\n\r\nvar _uniqueArray = _interopRequireDefault(require(\"./utils/unique-array\"));\r\n\r\nvar _splitStr = _interopRequireDefault(require(\"./utils/split-str\"));\r\n\r\nvar _inArray = _interopRequireDefault(require(\"./utils/in-array\"));\r\n\r\nvar _boolOrFn = _interopRequireDefault(require(\"./utils/bool-or-fn\"));\r\n\r\nvar _hasParent = _interopRequireDefault(require(\"./utils/has-parent\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n// this prevents errors when Hammer is loaded in the presence of an AMD\r\n//  style loader but by script tag, not by the loader.\r\nvar _default = (0, _assign.default)(_hammer.default, {\r\n  INPUT_START: _inputConsts.INPUT_START,\r\n  INPUT_MOVE: _inputConsts.INPUT_MOVE,\r\n  INPUT_END: _inputConsts.INPUT_END,\r\n  INPUT_CANCEL: _inputConsts.INPUT_CANCEL,\r\n  STATE_POSSIBLE: _recognizerConsts.STATE_POSSIBLE,\r\n  STATE_BEGAN: _recognizerConsts.STATE_BEGAN,\r\n  STATE_CHANGED: _recognizerConsts.STATE_CHANGED,\r\n  STATE_ENDED: _recognizerConsts.STATE_ENDED,\r\n  STATE_RECOGNIZED: _recognizerConsts.STATE_RECOGNIZED,\r\n  STATE_CANCELLED: _recognizerConsts.STATE_CANCELLED,\r\n  STATE_FAILED: _recognizerConsts.STATE_FAILED,\r\n  DIRECTION_NONE: _inputConsts.DIRECTION_NONE,\r\n  DIRECTION_LEFT: _inputConsts.DIRECTION_LEFT,\r\n  DIRECTION_RIGHT: _inputConsts.DIRECTION_RIGHT,\r\n  DIRECTION_UP: _inputConsts.DIRECTION_UP,\r\n  DIRECTION_DOWN: _inputConsts.DIRECTION_DOWN,\r\n  DIRECTION_HORIZONTAL: _inputConsts.DIRECTION_HORIZONTAL,\r\n  DIRECTION_VERTICAL: _inputConsts.DIRECTION_VERTICAL,\r\n  DIRECTION_ALL: _inputConsts.DIRECTION_ALL,\r\n  Manager: _manager.default,\r\n  Input: _inputConstructor.default,\r\n  TouchAction: _touchactionConstructor.default,\r\n  TouchInput: _touch.default,\r\n  PointerEventInput: _pointerevent.default,\r\n  Recognizer: _recognizerConstructor.default,\r\n  AttrRecognizer: _attribute.default,\r\n  Tap: _tap.default,\r\n  Pan: _pan.default,\r\n  Swipe: _swipe.default,\r\n  Pinch: _pinch.default,\r\n  Rotate: _rotate.default,\r\n  Press: _press.default,\r\n  on: _addEventListeners.default,\r\n  off: _removeEventListeners.default,\r\n  each: _each.default,\r\n  merge: _merge.default,\r\n  extend: _extend.default,\r\n  assign: _assign.default,\r\n  inherit: _inherit.default,\r\n  bindFn: _bindFn.default,\r\n  toArray: _toArray.default,\r\n  inArray: _inArray.default,\r\n  uniqueArray: _uniqueArray.default,\r\n  splitStr: _splitStr.default,\r\n  boolOrFn: _boolOrFn.default,\r\n  hasParent: _hasParent.default,\r\n  addEventListeners: _addEventListeners.default,\r\n  removeEventListeners: _removeEventListeners.default\r\n});\r\n\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _ifUndefined = _interopRequireDefault(require(\"./utils/if-undefined\"));\r\n\r\nvar _touchactionConsts = require(\"./touchactionjs/touchaction-Consts\");\r\n\r\nvar _inputConsts = require(\"./inputjs/input-consts\");\r\n\r\nvar _rotate = _interopRequireDefault(require(\"./recognizers/rotate\"));\r\n\r\nvar _pinch = _interopRequireDefault(require(\"./recognizers/pinch\"));\r\n\r\nvar _swipe = _interopRequireDefault(require(\"./recognizers/swipe\"));\r\n\r\nvar _pan = _interopRequireDefault(require(\"./recognizers/pan\"));\r\n\r\nvar _tap = _interopRequireDefault(require(\"./recognizers/tap\"));\r\n\r\nvar _press = _interopRequireDefault(require(\"./recognizers/press\"));\r\n\r\nvar _manager = _interopRequireDefault(require(\"./manager\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * Simple way to create a manager with a default set of recognizers.\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nclass Hammer {\r\n  constructor(options) {\r\n    options = options || {};\r\n    options.recognizers = (0, _ifUndefined.default)(options.recognizers, Hammer.defaults.preset);\r\n    return new _manager.default(options);\r\n  }\r\n\r\n}\r\n/**\r\n * @private\r\n * default settings\r\n * @namespace\r\n */\r\n\r\n\r\nexports.default = Hammer;\r\nHammer.defaults = {\r\n  /**\r\n   * @private\r\n   * set if DOM events are being triggered.\r\n   * But this is slower and unused by simple implementations, so disabled by default.\r\n   * @type {Boolean}\r\n   * @default false\r\n   */\r\n  domEvents: false,\r\n\r\n  /**\r\n   * @private\r\n   * The value for the touchAction property/fallback.\r\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\r\n   * @type {String}\r\n   * @default compute\r\n   */\r\n  touchAction: _touchactionConsts.TOUCH_ACTION_COMPUTE,\r\n\r\n  /**\r\n   * @private\r\n   * @type {Boolean}\r\n   * @default true\r\n   */\r\n  enable: true,\r\n\r\n  /**\r\n   * @private\r\n   * force an input class\r\n   * @type {Null|Function}\r\n   * @default null\r\n   */\r\n  inputClass: null,\r\n\r\n  /**\r\n   * @private\r\n   * Default recognizer setup when calling `Hammer()`\r\n   * When creating a new Manager these will be skipped.\r\n   * @type {Array}\r\n   */\r\n  preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\r\n  [_rotate.default, {\r\n    enable: false\r\n  }], [_pinch.default, {\r\n    enable: false\r\n  }, ['rotate']], [_swipe.default, {\r\n    direction: _inputConsts.DIRECTION_HORIZONTAL\r\n  }], [_pan.default, {\r\n    direction: _inputConsts.DIRECTION_HORIZONTAL\r\n  }, ['swipe']], [_tap.default], [_tap.default, {\r\n    event: 'doubletap',\r\n    taps: 2\r\n  }, ['tap']], [_press.default]]\r\n};","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = ifUndefined;\r\n\r\n/**\r\n * @private\r\n * use the val2 when val1 is undefined\r\n * @param {*} val1\r\n * @param {*} val2\r\n * @returns {*}\r\n */\r\nfunction ifUndefined(val1, val2) {\r\n  return val1 === undefined ? val2 : val1;\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.TOUCH_ACTION_MAP = exports.TOUCH_ACTION_PAN_Y = exports.TOUCH_ACTION_PAN_X = exports.TOUCH_ACTION_NONE = exports.TOUCH_ACTION_MANIPULATION = exports.TOUCH_ACTION_COMPUTE = exports.TOUCH_ACTION_AUTO = void 0;\r\n\r\nvar _utilsConsts = require(\"../utils/utils-consts\");\r\n\r\nvar _getTouchactionProps = _interopRequireDefault(require(\"./get-touchaction-props\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n// magical touchAction value\r\nconst TOUCH_ACTION_COMPUTE = 'compute';\r\nexports.TOUCH_ACTION_COMPUTE = TOUCH_ACTION_COMPUTE;\r\nconst TOUCH_ACTION_AUTO = 'auto';\r\nexports.TOUCH_ACTION_AUTO = TOUCH_ACTION_AUTO;\r\nconst TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\r\n\r\nexports.TOUCH_ACTION_MANIPULATION = TOUCH_ACTION_MANIPULATION;\r\nconst TOUCH_ACTION_NONE = 'none';\r\nexports.TOUCH_ACTION_NONE = TOUCH_ACTION_NONE;\r\nconst TOUCH_ACTION_PAN_X = 'pan-x';\r\nexports.TOUCH_ACTION_PAN_X = TOUCH_ACTION_PAN_X;\r\nconst TOUCH_ACTION_PAN_Y = 'pan-y';\r\nexports.TOUCH_ACTION_PAN_Y = TOUCH_ACTION_PAN_Y;\r\nconst TOUCH_ACTION_MAP = (0, _getTouchactionProps.default)();\r\nexports.TOUCH_ACTION_MAP = TOUCH_ACTION_MAP;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.now = exports.abs = exports.round = exports.TYPE_FUNCTION = void 0;\r\nconst TYPE_FUNCTION = 'function';\r\nexports.TYPE_FUNCTION = TYPE_FUNCTION;\r\nconst {\r\n  round,\r\n  abs\r\n} = Math;\r\nexports.abs = abs;\r\nexports.round = round;\r\nconst {\r\n  now\r\n} = Date;\r\nexports.now = now;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = getTouchActionProps;\r\n\r\nfunction getTouchActionProps() {\r\n  let touchMap = {};\r\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(val => {\r\n    // If css.supports is not supported but there is native touch-action assume it supports\r\n    // all values. This is the case for IE 10 and 11.\r\n    return touchMap[val] = true;\r\n  });\r\n  return touchMap;\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.PROPS_CLIENT_XY = exports.PROPS_XY = exports.DIRECTION_ALL = exports.DIRECTION_VERTICAL = exports.DIRECTION_HORIZONTAL = exports.DIRECTION_DOWN = exports.DIRECTION_UP = exports.DIRECTION_RIGHT = exports.DIRECTION_LEFT = exports.DIRECTION_NONE = exports.INPUT_CANCEL = exports.INPUT_END = exports.INPUT_MOVE = exports.INPUT_START = exports.COMPUTE_INTERVAL = exports.INPUT_TYPE_TOUCH = exports.INPUT_TYPE_PEN = exports.INPUT_TYPE_MOUSE = exports.INPUT_TYPE_KINECT = void 0;\r\nconst INPUT_TYPE_TOUCH = 'touch';\r\nexports.INPUT_TYPE_TOUCH = INPUT_TYPE_TOUCH;\r\nconst INPUT_TYPE_PEN = 'pen';\r\nexports.INPUT_TYPE_PEN = INPUT_TYPE_PEN;\r\nconst INPUT_TYPE_MOUSE = 'mouse';\r\nexports.INPUT_TYPE_MOUSE = INPUT_TYPE_MOUSE;\r\nconst INPUT_TYPE_KINECT = 'kinect';\r\nexports.INPUT_TYPE_KINECT = INPUT_TYPE_KINECT;\r\nconst COMPUTE_INTERVAL = 25;\r\nexports.COMPUTE_INTERVAL = COMPUTE_INTERVAL;\r\nconst INPUT_START = 1;\r\nexports.INPUT_START = INPUT_START;\r\nconst INPUT_MOVE = 2;\r\nexports.INPUT_MOVE = INPUT_MOVE;\r\nconst INPUT_END = 4;\r\nexports.INPUT_END = INPUT_END;\r\nconst INPUT_CANCEL = 8;\r\nexports.INPUT_CANCEL = INPUT_CANCEL;\r\nconst DIRECTION_NONE = 1;\r\nexports.DIRECTION_NONE = DIRECTION_NONE;\r\nconst DIRECTION_LEFT = 2;\r\nexports.DIRECTION_LEFT = DIRECTION_LEFT;\r\nconst DIRECTION_RIGHT = 4;\r\nexports.DIRECTION_RIGHT = DIRECTION_RIGHT;\r\nconst DIRECTION_UP = 8;\r\nexports.DIRECTION_UP = DIRECTION_UP;\r\nconst DIRECTION_DOWN = 16;\r\nexports.DIRECTION_DOWN = DIRECTION_DOWN;\r\nconst DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\r\nexports.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\r\nconst DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\r\nexports.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\r\nconst DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\r\nexports.DIRECTION_ALL = DIRECTION_ALL;\r\nconst PROPS_XY = ['x', 'y'];\r\nexports.PROPS_XY = PROPS_XY;\r\nconst PROPS_CLIENT_XY = ['clientX', 'clientY'];\r\nexports.PROPS_CLIENT_XY = PROPS_CLIENT_XY;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _attribute = _interopRequireDefault(require(\"./attribute\"));\r\n\r\nvar _touchactionConsts = require(\"../touchactionjs/touchaction-Consts\");\r\n\r\nvar _recognizerConsts = require(\"../recognizerjs/recognizer-consts\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * Rotate\r\n * Recognized when two or more pointer are moving in a circular motion.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nclass RotateRecognizer extends _attribute.default {\r\n  constructor() {\r\n    super(...arguments);\r\n  }\r\n\r\n  getTouchAction() {\r\n    return [_touchactionConsts.TOUCH_ACTION_NONE];\r\n  }\r\n\r\n  attrTest(input) {\r\n    return super.attrTest(input) && (Math.abs(input.rotation) > this.options.threshold || this.state & _recognizerConsts.STATE_BEGAN);\r\n  }\r\n\r\n}\r\n\r\nexports.default = RotateRecognizer;\r\nRotateRecognizer.prototype.defaults = {\r\n  event: 'rotate',\r\n  threshold: 0,\r\n  pointers: 2\r\n};","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _recognizerConstructor = _interopRequireDefault(require(\"../recognizerjs/recognizer-constructor\"));\r\n\r\nvar _recognizerConsts = require(\"../recognizerjs/recognizer-consts\");\r\n\r\nvar _inputConsts = require(\"../inputjs/input-consts\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * This recognizer is just used as a base for the simple attribute recognizers.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nclass AttrRecognizer extends _recognizerConstructor.default {\r\n  constructor() {\r\n    super(...arguments);\r\n  }\r\n  /**\r\n   * @private\r\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\r\n   * @memberof AttrRecognizer\r\n   * @param {Object} input\r\n   * @returns {Boolean} recognized\r\n   */\r\n\r\n\r\n  attrTest(input) {\r\n    let optionPointers = this.options.pointers;\r\n    return optionPointers === 0 || input.pointers.length === optionPointers;\r\n  }\r\n  /**\r\n   * @private\r\n   * Process the input and return the state for the recognizer\r\n   * @memberof AttrRecognizer\r\n   * @param {Object} input\r\n   * @returns {*} State\r\n   */\r\n\r\n\r\n  process(input) {\r\n    let {\r\n      state\r\n    } = this;\r\n    let {\r\n      eventType\r\n    } = input;\r\n    let isRecognized = state & (_recognizerConsts.STATE_BEGAN | _recognizerConsts.STATE_CHANGED);\r\n    let isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\r\n\r\n    if (isRecognized && (eventType & _inputConsts.INPUT_CANCEL || !isValid)) {\r\n      return state | _recognizerConsts.STATE_CANCELLED;\r\n    } else if (isRecognized || isValid) {\r\n      if (eventType & _inputConsts.INPUT_END) {\r\n        return state | _recognizerConsts.STATE_ENDED;\r\n      } else if (!(state & _recognizerConsts.STATE_BEGAN)) {\r\n        return _recognizerConsts.STATE_BEGAN;\r\n      }\r\n\r\n      return state | _recognizerConsts.STATE_CHANGED;\r\n    }\r\n\r\n    return _recognizerConsts.STATE_FAILED;\r\n  }\r\n\r\n}\r\n\r\nexports.default = AttrRecognizer;\r\nAttrRecognizer.prototype.defaults = {\r\n  /**\r\n   * @private\r\n   * @type {Number}\r\n   * @default 1\r\n   */\r\n  pointers: 1\r\n};","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _recognizerConsts = require(\"./recognizer-consts\");\r\n\r\nvar _assign = _interopRequireDefault(require(\"../utils/assign\"));\r\n\r\nvar _uniqueId = _interopRequireDefault(require(\"../utils/unique-id\"));\r\n\r\nvar _ifUndefined = _interopRequireDefault(require(\"../utils/if-undefined\"));\r\n\r\nvar _invokeArrayArg = _interopRequireDefault(require(\"../utils/invoke-array-arg\"));\r\n\r\nvar _inArray = _interopRequireDefault(require(\"../utils/in-array\"));\r\n\r\nvar _boolOrFn = _interopRequireDefault(require(\"../utils/bool-or-fn\"));\r\n\r\nvar _getRecognizerByNameIfManager = _interopRequireDefault(require(\"./get-recognizer-by-name-if-manager\"));\r\n\r\nvar _stateStr = _interopRequireDefault(require(\"./state-str\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * Recognizer flow explained; *\r\n * All recognizers have the initial state of POSSIBLE when a input session starts.\r\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\r\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\r\n *\r\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\r\n * which determines with state it should be.\r\n *\r\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\r\n * POSSIBLE to give it another change on the next cycle.\r\n *\r\n *               Possible\r\n *                  |\r\n *            +-----+---------------+\r\n *            |                     |\r\n *      +-----+-----+               |\r\n *      |           |               |\r\n *   Failed      Cancelled          |\r\n *                          +-------+------+\r\n *                          |              |\r\n *                      Recognized       Began\r\n *                                         |\r\n *                                      Changed\r\n *                                         |\r\n *                                  Ended/Recognized\r\n */\r\n\r\n/**\r\n * @private\r\n * Recognizer\r\n * Every recognizer needs to extend from this class.\r\n * @constructor\r\n * @param {Object} options\r\n */\r\nclass Recognizer {\r\n  constructor(options) {\r\n    this.options = (0, _assign.default)({}, this.defaults, options || {});\r\n    this.id = (0, _uniqueId.default)();\r\n    this.manager = null; // default is enable true\r\n\r\n    this.options.enable = (0, _ifUndefined.default)(this.options.enable, true);\r\n    this.state = _recognizerConsts.STATE_POSSIBLE;\r\n    this.simultaneous = {};\r\n    this.requireFail = [];\r\n  }\r\n  /**\r\n   * @private\r\n   * set options\r\n   * @param {Object} options\r\n   * @return {Recognizer}\r\n   */\r\n\r\n\r\n  set(options) {\r\n    (0, _assign.default)(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\r\n\r\n    this.manager && this.manager.touchAction.update();\r\n    return this;\r\n  }\r\n  /**\r\n   * @private\r\n   * recognize simultaneous with an other recognizer.\r\n   * @param {Recognizer} otherRecognizer\r\n   * @returns {Recognizer} this\r\n   */\r\n\r\n\r\n  recognizeWith(otherRecognizer) {\r\n    if ((0, _invokeArrayArg.default)(otherRecognizer, 'recognizeWith', this)) {\r\n      return this;\r\n    }\r\n\r\n    let {\r\n      simultaneous\r\n    } = this;\r\n    otherRecognizer = (0, _getRecognizerByNameIfManager.default)(otherRecognizer, this);\r\n\r\n    if (!simultaneous[otherRecognizer.id]) {\r\n      simultaneous[otherRecognizer.id] = otherRecognizer;\r\n      otherRecognizer.recognizeWith(this);\r\n    }\r\n\r\n    return this;\r\n  }\r\n  /**\r\n   * @private\r\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n   * @param {Recognizer} otherRecognizer\r\n   * @returns {Recognizer} this\r\n   */\r\n\r\n\r\n  dropRecognizeWith(otherRecognizer) {\r\n    if ((0, _invokeArrayArg.default)(otherRecognizer, 'dropRecognizeWith', this)) {\r\n      return this;\r\n    }\r\n\r\n    otherRecognizer = (0, _getRecognizerByNameIfManager.default)(otherRecognizer, this);\r\n    delete this.simultaneous[otherRecognizer.id];\r\n    return this;\r\n  }\r\n  /**\r\n   * @private\r\n   * recognizer can only run when an other is failing\r\n   * @param {Recognizer} otherRecognizer\r\n   * @returns {Recognizer} this\r\n   */\r\n\r\n\r\n  requireFailure(otherRecognizer) {\r\n    if ((0, _invokeArrayArg.default)(otherRecognizer, 'requireFailure', this)) {\r\n      return this;\r\n    }\r\n\r\n    let {\r\n      requireFail\r\n    } = this;\r\n    otherRecognizer = (0, _getRecognizerByNameIfManager.default)(otherRecognizer, this);\r\n\r\n    if ((0, _inArray.default)(requireFail, otherRecognizer) === -1) {\r\n      requireFail.push(otherRecognizer);\r\n      otherRecognizer.requireFailure(this);\r\n    }\r\n\r\n    return this;\r\n  }\r\n  /**\r\n   * @private\r\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n   * @param {Recognizer} otherRecognizer\r\n   * @returns {Recognizer} this\r\n   */\r\n\r\n\r\n  dropRequireFailure(otherRecognizer) {\r\n    if ((0, _invokeArrayArg.default)(otherRecognizer, 'dropRequireFailure', this)) {\r\n      return this;\r\n    }\r\n\r\n    otherRecognizer = (0, _getRecognizerByNameIfManager.default)(otherRecognizer, this);\r\n    let index = (0, _inArray.default)(this.requireFail, otherRecognizer);\r\n\r\n    if (index > -1) {\r\n      this.requireFail.splice(index, 1);\r\n    }\r\n\r\n    return this;\r\n  }\r\n  /**\r\n   * @private\r\n   * has require failures boolean\r\n   * @returns {boolean}\r\n   */\r\n\r\n\r\n  hasRequireFailures() {\r\n    return this.requireFail.length > 0;\r\n  }\r\n  /**\r\n   * @private\r\n   * if the recognizer can recognize simultaneous with an other recognizer\r\n   * @param {Recognizer} otherRecognizer\r\n   * @returns {Boolean}\r\n   */\r\n\r\n\r\n  canRecognizeWith(otherRecognizer) {\r\n    return !!this.simultaneous[otherRecognizer.id];\r\n  }\r\n  /**\r\n   * @private\r\n   * You should use `tryEmit` instead of `emit` directly to check\r\n   * that all the needed recognizers has failed before emitting.\r\n   * @param {Object} input\r\n   */\r\n\r\n\r\n  emit(input) {\r\n    let self = this;\r\n    let {\r\n      state\r\n    } = this;\r\n\r\n    function emit(event) {\r\n      self.manager.emit(event, input);\r\n    } // 'panstart' and 'panmove'\r\n\r\n\r\n    if (state < _recognizerConsts.STATE_ENDED) {\r\n      emit(self.options.event + (0, _stateStr.default)(state));\r\n    }\r\n\r\n    emit(self.options.event); // simple 'eventName' events\r\n\r\n    if (input.additionalEvent) {\r\n      // additional event(panleft, panright, pinchin, pinchout...)\r\n      emit(input.additionalEvent);\r\n    } // panend and pancancel\r\n\r\n\r\n    if (state >= _recognizerConsts.STATE_ENDED) {\r\n      emit(self.options.event + (0, _stateStr.default)(state));\r\n    }\r\n  }\r\n  /**\r\n   * @private\r\n   * Check that all the require failure recognizers has failed,\r\n   * if true, it emits a gesture event,\r\n   * otherwise, setup the state to FAILED.\r\n   * @param {Object} input\r\n   */\r\n\r\n\r\n  tryEmit(input) {\r\n    if (this.canEmit()) {\r\n      return this.emit(input);\r\n    } // it's failing anyway\r\n\r\n\r\n    this.state = _recognizerConsts.STATE_FAILED;\r\n  }\r\n  /**\r\n   * @private\r\n   * can we emit?\r\n   * @returns {boolean}\r\n   */\r\n\r\n\r\n  canEmit() {\r\n    let i = 0;\r\n\r\n    while (i < this.requireFail.length) {\r\n      if (!(this.requireFail[i].state & (_recognizerConsts.STATE_FAILED | _recognizerConsts.STATE_POSSIBLE))) {\r\n        return false;\r\n      }\r\n\r\n      i++;\r\n    }\r\n\r\n    return true;\r\n  }\r\n  /**\r\n   * @private\r\n   * update the recognizer\r\n   * @param {Object} inputData\r\n   */\r\n\r\n\r\n  recognize(inputData) {\r\n    // make a new copy of the inputData\r\n    // so we can change the inputData without messing up the other recognizers\r\n    let inputDataClone = (0, _assign.default)({}, inputData); // is is enabled and allow recognizing?\r\n\r\n    if (!(0, _boolOrFn.default)(this.options.enable, [this, inputDataClone])) {\r\n      this.reset();\r\n      this.state = _recognizerConsts.STATE_FAILED;\r\n      return;\r\n    } // reset when we've reached the end\r\n\r\n\r\n    if (this.state & (_recognizerConsts.STATE_RECOGNIZED | _recognizerConsts.STATE_CANCELLED | _recognizerConsts.STATE_FAILED)) {\r\n      this.state = _recognizerConsts.STATE_POSSIBLE;\r\n    }\r\n\r\n    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\r\n    // so trigger an event\r\n\r\n    if (this.state & (_recognizerConsts.STATE_BEGAN | _recognizerConsts.STATE_CHANGED | _recognizerConsts.STATE_ENDED | _recognizerConsts.STATE_CANCELLED)) {\r\n      this.tryEmit(inputDataClone);\r\n    }\r\n  }\r\n  /**\r\n   * @private\r\n   * return the state of the recognizer\r\n   * the actual recognizing happens in this method\r\n   * @virtual\r\n   * @param {Object} inputData\r\n   * @returns {constant} STATE\r\n   */\r\n\r\n  /* jshint ignore:start */\r\n\r\n\r\n  process(inputData) {}\r\n  /* jshint ignore:end */\r\n\r\n  /**\r\n   * @private\r\n   * return the preferred touch-action\r\n   * @virtual\r\n   * @returns {Array}\r\n   */\r\n\r\n\r\n  getTouchAction() {}\r\n  /**\r\n   * @private\r\n   * called when the gesture isn't allowed to recognize\r\n   * like when another is being recognized or it is disabled\r\n   * @virtual\r\n   */\r\n\r\n\r\n  reset() {}\r\n\r\n}\r\n\r\nexports.default = Recognizer;\r\nRecognizer.prototype.defaults = {};","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.STATE_FAILED = exports.STATE_CANCELLED = exports.STATE_RECOGNIZED = exports.STATE_ENDED = exports.STATE_CHANGED = exports.STATE_BEGAN = exports.STATE_POSSIBLE = void 0;\r\nconst STATE_POSSIBLE = 1;\r\nexports.STATE_POSSIBLE = STATE_POSSIBLE;\r\nconst STATE_BEGAN = 2;\r\nexports.STATE_BEGAN = STATE_BEGAN;\r\nconst STATE_CHANGED = 4;\r\nexports.STATE_CHANGED = STATE_CHANGED;\r\nconst STATE_ENDED = 8;\r\nexports.STATE_ENDED = STATE_ENDED;\r\nconst STATE_RECOGNIZED = STATE_ENDED;\r\nexports.STATE_RECOGNIZED = STATE_RECOGNIZED;\r\nconst STATE_CANCELLED = 16;\r\nexports.STATE_CANCELLED = STATE_CANCELLED;\r\nconst STATE_FAILED = 32;\r\nexports.STATE_FAILED = STATE_FAILED;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\n/**\r\n * @private\r\n * extend object.\r\n * means that properties in dest will be overwritten by the ones in src.\r\n * @param {Object} target\r\n * @param {...Object} objects_to_assign\r\n * @returns {Object} target\r\n */\r\nlet assign;\r\n\r\nif (typeof Object.assign !== 'function') {\r\n  assign = function assign(target) {\r\n    if (target === undefined || target === null) {\r\n      throw new TypeError('Cannot convert undefined or null to object');\r\n    }\r\n\r\n    let output = Object(target);\r\n\r\n    for (let index = 1; index < arguments.length; index++) {\r\n      const source = arguments[index];\r\n\r\n      if (source !== undefined && source !== null) {\r\n        for (const nextKey in source) {\r\n          if (source.hasOwnProperty(nextKey)) {\r\n            output[nextKey] = source[nextKey];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return output;\r\n  };\r\n} else {\r\n  assign = Object.assign;\r\n}\r\n\r\nvar _default = assign;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = uniqueId;\r\n\r\n/**\r\n * @private\r\n * get a unique id\r\n * @returns {number} uniqueId\r\n */\r\nlet _uniqueId = 1;\r\n\r\nfunction uniqueId() {\r\n  return _uniqueId++;\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = invokeArrayArg;\r\n\r\nvar _each = _interopRequireDefault(require(\"./each\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * if the argument is an array, we want to execute the fn on each entry\r\n * if it aint an array we don't want to do a thing.\r\n * this is used by all the methods that accept a single and array argument.\r\n * @param {*|Array} arg\r\n * @param {String} fn\r\n * @param {Object} [context]\r\n * @returns {Boolean}\r\n */\r\nfunction invokeArrayArg(arg, fn, context) {\r\n  if (Array.isArray(arg)) {\r\n    (0, _each.default)(arg, context[fn], context);\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = each;\r\n\r\n/**\r\n * @private\r\n * walk objects and arrays\r\n * @param {Object} obj\r\n * @param {Function} iterator\r\n * @param {Object} context\r\n */\r\nfunction each(obj, iterator, context) {\r\n  let i;\r\n\r\n  if (!obj) {\r\n    return;\r\n  }\r\n\r\n  if (obj.forEach) {\r\n    obj.forEach(iterator, context);\r\n  } else if (obj.length !== undefined) {\r\n    i = 0;\r\n\r\n    while (i < obj.length) {\r\n      iterator.call(context, obj[i], i, obj);\r\n      i++;\r\n    }\r\n  } else {\r\n    for (i in obj) {\r\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\r\n    }\r\n  }\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = inArray;\r\n\r\n/**\r\n * @private\r\n * find if a array contains the object using indexOf or a simple polyFill\r\n * @param {Array} src\r\n * @param {String} find\r\n * @param {String} [findByKey]\r\n * @return {Boolean|Number} false when not found, or the index\r\n */\r\nfunction inArray(src, find, findByKey) {\r\n  if (src.indexOf && !findByKey) {\r\n    return src.indexOf(find);\r\n  } else {\r\n    let i = 0;\r\n\r\n    while (i < src.length) {\r\n      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\r\n        // do not use === here, test fails\r\n        return i;\r\n      }\r\n\r\n      i++;\r\n    }\r\n\r\n    return -1;\r\n  }\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = boolOrFn;\r\n\r\nvar _utilsConsts = require(\"./utils-consts\");\r\n\r\n/**\r\n * @private\r\n * let a boolean value also be a function that must return a boolean\r\n * this first item in args will be used as the context\r\n * @param {Boolean|Function} val\r\n * @param {Array} [args]\r\n * @returns {Boolean}\r\n */\r\nfunction boolOrFn(val, args) {\r\n  if (typeof val === _utilsConsts.TYPE_FUNCTION) {\r\n    return val.apply(args ? args[0] || undefined : undefined, args);\r\n  }\r\n\r\n  return val;\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = getRecognizerByNameIfManager;\r\n\r\n/**\r\n * @private\r\n * get a recognizer by name if it is bound to a manager\r\n * @param {Recognizer|String} otherRecognizer\r\n * @param {Recognizer} recognizer\r\n * @returns {Recognizer}\r\n */\r\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\r\n  let {\r\n    manager\r\n  } = recognizer;\r\n\r\n  if (manager) {\r\n    return manager.get(otherRecognizer);\r\n  }\r\n\r\n  return otherRecognizer;\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = stateStr;\r\n\r\nvar _recognizerConsts = require(\"./recognizer-consts\");\r\n\r\n/**\r\n * @private\r\n * get a usable string, used as event postfix\r\n * @param {constant} state\r\n * @returns {String} state\r\n */\r\nfunction stateStr(state) {\r\n  if (state & _recognizerConsts.STATE_CANCELLED) {\r\n    return 'cancel';\r\n  } else if (state & _recognizerConsts.STATE_ENDED) {\r\n    return 'end';\r\n  } else if (state & _recognizerConsts.STATE_CHANGED) {\r\n    return 'move';\r\n  } else if (state & _recognizerConsts.STATE_BEGAN) {\r\n    return 'start';\r\n  }\r\n\r\n  return '';\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _attribute = _interopRequireDefault(require(\"./attribute\"));\r\n\r\nvar _touchactionConsts = require(\"../touchactionjs/touchaction-Consts\");\r\n\r\nvar _recognizerConsts = require(\"../recognizerjs/recognizer-consts\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * Pinch\r\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nclass PinchRecognizer extends _attribute.default {\r\n  constructor() {\r\n    super(...arguments);\r\n  }\r\n\r\n  getTouchAction() {\r\n    return [_touchactionConsts.TOUCH_ACTION_NONE];\r\n  }\r\n\r\n  attrTest(input) {\r\n    return super.attrTest(input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & _recognizerConsts.STATE_BEGAN);\r\n  }\r\n\r\n  emit(input) {\r\n    if (input.scale !== 1) {\r\n      let inOut = input.scale < 1 ? 'in' : 'out';\r\n      input.additionalEvent = this.options.event + inOut;\r\n    }\r\n\r\n    super.emit(input);\r\n  }\r\n\r\n}\r\n\r\nexports.default = PinchRecognizer;\r\nPinchRecognizer.prototype.defaults = {\r\n  event: 'pinch',\r\n  threshold: 0,\r\n  pointers: 2\r\n};","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _attribute = _interopRequireDefault(require(\"../recognizers/attribute\"));\r\n\r\nvar _utilsConsts = require(\"../utils/utils-consts\");\r\n\r\nvar _inputConsts = require(\"../inputjs/input-consts\");\r\n\r\nvar _pan = _interopRequireDefault(require(\"./pan\"));\r\n\r\nvar _directionStr = _interopRequireDefault(require(\"../recognizerjs/direction-str\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * Swipe\r\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nclass SwipeRecognizer extends _attribute.default {\r\n  constructor() {\r\n    super(...arguments);\r\n  }\r\n\r\n  getTouchAction() {\r\n    return _pan.default.prototype.getTouchAction.call(this);\r\n  }\r\n\r\n  attrTest(input) {\r\n    let {\r\n      direction\r\n    } = this.options;\r\n    let velocity;\r\n\r\n    if (direction & (_inputConsts.DIRECTION_HORIZONTAL | _inputConsts.DIRECTION_VERTICAL)) {\r\n      velocity = input.overallVelocity;\r\n    } else if (direction & _inputConsts.DIRECTION_HORIZONTAL) {\r\n      velocity = input.overallVelocityX;\r\n    } else if (direction & _inputConsts.DIRECTION_VERTICAL) {\r\n      velocity = input.overallVelocityY;\r\n    }\r\n\r\n    return super.attrTest(input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && (0, _utilsConsts.abs)(velocity) > this.options.velocity && input.eventType & _inputConsts.INPUT_END;\r\n  }\r\n\r\n  emit(input) {\r\n    let direction = (0, _directionStr.default)(input.offsetDirection);\r\n\r\n    if (direction) {\r\n      this.manager.emit(this.options.event + direction, input);\r\n    }\r\n\r\n    this.manager.emit(this.options.event, input);\r\n  }\r\n\r\n}\r\n\r\nexports.default = SwipeRecognizer;\r\nSwipeRecognizer.prototype.defaults = {\r\n  event: 'swipe',\r\n  threshold: 10,\r\n  velocity: 0.3,\r\n  direction: _inputConsts.DIRECTION_HORIZONTAL | _inputConsts.DIRECTION_VERTICAL,\r\n  pointers: 1\r\n};","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _attribute = _interopRequireDefault(require(\"./attribute\"));\r\n\r\nvar _inputConsts = require(\"../inputjs/input-consts\");\r\n\r\nvar _recognizerConsts = require(\"../recognizerjs/recognizer-consts\");\r\n\r\nvar _touchactionConsts = require(\"../touchactionjs/touchaction-Consts\");\r\n\r\nvar _directionStr = _interopRequireDefault(require(\"../recognizerjs/direction-str\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * Pan\r\n * Recognized when the pointer is down and moved in the allowed direction.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nclass PanRecognizer extends _attribute.default {\r\n  constructor() {\r\n    super(...arguments);\r\n    this.pX = null;\r\n    this.pY = null;\r\n  }\r\n\r\n  getTouchAction() {\r\n    let {\r\n      options: {\r\n        direction\r\n      }\r\n    } = this;\r\n    let actions = [];\r\n\r\n    if (direction & _inputConsts.DIRECTION_HORIZONTAL) {\r\n      actions.push(_touchactionConsts.TOUCH_ACTION_PAN_Y);\r\n    }\r\n\r\n    if (direction & _inputConsts.DIRECTION_VERTICAL) {\r\n      actions.push(_touchactionConsts.TOUCH_ACTION_PAN_X);\r\n    }\r\n\r\n    return actions;\r\n  }\r\n\r\n  directionTest(input) {\r\n    let {\r\n      options\r\n    } = this;\r\n    let hasMoved = true;\r\n    let {\r\n      distance\r\n    } = input;\r\n    let {\r\n      direction\r\n    } = input;\r\n    let x = input.deltaX;\r\n    let y = input.deltaY; // lock to axis?\r\n\r\n    if (!(direction & options.direction)) {\r\n      if (options.direction & _inputConsts.DIRECTION_HORIZONTAL) {\r\n        direction = x === 0 ? _inputConsts.DIRECTION_NONE : x < 0 ? _inputConsts.DIRECTION_LEFT : _inputConsts.DIRECTION_RIGHT;\r\n        hasMoved = x !== this.pX;\r\n        distance = Math.abs(input.deltaX);\r\n      } else {\r\n        direction = y === 0 ? _inputConsts.DIRECTION_NONE : y < 0 ? _inputConsts.DIRECTION_UP : _inputConsts.DIRECTION_DOWN;\r\n        hasMoved = y !== this.pY;\r\n        distance = Math.abs(input.deltaY);\r\n      }\r\n    }\r\n\r\n    input.direction = direction;\r\n    return hasMoved && distance > options.threshold && direction & options.direction;\r\n  }\r\n\r\n  attrTest(input) {\r\n    return _attribute.default.prototype.attrTest.call(this, input) && ( // replace with a super call\r\n    this.state & _recognizerConsts.STATE_BEGAN || !(this.state & _recognizerConsts.STATE_BEGAN) && this.directionTest(input));\r\n  }\r\n\r\n  emit(input) {\r\n    this.pX = input.deltaX;\r\n    this.pY = input.deltaY;\r\n    let direction = (0, _directionStr.default)(input.direction);\r\n\r\n    if (direction) {\r\n      input.additionalEvent = this.options.event + direction;\r\n    }\r\n\r\n    super.emit(input);\r\n  }\r\n\r\n}\r\n\r\nexports.default = PanRecognizer;\r\nPanRecognizer.prototype.defaults = {\r\n  event: 'pan',\r\n  threshold: 10,\r\n  pointers: 1,\r\n  direction: _inputConsts.DIRECTION_ALL\r\n};","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = directionStr;\r\n\r\nvar _inputConsts = require(\"../inputjs/input-consts\");\r\n\r\n/**\r\n * @private\r\n * direction cons to string\r\n * @param {constant} direction\r\n * @returns {String}\r\n */\r\nfunction directionStr(direction) {\r\n  if (direction === _inputConsts.DIRECTION_DOWN) {\r\n    return 'down';\r\n  } else if (direction === _inputConsts.DIRECTION_UP) {\r\n    return 'up';\r\n  } else if (direction === _inputConsts.DIRECTION_LEFT) {\r\n    return 'left';\r\n  } else if (direction === _inputConsts.DIRECTION_RIGHT) {\r\n    return 'right';\r\n  }\r\n\r\n  return '';\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _setTimeoutContext = _interopRequireDefault(require(\"../utils/set-timeout-context\"));\r\n\r\nvar _recognizerConstructor = _interopRequireDefault(require(\"../recognizerjs/recognizer-constructor\"));\r\n\r\nvar _touchactionConsts = require(\"../touchactionjs/touchaction-Consts\");\r\n\r\nvar _inputConsts = require(\"../inputjs/input-consts\");\r\n\r\nvar _recognizerConsts = require(\"../recognizerjs/recognizer-consts\");\r\n\r\nvar _getDistance = _interopRequireDefault(require(\"../inputjs/get-distance\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\r\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\r\n * a single tap.\r\n *\r\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n * multi-taps being recognized.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nclass TapRecognizer extends _recognizerConstructor.default {\r\n  constructor() {\r\n    super(...arguments); // previous time and center,\r\n    // used for tap counting\r\n\r\n    this.pTime = false;\r\n    this.pCenter = false;\r\n    this._timer = null;\r\n    this._input = null;\r\n    this.count = 0;\r\n  }\r\n\r\n  getTouchAction() {\r\n    return [_touchactionConsts.TOUCH_ACTION_MANIPULATION];\r\n  }\r\n\r\n  process(input) {\r\n    let {\r\n      options\r\n    } = this;\r\n    let validPointers = input.pointers.length === options.pointers;\r\n    let validMovement = input.distance < options.threshold;\r\n    let validTouchTime = input.deltaTime < options.time;\r\n    this.reset();\r\n\r\n    if (input.eventType & _inputConsts.INPUT_START && this.count === 0) {\r\n      return this.failTimeout();\r\n    } // we only allow little movement\r\n    // and we've reached an end event, so a tap is possible\r\n\r\n\r\n    if (validMovement && validTouchTime && validPointers) {\r\n      if (input.eventType !== _inputConsts.INPUT_END) {\r\n        return this.failTimeout();\r\n      }\r\n\r\n      let validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\r\n      let validMultiTap = !this.pCenter || (0, _getDistance.default)(this.pCenter, input.center) < options.posThreshold;\r\n      this.pTime = input.timeStamp;\r\n      this.pCenter = input.center;\r\n\r\n      if (!validMultiTap || !validInterval) {\r\n        this.count = 1;\r\n      } else {\r\n        this.count += 1;\r\n      }\r\n\r\n      this._input = input; // if tap count matches we have recognized it,\r\n      // else it has began recognizing...\r\n\r\n      let tapCount = this.count % options.taps;\r\n\r\n      if (tapCount === 0) {\r\n        // no failing requirements, immediately trigger the tap event\r\n        // or wait as long as the multitap interval to trigger\r\n        if (!this.hasRequireFailures()) {\r\n          return _recognizerConsts.STATE_RECOGNIZED;\r\n        } else {\r\n          this._timer = (0, _setTimeoutContext.default)(() => {\r\n            this.state = _recognizerConsts.STATE_RECOGNIZED;\r\n            this.tryEmit();\r\n          }, options.interval, this);\r\n          return _recognizerConsts.STATE_BEGAN;\r\n        }\r\n      }\r\n    }\r\n\r\n    return _recognizerConsts.STATE_FAILED;\r\n  }\r\n\r\n  failTimeout() {\r\n    this._timer = (0, _setTimeoutContext.default)(() => {\r\n      this.state = _recognizerConsts.STATE_FAILED;\r\n    }, this.options.interval, this);\r\n    return _recognizerConsts.STATE_FAILED;\r\n  }\r\n\r\n  reset() {\r\n    clearTimeout(this._timer);\r\n    this._timer = null;\r\n  }\r\n\r\n  emit() {\r\n    if (this.state === _recognizerConsts.STATE_RECOGNIZED) {\r\n      this._input.tapCount = this.count;\r\n      this.manager.emit(this.options.event, this._input);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexports.default = TapRecognizer;\r\nTapRecognizer.prototype.defaults = {\r\n  event: 'tap',\r\n  pointers: 1,\r\n  taps: 1,\r\n  interval: 300,\r\n  // max time between the multi-tap taps\r\n  time: 250,\r\n  // max time of the pointer to be down (like finger on the screen)\r\n  threshold: 9,\r\n  // a minimal movement is ok, but keep it low\r\n  posThreshold: 10 // a multi-tap can be a bit off the initial position\r\n\r\n};","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = setTimeoutContext;\r\n\r\nvar _bindFn = _interopRequireDefault(require(\"./bind-fn\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * set a timeout with a given scope\r\n * @param {Function} fn\r\n * @param {Number} timeout\r\n * @param {Object} context\r\n * @returns {number}\r\n */\r\nfunction setTimeoutContext(fn, timeout, context) {\r\n  return setTimeout((0, _bindFn.default)(fn, context), timeout);\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = bindFn;\r\n\r\n/**\r\n * @private\r\n * simple function bind\r\n * @param {Function} fn\r\n * @param {Object} context\r\n * @returns {Function}\r\n */\r\nfunction bindFn(fn, context) {\r\n  return function boundFn() {\r\n    return fn.apply(context, arguments);\r\n  };\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = getDistance;\r\n\r\nvar _inputConsts = require(\"./input-consts\");\r\n\r\n/**\r\n * @private\r\n * calculate the absolute distance between two points\r\n * @param {Object} p1 {x, y}\r\n * @param {Object} p2 {x, y}\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} distance\r\n */\r\nfunction getDistance(p1, p2, props) {\r\n  if (!props) {\r\n    props = _inputConsts.PROPS_XY;\r\n  }\r\n\r\n  let x = p2[props[0]] - p1[props[0]];\r\n  let y = p2[props[1]] - p1[props[1]];\r\n  return Math.sqrt(x * x + y * y);\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _recognizerConstructor = _interopRequireDefault(require(\"../recognizerjs/recognizer-constructor\"));\r\n\r\nvar _recognizerConsts = require(\"../recognizerjs/recognizer-consts\");\r\n\r\nvar _utilsConsts = require(\"../utils/utils-consts\");\r\n\r\nvar _setTimeoutContext = _interopRequireDefault(require(\"../utils/set-timeout-context\"));\r\n\r\nvar _touchactionConsts = require(\"../touchactionjs/touchaction-Consts\");\r\n\r\nvar _inputConsts = require(\"../inputjs/input-consts\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * Press\r\n * Recognized when the pointer is down for x ms without any movement.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nclass PressRecognizer extends _recognizerConstructor.default {\r\n  constructor() {\r\n    super(...arguments);\r\n    this._timer = null;\r\n    this._input = null;\r\n  }\r\n\r\n  getTouchAction() {\r\n    return [_touchactionConsts.TOUCH_ACTION_AUTO];\r\n  }\r\n\r\n  process(input) {\r\n    let {\r\n      options\r\n    } = this;\r\n    let validPointers = input.pointers.length === options.pointers;\r\n    let validMovement = input.distance < options.threshold;\r\n    let validTime = input.deltaTime > options.time;\r\n    this._input = input; // we only allow little movement\r\n    // and we've reached an end event, so a tap is possible\r\n\r\n    if (!validMovement || !validPointers || input.eventType & (_inputConsts.INPUT_END | _inputConsts.INPUT_CANCEL) && !validTime) {\r\n      this.reset();\r\n    } else if (input.eventType & _inputConsts.INPUT_START) {\r\n      this.reset();\r\n      this._timer = (0, _setTimeoutContext.default)(() => {\r\n        this.state = _recognizerConsts.STATE_RECOGNIZED;\r\n        this.tryEmit();\r\n      }, options.time, this);\r\n    } else if (input.eventType & _inputConsts.INPUT_END) {\r\n      return _recognizerConsts.STATE_RECOGNIZED;\r\n    }\r\n\r\n    return _recognizerConsts.STATE_FAILED;\r\n  }\r\n\r\n  reset() {\r\n    clearTimeout(this._timer);\r\n    this._timer = null;\r\n  }\r\n\r\n  emit(input) {\r\n    if (this.state !== _recognizerConsts.STATE_RECOGNIZED) {\r\n      return;\r\n    }\r\n\r\n    if (input && input.eventType & _inputConsts.INPUT_END) {\r\n      this.manager.emit(`${this.options.event}up`, input);\r\n    } else {\r\n      this._input.timeStamp = (0, _utilsConsts.now)();\r\n      this.manager.emit(this.options.event, this._input);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexports.default = PressRecognizer;\r\nPressRecognizer.prototype.defaults = {\r\n  event: 'press',\r\n  pointers: 1,\r\n  time: 251,\r\n  // minimal time of the pointer to be pressed\r\n  threshold: 9 // a minimal movement is ok, but keep it low\r\n\r\n};","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _assign = _interopRequireDefault(require(\"./utils/assign\"));\r\n\r\nvar _hammer = _interopRequireDefault(require(\"./hammer\"));\r\n\r\nvar _touchactionConstructor = _interopRequireDefault(require(\"./touchactionjs/touchaction-constructor\"));\r\n\r\nvar _createInputInstance = _interopRequireDefault(require(\"./inputjs/create-input-instance\"));\r\n\r\nvar _each = _interopRequireDefault(require(\"./utils/each\"));\r\n\r\nvar _inArray = _interopRequireDefault(require(\"./utils/in-array\"));\r\n\r\nvar _invokeArrayArg = _interopRequireDefault(require(\"./utils/invoke-array-arg\"));\r\n\r\nvar _splitStr = _interopRequireDefault(require(\"./utils/split-str\"));\r\n\r\nvar _recognizerConstructor = _interopRequireDefault(require(\"./recognizerjs/recognizer-constructor\"));\r\n\r\nvar _recognizerConsts = require(\"./recognizerjs/recognizer-consts\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst STOP = 1;\r\nconst FORCED_STOP = 2;\r\n/**\r\n * @private\r\n * Manager\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\n\r\nclass Manager {\r\n  constructor(options) {\r\n    this.options = (0, _assign.default)({}, _hammer.default.defaults, options || {});\r\n    this.handlers = {};\r\n    this.filters = [];\r\n    this.session = {};\r\n    this.recognizers = [];\r\n    this.input = (0, _createInputInstance.default)(this);\r\n    this.touchAction = new _touchactionConstructor.default(this, this.options.touchAction);\r\n    (0, _each.default)(this.options.recognizers, item => {\r\n      let recognizer = this.add(new item[0](item[1]));\r\n      item[2] && recognizer.recognizeWith(item[2]);\r\n      item[3] && recognizer.requireFailure(item[3]);\r\n    }, this);\r\n  }\r\n  /**\r\n   * @private\r\n   * set options\r\n   * @param {Object} options\r\n   * @returns {Manager}\r\n   */\r\n\r\n\r\n  set(options) {\r\n    (0, _assign.default)(this.options, options); // Options that need a little more setup\r\n\r\n    if (options.touchAction) {\r\n      this.touchAction.update();\r\n    }\r\n\r\n    return this;\r\n  }\r\n  /**\r\n   * @private\r\n   * stop recognizing for this session.\r\n   * This session will be discarded, when a new [input]start event is fired.\r\n   * When forced, the recognizer cycle is stopped immediately.\r\n   * @param {Boolean} [force]\r\n   */\r\n\r\n\r\n  stop(force) {\r\n    this.session.stopped = force ? FORCED_STOP : STOP;\r\n  }\r\n  /**\r\n   * @private\r\n   * add event filters\r\n   */\r\n\r\n\r\n  addFilter(filter) {\r\n    if (typeof filter !== 'function') {\r\n      throw new Error('filter must be a function');\r\n    }\r\n\r\n    this.filters.push(filter);\r\n  }\r\n  /**\r\n   * @private\r\n   * run the recognizers!\r\n   * called by the inputHandler function on every movement of the pointers (touches)\r\n   * it walks through all the recognizers and tries to detect the gesture that is being made\r\n   * @param {Object} inputData\r\n   */\r\n\r\n\r\n  recognize(inputData) {\r\n    let {\r\n      session\r\n    } = this;\r\n\r\n    if (session.stopped) {\r\n      return;\r\n    } // run the touch-action polyfill\r\n\r\n\r\n    this.touchAction.preventDefaults(inputData);\r\n    let recognizer;\r\n    let {\r\n      recognizers\r\n    } = this; // this holds the recognizer that is being recognized.\r\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\r\n    // if no recognizer is detecting a thing, it is set to `null`\r\n\r\n    let {\r\n      curRecognizer\r\n    } = session; // reset when the last recognizer is recognized\r\n    // or when we're in a new session\r\n\r\n    if (!curRecognizer || curRecognizer && curRecognizer.state & _recognizerConsts.STATE_RECOGNIZED) {\r\n      curRecognizer = session.curRecognizer = null;\r\n    }\r\n\r\n    let i = 0;\r\n\r\n    while (i < recognizers.length) {\r\n      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\r\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\r\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\r\n      //      that is being recognized.\r\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\r\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\r\n\r\n      if (session.stopped !== FORCED_STOP && ( // 1\r\n      !curRecognizer || recognizer === curRecognizer || // 2\r\n      recognizer.canRecognizeWith(curRecognizer))) {\r\n        // 3\r\n        recognizer.recognize(inputData);\r\n      } else {\r\n        recognizer.reset();\r\n      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\r\n      // current active recognizer. but only if we don't already have an active recognizer\r\n\r\n\r\n      if (!curRecognizer && recognizer.state & (_recognizerConsts.STATE_BEGAN | _recognizerConsts.STATE_CHANGED | _recognizerConsts.STATE_ENDED)) {\r\n        curRecognizer = session.curRecognizer = recognizer;\r\n      }\r\n\r\n      i++;\r\n    }\r\n  }\r\n  /**\r\n   * @private\r\n   * get a recognizer by its event name.\r\n   * @param {Recognizer|String} recognizer\r\n   * @returns {Recognizer|Null}\r\n   */\r\n\r\n\r\n  get(recognizer) {\r\n    if (recognizer instanceof _recognizerConstructor.default) {\r\n      return recognizer;\r\n    }\r\n\r\n    let {\r\n      recognizers\r\n    } = this;\r\n\r\n    for (let i = 0; i < recognizers.length; i++) {\r\n      if (recognizers[i].options.event === recognizer) {\r\n        return recognizers[i];\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n  /**\r\n   * @private add a recognizer to the manager\r\n   * existing recognizers with the same event name will be removed\r\n   * @param {Recognizer} recognizer\r\n   * @returns {Recognizer|Manager}\r\n   */\r\n\r\n\r\n  add(recognizer) {\r\n    if ((0, _invokeArrayArg.default)(recognizer, 'add', this)) {\r\n      return this;\r\n    } // remove existing\r\n\r\n\r\n    let existing = this.get(recognizer.options.event);\r\n\r\n    if (existing) {\r\n      this.remove(existing);\r\n    }\r\n\r\n    this.recognizers.push(recognizer);\r\n    recognizer.manager = this;\r\n    this.touchAction.update();\r\n    return recognizer;\r\n  }\r\n  /**\r\n   * @private\r\n   * remove a recognizer by name or instance\r\n   * @param {Recognizer|String} recognizer\r\n   * @returns {Manager}\r\n   */\r\n\r\n\r\n  remove(recognizer) {\r\n    if ((0, _invokeArrayArg.default)(recognizer, 'remove', this)) {\r\n      return this;\r\n    }\r\n\r\n    recognizer = this.get(recognizer); // let's make sure this recognizer exists\r\n\r\n    if (recognizer) {\r\n      let {\r\n        recognizers\r\n      } = this;\r\n      let index = (0, _inArray.default)(recognizers, recognizer);\r\n\r\n      if (index !== -1) {\r\n        recognizers.splice(index, 1);\r\n        this.touchAction.update();\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n  /**\r\n   * @private\r\n   * bind event\r\n   * @param {String} events\r\n   * @param {Function} handler\r\n   * @returns {EventEmitter} this\r\n   */\r\n\r\n\r\n  on(events, handler) {\r\n    if (events === undefined) {\r\n      return;\r\n    }\r\n\r\n    if (handler === undefined) {\r\n      return;\r\n    }\r\n\r\n    let {\r\n      handlers\r\n    } = this;\r\n    (0, _each.default)((0, _splitStr.default)(events), event => {\r\n      handlers[event] = handlers[event] || [];\r\n      handlers[event].push(handler);\r\n    });\r\n    return this;\r\n  }\r\n  /**\r\n   * @private unbind event, leave emit blank to remove all handlers\r\n   * @param {String} events\r\n   * @param {Function} [handler]\r\n   * @returns {EventEmitter} this\r\n   */\r\n\r\n\r\n  off(events, handler) {\r\n    if (events === undefined) {\r\n      return;\r\n    }\r\n\r\n    let {\r\n      handlers\r\n    } = this;\r\n    (0, _each.default)((0, _splitStr.default)(events), event => {\r\n      if (!handler) {\r\n        delete handlers[event];\r\n      } else {\r\n        handlers[event] && handlers[event].splice((0, _inArray.default)(handlers[event], handler), 1);\r\n      }\r\n    });\r\n    return this;\r\n  }\r\n  /**\r\n   * @private emit event to the listeners\r\n   * @param {String} event\r\n   * @param {Object} data\r\n   */\r\n\r\n\r\n  emit(event, data) {\r\n    // no handlers, so skip it all\r\n    let handlers = this.handlers[event] && this.handlers[event].slice();\r\n    const {\r\n      filters\r\n    } = this;\r\n\r\n    if (!handlers || !handlers.length) {\r\n      return;\r\n    } //let i = 0;\r\n    //let newData = Object.assign(data);\r\n    //data.type = event;\r\n    //data.preventDefault = function() {\r\n    //  data.srcEvent.preventDefault();\r\n    //};\r\n    //while (i < filters.length) {\r\n    //  newData = filters[i](newData);\r\n    //  i++;\r\n    //}\r\n    //\r\n\r\n\r\n    if (!event.startsWith('origin_input')) {\r\n      data.type = event;\r\n\r\n      data.preventDefault = function () {\r\n        data.srcEvent.preventDefault && data.srcEvent.preventDefault();\r\n      };\r\n    }\r\n\r\n    let i = 0;\r\n\r\n    while (i < handlers.length) {\r\n      handlers[i](data);\r\n      i++;\r\n    }\r\n  }\r\n  /**\r\n   * @private\r\n   * destroy the manager and unbinds all events\r\n   * it doesn't unbind dom events, that is the user own responsibility\r\n   */\r\n\r\n\r\n  destroy() {\r\n    this.handlers = {};\r\n    this.filters = [];\r\n    this.session = {};\r\n    this.input.destroy();\r\n  }\r\n\r\n}\r\n\r\nexports.default = Manager;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _touchactionConsts = require(\"./touchaction-Consts\");\r\n\r\nvar _inputConsts = require(\"../inputjs/input-consts\");\r\n\r\nvar _each = _interopRequireDefault(require(\"../utils/each\"));\r\n\r\nvar _boolOrFn = _interopRequireDefault(require(\"../utils/bool-or-fn\"));\r\n\r\nvar _inStr = _interopRequireDefault(require(\"../utils/in-str\"));\r\n\r\nvar _cleanTouchActions = _interopRequireDefault(require(\"./clean-touch-actions\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * Touch Action\r\n * sets the touchAction property or uses the js alternative\r\n * @param {Manager} manager\r\n * @param {String} value\r\n * @constructor\r\n */\r\nclass TouchAction {\r\n  constructor(manager, value) {\r\n    this.manager = manager;\r\n    this.set(value);\r\n  }\r\n  /**\r\n   * @private\r\n   * set the touchAction value on the element or enable the polyfill\r\n   * @param {String} value\r\n   */\r\n\r\n\r\n  set(value) {\r\n    // find out the touch-action by the event handlers\r\n    if (value === _touchactionConsts.TOUCH_ACTION_COMPUTE) {\r\n      value = this.compute();\r\n    }\r\n\r\n    this.actions = value.toLowerCase().trim();\r\n  }\r\n  /**\r\n   * @private\r\n   * just re-set the touchAction value\r\n   */\r\n\r\n\r\n  update() {\r\n    this.set(this.manager.options.touchAction);\r\n  }\r\n  /**\r\n   * @private\r\n   * compute the value for the touchAction property based on the recognizer's settings\r\n   * @returns {String} value\r\n   */\r\n\r\n\r\n  compute() {\r\n    let actions = [];\r\n    (0, _each.default)(this.manager.recognizers, recognizer => {\r\n      if ((0, _boolOrFn.default)(recognizer.options.enable, [recognizer])) {\r\n        actions = actions.concat(recognizer.getTouchAction());\r\n      }\r\n    });\r\n    return (0, _cleanTouchActions.default)(actions.join(' '));\r\n  }\r\n  /**\r\n   * @private\r\n   * this method is called on each input cycle and provides the preventing of the browser behavior\r\n   * @param {Object} input\r\n   */\r\n\r\n\r\n  preventDefaults(input) {\r\n    let {\r\n      srcEvent\r\n    } = input;\r\n    let direction = input.offsetDirection; // if the touch action did prevented once this session\r\n\r\n    if (this.manager.session.prevented) {\r\n      srcEvent.preventDefault();\r\n      return;\r\n    }\r\n\r\n    let {\r\n      actions\r\n    } = this;\r\n    let hasNone = (0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_NONE) && !_touchactionConsts.TOUCH_ACTION_MAP[_touchactionConsts.TOUCH_ACTION_NONE];\r\n    let hasPanY = (0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_PAN_Y) && !_touchactionConsts.TOUCH_ACTION_MAP[_touchactionConsts.TOUCH_ACTION_PAN_Y];\r\n    let hasPanX = (0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_PAN_X) && !_touchactionConsts.TOUCH_ACTION_MAP[_touchactionConsts.TOUCH_ACTION_PAN_X];\r\n\r\n    if (hasNone) {\r\n      // do not prevent defaults if this is a tap gesture\r\n      let isTapPointer = input.pointers.length === 1;\r\n      let isTapMovement = input.distance < 2;\r\n      let isTapTouchTime = input.deltaTime < 250;\r\n\r\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (hasPanX && hasPanY) {\r\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\r\n      return;\r\n    }\r\n\r\n    if (hasNone || hasPanY && direction & _inputConsts.DIRECTION_HORIZONTAL || hasPanX && direction & _inputConsts.DIRECTION_VERTICAL) {\r\n      return this.preventSrc(srcEvent);\r\n    }\r\n  }\r\n  /**\r\n   * @private\r\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n   * @param {Object} srcEvent\r\n   */\r\n\r\n\r\n  preventSrc(srcEvent) {\r\n    this.manager.session.prevented = true;\r\n    srcEvent.preventDefault();\r\n  }\r\n\r\n}\r\n\r\nexports.default = TouchAction;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = inStr;\r\n\r\n/**\r\n * @private\r\n * small indexOf wrapper\r\n * @param {String} str\r\n * @param {String} find\r\n * @returns {Boolean} found\r\n */\r\nfunction inStr(str, find) {\r\n  return str.indexOf(find) > -1;\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = cleanTouchActions;\r\n\r\nvar _inStr = _interopRequireDefault(require(\"../utils/in-str\"));\r\n\r\nvar _touchactionConsts = require(\"./touchaction-Consts\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n * @param {String} actions\r\n * @returns {*}\r\n */\r\nfunction cleanTouchActions(actions) {\r\n  // none\r\n  if ((0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_NONE)) {\r\n    return _touchactionConsts.TOUCH_ACTION_NONE;\r\n  }\r\n\r\n  let hasPanX = (0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_PAN_X);\r\n  let hasPanY = (0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\r\n  // for different directions, e.g. horizontal pan but vertical swipe?)\r\n  // we need none (as otherwise with pan-x pan-y combined none of these\r\n  // recognizers will work, since the browser would handle all panning\r\n\r\n  if (hasPanX && hasPanY) {\r\n    return _touchactionConsts.TOUCH_ACTION_NONE;\r\n  } // pan-x OR pan-y\r\n\r\n\r\n  if (hasPanX || hasPanY) {\r\n    return hasPanX ? _touchactionConsts.TOUCH_ACTION_PAN_X : _touchactionConsts.TOUCH_ACTION_PAN_Y;\r\n  } // manipulation\r\n\r\n\r\n  if ((0, _inStr.default)(actions, _touchactionConsts.TOUCH_ACTION_MANIPULATION)) {\r\n    return _touchactionConsts.TOUCH_ACTION_MANIPULATION;\r\n  }\r\n\r\n  return _touchactionConsts.TOUCH_ACTION_AUTO;\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = createInputInstance;\r\n\r\nvar _inputHandler = _interopRequireDefault(require(\"./input-handler\"));\r\n\r\nvar _touch = _interopRequireDefault(require(\"../input/touch\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * create new input type manager\r\n * called by the Manager constructor\r\n * @param {Hammer} manager\r\n * @returns {Input}\r\n */\r\nfunction createInputInstance(manager) {\r\n  let Type = _touch.default;\r\n\r\n  if (manager.options.inputClass) {\r\n    Type = inputClass;\r\n  }\r\n\r\n  return new Type(manager, _inputHandler.default);\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = inputHandler;\r\n\r\nvar _inputConsts = require(\"./input-consts\");\r\n\r\nvar _computeInputData = _interopRequireDefault(require(\"./compute-input-data\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * handle input events\r\n * @param {Manager} manager\r\n * @param {String} eventType\r\n * @param {Object} input\r\n */\r\nfunction inputHandler(manager, eventType, input) {\r\n  let pointersLen = input.pointers.length;\r\n  let changedPointersLen = input.changedPointers.length;\r\n  let isFirst = eventType & _inputConsts.INPUT_START && pointersLen - changedPointersLen === 0;\r\n  let isFinal = eventType & (_inputConsts.INPUT_END | _inputConsts.INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\r\n  input.isFirst = !!isFirst;\r\n  input.isFinal = !!isFinal;\r\n\r\n  if (isFirst) {\r\n    manager.session = {};\r\n  } // source event is the normalized value of the domEvents\r\n  // like 'touchstart, mouseup, pointerdown'\r\n\r\n\r\n  input.eventType = eventType; // compute scale, rotation etc\r\n\r\n  (0, _computeInputData.default)(manager, input); // emit secret event\r\n\r\n  manager.emit('hammer.input', input);\r\n  manager.recognize(input);\r\n  manager.session.prevInput = input;\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = computeInputData;\r\n\r\nvar _utilsConsts = require(\"../utils/utils-consts\");\r\n\r\nvar _hasParent = _interopRequireDefault(require(\"../utils/has-parent\"));\r\n\r\nvar _simpleCloneInputData = _interopRequireDefault(require(\"./simple-clone-input-data\"));\r\n\r\nvar _getCenter = _interopRequireDefault(require(\"./get-center\"));\r\n\r\nvar _getDistance = _interopRequireDefault(require(\"./get-distance\"));\r\n\r\nvar _getAngle = _interopRequireDefault(require(\"./get-angle\"));\r\n\r\nvar _getDirection = _interopRequireDefault(require(\"./get-direction\"));\r\n\r\nvar _computeDeltaXy = _interopRequireDefault(require(\"./compute-delta-xy\"));\r\n\r\nvar _getVelocity = _interopRequireDefault(require(\"./get-velocity\"));\r\n\r\nvar _getScale = _interopRequireDefault(require(\"./get-scale\"));\r\n\r\nvar _getRotation = _interopRequireDefault(require(\"./get-rotation\"));\r\n\r\nvar _computeIntervalInputData = _interopRequireDefault(require(\"./compute-interval-input-data\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * extend the data with some usable properties like scale, rotate, velocity etc\r\n * @param {Object} manager\r\n * @param {Object} input\r\n */\r\nfunction computeInputData(manager, input) {\r\n  let {\r\n    session\r\n  } = manager;\r\n  let {\r\n    pointers\r\n  } = input;\r\n  let {\r\n    length: pointersLength\r\n  } = pointers; // store the first input to calculate the distance and direction\r\n\r\n  if (!session.firstInput) {\r\n    session.firstInput = (0, _simpleCloneInputData.default)(input);\r\n  } // to compute scale and rotation we need to store the multiple touches\r\n\r\n\r\n  if (pointersLength > 1 && !session.firstMultiple) {\r\n    session.firstMultiple = (0, _simpleCloneInputData.default)(input);\r\n  } else if (pointersLength === 1) {\r\n    session.firstMultiple = false;\r\n  }\r\n\r\n  let {\r\n    firstInput,\r\n    firstMultiple\r\n  } = session;\r\n  let offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\r\n  let center = input.center = (0, _getCenter.default)(pointers);\r\n  input.timeStamp = (0, _utilsConsts.now)();\r\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\r\n  input.angle = (0, _getAngle.default)(offsetCenter, center);\r\n  input.distance = (0, _getDistance.default)(offsetCenter, center);\r\n  (0, _computeDeltaXy.default)(session, input);\r\n  input.offsetDirection = (0, _getDirection.default)(input.deltaX, input.deltaY);\r\n  let overallVelocity = (0, _getVelocity.default)(input.deltaTime, input.deltaX, input.deltaY);\r\n  input.overallVelocityX = overallVelocity.x;\r\n  input.overallVelocityY = overallVelocity.y;\r\n  input.overallVelocity = (0, _utilsConsts.abs)(overallVelocity.x) > (0, _utilsConsts.abs)(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\r\n  input.scale = firstMultiple ? (0, _getScale.default)(firstMultiple.pointers, pointers) : 1;\r\n  input.rotation = firstMultiple ? (0, _getRotation.default)(firstMultiple.pointers, pointers) : 0;\r\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\r\n  (0, _computeIntervalInputData.default)(session, input);\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = hasParent;\r\n\r\n/**\r\n * @private\r\n * find if a node is in the given parent\r\n * @method hasParent\r\n * @param {HTMLElement} node\r\n * @param {HTMLElement} parent\r\n * @return {Boolean} found\r\n */\r\nfunction hasParent(node, parent) {\r\n  while (node) {\r\n    if (node === parent) {\r\n      return true;\r\n    }\r\n\r\n    node = node.parentNode;\r\n  }\r\n\r\n  return false;\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = simpleCloneInputData;\r\n\r\nvar _utilsConsts = require(\"../utils/utils-consts\");\r\n\r\nvar _getCenter = _interopRequireDefault(require(\"./get-center\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n * @param {Object} input\r\n * @returns {Object} clonedInputData\r\n */\r\nfunction simpleCloneInputData(input) {\r\n  // make a simple copy of the pointers because we will get a reference if we don't\r\n  // we only need clientXY for the calculations\r\n  let pointers = [];\r\n  let i = 0;\r\n\r\n  while (i < input.pointers.length) {\r\n    pointers[i] = {\r\n      clientX: (0, _utilsConsts.round)(input.pointers[i].clientX),\r\n      clientY: (0, _utilsConsts.round)(input.pointers[i].clientY)\r\n    };\r\n    i++;\r\n  }\r\n\r\n  return {\r\n    timeStamp: (0, _utilsConsts.now)(),\r\n    pointers,\r\n    center: (0, _getCenter.default)(pointers),\r\n    deltaX: input.deltaX,\r\n    deltaY: input.deltaY\r\n  };\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = getCenter;\r\n\r\nvar _utilsConsts = require(\"../utils/utils-consts\");\r\n\r\n/**\r\n * @private\r\n * get the center of all the pointers\r\n * @param {Array} pointers\r\n * @return {Object} center contains `x` and `y` properties\r\n */\r\nfunction getCenter(pointers) {\r\n  let pointersLength = pointers.length; // no need to loop when only one touch\r\n\r\n  if (pointersLength === 1) {\r\n    return {\r\n      x: (0, _utilsConsts.round)(pointers[0].clientX),\r\n      y: (0, _utilsConsts.round)(pointers[0].clientY)\r\n    };\r\n  }\r\n\r\n  let x = 0;\r\n  let y = 0;\r\n  let i = 0;\r\n\r\n  while (i < pointersLength) {\r\n    x += pointers[i].clientX;\r\n    y += pointers[i].clientY;\r\n    i++;\r\n  }\r\n\r\n  return {\r\n    x: (0, _utilsConsts.round)(x / pointersLength),\r\n    y: (0, _utilsConsts.round)(y / pointersLength)\r\n  };\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = getAngle;\r\n\r\nvar _inputConsts = require(\"./input-consts\");\r\n\r\n/**\r\n * @private\r\n * calculate the angle between two coordinates\r\n * @param {Object} p1\r\n * @param {Object} p2\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} angle\r\n */\r\nfunction getAngle(p1, p2, props) {\r\n  if (!props) {\r\n    props = _inputConsts.PROPS_XY;\r\n  }\r\n\r\n  let x = p2[props[0]] - p1[props[0]];\r\n  let y = p2[props[1]] - p1[props[1]];\r\n  return Math.atan2(y, x) * 180 / Math.PI;\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = getDirection;\r\n\r\nvar _utilsConsts = require(\"../utils/utils-consts\");\r\n\r\nvar _inputConsts = require(\"./input-consts\");\r\n\r\n/**\r\n * @private\r\n * get the direction between two points\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Number} direction\r\n */\r\nfunction getDirection(x, y) {\r\n  if (x === y) {\r\n    return _inputConsts.DIRECTION_NONE;\r\n  }\r\n\r\n  if ((0, _utilsConsts.abs)(x) >= (0, _utilsConsts.abs)(y)) {\r\n    return x < 0 ? _inputConsts.DIRECTION_LEFT : _inputConsts.DIRECTION_RIGHT;\r\n  }\r\n\r\n  return y < 0 ? _inputConsts.DIRECTION_UP : _inputConsts.DIRECTION_DOWN;\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = computeDeltaXY;\r\n\r\nvar _inputConsts = require(\"./input-consts\");\r\n\r\nfunction computeDeltaXY(session, input) {\r\n  let {\r\n    center\r\n  } = input; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\r\n  // jscs throwing error on defalut destructured values and without defaults tests fail\r\n\r\n  let offset = session.offsetDelta || {};\r\n  let prevDelta = session.prevDelta || {};\r\n  let prevInput = session.prevInput || {};\r\n\r\n  if (input.eventType === _inputConsts.INPUT_START || prevInput.eventType === _inputConsts.INPUT_END) {\r\n    prevDelta = session.prevDelta = {\r\n      x: prevInput.deltaX || 0,\r\n      y: prevInput.deltaY || 0\r\n    };\r\n    offset = session.offsetDelta = {\r\n      x: center.x,\r\n      y: center.y\r\n    };\r\n  }\r\n\r\n  input.deltaX = prevDelta.x + (center.x - offset.x);\r\n  input.deltaY = prevDelta.y + (center.y - offset.y);\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = getVelocity;\r\n\r\n/**\r\n * @private\r\n * calculate the velocity between two points. unit is in px per ms.\r\n * @param {Number} deltaTime\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Object} velocity `x` and `y`\r\n */\r\nfunction getVelocity(deltaTime, x, y) {\r\n  return {\r\n    x: x / deltaTime || 0,\r\n    y: y / deltaTime || 0\r\n  };\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = getScale;\r\n\r\nvar _inputConsts = require(\"./input-consts\");\r\n\r\nvar _getDistance = _interopRequireDefault(require(\"./get-distance\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * calculate the scale factor between two pointersets\r\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} scale\r\n */\r\nfunction getScale(start, end) {\r\n  return (0, _getDistance.default)(end[0], end[1], _inputConsts.PROPS_CLIENT_XY) / (0, _getDistance.default)(start[0], start[1], _inputConsts.PROPS_CLIENT_XY);\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = getRotation;\r\n\r\nvar _getAngle = _interopRequireDefault(require(\"./get-angle\"));\r\n\r\nvar _inputConsts = require(\"./input-consts\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * calculate the rotation degrees between two pointersets\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} rotation\r\n */\r\nfunction getRotation(start, end) {\r\n  return (0, _getAngle.default)(end[1], end[0], _inputConsts.PROPS_CLIENT_XY) + (0, _getAngle.default)(start[1], start[0], _inputConsts.PROPS_CLIENT_XY);\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = computeIntervalInputData;\r\n\r\nvar _inputConsts = require(\"./input-consts\");\r\n\r\nvar _utilsConsts = require(\"../utils/utils-consts\");\r\n\r\nvar _getVelocity = _interopRequireDefault(require(\"./get-velocity\"));\r\n\r\nvar _getDirection = _interopRequireDefault(require(\"./get-direction\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * velocity is calculated every x ms\r\n * @param {Object} session\r\n * @param {Object} input\r\n */\r\nfunction computeIntervalInputData(session, input) {\r\n  let last = session.lastInterval || input;\r\n  let deltaTime = input.timeStamp - last.timeStamp;\r\n  let velocity;\r\n  let velocityX;\r\n  let velocityY;\r\n  let direction;\r\n\r\n  if (input.eventType !== _inputConsts.INPUT_CANCEL && (deltaTime > _inputConsts.COMPUTE_INTERVAL || last.velocity === undefined)) {\r\n    let deltaX = input.deltaX - last.deltaX;\r\n    let deltaY = input.deltaY - last.deltaY;\r\n    let v = (0, _getVelocity.default)(deltaTime, deltaX, deltaY);\r\n    velocityX = v.x;\r\n    velocityY = v.y;\r\n    velocity = (0, _utilsConsts.abs)(v.x) > (0, _utilsConsts.abs)(v.y) ? v.x : v.y;\r\n    direction = (0, _getDirection.default)(deltaX, deltaY);\r\n    session.lastInterval = input;\r\n  } else {\r\n    // use latest velocity info if it doesn't overtake a minimum period\r\n    velocity = last.velocity;\r\n    velocityX = last.velocityX;\r\n    velocityY = last.velocityY;\r\n    direction = last.direction;\r\n  }\r\n\r\n  input.velocity = velocity;\r\n  input.velocityX = velocityX;\r\n  input.velocityY = velocityY;\r\n  input.direction = direction;\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _inputConsts = require(\"../inputjs/input-consts\");\r\n\r\nvar _inputConstructor = _interopRequireDefault(require(\"../inputjs/input-constructor\"));\r\n\r\nvar _toArray = _interopRequireDefault(require(\"../utils/to-array\"));\r\n\r\nvar _hasParent = _interopRequireDefault(require(\"../utils/has-parent\"));\r\n\r\nvar _uniqueArray = _interopRequireDefault(require(\"../utils/unique-array\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst TOUCH_INPUT_MAP = {\r\n  touchstart: _inputConsts.INPUT_START,\r\n  touchmove: _inputConsts.INPUT_MOVE,\r\n  touchend: _inputConsts.INPUT_END,\r\n  touchcancel: _inputConsts.INPUT_CANCEL\r\n};\r\nconst TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n/**\r\n * @private\r\n * Multi-user touch events input\r\n * @constructor\r\n * @extends Input\r\n */\r\n\r\nclass TouchInput extends _inputConstructor.default {\r\n  constructor() {\r\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\r\n    TouchInput.prototype.targetIds = {};\r\n    TouchInput.prototype.events = TOUCH_TARGET_EVENTS;\r\n    super(...arguments);\r\n    this.evTarget = TOUCH_TARGET_EVENTS;\r\n    this.targetIds = {};\r\n  }\r\n\r\n  handler(ev) {\r\n    let type = TOUCH_INPUT_MAP[ev.type];\r\n    let touches = getTouches.call(this, ev, type);\r\n\r\n    if (!touches) {\r\n      return;\r\n    }\r\n\r\n    this.callback(this.manager, type, {\r\n      pointers: touches[0],\r\n      changedPointers: touches[1],\r\n      pointerType: _inputConsts.INPUT_TYPE_TOUCH,\r\n      srcEvent: ev\r\n    });\r\n  }\r\n\r\n}\r\n/**\r\n * @private\r\n * @this {TouchInput}\r\n * @param {Object} ev\r\n * @param {Number} type flag\r\n * @returns {undefined|Array} [all, changed]\r\n */\r\n\r\n\r\nexports.default = TouchInput;\r\n\r\nfunction getTouches(ev, type) {\r\n  let allTouches = (0, _toArray.default)(ev.touches);\r\n  let {\r\n    targetIds\r\n  } = this; // when there is only one touch, the process can be simplified\r\n\r\n  if (type & (_inputConsts.INPUT_START | _inputConsts.INPUT_MOVE) && allTouches.length === 1) {\r\n    targetIds[allTouches[0].identifier] = true;\r\n    return [allTouches, allTouches];\r\n  }\r\n\r\n  let i;\r\n  let targetTouches;\r\n  let changedTouches = (0, _toArray.default)(ev.changedTouches);\r\n  let changedTargetTouches = [];\r\n  let {\r\n    target\r\n  } = this; //// get target touches from touches targets\r\n  //targetTouches = allTouches.filter((touch) => {\r\n  //  return hasParent(touch.target, target);\r\n  //});\r\n\r\n  targetTouches = allTouches; // collect touches\r\n\r\n  if (type === _inputConsts.INPUT_START) {\r\n    i = 0;\r\n\r\n    while (i < targetTouches.length) {\r\n      targetIds[targetTouches[i].identifier] = true;\r\n      i++;\r\n    }\r\n  } // filter changed touches to only contain touches that exist in the collected target ids\r\n\r\n\r\n  i = 0;\r\n\r\n  while (i < changedTouches.length) {\r\n    if (targetIds[changedTouches[i].identifier]) {\r\n      changedTargetTouches.push(changedTouches[i]);\r\n    } // cleanup removed touches\r\n\r\n\r\n    if (type & (_inputConsts.INPUT_END | _inputConsts.INPUT_CANCEL)) {\r\n      delete targetIds[changedTouches[i].identifier];\r\n    }\r\n\r\n    i++;\r\n  }\r\n\r\n  if (!changedTargetTouches.length) {\r\n    return;\r\n  }\r\n\r\n  return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\r\n  (0, _uniqueArray.default)(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _boolOrFn = _interopRequireDefault(require(\"../utils/bool-or-fn\"));\r\n\r\nvar _addEventListeners = require(\"../utils/add-event-listeners\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * create new input type manager\r\n * @param {Manager} manager\r\n * @param {Function} callback\r\n * @returns {Input}\r\n * @constructor\r\n */\r\nclass Input {\r\n  constructor(manager, callback) {\r\n    let self = this;\r\n    this.manager = manager;\r\n    this.callback = callback; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\r\n    // so when disabled the input events are completely bypassed.\r\n\r\n    this.eventHandler = function (ev) {\r\n      if ((0, _boolOrFn.default)(manager.options.enable, [manager])) {\r\n        self.handler(ev);\r\n      }\r\n    };\r\n\r\n    this.init();\r\n  }\r\n  /**\r\n   * @private\r\n   * should handle the inputEvent data and trigger the callback\r\n   * @virtual\r\n   */\r\n\r\n\r\n  handler() {}\r\n  /**\r\n   * @private\r\n   */\r\n\r\n\r\n  init() {\r\n    (0, _addEventListeners.addManagerListeners)(this.manager, this.events || '', this.eventHandler);\r\n  }\r\n  /**\r\n   * @private\r\n   */\r\n\r\n\r\n  destroy() {\r\n    removeManagerListeners(this.manager, this.events || '', this.eventHandler);\r\n  }\r\n\r\n}\r\n\r\nexports.default = Input;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = addEventListeners;\r\nexports.addManagerListeners = addManagerListeners;\r\n\r\nvar _each = _interopRequireDefault(require(\"./each\"));\r\n\r\nvar _splitStr = _interopRequireDefault(require(\"./split-str\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * addEventListener with multiple events at once\r\n * @param {EventTarget} target\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nfunction addEventListeners(target, types, handler) {\r\n  (0, _each.default)((0, _splitStr.default)(types), type => {\r\n    target.addEventListener(type, handler, false);\r\n  });\r\n}\r\n\r\nfunction addManagerListeners(manager, types, handler) {\r\n  (0, _each.default)((0, _splitStr.default)(types), type => {\r\n    manager.on(`origin_input:${type}`, handler);\r\n  });\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = splitStr;\r\n\r\n/**\r\n * @private\r\n * split string on whitespace\r\n * @param {String} str\r\n * @returns {Array} words\r\n */\r\nfunction splitStr(str) {\r\n  return str.trim().split(/\\s+/g);\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = toArray;\r\n\r\n/**\r\n * @private\r\n * convert array-like objects to real arrays\r\n * @param {Object} obj\r\n * @returns {Array}\r\n */\r\nfunction toArray(obj) {\r\n  return Array.prototype.slice.call(obj, 0);\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = uniqueArray;\r\n\r\nvar _inArray = _interopRequireDefault(require(\"./in-array\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * unique array with objects based on a key (like 'id') or just by the array's value\r\n * @param {Array} src [{id:1},{id:2},{id:1}]\r\n * @param {String} [key]\r\n * @param {Boolean} [sort=False]\r\n * @returns {Array} [{id:1},{id:2}]\r\n */\r\nfunction uniqueArray(src, key, sort) {\r\n  let results = [];\r\n  let values = [];\r\n  let i = 0;\r\n\r\n  while (i < src.length) {\r\n    let val = key ? src[i][key] : src[i];\r\n\r\n    if ((0, _inArray.default)(values, val) < 0) {\r\n      results.push(src[i]);\r\n    }\r\n\r\n    values[i] = val;\r\n    i++;\r\n  }\r\n\r\n  if (sort) {\r\n    if (!key) {\r\n      results = results.sort();\r\n    } else {\r\n      results = results.sort((a, b) => {\r\n        return a[key] > b[key];\r\n      });\r\n    }\r\n  }\r\n\r\n  return results;\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _inputConsts = require(\"../inputjs/input-consts\");\r\n\r\nvar _inputConstructor = _interopRequireDefault(require(\"../inputjs/input-constructor\"));\r\n\r\nvar _inArray = _interopRequireDefault(require(\"../utils/in-array\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nconst POINTER_INPUT_MAP = {\r\n  pointerdown: _inputConsts.INPUT_START,\r\n  pointermove: _inputConsts.INPUT_MOVE,\r\n  pointerup: _inputConsts.INPUT_END,\r\n  pointercancel: _inputConsts.INPUT_CANCEL,\r\n  pointerout: _inputConsts.INPUT_CANCEL\r\n}; // in IE10 the pointer types is defined as an enum\r\n\r\nconst IE10_POINTER_TYPE_ENUM = {\r\n  2: _inputConsts.INPUT_TYPE_TOUCH,\r\n  3: _inputConsts.INPUT_TYPE_PEN,\r\n  4: _inputConsts.INPUT_TYPE_MOUSE,\r\n  5: _inputConsts.INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\r\n\r\n};\r\nlet POINTER_ELEMENT_EVENTS = 'pointerdown';\r\nlet POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\r\n/**\r\n * @private\r\n * Pointer events input\r\n * @constructor\r\n * @extends Input\r\n */\r\n\r\nclass PointerEventInput extends _inputConstructor.default {\r\n  constructor() {\r\n    PointerEventInput.prototype.events = `${POINTER_ELEMENT_EVENTS} ${POINTER_WINDOW_EVENTS}`;\r\n    super(...arguments);\r\n    this.evEl = POINTER_ELEMENT_EVENTS;\r\n    this.evWin = POINTER_WINDOW_EVENTS;\r\n    this.store = this.manager.session.pointerEvents = [];\r\n  }\r\n  /**\r\n   * @private\r\n   * handle mouse events\r\n   * @param {Object} ev\r\n   */\r\n\r\n\r\n  handler(ev) {\r\n    let {\r\n      store\r\n    } = this;\r\n    let removePointer = false;\r\n    let eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\r\n    let eventType = POINTER_INPUT_MAP[eventTypeNormalized];\r\n    let pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\r\n    let isTouch = pointerType === _inputConsts.INPUT_TYPE_TOUCH; // get index of the event in the store\r\n\r\n    let storeIndex = (0, _inArray.default)(store, ev.pointerId, 'pointerId'); // start and mouse must be down\r\n\r\n    if (eventType & _inputConsts.INPUT_START && (ev.button === 0 || isTouch)) {\r\n      if (storeIndex < 0) {\r\n        store.push(ev);\r\n        storeIndex = store.length - 1;\r\n      }\r\n    } else if (eventType & (_inputConsts.INPUT_END | _inputConsts.INPUT_CANCEL)) {\r\n      removePointer = true;\r\n    } // it not found, so the pointer hasn't been down (so it's probably a hover)\r\n\r\n\r\n    if (storeIndex < 0) {\r\n      return;\r\n    } // update the event in the store\r\n\r\n\r\n    store[storeIndex] = ev;\r\n    this.callback(this.manager, eventType, {\r\n      pointers: store,\r\n      changedPointers: [ev],\r\n      pointerType,\r\n      srcEvent: ev\r\n    });\r\n\r\n    if (removePointer) {\r\n      // remove from the store\r\n      store.splice(storeIndex, 1);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexports.default = PointerEventInput;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = removeEventListeners;\r\nexports.removeManagerListeners = removeManagerListeners;\r\n\r\nvar _each = _interopRequireDefault(require(\"./each\"));\r\n\r\nvar _splitStr = _interopRequireDefault(require(\"./split-str\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * removeEventListener with multiple events at once\r\n * @param {EventTarget} target\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nfunction removeEventListeners(target, types, handler) {\r\n  (0, _each.default)((0, _splitStr.default)(types), type => {\r\n    target.removeEventListener(type, handler, false);\r\n  });\r\n}\r\n\r\nfunction removeManagerListeners(manager, types, handler) {\r\n  (0, _each.default)((0, _splitStr.default)(types), type => {\r\n    manager.off(`origin_input:${type}`, handler);\r\n  });\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _deprecate = _interopRequireDefault(require(\"./deprecate\"));\r\n\r\nvar _extend = _interopRequireDefault(require(\"./extend\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * merge the values from src in the dest.\r\n * means that properties that exist in dest will not be overwritten by src\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @returns {Object} dest\r\n */\r\nconst merge = (0, _deprecate.default)((dest, src) => {\r\n  return (0, _extend.default)(dest, src, true);\r\n}, 'merge', 'Use `assign`.');\r\nvar _default = merge;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = deprecate;\r\n\r\n/**\r\n * @private\r\n * wrap a method with a deprecation warning and stack trace\r\n * @param {Function} method\r\n * @param {String} name\r\n * @param {String} message\r\n * @returns {Function} A new function wrapping the supplied method.\r\n */\r\nfunction deprecate(method, name, message) {\r\n  let deprecationMessage = `DEPRECATED METHOD: ${name}\\n${message} AT \\n`;\r\n  return function () {\r\n    let e = new Error('get-stack-trace');\r\n    let stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\r\n    let log = console.warn;\r\n\r\n    if (log) {\r\n      log(deprecationMessage, stack);\r\n    }\r\n\r\n    return method.apply(this, arguments);\r\n  };\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _deprecate = _interopRequireDefault(require(\"./deprecate\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * extend object.\r\n * means that properties in dest will be overwritten by the ones in src.\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @param {Boolean} [merge=false]\r\n * @returns {Object} dest\r\n */\r\nconst extend = (0, _deprecate.default)((dest, src, merge) => {\r\n  let keys = Object.keys(src);\r\n  let i = 0;\r\n\r\n  while (i < keys.length) {\r\n    if (!merge || merge && dest[keys[i]] === undefined) {\r\n      dest[keys[i]] = src[keys[i]];\r\n    }\r\n\r\n    i++;\r\n  }\r\n\r\n  return dest;\r\n}, 'extend', 'Use `assign`.');\r\nvar _default = extend;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = inherit;\r\n\r\nvar _assign = _interopRequireDefault(require(\"./assign\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @private\r\n * simple class inheritance\r\n * @param {Function} child\r\n * @param {Function} base\r\n * @param {Object} [properties]\r\n */\r\nfunction inherit(child, base, properties) {\r\n  let baseP = base.prototype;\r\n  let childP;\r\n  childP = child.prototype = Object.create(baseP);\r\n  childP.constructor = child;\r\n  childP._super = baseP;\r\n\r\n  if (properties) {\r\n    (0, _assign.default)(childP, properties);\r\n  }\r\n}"]}