{"version":3,"sources":["index.js","util/path.js","types.js","interfaces.js","event/graph-event.js","abstract/base.js","util/util.js","abstract/canvas.js","abstract/container.js","abstract/element.js","util/matrix.js","animate/timeline.js","animate/register.js","util/color.js","event/event-contoller.js","abstract/group.js","abstract/shape.js","bbox/index.js","bbox/register.js","bbox/rect.js","bbox/circle.js","bbox/polyline.js","bbox/util.js","bbox/polygon.js","bbox/text.js","util/text.js","util/offscreen.js","bbox/path.js","bbox/line.js","bbox/ellipse.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;AGRA,AJYA,ACHA;AGRA,AJYA,ACHA;AGRA,AJYA,ACHA;AIXA,ADGA,AJYA,ACHA;AIXA,ADGA,AJYA,ACHA;AIXA,ADGA,AJYA,ACHA;AIXA,ADGA,AJYA,ACHA,AKfA;ADIA,ADGA,AJYA,ACHA,AKfA;ADIA,ADGA,AJYA,ACHA,AKfA;ADIA,AENA,AHSA,AJYA,ACHA,AKfA;ADIA,AENA,AHSA,AJYA,ACHA,AKfA;ADIA,AENA,AHSA,AJYA,ACHA,AKfA;ADIA,AENA,ACHA,AJYA,AJYA,ACHA,AKfA;ADIA,AENA,ACHA,AJYA,AJYA,ACHA,AKfA;ADIA,AENA,ACHA,AJYA,AJYA,ACHA,AKfA;ADIA,AENA,ACHA,ACHA,ALeA,AJYA,ACHA,AKfA;ADIA,AENA,ACHA,ACHA,ALeA,AJYA,ACHA,AKfA;ADIA,AENA,ACHA,ACHA,ALeA,AJYA,ACHA,AKfA;ADIA,AENA,ACHA,ACHA,ALeA,AJYA,AU9BA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,ALeA,AJYA,AU9BA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,ALeA,AJYA,AU9BA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AENA,APqBA,AJYA,AU9BA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AENA,APqBA,AJYA,AU9BA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AENA,APqBA,AJYA,AU9BA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AGTA,ADGA,APqBA,AJYA,AU9BA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AGTA,ADGA,APqBA,AJYA,AU9BA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AGTA,ADGA,APqBA,AJYA,AU9BA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AGTA,ADGA,APqBA,AS3BA,AHSA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AGTA,ADGA,APqBA,AS3BA,AHSA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AGTA,ADGA,APqBA,AS3BA,AHSA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AGTA,ADGA,AGTA,AV8BA,AS3BA,AHSA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AGTA,ADGA,AGTA,AV8BA,AS3BA,AHSA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AGTA,ADGA,AGTA,AV8BA,AS3BA,AHSA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AMlBA,AHSA,ADGA,AGTA,AV8BA,AMlBA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AMlBA,AHSA,ADGA,AGTA,AV8BA,AMlBA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AMlBA,AHSA,ADGA,AGTA,AV8BA,AMlBA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AMlBA,ACHA,AJYA,ADGA,AGTA,AV8BA,AMlBA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AMlBA,ACHA,AJYA,ADGA,AGTA,AV8BA,AMlBA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AMlBA,ACHA,AJYA,ADGA,AGTA,AV8BA,AMlBA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AMlBA,ACHA,AJYA,ADGA,AMlBA,AHSA,AV8BA,AMlBA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AMlBA,ACHA,AJYA,ADGA,AMlBA,AHSA,AV8BA,AMlBA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AMlBA,ACHA,AJYA,ADGA,AMlBA,AHSA,AV8BA,AMlBA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AMlBA,ACHA,AJYA,ADGA,AMlBA,ACHA,AJYA,AV8BA,AMlBA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AMlBA,ACHA,AJYA,ADGA,AMlBA,ACHA,AJYA,AV8BA,AMlBA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AMlBA,ACHA,AJYA,ADGA,AMlBA,ACHA,AJYA,AV8BA,AMlBA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AMlBA,ACHA,AJYA,ADGA,AMlBA,AENA,ADGA,AJYA,AV8BA,AMlBA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AMlBA,ACHA,AJYA,ADGA,AMlBA,AENA,ADGA,AJYA,AV8BA,AMlBA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AMlBA,ACHA,AJYA,ADGA,AMlBA,AENA,ADGA,AJYA,AV8BA,AMlBA,AT2BA,AKfA;ADIA,AENA,ACHA,ACHA,AMlBA,ACHA,ALeA,AS3BA,AHSA,AENA,ADGA,AJYA,AV8BA,AMlBA,AT2BA,AKfA;ACFA,ACHA,ACHA,AMlBA,ACHA,ALeA,AS3BA,AHSA,AENA,ADGA,AJYA,AV8BA,AMlBA,AT2BA,AKfA;ACFA,ACHA,ACHA,AMlBA,ACHA,ALeA,AS3BA,AHSA,AENA,ADGA,AJYA,AV8BA,AMlBA,AT2BA;AMjBA,ACHA,ACHA,AMlBA,ACHA,ALeA,AS3BA,AHSA,AIZA,AFMA,ADGA,AJYA,AV8BA,AMlBA,AT2BA;AMjBA,ACHA,ACHA,AMlBA,ACHA,ALeA,AS3BA,AHSA,AIZA,AFMA,ADGA,AJYA,AV8BA,AMlBA,AT2BA;AMjBA,ACHA,ACHA,AMlBA,ACHA,ALeA,AS3BA,AHSA,AIZA,AFMA,ADGA,AJYA,AV8BA,AMlBA,AT2BA;AMjBA,ACHA,ACHA,AMlBA,ACHA,ALeA,AS3BA,AHSA,AIZA,AFMA,ADGA,AIZA,ARwBA,AV8BA,AMlBA,AT2BA;AMjBA,ACHA,ACHA,AMlBA,ACHA,ALeA,AS3BA,AHSA,AIZA,AFMA,ADGA,AIZA,ARwBA,AV8BA,AMlBA,AT2BA;AMjBA,ACHA,ACHA,AMlBA,ACHA,ALeA,AS3BA,AHSA,AIZA,AFMA,ADGA,AIZA,ARwBA,AV8BA,AMlBA,AT2BA;AMjBA,ACHA,ACHA,AMlBA,ACHA,ALeA,AS3BA,AHSA,AMlBA,AFMA,AFMA,ADGA,AIZA,ARwBA,AV8BA,AMlBA,AT2BA;AMjBA,ACHA,ACHA,AMlBA,ACHA,ALeA,AS3BA,AHSA,AMlBA,AFMA,AFMA,ADGA,AIZA,ARwBA,AV8BA,AMlBA,AT2BA;AMjBA,ACHA,ACHA,AMlBA,ACHA,ALeA,AS3BA,AHSA,AMlBA,AFMA,AHSA,AIZA,ARwBA,AV8BA,AMlBA,AT2BA;AMjBA,ACHA,ACHA,AMlBA,ACHA,ALeA,AS3BA,AHSA,AMlBA,AFMA,AHSA,AMlBA,AFMA,ARwBA,AV8BA,AMlBA,AT2BA;AMjBA,ACHA,ACHA,AMlBA,ACHA,ALeA,AMlBA,AMlBA,AFMA,AHSA,AMlBA,AFMA,ARwBA,AV8BA,AMlBA,AT2BA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AMlBA,AMlBA,AFMA,AHSA,AMlBA,AFMA,ARwBA,AV8BA,AMlBA,AT2BA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AMlBA,AMlBA,AFMA,AHSA,AMlBA,AFMA,ARwBA,AV8BA,AMlBA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AYpCA,AFMA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AYpCA,AFMA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AYpCA,AFMA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AgBhDA,AzB2EA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AYpCA,AFMA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AgBhDA,AzB2EA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AYpCA,AFMA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AgBhDA,AzB2EA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AJYA,AFMA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AgBhDA,AzB2EA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AJYA,AFMA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AgBhDA,AzB2EA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AJYA,AFMA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AgBhDA,AzB2EA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AiBnDA,ADGA,AJYA,AFMA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AgBhDA,AzB2EA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AiBnDA,ADGA,AJYA,AFMA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AgBhDA,AzB2EA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AiBnDA,ADGA,ANkBA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AgBhDA,AzB2EA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AkBtDA,ADGA,ADGA,ANkBA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AgBhDA,AzB2EA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AkBtDA,ADGA,ADGA,ANkBA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AgBhDA,AzB2EA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AkBtDA,ADGA,ADGA,ANkBA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AgBhDA,AzB2EA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AkBtDA,ADGA,ADGA,ANkBA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AgBhDA,AzB2EA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AkBtDA,ADGA,ADGA,ANkBA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AgBhDA,AzB2EA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AkBtDA,ADGA,ADGA,ANkBA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AgBhDA,AzB2EA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AkBtDA,ADGA,ADGA,ANkBA,AGTA,AFMA,ARwBA,AV8BA,AMlBA,AgBhDA,AzB2EA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AkBtDA,ADGA,ADGA,AHSA,AFMA,ARwBA,AV8BA,AMlBA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AkBtDA,ADGA,ADGA,AHSA,AFMA,ARwBA,AV8BA,AMlBA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AkBtDA,ADGA,ADGA,AHSA,AFMA,ARwBA,AV8BA,AMlBA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AkBtDA,ADGA,ADGA,AHSA,AFMA,ARwBA,AV8BA,AMlBA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AkBtDA,ADGA,ADGA,AHSA,AFMA,ARwBA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AkBtDA,ADGA,ADGA,AHSA,AFMA,ARwBA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AkBtDA,ADGA,ADGA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AiBnDA,ADGA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AiBnDA,ADGA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AiBnDA,ADGA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AiBnDA,ADGA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AiBnDA,ADGA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AiBnDA,ADGA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AiBnDA,ADGA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AiBnDA,ADGA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AiBnDA,ADGA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AJYA,AT2BA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AHSA,AV8BA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA,AwBxEA;AlBuDA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AOrBA,ALeA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AgBhDA,AbuCA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AMjBA,ACHA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AENA,AGTA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,AKfA,AbuCA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AOpBA,ACHA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\n/**\r\n * @fileoverview G 的基础接口定义和所有的抽象类\r\n * @author dxq613@gmail.com\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.version = exports.PathUtil = void 0;\r\nvar tslib_1 = require(\"tslib\");\r\nvar PathUtil = require(\"./util/path\");\r\nexports.PathUtil = PathUtil;\r\ntslib_1.__exportStar(require(\"./types\"), exports);\r\ntslib_1.__exportStar(require(\"./interfaces\"), exports);\r\nvar graph_event_1 = require(\"./event/graph-event\");\r\nObject.defineProperty(exports, \"Event\", { enumerable: true, get: function () { return graph_event_1.default; } });\r\nvar base_1 = require(\"./abstract/base\");\r\nObject.defineProperty(exports, \"Base\", { enumerable: true, get: function () { return base_1.default; } });\r\nvar canvas_1 = require(\"./abstract/canvas\");\r\nObject.defineProperty(exports, \"AbstractCanvas\", { enumerable: true, get: function () { return canvas_1.default; } });\r\nvar group_1 = require(\"./abstract/group\");\r\nObject.defineProperty(exports, \"AbstractGroup\", { enumerable: true, get: function () { return group_1.default; } });\r\nvar shape_1 = require(\"./abstract/shape\");\r\nObject.defineProperty(exports, \"AbstractShape\", { enumerable: true, get: function () { return shape_1.default; } });\r\nvar bbox_1 = require(\"./bbox\");\r\nObject.defineProperty(exports, \"getBBoxMethod\", { enumerable: true, get: function () { return bbox_1.getBBoxMethod; } });\r\nObject.defineProperty(exports, \"registerBBox\", { enumerable: true, get: function () { return bbox_1.registerBBox; } });\r\nvar text_1 = require(\"./util/text\");\r\nObject.defineProperty(exports, \"getTextHeight\", { enumerable: true, get: function () { return text_1.getTextHeight; } });\r\nObject.defineProperty(exports, \"assembleFont\", { enumerable: true, get: function () { return text_1.assembleFont; } });\r\nvar util_1 = require(\"./util/util\");\r\nObject.defineProperty(exports, \"isAllowCapture\", { enumerable: true, get: function () { return util_1.isAllowCapture; } });\r\nvar matrix_1 = require(\"./util/matrix\");\r\nObject.defineProperty(exports, \"multiplyVec2\", { enumerable: true, get: function () { return matrix_1.multiplyVec2; } });\r\nObject.defineProperty(exports, \"invert\", { enumerable: true, get: function () { return matrix_1.invert; } });\r\nvar offscreen_1 = require(\"./util/offscreen\");\r\nObject.defineProperty(exports, \"getOffScreenContext\", { enumerable: true, get: function () { return offscreen_1.getOffScreenContext; } });\r\nvar register_1 = require(\"./animate/register\");\r\nObject.defineProperty(exports, \"registerEasing\", { enumerable: true, get: function () { return register_1.registerEasing; } });\r\nexports.version = '0.5.11';\r\n//# sourceMappingURL=index.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.rectPath = exports.pathToCurve = exports.pathToAbsolute = exports.parsePathString = exports.parsePathArray = exports.intersection = exports.formatPath = exports.fillPathByDiff = exports.fillPath = exports.catmullRomToBezier = void 0;\r\nvar util_1 = require(\"@antv/util\");\r\nvar SPACES = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\r\nvar PATH_COMMAND = new RegExp(\"([a-z])[\" + SPACES + \",]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[\" + SPACES + \"]*,?[\" + SPACES + \"]*)+)\", 'ig');\r\nvar PATH_VALUES = new RegExp(\"(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[\" + SPACES + \"]*,?[\" + SPACES + \"]*\", 'ig');\r\n// Parse given path string into an array of arrays of path segments\r\nvar parsePathString = function (pathString) {\r\n    if (!pathString) {\r\n        return null;\r\n    }\r\n    if (util_1.isArray(pathString)) {\r\n        return pathString;\r\n    }\r\n    var paramCounts = {\r\n        a: 7,\r\n        c: 6,\r\n        o: 2,\r\n        h: 1,\r\n        l: 2,\r\n        m: 2,\r\n        r: 4,\r\n        q: 4,\r\n        s: 4,\r\n        t: 2,\r\n        v: 1,\r\n        u: 3,\r\n        z: 0,\r\n    };\r\n    var data = [];\r\n    String(pathString).replace(PATH_COMMAND, function (a, b, c) {\r\n        var params = [];\r\n        var name = b.toLowerCase();\r\n        c.replace(PATH_VALUES, function (a, b) {\r\n            b && params.push(+b);\r\n        });\r\n        if (name === 'm' && params.length > 2) {\r\n            data.push([b].concat(params.splice(0, 2)));\r\n            name = 'l';\r\n            b = b === 'm' ? 'l' : 'L';\r\n        }\r\n        if (name === 'o' && params.length === 1) {\r\n            data.push([b, params[0]]);\r\n        }\r\n        if (name === 'r') {\r\n            data.push([b].concat(params));\r\n        }\r\n        else {\r\n            while (params.length >= paramCounts[name]) {\r\n                data.push([b].concat(params.splice(0, paramCounts[name])));\r\n                if (!paramCounts[name]) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return pathString;\r\n    });\r\n    return data;\r\n};\r\nexports.parsePathString = parsePathString;\r\n// http://schepers.cc/getting-to-the-point\r\nvar catmullRomToBezier = function (crp, z) {\r\n    var d = [];\r\n    // @ts-ignore\r\n    for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\r\n        var p = [\r\n            {\r\n                x: +crp[i - 2],\r\n                y: +crp[i - 1],\r\n            },\r\n            {\r\n                x: +crp[i],\r\n                y: +crp[i + 1],\r\n            },\r\n            {\r\n                x: +crp[i + 2],\r\n                y: +crp[i + 3],\r\n            },\r\n            {\r\n                x: +crp[i + 4],\r\n                y: +crp[i + 5],\r\n            },\r\n        ];\r\n        if (z) {\r\n            if (!i) {\r\n                p[0] = {\r\n                    x: +crp[iLen - 2],\r\n                    y: +crp[iLen - 1],\r\n                };\r\n            }\r\n            else if (iLen - 4 === i) {\r\n                p[3] = {\r\n                    x: +crp[0],\r\n                    y: +crp[1],\r\n                };\r\n            }\r\n            else if (iLen - 2 === i) {\r\n                p[2] = {\r\n                    x: +crp[0],\r\n                    y: +crp[1],\r\n                };\r\n                p[3] = {\r\n                    x: +crp[2],\r\n                    y: +crp[3],\r\n                };\r\n            }\r\n        }\r\n        else {\r\n            if (iLen - 4 === i) {\r\n                p[3] = p[2];\r\n            }\r\n            else if (!i) {\r\n                p[0] = {\r\n                    x: +crp[i],\r\n                    y: +crp[i + 1],\r\n                };\r\n            }\r\n        }\r\n        d.push([\r\n            'C',\r\n            (-p[0].x + 6 * p[1].x + p[2].x) / 6,\r\n            (-p[0].y + 6 * p[1].y + p[2].y) / 6,\r\n            (p[1].x + 6 * p[2].x - p[3].x) / 6,\r\n            (p[1].y + 6 * p[2].y - p[3].y) / 6,\r\n            p[2].x,\r\n            p[2].y,\r\n        ]);\r\n    }\r\n    return d;\r\n};\r\nexports.catmullRomToBezier = catmullRomToBezier;\r\nvar ellipsePath = function (x, y, rx, ry, a) {\r\n    var res = [];\r\n    if (a === null && ry === null) {\r\n        ry = rx;\r\n    }\r\n    x = +x;\r\n    y = +y;\r\n    rx = +rx;\r\n    ry = +ry;\r\n    if (a !== null) {\r\n        var rad = Math.PI / 180;\r\n        var x1 = x + rx * Math.cos(-ry * rad);\r\n        var x2 = x + rx * Math.cos(-a * rad);\r\n        var y1 = y + rx * Math.sin(-ry * rad);\r\n        var y2 = y + rx * Math.sin(-a * rad);\r\n        res = [\r\n            ['M', x1, y1],\r\n            ['A', rx, rx, 0, +(a - ry > 180), 0, x2, y2],\r\n        ];\r\n    }\r\n    else {\r\n        res = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];\r\n    }\r\n    return res;\r\n};\r\nvar pathToAbsolute = function (pathArray) {\r\n    pathArray = parsePathString(pathArray);\r\n    if (!pathArray || !pathArray.length) {\r\n        return [['M', 0, 0]];\r\n    }\r\n    var res = [];\r\n    var x = 0;\r\n    var y = 0;\r\n    var mx = 0;\r\n    var my = 0;\r\n    var start = 0;\r\n    var pa0;\r\n    var dots;\r\n    if (pathArray[0][0] === 'M') {\r\n        x = +pathArray[0][1];\r\n        y = +pathArray[0][2];\r\n        mx = x;\r\n        my = y;\r\n        start++;\r\n        res[0] = ['M', x, y];\r\n    }\r\n    var crz = pathArray.length === 3 &&\r\n        pathArray[0][0] === 'M' &&\r\n        pathArray[1][0].toUpperCase() === 'R' &&\r\n        pathArray[2][0].toUpperCase() === 'Z';\r\n    for (var r = void 0, pa = void 0, i = start, ii = pathArray.length; i < ii; i++) {\r\n        res.push((r = []));\r\n        pa = pathArray[i];\r\n        pa0 = pa[0];\r\n        if (pa0 !== pa0.toUpperCase()) {\r\n            r[0] = pa0.toUpperCase();\r\n            switch (r[0]) {\r\n                case 'A':\r\n                    r[1] = pa[1];\r\n                    r[2] = pa[2];\r\n                    r[3] = pa[3];\r\n                    r[4] = pa[4];\r\n                    r[5] = pa[5];\r\n                    r[6] = +pa[6] + x;\r\n                    r[7] = +pa[7] + y;\r\n                    break;\r\n                case 'V':\r\n                    r[1] = +pa[1] + y;\r\n                    break;\r\n                case 'H':\r\n                    r[1] = +pa[1] + x;\r\n                    break;\r\n                case 'R':\r\n                    dots = [x, y].concat(pa.slice(1));\r\n                    for (var j = 2, jj = dots.length; j < jj; j++) {\r\n                        dots[j] = +dots[j] + x;\r\n                        dots[++j] = +dots[j] + y;\r\n                    }\r\n                    res.pop();\r\n                    res = res.concat(catmullRomToBezier(dots, crz));\r\n                    break;\r\n                case 'O':\r\n                    res.pop();\r\n                    dots = ellipsePath(x, y, pa[1], pa[2]);\r\n                    dots.push(dots[0]);\r\n                    res = res.concat(dots);\r\n                    break;\r\n                case 'U':\r\n                    res.pop();\r\n                    res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\r\n                    r = ['U'].concat(res[res.length - 1].slice(-2));\r\n                    break;\r\n                case 'M':\r\n                    mx = +pa[1] + x;\r\n                    my = +pa[2] + y;\r\n                    break; // for lint\r\n                default:\r\n                    for (var j = 1, jj = pa.length; j < jj; j++) {\r\n                        r[j] = +pa[j] + (j % 2 ? x : y);\r\n                    }\r\n            }\r\n        }\r\n        else if (pa0 === 'R') {\r\n            dots = [x, y].concat(pa.slice(1));\r\n            res.pop();\r\n            res = res.concat(catmullRomToBezier(dots, crz));\r\n            r = ['R'].concat(pa.slice(-2));\r\n        }\r\n        else if (pa0 === 'O') {\r\n            res.pop();\r\n            dots = ellipsePath(x, y, pa[1], pa[2]);\r\n            dots.push(dots[0]);\r\n            res = res.concat(dots);\r\n        }\r\n        else if (pa0 === 'U') {\r\n            res.pop();\r\n            res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\r\n            r = ['U'].concat(res[res.length - 1].slice(-2));\r\n        }\r\n        else {\r\n            for (var k = 0, kk = pa.length; k < kk; k++) {\r\n                r[k] = pa[k];\r\n            }\r\n        }\r\n        pa0 = pa0.toUpperCase();\r\n        if (pa0 !== 'O') {\r\n            switch (r[0]) {\r\n                case 'Z':\r\n                    x = +mx;\r\n                    y = +my;\r\n                    break;\r\n                case 'H':\r\n                    x = r[1];\r\n                    break;\r\n                case 'V':\r\n                    y = r[1];\r\n                    break;\r\n                case 'M':\r\n                    mx = r[r.length - 2];\r\n                    my = r[r.length - 1];\r\n                    break; // for lint\r\n                default:\r\n                    x = r[r.length - 2];\r\n                    y = r[r.length - 1];\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n};\r\nexports.pathToAbsolute = pathToAbsolute;\r\nvar l2c = function (x1, y1, x2, y2) {\r\n    return [x1, y1, x2, y2, x2, y2];\r\n};\r\nvar q2c = function (x1, y1, ax, ay, x2, y2) {\r\n    var _13 = 1 / 3;\r\n    var _23 = 2 / 3;\r\n    return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];\r\n};\r\nvar a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\r\n    // for more information of where this math came from visit:\r\n    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\r\n    if (rx === ry) {\r\n        rx += 1;\r\n    }\r\n    var _120 = (Math.PI * 120) / 180;\r\n    var rad = (Math.PI / 180) * (+angle || 0);\r\n    var res = [];\r\n    var xy;\r\n    var f1;\r\n    var f2;\r\n    var cx;\r\n    var cy;\r\n    var rotate = function (x, y, rad) {\r\n        var X = x * Math.cos(rad) - y * Math.sin(rad);\r\n        var Y = x * Math.sin(rad) + y * Math.cos(rad);\r\n        return {\r\n            x: X,\r\n            y: Y,\r\n        };\r\n    };\r\n    if (!recursive) {\r\n        xy = rotate(x1, y1, -rad);\r\n        x1 = xy.x;\r\n        y1 = xy.y;\r\n        xy = rotate(x2, y2, -rad);\r\n        x2 = xy.x;\r\n        y2 = xy.y;\r\n        if (x1 === x2 && y1 === y2) {\r\n            // 若弧的起始点和终点重叠则错开一点\r\n            x2 += 1;\r\n            y2 += 1;\r\n        }\r\n        // const cos = Math.cos(Math.PI / 180 * angle);\r\n        // const sin = Math.sin(Math.PI / 180 * angle);\r\n        var x = (x1 - x2) / 2;\r\n        var y = (y1 - y2) / 2;\r\n        var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\r\n        if (h > 1) {\r\n            h = Math.sqrt(h);\r\n            rx = h * rx;\r\n            ry = h * ry;\r\n        }\r\n        var rx2 = rx * rx;\r\n        var ry2 = ry * ry;\r\n        var k = (large_arc_flag === sweep_flag ? -1 : 1) *\r\n            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\r\n        cx = (k * rx * y) / ry + (x1 + x2) / 2;\r\n        cy = (k * -ry * x) / rx + (y1 + y2) / 2;\r\n        // @ts-ignore\r\n        f1 = Math.asin(((y1 - cy) / ry).toFixed(9));\r\n        // @ts-ignore\r\n        f2 = Math.asin(((y2 - cy) / ry).toFixed(9));\r\n        f1 = x1 < cx ? Math.PI - f1 : f1;\r\n        f2 = x2 < cx ? Math.PI - f2 : f2;\r\n        f1 < 0 && (f1 = Math.PI * 2 + f1);\r\n        f2 < 0 && (f2 = Math.PI * 2 + f2);\r\n        if (sweep_flag && f1 > f2) {\r\n            f1 = f1 - Math.PI * 2;\r\n        }\r\n        if (!sweep_flag && f2 > f1) {\r\n            f2 = f2 - Math.PI * 2;\r\n        }\r\n    }\r\n    else {\r\n        f1 = recursive[0];\r\n        f2 = recursive[1];\r\n        cx = recursive[2];\r\n        cy = recursive[3];\r\n    }\r\n    var df = f2 - f1;\r\n    if (Math.abs(df) > _120) {\r\n        var f2old = f2;\r\n        var x2old = x2;\r\n        var y2old = y2;\r\n        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\r\n        x2 = cx + rx * Math.cos(f2);\r\n        y2 = cy + ry * Math.sin(f2);\r\n        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\r\n    }\r\n    df = f2 - f1;\r\n    var c1 = Math.cos(f1);\r\n    var s1 = Math.sin(f1);\r\n    var c2 = Math.cos(f2);\r\n    var s2 = Math.sin(f2);\r\n    var t = Math.tan(df / 4);\r\n    var hx = (4 / 3) * rx * t;\r\n    var hy = (4 / 3) * ry * t;\r\n    var m1 = [x1, y1];\r\n    var m2 = [x1 + hx * s1, y1 - hy * c1];\r\n    var m3 = [x2 + hx * s2, y2 - hy * c2];\r\n    var m4 = [x2, y2];\r\n    m2[0] = 2 * m1[0] - m2[0];\r\n    m2[1] = 2 * m1[1] - m2[1];\r\n    if (recursive) {\r\n        return [m2, m3, m4].concat(res);\r\n    }\r\n    res = [m2, m3, m4].concat(res).join().split(',');\r\n    var newres = [];\r\n    for (var i = 0, ii = res.length; i < ii; i++) {\r\n        newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\r\n    }\r\n    return newres;\r\n};\r\nvar pathToCurve = function (path, path2) {\r\n    var p = pathToAbsolute(path);\r\n    var p2 = path2 && pathToAbsolute(path2);\r\n    var attrs = {\r\n        x: 0,\r\n        y: 0,\r\n        bx: 0,\r\n        by: 0,\r\n        X: 0,\r\n        Y: 0,\r\n        qx: null,\r\n        qy: null,\r\n    };\r\n    var attrs2 = {\r\n        x: 0,\r\n        y: 0,\r\n        bx: 0,\r\n        by: 0,\r\n        X: 0,\r\n        Y: 0,\r\n        qx: null,\r\n        qy: null,\r\n    };\r\n    var pcoms1 = []; // path commands of original path p\r\n    var pcoms2 = []; // path commands of original path p2\r\n    var pfirst = ''; // temporary holder for original path command\r\n    var pcom = ''; // holder for previous path command of original path\r\n    var ii;\r\n    var processPath = function (path, d, pcom) {\r\n        var nx;\r\n        var ny;\r\n        if (!path) {\r\n            return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\r\n        }\r\n        !(path[0] in\r\n            {\r\n                T: 1,\r\n                Q: 1,\r\n            }) && (d.qx = d.qy = null);\r\n        switch (path[0]) {\r\n            case 'M':\r\n                d.X = path[1];\r\n                d.Y = path[2];\r\n                break;\r\n            case 'A':\r\n                path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\r\n                break;\r\n            case 'S':\r\n                if (pcom === 'C' || pcom === 'S') {\r\n                    // In \"S\" case we have to take into account, if the previous command is C/S.\r\n                    nx = d.x * 2 - d.bx; // And reflect the previous\r\n                    ny = d.y * 2 - d.by; // command's control point relative to the current point.\r\n                }\r\n                else {\r\n                    // or some else or nothing\r\n                    nx = d.x;\r\n                    ny = d.y;\r\n                }\r\n                path = ['C', nx, ny].concat(path.slice(1));\r\n                break;\r\n            case 'T':\r\n                if (pcom === 'Q' || pcom === 'T') {\r\n                    // In \"T\" case we have to take into account, if the previous command is Q/T.\r\n                    d.qx = d.x * 2 - d.qx; // And make a reflection similar\r\n                    d.qy = d.y * 2 - d.qy; // to case \"S\".\r\n                }\r\n                else {\r\n                    // or something else or nothing\r\n                    d.qx = d.x;\r\n                    d.qy = d.y;\r\n                }\r\n                path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\r\n                break;\r\n            case 'Q':\r\n                d.qx = path[1];\r\n                d.qy = path[2];\r\n                path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\r\n                break;\r\n            case 'L':\r\n                path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));\r\n                break;\r\n            case 'H':\r\n                path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));\r\n                break;\r\n            case 'V':\r\n                path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));\r\n                break;\r\n            case 'Z':\r\n                path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return path;\r\n    };\r\n    var fixArc = function (pp, i) {\r\n        if (pp[i].length > 7) {\r\n            pp[i].shift();\r\n            var pi = pp[i];\r\n            while (pi.length) {\r\n                pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved\r\n                p2 && (pcoms2[i] = 'A'); // the same as above\r\n                pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\r\n            }\r\n            pp.splice(i, 1);\r\n            ii = Math.max(p.length, (p2 && p2.length) || 0);\r\n        }\r\n    };\r\n    var fixM = function (path1, path2, a1, a2, i) {\r\n        if (path1 && path2 && path1[i][0] === 'M' && path2[i][0] !== 'M') {\r\n            path2.splice(i, 0, ['M', a2.x, a2.y]);\r\n            a1.bx = 0;\r\n            a1.by = 0;\r\n            a1.x = path1[i][1];\r\n            a1.y = path1[i][2];\r\n            ii = Math.max(p.length, (p2 && p2.length) || 0);\r\n        }\r\n    };\r\n    ii = Math.max(p.length, (p2 && p2.length) || 0);\r\n    for (var i = 0; i < ii; i++) {\r\n        p[i] && (pfirst = p[i][0]); // save current path command\r\n        if (pfirst !== 'C') {\r\n            // C is not saved yet, because it may be result of conversion\r\n            pcoms1[i] = pfirst; // Save current path command\r\n            i && (pcom = pcoms1[i - 1]); // Get previous path command pcom\r\n        }\r\n        p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\r\n        if (pcoms1[i] !== 'A' && pfirst === 'C')\r\n            pcoms1[i] = 'C'; // A is the only command\r\n        // which may produce multiple C:s\r\n        // so we have to make sure that C is also C in original path\r\n        fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\r\n        if (p2) {\r\n            // the same procedures is done to p2\r\n            p2[i] && (pfirst = p2[i][0]);\r\n            if (pfirst !== 'C') {\r\n                pcoms2[i] = pfirst;\r\n                i && (pcom = pcoms2[i - 1]);\r\n            }\r\n            p2[i] = processPath(p2[i], attrs2, pcom);\r\n            if (pcoms2[i] !== 'A' && pfirst === 'C') {\r\n                pcoms2[i] = 'C';\r\n            }\r\n            fixArc(p2, i);\r\n        }\r\n        fixM(p, p2, attrs, attrs2, i);\r\n        fixM(p2, p, attrs2, attrs, i);\r\n        var seg = p[i];\r\n        var seg2 = p2 && p2[i];\r\n        var seglen = seg.length;\r\n        var seg2len = p2 && seg2.length;\r\n        attrs.x = seg[seglen - 2];\r\n        attrs.y = seg[seglen - 1];\r\n        attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\r\n        attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\r\n        attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);\r\n        attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);\r\n        attrs2.x = p2 && seg2[seg2len - 2];\r\n        attrs2.y = p2 && seg2[seg2len - 1];\r\n    }\r\n    return p2 ? [p, p2] : p;\r\n};\r\nexports.pathToCurve = pathToCurve;\r\nvar p2s = /,?([a-z]),?/gi;\r\nvar parsePathArray = function (path) {\r\n    return path.join(',').replace(p2s, '$1');\r\n};\r\nexports.parsePathArray = parsePathArray;\r\nvar base3 = function (t, p1, p2, p3, p4) {\r\n    var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;\r\n    var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\r\n    return t * t2 - 3 * p1 + 3 * p2;\r\n};\r\nvar bezlen = function (x1, y1, x2, y2, x3, y3, x4, y4, z) {\r\n    if (z === null) {\r\n        z = 1;\r\n    }\r\n    z = z > 1 ? 1 : z < 0 ? 0 : z;\r\n    var z2 = z / 2;\r\n    var n = 12;\r\n    var Tvalues = [\r\n        -0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816,\r\n    ];\r\n    var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];\r\n    var sum = 0;\r\n    for (var i = 0; i < n; i++) {\r\n        var ct = z2 * Tvalues[i] + z2;\r\n        var xbase = base3(ct, x1, x2, x3, x4);\r\n        var ybase = base3(ct, y1, y2, y3, y4);\r\n        var comb = xbase * xbase + ybase * ybase;\r\n        sum += Cvalues[i] * Math.sqrt(comb);\r\n    }\r\n    return z2 * sum;\r\n};\r\nvar curveDim = function (x0, y0, x1, y1, x2, y2, x3, y3) {\r\n    var tvalues = [];\r\n    var bounds = [[], []];\r\n    var a;\r\n    var b;\r\n    var c;\r\n    var t;\r\n    for (var i = 0; i < 2; ++i) {\r\n        if (i === 0) {\r\n            b = 6 * x0 - 12 * x1 + 6 * x2;\r\n            a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\r\n            c = 3 * x1 - 3 * x0;\r\n        }\r\n        else {\r\n            b = 6 * y0 - 12 * y1 + 6 * y2;\r\n            a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\r\n            c = 3 * y1 - 3 * y0;\r\n        }\r\n        if (Math.abs(a) < 1e-12) {\r\n            if (Math.abs(b) < 1e-12) {\r\n                continue;\r\n            }\r\n            t = -c / b;\r\n            if (t > 0 && t < 1) {\r\n                tvalues.push(t);\r\n            }\r\n            continue;\r\n        }\r\n        var b2ac = b * b - 4 * c * a;\r\n        var sqrtb2ac = Math.sqrt(b2ac);\r\n        if (b2ac < 0) {\r\n            continue;\r\n        }\r\n        var t1 = (-b + sqrtb2ac) / (2 * a);\r\n        if (t1 > 0 && t1 < 1) {\r\n            tvalues.push(t1);\r\n        }\r\n        var t2 = (-b - sqrtb2ac) / (2 * a);\r\n        if (t2 > 0 && t2 < 1) {\r\n            tvalues.push(t2);\r\n        }\r\n    }\r\n    var j = tvalues.length;\r\n    var jlen = j;\r\n    var mt;\r\n    while (j--) {\r\n        t = tvalues[j];\r\n        mt = 1 - t;\r\n        bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\r\n        bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\r\n    }\r\n    bounds[0][jlen] = x0;\r\n    bounds[1][jlen] = y0;\r\n    bounds[0][jlen + 1] = x3;\r\n    bounds[1][jlen + 1] = y3;\r\n    bounds[0].length = bounds[1].length = jlen + 2;\r\n    return {\r\n        min: {\r\n            x: Math.min.apply(0, bounds[0]),\r\n            y: Math.min.apply(0, bounds[1]),\r\n        },\r\n        max: {\r\n            x: Math.max.apply(0, bounds[0]),\r\n            y: Math.max.apply(0, bounds[1]),\r\n        },\r\n    };\r\n};\r\nvar intersect = function (x1, y1, x2, y2, x3, y3, x4, y4) {\r\n    if (Math.max(x1, x2) < Math.min(x3, x4) ||\r\n        Math.min(x1, x2) > Math.max(x3, x4) ||\r\n        Math.max(y1, y2) < Math.min(y3, y4) ||\r\n        Math.min(y1, y2) > Math.max(y3, y4)) {\r\n        return;\r\n    }\r\n    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);\r\n    var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);\r\n    var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\r\n    if (!denominator) {\r\n        return;\r\n    }\r\n    var px = nx / denominator;\r\n    var py = ny / denominator;\r\n    var px2 = +px.toFixed(2);\r\n    var py2 = +py.toFixed(2);\r\n    if (px2 < +Math.min(x1, x2).toFixed(2) ||\r\n        px2 > +Math.max(x1, x2).toFixed(2) ||\r\n        px2 < +Math.min(x3, x4).toFixed(2) ||\r\n        px2 > +Math.max(x3, x4).toFixed(2) ||\r\n        py2 < +Math.min(y1, y2).toFixed(2) ||\r\n        py2 > +Math.max(y1, y2).toFixed(2) ||\r\n        py2 < +Math.min(y3, y4).toFixed(2) ||\r\n        py2 > +Math.max(y3, y4).toFixed(2)) {\r\n        return;\r\n    }\r\n    return {\r\n        x: px,\r\n        y: py,\r\n    };\r\n};\r\nvar isPointInsideBBox = function (bbox, x, y) {\r\n    return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;\r\n};\r\nvar rectPath = function (x, y, w, h, r) {\r\n    if (r) {\r\n        return [\r\n            ['M', +x + +r, y],\r\n            ['l', w - r * 2, 0],\r\n            ['a', r, r, 0, 0, 1, r, r],\r\n            ['l', 0, h - r * 2],\r\n            ['a', r, r, 0, 0, 1, -r, r],\r\n            ['l', r * 2 - w, 0],\r\n            ['a', r, r, 0, 0, 1, -r, -r],\r\n            ['l', 0, r * 2 - h],\r\n            ['a', r, r, 0, 0, 1, r, -r],\r\n            ['z'],\r\n        ];\r\n    }\r\n    var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];\r\n    // @ts-ignore\r\n    res.parsePathArray = parsePathArray;\r\n    return res;\r\n};\r\nexports.rectPath = rectPath;\r\nvar box = function (x, y, width, height) {\r\n    if (x === null) {\r\n        x = y = width = height = 0;\r\n    }\r\n    if (y === null) {\r\n        y = x.y;\r\n        width = x.width;\r\n        height = x.height;\r\n        x = x.x;\r\n    }\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        width: width,\r\n        w: width,\r\n        height: height,\r\n        h: height,\r\n        x2: x + width,\r\n        y2: y + height,\r\n        cx: x + width / 2,\r\n        cy: y + height / 2,\r\n        r1: Math.min(width, height) / 2,\r\n        r2: Math.max(width, height) / 2,\r\n        r0: Math.sqrt(width * width + height * height) / 2,\r\n        path: rectPath(x, y, width, height),\r\n        vb: [x, y, width, height].join(' '),\r\n    };\r\n};\r\nvar isBBoxIntersect = function (bbox1, bbox2) {\r\n    bbox1 = box(bbox1);\r\n    bbox2 = box(bbox2);\r\n    return (isPointInsideBBox(bbox2, bbox1.x, bbox1.y) ||\r\n        isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) ||\r\n        isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) ||\r\n        isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) ||\r\n        isPointInsideBBox(bbox1, bbox2.x, bbox2.y) ||\r\n        isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) ||\r\n        isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) ||\r\n        isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) ||\r\n        (((bbox1.x < bbox2.x2 && bbox1.x > bbox2.x) || (bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)) &&\r\n            ((bbox1.y < bbox2.y2 && bbox1.y > bbox2.y) || (bbox2.y < bbox1.y2 && bbox2.y > bbox1.y))));\r\n};\r\nvar bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\r\n    if (!util_1.isArray(p1x)) {\r\n        p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\r\n    }\r\n    var bbox = curveDim.apply(null, p1x);\r\n    return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);\r\n};\r\nvar findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\r\n    var t1 = 1 - t;\r\n    var t13 = Math.pow(t1, 3);\r\n    var t12 = Math.pow(t1, 2);\r\n    var t2 = t * t;\r\n    var t3 = t2 * t;\r\n    var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;\r\n    var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;\r\n    var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);\r\n    var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);\r\n    var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);\r\n    var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);\r\n    var ax = t1 * p1x + t * c1x;\r\n    var ay = t1 * p1y + t * c1y;\r\n    var cx = t1 * c2x + t * p2x;\r\n    var cy = t1 * c2y + t * p2y;\r\n    var alpha = 90 - (Math.atan2(mx - nx, my - ny) * 180) / Math.PI;\r\n    // (mx > nx || my < ny) && (alpha += 180);\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        m: {\r\n            x: mx,\r\n            y: my,\r\n        },\r\n        n: {\r\n            x: nx,\r\n            y: ny,\r\n        },\r\n        start: {\r\n            x: ax,\r\n            y: ay,\r\n        },\r\n        end: {\r\n            x: cx,\r\n            y: cy,\r\n        },\r\n        alpha: alpha,\r\n    };\r\n};\r\nvar interHelper = function (bez1, bez2, justCount) {\r\n    var bbox1 = bezierBBox(bez1);\r\n    var bbox2 = bezierBBox(bez2);\r\n    if (!isBBoxIntersect(bbox1, bbox2)) {\r\n        return justCount ? 0 : [];\r\n    }\r\n    var l1 = bezlen.apply(0, bez1);\r\n    var l2 = bezlen.apply(0, bez2);\r\n    var n1 = ~~(l1 / 8);\r\n    var n2 = ~~(l2 / 8);\r\n    var dots1 = [];\r\n    var dots2 = [];\r\n    var xy = {};\r\n    var res = justCount ? 0 : [];\r\n    for (var i = 0; i < n1 + 1; i++) {\r\n        var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));\r\n        dots1.push({\r\n            x: d.x,\r\n            y: d.y,\r\n            t: i / n1,\r\n        });\r\n    }\r\n    for (var i = 0; i < n2 + 1; i++) {\r\n        var d = findDotsAtSegment.apply(0, bez2.concat(i / n2));\r\n        dots2.push({\r\n            x: d.x,\r\n            y: d.y,\r\n            t: i / n2,\r\n        });\r\n    }\r\n    for (var i = 0; i < n1; i++) {\r\n        for (var j = 0; j < n2; j++) {\r\n            var di = dots1[i];\r\n            var di1 = dots1[i + 1];\r\n            var dj = dots2[j];\r\n            var dj1 = dots2[j + 1];\r\n            var ci = Math.abs(di1.x - di.x) < 0.001 ? 'y' : 'x';\r\n            var cj = Math.abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';\r\n            var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\r\n            if (is) {\r\n                if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {\r\n                    continue;\r\n                }\r\n                xy[is.x.toFixed(4)] = is.y.toFixed(4);\r\n                var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);\r\n                var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\r\n                if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\r\n                    if (justCount) {\r\n                        // @ts-ignore\r\n                        res += 1;\r\n                    }\r\n                    else {\r\n                        // @ts-ignore\r\n                        res.push({\r\n                            x: is.x,\r\n                            y: is.y,\r\n                            t1: t1,\r\n                            t2: t2,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n};\r\nvar interPathHelper = function (path1, path2, justCount) {\r\n    path1 = pathToCurve(path1);\r\n    path2 = pathToCurve(path2);\r\n    var x1;\r\n    var y1;\r\n    var x2;\r\n    var y2;\r\n    var x1m;\r\n    var y1m;\r\n    var x2m;\r\n    var y2m;\r\n    var bez1;\r\n    var bez2;\r\n    var res = justCount ? 0 : [];\r\n    for (var i = 0, ii = path1.length; i < ii; i++) {\r\n        var pi = path1[i];\r\n        if (pi[0] === 'M') {\r\n            x1 = x1m = pi[1];\r\n            y1 = y1m = pi[2];\r\n        }\r\n        else {\r\n            if (pi[0] === 'C') {\r\n                bez1 = [x1, y1].concat(pi.slice(1));\r\n                x1 = bez1[6];\r\n                y1 = bez1[7];\r\n            }\r\n            else {\r\n                bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\r\n                x1 = x1m;\r\n                y1 = y1m;\r\n            }\r\n            for (var j = 0, jj = path2.length; j < jj; j++) {\r\n                var pj = path2[j];\r\n                if (pj[0] === 'M') {\r\n                    x2 = x2m = pj[1];\r\n                    y2 = y2m = pj[2];\r\n                }\r\n                else {\r\n                    if (pj[0] === 'C') {\r\n                        bez2 = [x2, y2].concat(pj.slice(1));\r\n                        x2 = bez2[6];\r\n                        y2 = bez2[7];\r\n                    }\r\n                    else {\r\n                        bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\r\n                        x2 = x2m;\r\n                        y2 = y2m;\r\n                    }\r\n                    var intr = interHelper(bez1, bez2, justCount);\r\n                    if (justCount) {\r\n                        // @ts-ignore\r\n                        res += intr;\r\n                    }\r\n                    else {\r\n                        // @ts-ignore\r\n                        for (var k = 0, kk = intr.length; k < kk; k++) {\r\n                            intr[k].segment1 = i;\r\n                            intr[k].segment2 = j;\r\n                            intr[k].bez1 = bez1;\r\n                            intr[k].bez2 = bez2;\r\n                        }\r\n                        // @ts-ignore\r\n                        res = res.concat(intr);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n};\r\nvar intersection = function (path1, path2) {\r\n    return interPathHelper(path1, path2);\r\n};\r\nexports.intersection = intersection;\r\nfunction decasteljau(points, t) {\r\n    var left = [];\r\n    var right = [];\r\n    function recurse(points, t) {\r\n        if (points.length === 1) {\r\n            left.push(points[0]);\r\n            right.push(points[0]);\r\n        }\r\n        else {\r\n            var middlePoints = [];\r\n            for (var i = 0; i < points.length - 1; i++) {\r\n                if (i === 0) {\r\n                    left.push(points[0]);\r\n                }\r\n                if (i === points.length - 2) {\r\n                    right.push(points[i + 1]);\r\n                }\r\n                middlePoints[i] = [\r\n                    (1 - t) * points[i][0] + t * points[i + 1][0],\r\n                    (1 - t) * points[i][1] + t * points[i + 1][1],\r\n                ];\r\n            }\r\n            recurse(middlePoints, t);\r\n        }\r\n    }\r\n    if (points.length) {\r\n        recurse(points, t);\r\n    }\r\n    return { left: left, right: right.reverse() };\r\n}\r\nfunction splitCurve(start, end, count) {\r\n    var points = [[start[1], start[2]]];\r\n    count = count || 2;\r\n    var segments = [];\r\n    if (end[0] === 'A') {\r\n        points.push(end[6]);\r\n        points.push(end[7]);\r\n    }\r\n    else if (end[0] === 'C') {\r\n        points.push([end[1], end[2]]);\r\n        points.push([end[3], end[4]]);\r\n        points.push([end[5], end[6]]);\r\n    }\r\n    else if (end[0] === 'S' || end[0] === 'Q') {\r\n        points.push([end[1], end[2]]);\r\n        points.push([end[3], end[4]]);\r\n    }\r\n    else {\r\n        points.push([end[1], end[2]]);\r\n    }\r\n    var leftSegments = points;\r\n    var t = 1 / count;\r\n    for (var i = 0; i < count - 1; i++) {\r\n        var rt = t / (1 - t * i);\r\n        var split = decasteljau(leftSegments, rt);\r\n        segments.push(split.left);\r\n        leftSegments = split.right;\r\n    }\r\n    segments.push(leftSegments);\r\n    var result = segments.map(function (segment) {\r\n        var cmd = [];\r\n        if (segment.length === 4) {\r\n            cmd.push('C');\r\n            cmd = cmd.concat(segment[2]);\r\n        }\r\n        if (segment.length >= 3) {\r\n            if (segment.length === 3) {\r\n                cmd.push('Q');\r\n            }\r\n            cmd = cmd.concat(segment[1]);\r\n        }\r\n        if (segment.length === 2) {\r\n            cmd.push('L');\r\n        }\r\n        cmd = cmd.concat(segment[segment.length - 1]);\r\n        return cmd;\r\n    });\r\n    return result;\r\n}\r\nvar splitSegment = function (start, end, count) {\r\n    if (count === 1) {\r\n        return [[].concat(start)];\r\n    }\r\n    var segments = [];\r\n    if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {\r\n        segments = segments.concat(splitCurve(start, end, count));\r\n    }\r\n    else {\r\n        var temp = [].concat(start);\r\n        if (temp[0] === 'M') {\r\n            temp[0] = 'L';\r\n        }\r\n        for (var i = 0; i <= count - 1; i++) {\r\n            segments.push(temp);\r\n        }\r\n    }\r\n    return segments;\r\n};\r\nvar fillPath = function (source, target) {\r\n    if (source.length === 1) {\r\n        return source;\r\n    }\r\n    var sourceLen = source.length - 1;\r\n    var targetLen = target.length - 1;\r\n    var ratio = sourceLen / targetLen;\r\n    var segmentsToFill = [];\r\n    if (source.length === 1 && source[0][0] === 'M') {\r\n        for (var i = 0; i < targetLen - sourceLen; i++) {\r\n            source.push(source[0]);\r\n        }\r\n        return source;\r\n    }\r\n    for (var i = 0; i < targetLen; i++) {\r\n        var index = Math.floor(ratio * i);\r\n        segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;\r\n    }\r\n    var filled = segmentsToFill.reduce(function (filled, count, i) {\r\n        if (i === sourceLen) {\r\n            return filled.concat(source[sourceLen]);\r\n        }\r\n        return filled.concat(splitSegment(source[i], source[i + 1], count));\r\n    }, []);\r\n    filled.unshift(source[0]);\r\n    if (target[targetLen] === 'Z' || target[targetLen] === 'z') {\r\n        filled.push('Z');\r\n    }\r\n    return filled;\r\n};\r\nexports.fillPath = fillPath;\r\nvar isEqual = function (obj1, obj2) {\r\n    if (obj1.length !== obj2.length) {\r\n        return false;\r\n    }\r\n    var result = true;\r\n    util_1.each(obj1, function (item, i) {\r\n        if (item !== obj2[i]) {\r\n            result = false;\r\n            return false;\r\n        }\r\n    });\r\n    return result;\r\n};\r\nfunction getMinDiff(del, add, modify) {\r\n    var type = null;\r\n    var min = modify;\r\n    if (add < min) {\r\n        min = add;\r\n        type = 'add';\r\n    }\r\n    if (del < min) {\r\n        min = del;\r\n        type = 'del';\r\n    }\r\n    return {\r\n        type: type,\r\n        min: min,\r\n    };\r\n}\r\n/*\r\n * https://en.wikipedia.org/wiki/Levenshtein_distance\r\n * 计算两条path的编辑距离\r\n */\r\nvar levenshteinDistance = function (source, target) {\r\n    var sourceLen = source.length;\r\n    var targetLen = target.length;\r\n    var sourceSegment;\r\n    var targetSegment;\r\n    var temp = 0;\r\n    if (sourceLen === 0 || targetLen === 0) {\r\n        return null;\r\n    }\r\n    var dist = [];\r\n    for (var i = 0; i <= sourceLen; i++) {\r\n        dist[i] = [];\r\n        dist[i][0] = { min: i };\r\n    }\r\n    for (var j = 0; j <= targetLen; j++) {\r\n        dist[0][j] = { min: j };\r\n    }\r\n    for (var i = 1; i <= sourceLen; i++) {\r\n        sourceSegment = source[i - 1];\r\n        for (var j = 1; j <= targetLen; j++) {\r\n            targetSegment = target[j - 1];\r\n            if (isEqual(sourceSegment, targetSegment)) {\r\n                temp = 0;\r\n            }\r\n            else {\r\n                temp = 1;\r\n            }\r\n            var del = dist[i - 1][j].min + 1;\r\n            var add = dist[i][j - 1].min + 1;\r\n            var modify = dist[i - 1][j - 1].min + temp;\r\n            dist[i][j] = getMinDiff(del, add, modify);\r\n        }\r\n    }\r\n    return dist;\r\n};\r\nvar fillPathByDiff = function (source, target) {\r\n    var diffMatrix = levenshteinDistance(source, target);\r\n    var sourceLen = source.length;\r\n    var targetLen = target.length;\r\n    var changes = [];\r\n    var index = 1;\r\n    var minPos = 1;\r\n    // 如果source和target不是完全不相等\r\n    if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {\r\n        // 获取从source到target所需改动\r\n        for (var i = 1; i <= sourceLen; i++) {\r\n            var min = diffMatrix[i][i].min;\r\n            minPos = i;\r\n            for (var j = index; j <= targetLen; j++) {\r\n                if (diffMatrix[i][j].min < min) {\r\n                    min = diffMatrix[i][j].min;\r\n                    minPos = j;\r\n                }\r\n            }\r\n            index = minPos;\r\n            if (diffMatrix[i][index].type) {\r\n                changes.push({ index: i - 1, type: diffMatrix[i][index].type });\r\n            }\r\n        }\r\n        // 对source进行增删path\r\n        for (var i = changes.length - 1; i >= 0; i--) {\r\n            index = changes[i].index;\r\n            if (changes[i].type === 'add') {\r\n                source.splice(index, 0, [].concat(source[index]));\r\n            }\r\n            else {\r\n                source.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n    // source尾部补齐\r\n    sourceLen = source.length;\r\n    var diff = targetLen - sourceLen;\r\n    if (sourceLen < targetLen) {\r\n        for (var i = 0; i < diff; i++) {\r\n            if (source[sourceLen - 1][0] === 'z' || source[sourceLen - 1][0] === 'Z') {\r\n                source.splice(sourceLen - 2, 0, source[sourceLen - 2]);\r\n            }\r\n            else {\r\n                source.push(source[sourceLen - 1]);\r\n            }\r\n            sourceLen += 1;\r\n        }\r\n    }\r\n    return source;\r\n};\r\nexports.fillPathByDiff = fillPathByDiff;\r\n// 将两个点均分成count个点\r\nfunction _splitPoints(points, former, count) {\r\n    var result = [].concat(points);\r\n    var index;\r\n    var t = 1 / (count + 1);\r\n    var formerEnd = _getSegmentPoints(former)[0];\r\n    for (var i = 1; i <= count; i++) {\r\n        t *= i;\r\n        index = Math.floor(points.length * t);\r\n        if (index === 0) {\r\n            result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);\r\n        }\r\n        else {\r\n            result.splice(index, 0, [\r\n                formerEnd[0] * t + points[index][0] * (1 - t),\r\n                formerEnd[1] * t + points[index][1] * (1 - t),\r\n            ]);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/*\r\n * 抽取pathSegment中的关键点\r\n * M,L,A,Q,H,V一个端点\r\n * Q, S抽取一个端点，一个控制点\r\n * C抽取一个端点，两个控制点\r\n */\r\nfunction _getSegmentPoints(segment) {\r\n    var points = [];\r\n    switch (segment[0]) {\r\n        case 'M':\r\n            points.push([segment[1], segment[2]]);\r\n            break;\r\n        case 'L':\r\n            points.push([segment[1], segment[2]]);\r\n            break;\r\n        case 'A':\r\n            points.push([segment[6], segment[7]]);\r\n            break;\r\n        case 'Q':\r\n            points.push([segment[3], segment[4]]);\r\n            points.push([segment[1], segment[2]]);\r\n            break;\r\n        case 'T':\r\n            points.push([segment[1], segment[2]]);\r\n            break;\r\n        case 'C':\r\n            points.push([segment[5], segment[6]]);\r\n            points.push([segment[1], segment[2]]);\r\n            points.push([segment[3], segment[4]]);\r\n            break;\r\n        case 'S':\r\n            points.push([segment[3], segment[4]]);\r\n            points.push([segment[1], segment[2]]);\r\n            break;\r\n        case 'H':\r\n            points.push([segment[1], segment[1]]);\r\n            break;\r\n        case 'V':\r\n            points.push([segment[1], segment[1]]);\r\n            break;\r\n        default:\r\n    }\r\n    return points;\r\n}\r\nvar formatPath = function (fromPath, toPath) {\r\n    if (fromPath.length <= 1) {\r\n        return fromPath;\r\n    }\r\n    var points;\r\n    for (var i = 0; i < toPath.length; i++) {\r\n        if (fromPath[i][0] !== toPath[i][0]) {\r\n            // 获取fromPath的pathSegment的端点，根据toPath的指令对其改造\r\n            points = _getSegmentPoints(fromPath[i]);\r\n            switch (toPath[i][0]) {\r\n                case 'M':\r\n                    fromPath[i] = ['M'].concat(points[0]);\r\n                    break;\r\n                case 'L':\r\n                    fromPath[i] = ['L'].concat(points[0]);\r\n                    break;\r\n                case 'A':\r\n                    fromPath[i] = [].concat(toPath[i]);\r\n                    fromPath[i][6] = points[0][0];\r\n                    fromPath[i][7] = points[0][1];\r\n                    break;\r\n                case 'Q':\r\n                    if (points.length < 2) {\r\n                        if (i > 0) {\r\n                            points = _splitPoints(points, fromPath[i - 1], 1);\r\n                        }\r\n                        else {\r\n                            fromPath[i] = toPath[i];\r\n                            break;\r\n                        }\r\n                    }\r\n                    fromPath[i] = ['Q'].concat(points.reduce(function (arr, i) {\r\n                        return arr.concat(i);\r\n                    }, []));\r\n                    break;\r\n                case 'T':\r\n                    fromPath[i] = ['T'].concat(points[0]);\r\n                    break;\r\n                case 'C':\r\n                    if (points.length < 3) {\r\n                        if (i > 0) {\r\n                            points = _splitPoints(points, fromPath[i - 1], 2);\r\n                        }\r\n                        else {\r\n                            fromPath[i] = toPath[i];\r\n                            break;\r\n                        }\r\n                    }\r\n                    fromPath[i] = ['C'].concat(points.reduce(function (arr, i) {\r\n                        return arr.concat(i);\r\n                    }, []));\r\n                    break;\r\n                case 'S':\r\n                    if (points.length < 2) {\r\n                        if (i > 0) {\r\n                            points = _splitPoints(points, fromPath[i - 1], 1);\r\n                        }\r\n                        else {\r\n                            fromPath[i] = toPath[i];\r\n                            break;\r\n                        }\r\n                    }\r\n                    fromPath[i] = ['S'].concat(points.reduce(function (arr, i) {\r\n                        return arr.concat(i);\r\n                    }, []));\r\n                    break;\r\n                default:\r\n                    fromPath[i] = toPath[i];\r\n            }\r\n        }\r\n    }\r\n    return fromPath;\r\n};\r\nexports.formatPath = formatPath;\r\n//# sourceMappingURL=path.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//# sourceMappingURL=types.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//# sourceMappingURL=interfaces.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar GraphEvent = /** @class */ (function () {\r\n    function GraphEvent(type, event) {\r\n        /**\r\n         * 是否允许冒泡\r\n         * @type {boolean}\r\n         */\r\n        this.bubbles = true;\r\n        /**\r\n         * 触发对象\r\n         * @type {object}\r\n         */\r\n        this.target = null;\r\n        /**\r\n         * 监听对象\r\n         * @type {object}\r\n         */\r\n        this.currentTarget = null;\r\n        /**\r\n         * 委托对象\r\n         * @type {object}\r\n         */\r\n        this.delegateTarget = null;\r\n        /**\r\n         * 委托事件监听对象的代理对象，即 ev.delegateObject = ev.currentTarget.get('delegateObject')\r\n         * @type {object}\r\n         */\r\n        this.delegateObject = null;\r\n        /**\r\n         * 是否阻止了原生事件\r\n         * @type {boolean}\r\n         */\r\n        this.defaultPrevented = false;\r\n        /**\r\n         * 是否阻止传播（向上冒泡）\r\n         * @type {boolean}\r\n         */\r\n        this.propagationStopped = false;\r\n        /**\r\n         * 触发事件的图形\r\n         * @type {IShape}\r\n         */\r\n        this.shape = null;\r\n        /**\r\n         * 开始触发事件的图形\r\n         * @type {IShape}\r\n         */\r\n        this.fromShape = null;\r\n        /**\r\n         * 事件结束时的触发图形\r\n         * @type {IShape}\r\n         */\r\n        this.toShape = null;\r\n        // 触发事件的路径\r\n        this.propagationPath = [];\r\n        this.type = type;\r\n        this.name = type;\r\n        this.originalEvent = event;\r\n        this.timeStamp = event.timeStamp;\r\n    }\r\n    /**\r\n     * 阻止浏览器默认的行为\r\n     */\r\n    GraphEvent.prototype.preventDefault = function () {\r\n        this.defaultPrevented = true;\r\n        if (this.originalEvent.preventDefault) {\r\n            this.originalEvent.preventDefault();\r\n        }\r\n    };\r\n    /**\r\n     * 阻止冒泡\r\n     */\r\n    GraphEvent.prototype.stopPropagation = function () {\r\n        this.propagationStopped = true;\r\n    };\r\n    GraphEvent.prototype.toString = function () {\r\n        var type = this.type;\r\n        return \"[Event (type=\" + type + \")]\";\r\n    };\r\n    GraphEvent.prototype.save = function () { };\r\n    GraphEvent.prototype.restore = function () { };\r\n    return GraphEvent;\r\n}());\r\nexports.default = GraphEvent;\r\n//# sourceMappingURL=graph-event.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar event_emitter_1 = require(\"@antv/event-emitter\");\r\nvar util_1 = require(\"../util/util\");\r\nvar Base = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Base, _super);\r\n    function Base(cfg) {\r\n        var _this = _super.call(this) || this;\r\n        /**\r\n         * 是否被销毁\r\n         * @type {boolean}\r\n         */\r\n        _this.destroyed = false;\r\n        var defaultCfg = _this.getDefaultCfg();\r\n        _this.cfg = util_1.mix(defaultCfg, cfg);\r\n        return _this;\r\n    }\r\n    /**\r\n     * @protected\r\n     * 默认的配置项\r\n     * @returns {object} 默认的配置项\r\n     */\r\n    Base.prototype.getDefaultCfg = function () {\r\n        return {};\r\n    };\r\n    // 实现接口的方法\r\n    Base.prototype.get = function (name) {\r\n        return this.cfg[name];\r\n    };\r\n    // 实现接口的方法\r\n    Base.prototype.set = function (name, value) {\r\n        this.cfg[name] = value;\r\n    };\r\n    // 实现接口的方法\r\n    Base.prototype.destroy = function () {\r\n        this.cfg = {\r\n            destroyed: true,\r\n        };\r\n        this.off();\r\n        this.destroyed = true;\r\n    };\r\n    return Base;\r\n}(event_emitter_1.default));\r\nexports.default = Base;\r\n//# sourceMappingURL=base.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isAllowCapture = exports.isParent = exports.isBrowser = exports.removeFromArray = void 0;\r\nfunction removeFromArray(arr, obj) {\r\n    var index = arr.indexOf(obj);\r\n    if (index !== -1) {\r\n        arr.splice(index, 1);\r\n    }\r\n}\r\nexports.removeFromArray = removeFromArray;\r\nexports.isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\r\nvar util_1 = require(\"@antv/util\");\r\nObject.defineProperty(exports, \"isNil\", { enumerable: true, get: function () { return util_1.isNil; } });\r\nObject.defineProperty(exports, \"isFunction\", { enumerable: true, get: function () { return util_1.isFunction; } });\r\nObject.defineProperty(exports, \"isString\", { enumerable: true, get: function () { return util_1.isString; } });\r\nObject.defineProperty(exports, \"isObject\", { enumerable: true, get: function () { return util_1.isObject; } });\r\nObject.defineProperty(exports, \"isArray\", { enumerable: true, get: function () { return util_1.isArray; } });\r\nObject.defineProperty(exports, \"mix\", { enumerable: true, get: function () { return util_1.mix; } });\r\nObject.defineProperty(exports, \"each\", { enumerable: true, get: function () { return util_1.each; } });\r\nObject.defineProperty(exports, \"upperFirst\", { enumerable: true, get: function () { return util_1.upperFirst; } });\r\n// 是否元素的父容器\r\nfunction isParent(container, shape) {\r\n    // 所有 shape 都是 canvas 的子元素\r\n    if (container.isCanvas()) {\r\n        return true;\r\n    }\r\n    var parent = shape.getParent();\r\n    var isParent = false;\r\n    while (parent) {\r\n        if (parent === container) {\r\n            isParent = true;\r\n            break;\r\n        }\r\n        parent = parent.getParent();\r\n    }\r\n    return isParent;\r\n}\r\nexports.isParent = isParent;\r\nfunction isAllowCapture(element) {\r\n    // @ts-ignore\r\n    return element.cfg.visible && element.cfg.capture;\r\n}\r\nexports.isAllowCapture = isAllowCapture;\r\n//# sourceMappingURL=util.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar detect_browser_1 = require(\"detect-browser\");\r\nvar container_1 = require(\"./container\");\r\nvar util_1 = require(\"../util/util\");\r\nvar timeline_1 = require(\"../animate/timeline\");\r\nvar event_contoller_1 = require(\"../event/event-contoller\");\r\nvar PX_SUFFIX = 'px';\r\nvar browser = detect_browser_1.detect();\r\nvar isFirefox = browser && browser.name === 'firefox';\r\nvar Canvas = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Canvas, _super);\r\n    function Canvas(cfg) {\r\n        var _this = _super.call(this, cfg) || this;\r\n        _this.initContainer();\r\n        _this.initDom();\r\n        _this.initEvents();\r\n        _this.initTimeline();\r\n        return _this;\r\n    }\r\n    Canvas.prototype.getDefaultCfg = function () {\r\n        var cfg = _super.prototype.getDefaultCfg.call(this);\r\n        // set default cursor style for canvas\r\n        cfg['cursor'] = 'default';\r\n        // CSS transform 目前尚未经过长时间验证，为了避免影响上层业务，默认关闭，上层按需开启\r\n        cfg['supportCSSTransform'] = false;\r\n        return cfg;\r\n    };\r\n    /**\r\n     * @protected\r\n     * 初始化容器\r\n     */\r\n    Canvas.prototype.initContainer = function () {\r\n        var container = this.get('container');\r\n        if (util_1.isString(container)) {\r\n            container = document.getElementById(container);\r\n            this.set('container', container);\r\n        }\r\n    };\r\n    /**\r\n     * @protected\r\n     * 初始化 DOM\r\n     */\r\n    Canvas.prototype.initDom = function () {\r\n        var el = this.createDom();\r\n        this.set('el', el);\r\n        // 附加到容器\r\n        var container = this.get('container');\r\n        container.appendChild(el);\r\n        // 设置初始宽度\r\n        this.setDOMSize(this.get('width'), this.get('height'));\r\n    };\r\n    /**\r\n     * @protected\r\n     * 初始化绑定的事件\r\n     */\r\n    Canvas.prototype.initEvents = function () {\r\n        var eventController = new event_contoller_1.default({\r\n            canvas: this,\r\n        });\r\n        eventController.init();\r\n        this.set('eventController', eventController);\r\n    };\r\n    /**\r\n     * @protected\r\n     * 初始化时间轴\r\n     */\r\n    Canvas.prototype.initTimeline = function () {\r\n        var timeline = new timeline_1.default(this);\r\n        this.set('timeline', timeline);\r\n    };\r\n    /**\r\n     * @protected\r\n     * 修改画布对应的 DOM 的大小\r\n     * @param {number} width  宽度\r\n     * @param {number} height 高度\r\n     */\r\n    Canvas.prototype.setDOMSize = function (width, height) {\r\n        var el = this.get('el');\r\n        if (util_1.isBrowser) {\r\n            el.style.width = width + PX_SUFFIX;\r\n            el.style.height = height + PX_SUFFIX;\r\n        }\r\n    };\r\n    // 实现接口\r\n    Canvas.prototype.changeSize = function (width, height) {\r\n        this.setDOMSize(width, height);\r\n        this.set('width', width);\r\n        this.set('height', height);\r\n        this.onCanvasChange('changeSize');\r\n    };\r\n    /**\r\n     * 获取当前的渲染引擎\r\n     * @return {Renderer} 返回当前的渲染引擎\r\n     */\r\n    Canvas.prototype.getRenderer = function () {\r\n        return this.get('renderer');\r\n    };\r\n    /**\r\n     * 获取画布的 cursor 样式\r\n     * @return {Cursor}\r\n     */\r\n    Canvas.prototype.getCursor = function () {\r\n        return this.get('cursor');\r\n    };\r\n    /**\r\n     * 设置画布的 cursor 样式\r\n     * @param {Cursor} cursor  cursor 样式\r\n     */\r\n    Canvas.prototype.setCursor = function (cursor) {\r\n        this.set('cursor', cursor);\r\n        var el = this.get('el');\r\n        if (util_1.isBrowser && el) {\r\n            // 直接设置样式，不等待鼠标移动时再设置\r\n            el.style.cursor = cursor;\r\n        }\r\n    };\r\n    // 实现接口\r\n    Canvas.prototype.getPointByEvent = function (ev) {\r\n        var supportCSSTransform = this.get('supportCSSTransform');\r\n        if (supportCSSTransform) {\r\n            // For Firefox <= 38\r\n            if (isFirefox && !util_1.isNil(ev.layerX) && ev.layerX !== ev.offsetX) {\r\n                return {\r\n                    x: ev.layerX,\r\n                    y: ev.layerY,\r\n                };\r\n            }\r\n            if (!util_1.isNil(ev.offsetX)) {\r\n                // For IE6+, Firefox >= 39, Chrome, Safari, Opera\r\n                return {\r\n                    x: ev.offsetX,\r\n                    y: ev.offsetY,\r\n                };\r\n            }\r\n        }\r\n        // should calculate by self for other cases, like Safari in ios\r\n        // TODO: support CSS transform\r\n        var _a = this.getClientByEvent(ev), clientX = _a.x, clientY = _a.y;\r\n        return this.getPointByClient(clientX, clientY);\r\n    };\r\n    // 获取 touch 事件的 clientX 和 clientY 需要单独处理\r\n    Canvas.prototype.getClientByEvent = function (ev) {\r\n        var clientInfo = ev;\r\n        if (ev.touches) {\r\n            if (ev.type === 'touchend') {\r\n                clientInfo = ev.changedTouches[0];\r\n            }\r\n            else {\r\n                clientInfo = ev.touches[0];\r\n            }\r\n        }\r\n        return {\r\n            x: clientInfo.clientX,\r\n            y: clientInfo.clientY,\r\n        };\r\n    };\r\n    // 实现接口\r\n    Canvas.prototype.getPointByClient = function (clientX, clientY) {\r\n        var el = this.get('el');\r\n        var bbox = el.getBoundingClientRect();\r\n        return {\r\n            x: clientX - bbox.left,\r\n            y: clientY - bbox.top,\r\n        };\r\n    };\r\n    // 实现接口\r\n    Canvas.prototype.getClientByPoint = function (x, y) {\r\n        var el = this.get('el');\r\n        var bbox = el.getBoundingClientRect();\r\n        return {\r\n            x: x + bbox.left,\r\n            y: y + bbox.top,\r\n        };\r\n    };\r\n    // 实现接口\r\n    Canvas.prototype.draw = function () { };\r\n    /**\r\n     * @protected\r\n     * 销毁 DOM 容器\r\n     */\r\n    Canvas.prototype.removeDom = function () {\r\n        var el = this.get('el');\r\n        el.parentNode.removeChild(el);\r\n    };\r\n    /**\r\n     * @protected\r\n     * 清理所有的事件\r\n     */\r\n    Canvas.prototype.clearEvents = function () {\r\n        var eventController = this.get('eventController');\r\n        eventController.destroy();\r\n    };\r\n    Canvas.prototype.isCanvas = function () {\r\n        return true;\r\n    };\r\n    Canvas.prototype.getParent = function () {\r\n        return null;\r\n    };\r\n    Canvas.prototype.destroy = function () {\r\n        var timeline = this.get('timeline');\r\n        if (this.get('destroyed')) {\r\n            return;\r\n        }\r\n        this.clear();\r\n        // 同初始化时相反顺序调用\r\n        if (timeline) {\r\n            // 画布销毁时自动停止动画\r\n            timeline.stop();\r\n        }\r\n        this.clearEvents();\r\n        this.removeDom();\r\n        _super.prototype.destroy.call(this);\r\n    };\r\n    return Canvas;\r\n}(container_1.default));\r\nexports.default = Canvas;\r\n//# sourceMappingURL=canvas.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar element_1 = require(\"./element\");\r\nvar util_1 = require(\"../util/util\");\r\nvar SHAPE_MAP = {};\r\nvar INDEX = '_INDEX';\r\n/**\r\n * 设置 canvas\r\n * @param {IElement} element 元素\r\n * @param {ICanvas}  canvas  画布\r\n */\r\nfunction setCanvas(element, canvas) {\r\n    element.set('canvas', canvas);\r\n    if (element.isGroup()) {\r\n        var children = element.get('children');\r\n        if (children.length) {\r\n            children.forEach(function (child) {\r\n                setCanvas(child, canvas);\r\n            });\r\n        }\r\n    }\r\n}\r\n/**\r\n * 设置 timeline\r\n * @param {IElement} element  元素\r\n * @param {Timeline} timeline 时间轴\r\n */\r\nfunction setTimeline(element, timeline) {\r\n    element.set('timeline', timeline);\r\n    if (element.isGroup()) {\r\n        var children = element.get('children');\r\n        if (children.length) {\r\n            children.forEach(function (child) {\r\n                setTimeline(child, timeline);\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction contains(container, element) {\r\n    var children = container.getChildren();\r\n    return children.indexOf(element) >= 0;\r\n}\r\nfunction removeChild(container, element, destroy) {\r\n    if (destroy === void 0) { destroy = true; }\r\n    // 不再调用 element.remove() 方法，会出现循环调用\r\n    if (destroy) {\r\n        element.destroy();\r\n    }\r\n    else {\r\n        element.set('parent', null);\r\n        element.set('canvas', null);\r\n    }\r\n    util_1.removeFromArray(container.getChildren(), element);\r\n}\r\nfunction getComparer(compare) {\r\n    return function (left, right) {\r\n        var result = compare(left, right);\r\n        return result === 0 ? left[INDEX] - right[INDEX] : result;\r\n    };\r\n}\r\nvar Container = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Container, _super);\r\n    function Container() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Container.prototype.isCanvas = function () {\r\n        return false;\r\n    };\r\n    // 根据子节点确定 BBox\r\n    Container.prototype.getBBox = function () {\r\n        // 所有的值可能在画布的可视区外\r\n        var minX = Infinity;\r\n        var maxX = -Infinity;\r\n        var minY = Infinity;\r\n        var maxY = -Infinity;\r\n        // 将可见元素、图形以及不为空的图形分组筛选出来，用于包围盒合并\r\n        var children = this.getChildren().filter(function (child) {\r\n            return child.get('visible') && (!child.isGroup() || (child.isGroup() && child.getChildren().length > 0));\r\n        });\r\n        if (children.length > 0) {\r\n            util_1.each(children, function (child) {\r\n                var _a = child.getBBox(), childMinX = _a.minX, childMaxX = _a.maxX, childMinY = _a.minY, childMaxY = _a.maxY;\r\n                if (childMinX < minX) {\r\n                    minX = childMinX;\r\n                }\r\n                if (childMaxX > maxX) {\r\n                    maxX = childMaxX;\r\n                }\r\n                if (childMinY < minY) {\r\n                    minY = childMinY;\r\n                }\r\n                if (childMaxY > maxY) {\r\n                    maxY = childMaxY;\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            minX = 0;\r\n            maxX = 0;\r\n            minY = 0;\r\n            maxY = 0;\r\n        }\r\n        var box = {\r\n            x: minX,\r\n            y: minY,\r\n            minX: minX,\r\n            minY: minY,\r\n            maxX: maxX,\r\n            maxY: maxY,\r\n            width: maxX - minX,\r\n            height: maxY - minY,\r\n        };\r\n        return box;\r\n    };\r\n    // 获取画布的包围盒\r\n    Container.prototype.getCanvasBBox = function () {\r\n        var minX = Infinity;\r\n        var maxX = -Infinity;\r\n        var minY = Infinity;\r\n        var maxY = -Infinity;\r\n        // 将可见元素、图形以及不为空的图形分组筛选出来，用于包围盒合并\r\n        var children = this.getChildren().filter(function (child) {\r\n            return child.get('visible') && (!child.isGroup() || (child.isGroup() && child.getChildren().length > 0));\r\n        });\r\n        if (children.length > 0) {\r\n            util_1.each(children, function (child) {\r\n                var _a = child.getCanvasBBox(), childMinX = _a.minX, childMaxX = _a.maxX, childMinY = _a.minY, childMaxY = _a.maxY;\r\n                if (childMinX < minX) {\r\n                    minX = childMinX;\r\n                }\r\n                if (childMaxX > maxX) {\r\n                    maxX = childMaxX;\r\n                }\r\n                if (childMinY < minY) {\r\n                    minY = childMinY;\r\n                }\r\n                if (childMaxY > maxY) {\r\n                    maxY = childMaxY;\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            minX = 0;\r\n            maxX = 0;\r\n            minY = 0;\r\n            maxY = 0;\r\n        }\r\n        var box = {\r\n            x: minX,\r\n            y: minY,\r\n            minX: minX,\r\n            minY: minY,\r\n            maxX: maxX,\r\n            maxY: maxY,\r\n            width: maxX - minX,\r\n            height: maxY - minY,\r\n        };\r\n        return box;\r\n    };\r\n    Container.prototype.getDefaultCfg = function () {\r\n        var cfg = _super.prototype.getDefaultCfg.call(this);\r\n        cfg['children'] = [];\r\n        return cfg;\r\n    };\r\n    Container.prototype.onAttrChange = function (name, value, originValue) {\r\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\r\n        if (name === 'matrix') {\r\n            var totalMatrix = this.getTotalMatrix();\r\n            this._applyChildrenMarix(totalMatrix);\r\n        }\r\n    };\r\n    // 不但应用到自己身上还要应用于子元素\r\n    Container.prototype.applyMatrix = function (matrix) {\r\n        var preTotalMatrix = this.getTotalMatrix();\r\n        _super.prototype.applyMatrix.call(this, matrix);\r\n        var totalMatrix = this.getTotalMatrix();\r\n        // totalMatrix 没有发生变化时，这里仅考虑两者都为 null 时\r\n        // 不继续向下传递矩阵\r\n        if (totalMatrix === preTotalMatrix) {\r\n            return;\r\n        }\r\n        this._applyChildrenMarix(totalMatrix);\r\n    };\r\n    // 在子元素上设置矩阵\r\n    Container.prototype._applyChildrenMarix = function (totalMatrix) {\r\n        var children = this.getChildren();\r\n        util_1.each(children, function (child) {\r\n            child.applyMatrix(totalMatrix);\r\n        });\r\n    };\r\n    // 兼容老版本的接口\r\n    Container.prototype.addShape = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var type = args[0];\r\n        var cfg = args[1];\r\n        if (util_1.isObject(type)) {\r\n            cfg = type;\r\n        }\r\n        else {\r\n            cfg['type'] = type;\r\n        }\r\n        var shapeType = SHAPE_MAP[cfg.type];\r\n        if (!shapeType) {\r\n            shapeType = util_1.upperFirst(cfg.type);\r\n            SHAPE_MAP[cfg.type] = shapeType;\r\n        }\r\n        var ShapeBase = this.getShapeBase();\r\n        var shape = new ShapeBase[shapeType](cfg);\r\n        this.add(shape);\r\n        return shape;\r\n    };\r\n    Container.prototype.addGroup = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var groupClass = args[0], cfg = args[1];\r\n        var group;\r\n        if (util_1.isFunction(groupClass)) {\r\n            if (cfg) {\r\n                group = new groupClass(cfg);\r\n            }\r\n            else {\r\n                group = new groupClass({\r\n                    // canvas,\r\n                    parent: this,\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            var tmpCfg = groupClass || {};\r\n            var TmpGroupClass = this.getGroupBase();\r\n            group = new TmpGroupClass(tmpCfg);\r\n        }\r\n        this.add(group);\r\n        return group;\r\n    };\r\n    Container.prototype.getCanvas = function () {\r\n        var canvas;\r\n        if (this.isCanvas()) {\r\n            canvas = this;\r\n        }\r\n        else {\r\n            canvas = this.get('canvas');\r\n        }\r\n        return canvas;\r\n    };\r\n    Container.prototype.getShape = function (x, y, ev) {\r\n        // 如果不支持拾取，则直接返回\r\n        if (!util_1.isAllowCapture(this)) {\r\n            return null;\r\n        }\r\n        var children = this.getChildren();\r\n        var shape;\r\n        // 如果容器是 group\r\n        if (!this.isCanvas()) {\r\n            var v = [x, y, 1];\r\n            // 将 x, y 转换成对应于 group 的局部坐标\r\n            v = this.invertFromMatrix(v);\r\n            if (!this.isClipped(v[0], v[1])) {\r\n                shape = this._findShape(children, v[0], v[1], ev);\r\n            }\r\n        }\r\n        else {\r\n            shape = this._findShape(children, x, y, ev);\r\n        }\r\n        return shape;\r\n    };\r\n    Container.prototype._findShape = function (children, x, y, ev) {\r\n        var shape = null;\r\n        for (var i = children.length - 1; i >= 0; i--) {\r\n            var child = children[i];\r\n            if (util_1.isAllowCapture(child)) {\r\n                if (child.isGroup()) {\r\n                    shape = child.getShape(x, y, ev);\r\n                }\r\n                else if (child.isHit(x, y)) {\r\n                    shape = child;\r\n                }\r\n            }\r\n            if (shape) {\r\n                break;\r\n            }\r\n        }\r\n        return shape;\r\n    };\r\n    Container.prototype.add = function (element) {\r\n        var canvas = this.getCanvas();\r\n        var children = this.getChildren();\r\n        var timeline = this.get('timeline');\r\n        var preParent = element.getParent();\r\n        if (preParent) {\r\n            removeChild(preParent, element, false);\r\n        }\r\n        element.set('parent', this);\r\n        if (canvas) {\r\n            setCanvas(element, canvas);\r\n        }\r\n        if (timeline) {\r\n            setTimeline(element, timeline);\r\n        }\r\n        children.push(element);\r\n        element.onCanvasChange('add');\r\n        this._applyElementMatrix(element);\r\n    };\r\n    // 将当前容器的矩阵应用到子元素\r\n    Container.prototype._applyElementMatrix = function (element) {\r\n        var totalMatrix = this.getTotalMatrix();\r\n        // 添加图形或者分组时，需要把当前图元的矩阵设置进去\r\n        if (totalMatrix) {\r\n            element.applyMatrix(totalMatrix);\r\n        }\r\n    };\r\n    Container.prototype.getChildren = function () {\r\n        return this.get('children');\r\n    };\r\n    Container.prototype.sort = function () {\r\n        var children = this.getChildren();\r\n        // 稳定排序\r\n        util_1.each(children, function (child, index) {\r\n            child[INDEX] = index;\r\n            return child;\r\n        });\r\n        children.sort(getComparer(function (obj1, obj2) {\r\n            return obj1.get('zIndex') - obj2.get('zIndex');\r\n        }));\r\n        this.onCanvasChange('sort');\r\n    };\r\n    Container.prototype.clear = function () {\r\n        this.set('clearing', true);\r\n        if (this.destroyed) {\r\n            return;\r\n        }\r\n        var children = this.getChildren();\r\n        for (var i = children.length - 1; i >= 0; i--) {\r\n            children[i].destroy(); // 销毁子元素\r\n        }\r\n        this.set('children', []);\r\n        this.onCanvasChange('clear');\r\n        this.set('clearing', false);\r\n    };\r\n    Container.prototype.destroy = function () {\r\n        if (this.get('destroyed')) {\r\n            return;\r\n        }\r\n        this.clear();\r\n        _super.prototype.destroy.call(this);\r\n    };\r\n    /**\r\n     * 获取第一个子元素\r\n     * @return {IElement} 第一个元素\r\n     */\r\n    Container.prototype.getFirst = function () {\r\n        return this.getChildByIndex(0);\r\n    };\r\n    /**\r\n     * 获取最后一个子元素\r\n     * @return {IElement} 元素\r\n     */\r\n    Container.prototype.getLast = function () {\r\n        var children = this.getChildren();\r\n        return this.getChildByIndex(children.length - 1);\r\n    };\r\n    /**\r\n     * 根据索引获取子元素\r\n     * @return {IElement} 第一个元素\r\n     */\r\n    Container.prototype.getChildByIndex = function (index) {\r\n        var children = this.getChildren();\r\n        return children[index];\r\n    };\r\n    /**\r\n     * 子元素的数量\r\n     * @return {number} 子元素数量\r\n     */\r\n    Container.prototype.getCount = function () {\r\n        var children = this.getChildren();\r\n        return children.length;\r\n    };\r\n    /**\r\n     * 是否包含对应元素\r\n     * @param {IElement} element 元素\r\n     * @return {boolean}\r\n     */\r\n    Container.prototype.contain = function (element) {\r\n        var children = this.getChildren();\r\n        return children.indexOf(element) > -1;\r\n    };\r\n    /**\r\n     * 移除对应子元素\r\n     * @param {IElement} element 子元素\r\n     * @param {boolean} destroy 是否销毁子元素，默认为 true\r\n     */\r\n    Container.prototype.removeChild = function (element, destroy) {\r\n        if (destroy === void 0) { destroy = true; }\r\n        if (this.contain(element)) {\r\n            element.remove(destroy);\r\n        }\r\n    };\r\n    /**\r\n     * 查找所有匹配的元素\r\n     * @param  {ElementFilterFn}   fn  匹配函数\r\n     * @return {IElement[]} 元素数组\r\n     */\r\n    Container.prototype.findAll = function (fn) {\r\n        var rst = [];\r\n        var children = this.getChildren();\r\n        util_1.each(children, function (element) {\r\n            if (fn(element)) {\r\n                rst.push(element);\r\n            }\r\n            if (element.isGroup()) {\r\n                rst = rst.concat(element.findAll(fn));\r\n            }\r\n        });\r\n        return rst;\r\n    };\r\n    /**\r\n     * 查找元素，找到第一个返回\r\n     * @param  {ElementFilterFn} fn    匹配函数\r\n     * @return {IElement|null} 元素，可以为空\r\n     */\r\n    Container.prototype.find = function (fn) {\r\n        var rst = null;\r\n        var children = this.getChildren();\r\n        util_1.each(children, function (element) {\r\n            if (fn(element)) {\r\n                rst = element;\r\n            }\r\n            else if (element.isGroup()) {\r\n                rst = element.find(fn);\r\n            }\r\n            if (rst) {\r\n                return false;\r\n            }\r\n        });\r\n        return rst;\r\n    };\r\n    /**\r\n     * 根据 ID 查找元素\r\n     * @param {string} id 元素 id\r\n     * @return {IElement|null} 元素\r\n     */\r\n    Container.prototype.findById = function (id) {\r\n        return this.find(function (element) {\r\n            return element.get('id') === id;\r\n        });\r\n    };\r\n    /**\r\n     * 该方法即将废弃，不建议使用\r\n     * 根据 className 查找元素\r\n     * TODO: 该方式定义暂时只给 G6 3.3 以后的版本使用，待 G6 中的 findByClassName 方法移除后，G 也需要同步移除\r\n     * @param {string} className 元素 className\r\n     * @return {IElement | null} 元素\r\n     */\r\n    Container.prototype.findByClassName = function (className) {\r\n        return this.find(function (element) {\r\n            return element.get('className') === className;\r\n        });\r\n    };\r\n    /**\r\n     * 根据 name 查找元素列表\r\n     * @param {string}      name 元素名称\r\n     * @return {IElement[]} 元素\r\n     */\r\n    Container.prototype.findAllByName = function (name) {\r\n        return this.findAll(function (element) {\r\n            return element.get('name') === name;\r\n        });\r\n    };\r\n    return Container;\r\n}(element_1.default));\r\nexports.default = Container;\r\n//# sourceMappingURL=container.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar util_1 = require(\"@antv/util\");\r\nvar matrix_util_1 = require(\"@antv/matrix-util\");\r\nvar util_2 = require(\"../util/util\");\r\nvar matrix_1 = require(\"../util/matrix\");\r\nvar base_1 = require(\"./base\");\r\nvar transform = matrix_util_1.ext.transform;\r\nvar MATRIX = 'matrix';\r\nvar CLONE_CFGS = ['zIndex', 'capture', 'visible', 'type'];\r\n// 可以在 toAttrs 中设置，但不属于绘图属性的字段\r\nvar RESERVED_PORPS = ['repeat'];\r\nvar DELEGATION_SPLIT = ':';\r\nvar WILDCARD = '*';\r\n// 需要考虑数组嵌套数组的场景\r\n// 数组嵌套对象的场景不考虑\r\nfunction _cloneArrayAttr(arr) {\r\n    var result = [];\r\n    for (var i = 0; i < arr.length; i++) {\r\n        if (util_1.isArray(arr[i])) {\r\n            result.push([].concat(arr[i]));\r\n        }\r\n        else {\r\n            result.push(arr[i]);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction getFormatFromAttrs(toAttrs, shape) {\r\n    var fromAttrs = {};\r\n    var attrs = shape.attrs;\r\n    for (var k in toAttrs) {\r\n        fromAttrs[k] = attrs[k];\r\n    }\r\n    return fromAttrs;\r\n}\r\nfunction getFormatToAttrs(props, shape) {\r\n    var toAttrs = {};\r\n    var attrs = shape.attr();\r\n    util_1.each(props, function (v, k) {\r\n        if (RESERVED_PORPS.indexOf(k) === -1 && !util_1.isEqual(attrs[k], v)) {\r\n            toAttrs[k] = v;\r\n        }\r\n    });\r\n    return toAttrs;\r\n}\r\nfunction checkExistedAttrs(animations, animation) {\r\n    if (animation.onFrame) {\r\n        return animations;\r\n    }\r\n    var startTime = animation.startTime, delay = animation.delay, duration = animation.duration;\r\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n    util_1.each(animations, function (item) {\r\n        // 后一个动画开始执行的时间 < 前一个动画的结束时间 && 后一个动画的执行时间 > 前一个动画的延迟\r\n        if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {\r\n            util_1.each(animation.toAttrs, function (v, k) {\r\n                if (hasOwnProperty.call(item.toAttrs, k)) {\r\n                    delete item.toAttrs[k];\r\n                    delete item.fromAttrs[k];\r\n                }\r\n            });\r\n        }\r\n    });\r\n    return animations;\r\n}\r\nvar Element = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Element, _super);\r\n    function Element(cfg) {\r\n        var _this = _super.call(this, cfg) || this;\r\n        /**\r\n         * @protected\r\n         * 图形属性\r\n         * @type {ShapeAttrs}\r\n         */\r\n        _this.attrs = {};\r\n        var attrs = _this.getDefaultAttrs();\r\n        util_1.mix(attrs, cfg.attrs);\r\n        _this.attrs = attrs;\r\n        _this.initAttrs(attrs);\r\n        _this.initAnimate(); // 初始化动画\r\n        return _this;\r\n    }\r\n    // override\r\n    Element.prototype.getDefaultCfg = function () {\r\n        return {\r\n            visible: true,\r\n            capture: true,\r\n            zIndex: 0,\r\n        };\r\n    };\r\n    /**\r\n     * @protected\r\n     * 获取默认的属相\r\n     */\r\n    Element.prototype.getDefaultAttrs = function () {\r\n        return {\r\n            matrix: this.getDefaultMatrix(),\r\n            opacity: 1,\r\n        };\r\n    };\r\n    /**\r\n     * @protected\r\n     * 一些方法调用会引起画布变化\r\n     * @param {ChangeType} changeType 改变的类型\r\n     */\r\n    Element.prototype.onCanvasChange = function (changeType) { };\r\n    /**\r\n     * @protected\r\n     * 初始化属性，有些属性需要加工\r\n     * @param {object} attrs 属性值\r\n     */\r\n    Element.prototype.initAttrs = function (attrs) { };\r\n    /**\r\n     * @protected\r\n     * 初始化动画\r\n     */\r\n    Element.prototype.initAnimate = function () {\r\n        this.set('animable', true);\r\n        this.set('animating', false);\r\n    };\r\n    Element.prototype.isGroup = function () {\r\n        return false;\r\n    };\r\n    Element.prototype.getParent = function () {\r\n        return this.get('parent');\r\n    };\r\n    Element.prototype.getCanvas = function () {\r\n        return this.get('canvas');\r\n    };\r\n    Element.prototype.attr = function () {\r\n        var _a;\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var name = args[0], value = args[1];\r\n        if (!name)\r\n            return this.attrs;\r\n        if (util_1.isObject(name)) {\r\n            for (var k in name) {\r\n                this.setAttr(k, name[k]);\r\n            }\r\n            this.afterAttrsChange(name);\r\n            return this;\r\n        }\r\n        if (args.length === 2) {\r\n            this.setAttr(name, value);\r\n            this.afterAttrsChange((_a = {},\r\n                _a[name] = value,\r\n                _a));\r\n            return this;\r\n        }\r\n        return this.attrs[name];\r\n    };\r\n    // 是否被裁剪，被裁剪则不显示，不参与拾取\r\n    Element.prototype.isClipped = function (refX, refY) {\r\n        var clip = this.getClip();\r\n        return clip && !clip.isHit(refX, refY);\r\n    };\r\n    /**\r\n     * 内部设置属性值的接口\r\n     * @param {string} name 属性名\r\n     * @param {any} value 属性值\r\n     */\r\n    Element.prototype.setAttr = function (name, value) {\r\n        var originValue = this.attrs[name];\r\n        if (originValue !== value) {\r\n            this.attrs[name] = value;\r\n            this.onAttrChange(name, value, originValue);\r\n        }\r\n    };\r\n    /**\r\n     * @protected\r\n     * 属性值发生改变\r\n     * @param {string} name 属性名\r\n     * @param {any} value 属性值\r\n     * @param {any} originValue 属性值\r\n     */\r\n    Element.prototype.onAttrChange = function (name, value, originValue) {\r\n        if (name === 'matrix') {\r\n            this.set('totalMatrix', null);\r\n        }\r\n    };\r\n    /**\r\n     * 属性更改后需要做的事情\r\n     * @protected\r\n     */\r\n    Element.prototype.afterAttrsChange = function (targetAttrs) {\r\n        if (this.cfg.isClipShape) {\r\n            var applyTo = this.cfg.applyTo;\r\n            if (applyTo) {\r\n                applyTo.onCanvasChange('clip');\r\n            }\r\n        }\r\n        else {\r\n            this.onCanvasChange('attr');\r\n        }\r\n    };\r\n    Element.prototype.show = function () {\r\n        // 不是高频操作直接使用 set\r\n        this.set('visible', true);\r\n        this.onCanvasChange('show');\r\n        return this;\r\n    };\r\n    Element.prototype.hide = function () {\r\n        // 不是高频操作直接使用 set\r\n        this.set('visible', false);\r\n        this.onCanvasChange('hide');\r\n        return this;\r\n    };\r\n    Element.prototype.setZIndex = function (zIndex) {\r\n        this.set('zIndex', zIndex);\r\n        var parent = this.getParent();\r\n        if (parent) {\r\n            // 改变 zIndex 不应该立即触发渲染 (调用 onCanvasChange('zIndex'))，需要经过 sort 再触发\r\n            parent.sort();\r\n        }\r\n        return this;\r\n    };\r\n    Element.prototype.toFront = function () {\r\n        var parent = this.getParent();\r\n        if (!parent) {\r\n            return;\r\n        }\r\n        var children = parent.getChildren();\r\n        var el = this.get('el');\r\n        var index = children.indexOf(this);\r\n        children.splice(index, 1);\r\n        children.push(this);\r\n        this.onCanvasChange('zIndex');\r\n    };\r\n    Element.prototype.toBack = function () {\r\n        var parent = this.getParent();\r\n        if (!parent) {\r\n            return;\r\n        }\r\n        var children = parent.getChildren();\r\n        var el = this.get('el');\r\n        var index = children.indexOf(this);\r\n        children.splice(index, 1);\r\n        children.unshift(this);\r\n        this.onCanvasChange('zIndex');\r\n    };\r\n    Element.prototype.remove = function (destroy) {\r\n        if (destroy === void 0) { destroy = true; }\r\n        var parent = this.getParent();\r\n        if (parent) {\r\n            util_2.removeFromArray(parent.getChildren(), this);\r\n            if (!parent.get('clearing')) {\r\n                // 如果父元素正在清理，当前元素不触发 remove\r\n                this.onCanvasChange('remove');\r\n            }\r\n        }\r\n        else {\r\n            this.onCanvasChange('remove');\r\n        }\r\n        if (destroy) {\r\n            this.destroy();\r\n        }\r\n    };\r\n    Element.prototype.resetMatrix = function () {\r\n        this.attr(MATRIX, this.getDefaultMatrix());\r\n        this.onCanvasChange('matrix');\r\n    };\r\n    Element.prototype.getMatrix = function () {\r\n        return this.attr(MATRIX);\r\n    };\r\n    Element.prototype.setMatrix = function (m) {\r\n        this.attr(MATRIX, m);\r\n        this.onCanvasChange('matrix');\r\n    };\r\n    // 获取总的 matrix\r\n    Element.prototype.getTotalMatrix = function () {\r\n        var totalMatrix = this.cfg.totalMatrix;\r\n        if (!totalMatrix) {\r\n            var currentMatrix = this.attr('matrix');\r\n            var parentMatrix = this.cfg.parentMatrix;\r\n            if (parentMatrix && currentMatrix) {\r\n                totalMatrix = matrix_1.multiplyMatrix(parentMatrix, currentMatrix);\r\n            }\r\n            else {\r\n                totalMatrix = currentMatrix || parentMatrix;\r\n            }\r\n            this.set('totalMatrix', totalMatrix);\r\n        }\r\n        return totalMatrix;\r\n    };\r\n    // 上层分组设置 matrix\r\n    Element.prototype.applyMatrix = function (matrix) {\r\n        var currentMatrix = this.attr('matrix');\r\n        var totalMatrix = null;\r\n        if (matrix && currentMatrix) {\r\n            totalMatrix = matrix_1.multiplyMatrix(matrix, currentMatrix);\r\n        }\r\n        else {\r\n            totalMatrix = currentMatrix || matrix;\r\n        }\r\n        this.set('totalMatrix', totalMatrix);\r\n        this.set('parentMatrix', matrix);\r\n    };\r\n    /**\r\n     * @protected\r\n     * 获取默认的矩阵\r\n     * @returns {number[]|null} 默认的矩阵\r\n     */\r\n    Element.prototype.getDefaultMatrix = function () {\r\n        return null;\r\n    };\r\n    // 将向量应用设置的矩阵\r\n    Element.prototype.applyToMatrix = function (v) {\r\n        var matrix = this.attr('matrix');\r\n        if (matrix) {\r\n            return matrix_1.multiplyVec2(matrix, v);\r\n        }\r\n        return v;\r\n    };\r\n    // 根据设置的矩阵，将向量转换相对于图形/分组的位置\r\n    Element.prototype.invertFromMatrix = function (v) {\r\n        var matrix = this.attr('matrix');\r\n        if (matrix) {\r\n            var invertMatrix = matrix_1.invert(matrix);\r\n            if (invertMatrix) {\r\n                return matrix_1.multiplyVec2(invertMatrix, v);\r\n            }\r\n        }\r\n        return v;\r\n    };\r\n    // 设置 clip\r\n    Element.prototype.setClip = function (clipCfg) {\r\n        var canvas = this.getCanvas();\r\n        // 应该只设置当前元素的 clip，不应该去修改 clip 本身，方便 clip 被复用\r\n        // TODO: setClip 的传参既 shape 配置，也支持 shape 对象\r\n        // const preShape = this.get('clipShape');\r\n        // if (preShape) {\r\n        //   // 将之前的 clipShape 销毁\r\n        //   preShape.destroy();\r\n        // }\r\n        var clipShape = null;\r\n        // 如果配置项为 null，则不移除 clipShape\r\n        if (clipCfg) {\r\n            var ShapeBase = this.getShapeBase();\r\n            var shapeType = util_1.upperFirst(clipCfg.type);\r\n            var Cons = ShapeBase[shapeType];\r\n            if (Cons) {\r\n                clipShape = new Cons({\r\n                    type: clipCfg.type,\r\n                    isClipShape: true,\r\n                    applyTo: this,\r\n                    attrs: clipCfg.attrs,\r\n                    canvas: canvas,\r\n                });\r\n            }\r\n        }\r\n        this.set('clipShape', clipShape);\r\n        this.onCanvasChange('clip');\r\n        return clipShape;\r\n    };\r\n    Element.prototype.getClip = function () {\r\n        // 高频率调用的地方直接使用 this.cfg.xxx\r\n        var clipShape = this.cfg.clipShape;\r\n        // 未设置时返回 Null，保证一致性\r\n        if (!clipShape) {\r\n            return null;\r\n        }\r\n        return clipShape;\r\n    };\r\n    Element.prototype.clone = function () {\r\n        var _this = this;\r\n        var originAttrs = this.attrs;\r\n        var attrs = {};\r\n        util_1.each(originAttrs, function (i, k) {\r\n            if (util_1.isArray(originAttrs[k])) {\r\n                attrs[k] = _cloneArrayAttr(originAttrs[k]);\r\n            }\r\n            else {\r\n                attrs[k] = originAttrs[k];\r\n            }\r\n        });\r\n        var cons = this.constructor;\r\n        // @ts-ignore\r\n        var clone = new cons({ attrs: attrs });\r\n        util_1.each(CLONE_CFGS, function (cfgName) {\r\n            clone.set(cfgName, _this.get(cfgName));\r\n        });\r\n        return clone;\r\n    };\r\n    Element.prototype.destroy = function () {\r\n        var destroyed = this.destroyed;\r\n        if (destroyed) {\r\n            return;\r\n        }\r\n        this.attrs = {};\r\n        _super.prototype.destroy.call(this);\r\n        // this.onCanvasChange('destroy');\r\n    };\r\n    /**\r\n     * 是否处于动画暂停状态\r\n     * @return {boolean} 是否处于动画暂停状态\r\n     */\r\n    Element.prototype.isAnimatePaused = function () {\r\n        return this.get('_pause').isPaused;\r\n    };\r\n    /**\r\n     * 执行动画，支持多种函数签名\r\n     * 1. animate(toAttrs: ElementAttrs, duration: number, easing?: string, callback?: () => void, delay?: number)\r\n     * 2. animate(onFrame: OnFrame, duration: number, easing?: string, callback?: () => void, delay?: number)\r\n     * 3. animate(toAttrs: ElementAttrs, cfg: AnimateCfg)\r\n     * 4. animate(onFrame: OnFrame, cfg: AnimateCfg)\r\n     * 各个参数的含义为:\r\n     *   toAttrs  动画最终状态\r\n     *   onFrame  自定义帧动画函数\r\n     *   duration 动画执行时间\r\n     *   easing   动画缓动效果\r\n     *   callback 动画执行后的回调\r\n     *   delay    动画延迟时间\r\n     */\r\n    Element.prototype.animate = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (!this.get('timeline') && !this.get('canvas')) {\r\n            return;\r\n        }\r\n        this.set('animating', true);\r\n        var timeline = this.get('timeline');\r\n        if (!timeline) {\r\n            timeline = this.get('canvas').get('timeline');\r\n            this.set('timeline', timeline);\r\n        }\r\n        var animations = this.get('animations') || [];\r\n        // 初始化 tick\r\n        if (!timeline.timer) {\r\n            timeline.initTimer();\r\n        }\r\n        var toAttrs = args[0], duration = args[1], _a = args[2], easing = _a === void 0 ? 'easeLinear' : _a, _b = args[3], callback = _b === void 0 ? util_1.noop : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;\r\n        var onFrame;\r\n        var repeat;\r\n        var pauseCallback;\r\n        var resumeCallback;\r\n        var animateCfg;\r\n        // 第二个参数，既可以是动画最终状态 toAttrs，也可以是自定义帧动画函数 onFrame\r\n        if (util_1.isFunction(toAttrs)) {\r\n            onFrame = toAttrs;\r\n            toAttrs = {};\r\n        }\r\n        else if (util_1.isObject(toAttrs) && toAttrs.onFrame) {\r\n            // 兼容 3.0 中的写法，onFrame 和 repeat 可在 toAttrs 中设置\r\n            onFrame = toAttrs.onFrame;\r\n            repeat = toAttrs.repeat;\r\n        }\r\n        // 第二个参数，既可以是执行时间 duration，也可以是动画参数 animateCfg\r\n        if (util_1.isObject(duration)) {\r\n            animateCfg = duration;\r\n            duration = animateCfg.duration;\r\n            easing = animateCfg.easing || 'easeLinear';\r\n            delay = animateCfg.delay || 0;\r\n            // animateCfg 中的设置优先级更高\r\n            repeat = animateCfg.repeat || repeat || false;\r\n            callback = animateCfg.callback || util_1.noop;\r\n            pauseCallback = animateCfg.pauseCallback || util_1.noop;\r\n            resumeCallback = animateCfg.resumeCallback || util_1.noop;\r\n        }\r\n        else {\r\n            // 第四个参数，既可以是回调函数 callback，也可以是延迟时间 delay\r\n            if (util_1.isNumber(callback)) {\r\n                delay = callback;\r\n                callback = null;\r\n            }\r\n            // 第三个参数，既可以是缓动参数 easing，也可以是回调函数 callback\r\n            if (util_1.isFunction(easing)) {\r\n                callback = easing;\r\n                easing = 'easeLinear';\r\n            }\r\n            else {\r\n                easing = easing || 'easeLinear';\r\n            }\r\n        }\r\n        var formatToAttrs = getFormatToAttrs(toAttrs, this);\r\n        var animation = {\r\n            fromAttrs: getFormatFromAttrs(formatToAttrs, this),\r\n            toAttrs: formatToAttrs,\r\n            duration: duration,\r\n            easing: easing,\r\n            repeat: repeat,\r\n            callback: callback,\r\n            pauseCallback: pauseCallback,\r\n            resumeCallback: resumeCallback,\r\n            delay: delay,\r\n            startTime: timeline.getTime(),\r\n            id: util_1.uniqueId(),\r\n            onFrame: onFrame,\r\n            pathFormatted: false,\r\n        };\r\n        // 如果动画元素队列中已经有这个图形了\r\n        if (animations.length > 0) {\r\n            // 先检查是否需要合并属性。若有相同的动画，将该属性从前一个动画中删除,直接用后一个动画中\r\n            animations = checkExistedAttrs(animations, animation);\r\n        }\r\n        else {\r\n            // 否则将图形添加到动画元素队列\r\n            timeline.addAnimator(this);\r\n        }\r\n        animations.push(animation);\r\n        this.set('animations', animations);\r\n        this.set('_pause', { isPaused: false });\r\n    };\r\n    /**\r\n     * 停止动画\r\n     * @param {boolean} toEnd 是否到动画的最终状态\r\n     */\r\n    Element.prototype.stopAnimate = function (toEnd) {\r\n        var _this = this;\r\n        if (toEnd === void 0) { toEnd = true; }\r\n        var animations = this.get('animations');\r\n        util_1.each(animations, function (animation) {\r\n            // 将动画执行到最后一帧\r\n            if (toEnd) {\r\n                if (animation.onFrame) {\r\n                    _this.attr(animation.onFrame(1));\r\n                }\r\n                else {\r\n                    _this.attr(animation.toAttrs);\r\n                }\r\n            }\r\n            if (animation.callback) {\r\n                // 动画停止时的回调\r\n                animation.callback();\r\n            }\r\n        });\r\n        this.set('animating', false);\r\n        this.set('animations', []);\r\n    };\r\n    /**\r\n     * 暂停动画\r\n     */\r\n    Element.prototype.pauseAnimate = function () {\r\n        var timeline = this.get('timeline');\r\n        var animations = this.get('animations');\r\n        var pauseTime = timeline.getTime();\r\n        util_1.each(animations, function (animation) {\r\n            animation._paused = true;\r\n            animation._pauseTime = pauseTime;\r\n            if (animation.pauseCallback) {\r\n                // 动画暂停时的回调\r\n                animation.pauseCallback();\r\n            }\r\n        });\r\n        // 记录下是在什么时候暂停的\r\n        this.set('_pause', {\r\n            isPaused: true,\r\n            pauseTime: pauseTime,\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * 恢复动画\r\n     */\r\n    Element.prototype.resumeAnimate = function () {\r\n        var timeline = this.get('timeline');\r\n        var current = timeline.getTime();\r\n        var animations = this.get('animations');\r\n        var pauseTime = this.get('_pause').pauseTime;\r\n        // 之后更新属性需要计算动画已经执行的时长，如果暂停了，就把初始时间调后\r\n        util_1.each(animations, function (animation) {\r\n            animation.startTime = animation.startTime + (current - pauseTime);\r\n            animation._paused = false;\r\n            animation._pauseTime = null;\r\n            if (animation.resumeCallback) {\r\n                animation.resumeCallback();\r\n            }\r\n        });\r\n        this.set('_pause', {\r\n            isPaused: false,\r\n        });\r\n        this.set('animations', animations);\r\n        return this;\r\n    };\r\n    /**\r\n     * 触发委托事件\r\n     * @param  {string}     type 事件类型\r\n     * @param  {GraphEvent} eventObj 事件对象\r\n     */\r\n    Element.prototype.emitDelegation = function (type, eventObj) {\r\n        var _this = this;\r\n        var paths = eventObj.propagationPath;\r\n        var events = this.getEvents();\r\n        var relativeShape;\r\n        if (type === 'mouseenter') {\r\n            relativeShape = eventObj.fromShape;\r\n        }\r\n        else if (type === 'mouseleave') {\r\n            relativeShape = eventObj.toShape;\r\n        }\r\n        var _loop_1 = function (i) {\r\n            var element = paths[i];\r\n            // 暂定跟 name 绑定\r\n            var name_1 = element.get('name');\r\n            if (name_1) {\r\n                // 第一个 mouseenter 和 mouseleave 的停止即可，因为后面的都是前面的 Parent\r\n                if (\r\n                // 只有 element 是 Group 或者 Canvas 的时候，才需要判断 isParent\r\n                (element.isGroup() || (element.isCanvas && element.isCanvas())) &&\r\n                    relativeShape &&\r\n                    util_2.isParent(element, relativeShape)) {\r\n                    return \"break\";\r\n                }\r\n                if (util_1.isArray(name_1)) {\r\n                    util_1.each(name_1, function (subName) {\r\n                        _this.emitDelegateEvent(element, subName, eventObj);\r\n                    });\r\n                }\r\n                else {\r\n                    this_1.emitDelegateEvent(element, name_1, eventObj);\r\n                }\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        // 至少有一个对象，且第一个对象为 shape\r\n        for (var i = 0; i < paths.length; i++) {\r\n            var state_1 = _loop_1(i);\r\n            if (state_1 === \"break\")\r\n                break;\r\n        }\r\n    };\r\n    Element.prototype.emitDelegateEvent = function (element, name, eventObj) {\r\n        var events = this.getEvents();\r\n        // 事件委托的形式 name:type\r\n        var eventName = name + DELEGATION_SPLIT + eventObj.type;\r\n        if (events[eventName] || events[WILDCARD]) {\r\n            // 对于通配符 *，事件名称 = 委托事件名称\r\n            eventObj.name = eventName;\r\n            eventObj.currentTarget = element;\r\n            eventObj.delegateTarget = this;\r\n            // 将委托事件的监听对象 delegateObject 挂载到事件对象上\r\n            eventObj.delegateObject = element.get('delegateObject');\r\n            this.emit(eventName, eventObj);\r\n        }\r\n    };\r\n    /**\r\n     * 移动元素\r\n     * @param {number} translateX 水平移动距离\r\n     * @param {number} translateY 垂直移动距离\r\n     * @return {IElement} 元素\r\n     */\r\n    Element.prototype.translate = function (translateX, translateY) {\r\n        if (translateX === void 0) { translateX = 0; }\r\n        if (translateY === void 0) { translateY = 0; }\r\n        var matrix = this.getMatrix();\r\n        var newMatrix = transform(matrix, [['t', translateX, translateY]]);\r\n        this.setMatrix(newMatrix);\r\n        return this;\r\n    };\r\n    /**\r\n     * 移动元素到目标位置\r\n     * @param {number} targetX 目标位置的水平坐标\r\n     * @param {number} targetX 目标位置的垂直坐标\r\n     * @return {IElement} 元素\r\n     */\r\n    Element.prototype.move = function (targetX, targetY) {\r\n        var x = this.attr('x') || 0;\r\n        var y = this.attr('y') || 0;\r\n        this.translate(targetX - x, targetY - y);\r\n        return this;\r\n    };\r\n    /**\r\n     * 移动元素到目标位置，等价于 move 方法。由于 moveTo 的语义性更强，因此在文档中推荐使用 moveTo 方法\r\n     * @param {number} targetX 目标位置的 x 轴坐标\r\n     * @param {number} targetY 目标位置的 y 轴坐标\r\n     * @return {IElement} 元素\r\n     */\r\n    Element.prototype.moveTo = function (targetX, targetY) {\r\n        return this.move(targetX, targetY);\r\n    };\r\n    /**\r\n     * 缩放元素\r\n     * @param {number} ratioX 水平缩放比例\r\n     * @param {number} ratioY 垂直缩放比例\r\n     * @return {IElement} 元素\r\n     */\r\n    Element.prototype.scale = function (ratioX, ratioY) {\r\n        var matrix = this.getMatrix();\r\n        var newMatrix = transform(matrix, [['s', ratioX, ratioY || ratioX]]);\r\n        this.setMatrix(newMatrix);\r\n        return this;\r\n    };\r\n    /**\r\n     * 以画布左上角 (0, 0) 为中心旋转元素\r\n     * @param {number} radian 旋转角度(弧度值)\r\n     * @return {IElement} 元素\r\n     */\r\n    Element.prototype.rotate = function (radian) {\r\n        var matrix = this.getMatrix();\r\n        var newMatrix = transform(matrix, [['r', radian]]);\r\n        this.setMatrix(newMatrix);\r\n        return this;\r\n    };\r\n    /**\r\n     * 以起始点为中心旋转元素\r\n     * @param {number} radian 旋转角度(弧度值)\r\n     * @return {IElement} 元素\r\n     */\r\n    Element.prototype.rotateAtStart = function (rotate) {\r\n        var _a = this.attr(), x = _a.x, y = _a.y;\r\n        var matrix = this.getMatrix();\r\n        var newMatrix = transform(matrix, [\r\n            ['t', -x, -y],\r\n            ['r', rotate],\r\n            ['t', x, y],\r\n        ]);\r\n        this.setMatrix(newMatrix);\r\n        return this;\r\n    };\r\n    /**\r\n     * 以任意点 (x, y) 为中心旋转元素\r\n     * @param {number} radian 旋转角度(弧度值)\r\n     * @return {IElement} 元素\r\n     */\r\n    Element.prototype.rotateAtPoint = function (x, y, rotate) {\r\n        var matrix = this.getMatrix();\r\n        var newMatrix = transform(matrix, [\r\n            ['t', -x, -y],\r\n            ['r', rotate],\r\n            ['t', x, y],\r\n        ]);\r\n        this.setMatrix(newMatrix);\r\n        return this;\r\n    };\r\n    return Element;\r\n}(base_1.default));\r\nexports.default = Element;\r\n//# sourceMappingURL=element.js.map","\r\n/**\r\n * @fileoverview 矩阵运算，本来是要引入 gl-matrix, 但是考虑到 g-mobile 对大小有限制，同时 g-webgl 使用的 matrix 不一致\r\n * 所以，这里仅实现 2D 几个运算，上层自己引入 gl-matrix\r\n * @author dxq613@gmail.com\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.invert = exports.multiplyVec2 = exports.multiplyMatrix = void 0;\r\n/**\r\n * 3阶矩阵相乘\r\n * @param {number[]} a 矩阵1\r\n * @param {number[]} b 矩阵2\r\n */\r\nfunction multiplyMatrix(a, b) {\r\n    var out = [];\r\n    var a00 = a[0];\r\n    var a01 = a[1];\r\n    var a02 = a[2];\r\n    var a10 = a[3];\r\n    var a11 = a[4];\r\n    var a12 = a[5];\r\n    var a20 = a[6];\r\n    var a21 = a[7];\r\n    var a22 = a[8];\r\n    var b00 = b[0];\r\n    var b01 = b[1];\r\n    var b02 = b[2];\r\n    var b10 = b[3];\r\n    var b11 = b[4];\r\n    var b12 = b[5];\r\n    var b20 = b[6];\r\n    var b21 = b[7];\r\n    var b22 = b[8];\r\n    out[0] = b00 * a00 + b01 * a10 + b02 * a20;\r\n    out[1] = b00 * a01 + b01 * a11 + b02 * a21;\r\n    out[2] = b00 * a02 + b01 * a12 + b02 * a22;\r\n    out[3] = b10 * a00 + b11 * a10 + b12 * a20;\r\n    out[4] = b10 * a01 + b11 * a11 + b12 * a21;\r\n    out[5] = b10 * a02 + b11 * a12 + b12 * a22;\r\n    out[6] = b20 * a00 + b21 * a10 + b22 * a20;\r\n    out[7] = b20 * a01 + b21 * a11 + b22 * a21;\r\n    out[8] = b20 * a02 + b21 * a12 + b22 * a22;\r\n    return out;\r\n}\r\nexports.multiplyMatrix = multiplyMatrix;\r\n/**\r\n * 3阶矩阵同2阶向量相乘\r\n * @param {number[]} m 矩阵\r\n * @param {number[]} v 二阶向量\r\n */\r\nfunction multiplyVec2(m, v) {\r\n    var out = [];\r\n    var x = v[0];\r\n    var y = v[1];\r\n    out[0] = m[0] * x + m[3] * y + m[6];\r\n    out[1] = m[1] * x + m[4] * y + m[7];\r\n    return out;\r\n}\r\nexports.multiplyVec2 = multiplyVec2;\r\n/**\r\n * 矩阵的逆\r\n * @param {number[]} a 矩阵\r\n */\r\nfunction invert(a) {\r\n    var out = [];\r\n    var a00 = a[0];\r\n    var a01 = a[1];\r\n    var a02 = a[2];\r\n    var a10 = a[3];\r\n    var a11 = a[4];\r\n    var a12 = a[5];\r\n    var a20 = a[6];\r\n    var a21 = a[7];\r\n    var a22 = a[8];\r\n    var b01 = a22 * a11 - a12 * a21;\r\n    var b11 = -a22 * a10 + a12 * a20;\r\n    var b21 = a21 * a10 - a11 * a20;\r\n    // Calculate the determinant\r\n    var det = a00 * b01 + a01 * b11 + a02 * b21;\r\n    if (!det) {\r\n        return null;\r\n    }\r\n    det = 1.0 / det;\r\n    out[0] = b01 * det;\r\n    out[1] = (-a22 * a01 + a02 * a21) * det;\r\n    out[2] = (a12 * a01 - a02 * a11) * det;\r\n    out[3] = b11 * det;\r\n    out[4] = (a22 * a00 - a02 * a20) * det;\r\n    out[5] = (-a12 * a00 + a02 * a10) * det;\r\n    out[6] = b21 * det;\r\n    out[7] = (-a21 * a00 + a01 * a20) * det;\r\n    out[8] = (a11 * a00 - a01 * a10) * det;\r\n    return out;\r\n}\r\nexports.invert = invert;\r\n//# sourceMappingURL=matrix.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = require(\"@antv/util\");\r\nvar d3Timer = require(\"d3-timer\");\r\nvar d3_interpolate_1 = require(\"d3-interpolate\"); // 目前整体动画只需要数值和数组的差值计算\r\nvar register_1 = require(\"./register\");\r\nvar PathUtil = require(\"../util/path\");\r\nvar color_1 = require(\"../util/color\");\r\nvar IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n/**\r\n * 使用 ratio 进行插值计算来更新属性\r\n * @param {IElement}  shape    元素\r\n * @param {Animation} animation 动画\r\n * @param {number}    ratio    比例\r\n * @return {boolean}  动画是否执行完成\r\n */\r\nfunction _update(shape, animation, ratio) {\r\n    var cProps = {}; // 此刻属性\r\n    var fromAttrs = animation.fromAttrs, toAttrs = animation.toAttrs;\r\n    if (shape.destroyed) {\r\n        return;\r\n    }\r\n    var interf; //  差值函数\r\n    for (var k in toAttrs) {\r\n        if (!util_1.isEqual(fromAttrs[k], toAttrs[k])) {\r\n            if (k === 'path') {\r\n                var toPath = toAttrs[k];\r\n                var fromPath = fromAttrs[k];\r\n                if (toPath.length > fromPath.length) {\r\n                    toPath = PathUtil.parsePathString(toAttrs[k]); // 终点状态\r\n                    fromPath = PathUtil.parsePathString(fromAttrs[k]); // 起始状态\r\n                    fromPath = PathUtil.fillPathByDiff(fromPath, toPath);\r\n                    fromPath = PathUtil.formatPath(fromPath, toPath);\r\n                    animation.fromAttrs.path = fromPath;\r\n                    animation.toAttrs.path = toPath;\r\n                }\r\n                else if (!animation.pathFormatted) {\r\n                    toPath = PathUtil.parsePathString(toAttrs[k]);\r\n                    fromPath = PathUtil.parsePathString(fromAttrs[k]);\r\n                    fromPath = PathUtil.formatPath(fromPath, toPath);\r\n                    animation.fromAttrs.path = fromPath;\r\n                    animation.toAttrs.path = toPath;\r\n                    animation.pathFormatted = true;\r\n                }\r\n                cProps[k] = [];\r\n                for (var i = 0; i < toPath.length; i++) {\r\n                    var toPathPoint = toPath[i];\r\n                    var fromPathPoint = fromPath[i];\r\n                    var cPathPoint = [];\r\n                    for (var j = 0; j < toPathPoint.length; j++) {\r\n                        if (util_1.isNumber(toPathPoint[j]) && fromPathPoint && util_1.isNumber(fromPathPoint[j])) {\r\n                            interf = d3_interpolate_1.interpolate(fromPathPoint[j], toPathPoint[j]);\r\n                            cPathPoint.push(interf(ratio));\r\n                        }\r\n                        else {\r\n                            cPathPoint.push(toPathPoint[j]);\r\n                        }\r\n                    }\r\n                    cProps[k].push(cPathPoint);\r\n                }\r\n            }\r\n            else if (k === 'matrix') {\r\n                /*\r\n                 对矩阵进行插值时，需要保证矩阵不为空，为空则使用单位矩阵\r\n                 TODO: 二维和三维场景下单位矩阵不同，之后 WebGL 版需要做进一步处理\r\n                 */\r\n                var matrixFn = d3_interpolate_1.interpolateArray(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);\r\n                var currentMatrix = matrixFn(ratio);\r\n                cProps[k] = currentMatrix;\r\n            }\r\n            else if (color_1.isColorProp(k) && color_1.isGradientColor(toAttrs[k])) {\r\n                cProps[k] = toAttrs[k];\r\n            }\r\n            else if (!util_1.isFunction(toAttrs[k])) {\r\n                // 非函数类型的值才能做插值\r\n                interf = d3_interpolate_1.interpolate(fromAttrs[k], toAttrs[k]);\r\n                cProps[k] = interf(ratio);\r\n            }\r\n        }\r\n    }\r\n    shape.attr(cProps);\r\n}\r\n/**\r\n * 根据自定义帧动画函数 onFrame 来更新属性\r\n * @param {IElement}  shape    元素\r\n * @param {Animation} animation 动画\r\n * @param {number}    elapsed  动画执行时间(毫秒)\r\n * @return {boolean}  动画是否执行完成\r\n */\r\nfunction update(shape, animation, elapsed) {\r\n    var startTime = animation.startTime, delay = animation.delay;\r\n    // 如果还没有开始执行或暂停，先不更新\r\n    if (elapsed < startTime + delay || animation._paused) {\r\n        return false;\r\n    }\r\n    var ratio;\r\n    var duration = animation.duration;\r\n    var easing = animation.easing;\r\n    var easeFn = register_1.getEasing(easing);\r\n    // 已执行时间\r\n    elapsed = elapsed - startTime - animation.delay;\r\n    if (animation.repeat) {\r\n        // 如果动画重复执行，则 elapsed > duration，计算 ratio 时需取模\r\n        ratio = (elapsed % duration) / duration;\r\n        ratio = easeFn(ratio);\r\n    }\r\n    else {\r\n        ratio = elapsed / duration;\r\n        if (ratio < 1) {\r\n            // 动画未执行完\r\n            ratio = easeFn(ratio);\r\n        }\r\n        else {\r\n            // 动画已执行完\r\n            if (animation.onFrame) {\r\n                shape.attr(animation.onFrame(1));\r\n            }\r\n            else {\r\n                shape.attr(animation.toAttrs);\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    if (animation.onFrame) {\r\n        var attrs = animation.onFrame(ratio);\r\n        shape.attr(attrs);\r\n    }\r\n    else {\r\n        _update(shape, animation, ratio);\r\n    }\r\n    return false;\r\n}\r\nvar Timeline = /** @class */ (function () {\r\n    /**\r\n     * 时间轴构造函数，依赖于画布\r\n     * @param {}\r\n     */\r\n    function Timeline(canvas) {\r\n        /**\r\n         * 执行动画的元素列表\r\n         * @type {IElement[]}\r\n         */\r\n        this.animators = [];\r\n        /**\r\n         * 当前时间\r\n         * @type {number}\r\n         */\r\n        this.current = 0;\r\n        /**\r\n         * 定时器\r\n         * @type {d3Timer.Timer}\r\n         */\r\n        this.timer = null;\r\n        this.canvas = canvas;\r\n    }\r\n    /**\r\n     * 初始化定时器\r\n     */\r\n    Timeline.prototype.initTimer = function () {\r\n        var _this = this;\r\n        var isFinished = false;\r\n        var shape;\r\n        var animations;\r\n        var animation;\r\n        this.timer = d3Timer.timer(function (elapsed) {\r\n            _this.current = elapsed;\r\n            if (_this.animators.length > 0) {\r\n                for (var i = _this.animators.length - 1; i >= 0; i--) {\r\n                    shape = _this.animators[i];\r\n                    if (shape.destroyed) {\r\n                        // 如果已经被销毁，直接移出队列\r\n                        _this.removeAnimator(i);\r\n                        continue;\r\n                    }\r\n                    if (!shape.isAnimatePaused()) {\r\n                        animations = shape.get('animations');\r\n                        for (var j = animations.length - 1; j >= 0; j--) {\r\n                            animation = animations[j];\r\n                            isFinished = update(shape, animation, elapsed);\r\n                            if (isFinished) {\r\n                                animations.splice(j, 1);\r\n                                isFinished = false;\r\n                                if (animation.callback) {\r\n                                    animation.callback();\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (animations.length === 0) {\r\n                        _this.removeAnimator(i);\r\n                    }\r\n                }\r\n                var autoDraw = _this.canvas.get('autoDraw');\r\n                // 非自动渲染模式下，手动调用 canvas.draw() 重新渲染\r\n                if (!autoDraw) {\r\n                    _this.canvas.draw();\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * 增加动画元素\r\n     */\r\n    Timeline.prototype.addAnimator = function (shape) {\r\n        this.animators.push(shape);\r\n    };\r\n    /**\r\n     * 移除动画元素\r\n     */\r\n    Timeline.prototype.removeAnimator = function (index) {\r\n        this.animators.splice(index, 1);\r\n    };\r\n    /**\r\n     * 是否有动画在执行\r\n     */\r\n    Timeline.prototype.isAnimating = function () {\r\n        return !!this.animators.length;\r\n    };\r\n    /**\r\n     * 停止定时器\r\n     */\r\n    Timeline.prototype.stop = function () {\r\n        if (this.timer) {\r\n            this.timer.stop();\r\n        }\r\n    };\r\n    /**\r\n     * 停止时间轴上所有元素的动画，并置空动画元素列表\r\n     * @param {boolean} toEnd 是否到动画的最终状态，用来透传给动画元素的 stopAnimate 方法\r\n     */\r\n    Timeline.prototype.stopAllAnimations = function (toEnd) {\r\n        if (toEnd === void 0) { toEnd = true; }\r\n        this.animators.forEach(function (animator) {\r\n            animator.stopAnimate(toEnd);\r\n        });\r\n        this.animators = [];\r\n        this.canvas.draw();\r\n    };\r\n    /**\r\n     * 获取当前时间\r\n     */\r\n    Timeline.prototype.getTime = function () {\r\n        return this.current;\r\n    };\r\n    return Timeline;\r\n}());\r\nexports.default = Timeline;\r\n//# sourceMappingURL=timeline.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.registerEasing = exports.getEasing = void 0;\r\nvar d3Ease = require(\"d3-ease\");\r\nvar EASING_MAP = {};\r\n/**\r\n * 根据名称获取对应的动画缓动函数\r\n * @param type 动画缓动函数名称\r\n */\r\nfunction getEasing(type) {\r\n    // 默认从 d3-ease 中获取\r\n    return EASING_MAP[type.toLowerCase()] || d3Ease[type];\r\n}\r\nexports.getEasing = getEasing;\r\n/**\r\n * 注册动画缓动函数\r\n * @param type 动画缓动函数名称\r\n * @param easeFn 动画缓动函数\r\n */\r\nfunction registerEasing(type, easeFn) {\r\n    EASING_MAP[type.toLowerCase()] = easeFn;\r\n}\r\nexports.registerEasing = registerEasing;\r\n//# sourceMappingURL=register.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isGradientColor = exports.isColorProp = void 0;\r\nexports.isColorProp = function (prop) { return ['fill', 'stroke', 'fillStyle', 'strokeStyle'].includes(prop); };\r\nexports.isGradientColor = function (val) { return /^[r,R,L,l]{1}[\\s]*\\(/.test(val); };\r\n//# sourceMappingURL=color.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * @fileoverview 事件处理器\r\n * @author dxq613@gmail.com\r\n */\r\nvar graph_event_1 = require(\"./graph-event\");\r\nvar util_1 = require(\"../util/util\");\r\nvar CLICK_OFFSET = 40;\r\nvar LEFT_BTN_CODE = 0;\r\nvar DELEGATION_SPLIT = ':';\r\nvar EVENTS = [\r\n    'mousedown',\r\n    'mouseup',\r\n    'dblclick',\r\n    'mouseout',\r\n    'mouseover',\r\n    'mousemove',\r\n    'mouseleave',\r\n    'mouseenter',\r\n    'touchstart',\r\n    'touchmove',\r\n    'touchend',\r\n    'dragenter',\r\n    'dragover',\r\n    'dragleave',\r\n    'drop',\r\n    'contextmenu',\r\n    'mousewheel',\r\n];\r\n// 是否有委托事件监听\r\nfunction hasDelegation(events, type) {\r\n    for (var key in events) {\r\n        if (events.hasOwnProperty(key) && key.indexOf(DELEGATION_SPLIT + type) >= 0) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n// 触发目标事件，目标只能是 shape 或 canvas\r\nfunction emitTargetEvent(target, type, eventObj) {\r\n    eventObj.name = type;\r\n    eventObj.target = target;\r\n    eventObj.currentTarget = target;\r\n    eventObj.delegateTarget = target;\r\n    target.emit(type, eventObj);\r\n}\r\n// 事件冒泡, enter 和 leave 需要对 fromShape 和 toShape 进行判同\r\nfunction bubbleEvent(container, type, eventObj) {\r\n    if (eventObj.bubbles) {\r\n        var relativeShape = void 0;\r\n        var isOverEvent = false;\r\n        if (type === 'mouseenter') {\r\n            relativeShape = eventObj.fromShape;\r\n            isOverEvent = true;\r\n        }\r\n        else if (type === 'mouseleave') {\r\n            isOverEvent = true;\r\n            relativeShape = eventObj.toShape;\r\n        }\r\n        // canvas 上的 mouseenter， mouseleave 事件，仅当进入或者移出 canvas 时触发\r\n        if (container.isCanvas() && isOverEvent) {\r\n            return;\r\n        }\r\n        // 如果相关图形同当前图形在同一个容器内，不触发事件\r\n        if (relativeShape && util_1.isParent(container, relativeShape)) {\r\n            // 阻止继续向上冒泡\r\n            eventObj.bubbles = false;\r\n            return;\r\n        }\r\n        // 事件名称可能在委托过程中被修改，因此事件冒泡时需要重新设置事件名称\r\n        eventObj.name = type;\r\n        eventObj.currentTarget = container;\r\n        eventObj.delegateTarget = container;\r\n        container.emit(type, eventObj);\r\n    }\r\n}\r\nvar EventController = /** @class */ (function () {\r\n    function EventController(cfg) {\r\n        var _this = this;\r\n        // 正在被拖拽的图形\r\n        this.draggingShape = null;\r\n        this.dragging = false;\r\n        // 当前鼠标/touch所在位置的图形\r\n        this.currentShape = null;\r\n        this.mousedownShape = null;\r\n        this.mousedownPoint = null;\r\n        // 统一处理所有的回调\r\n        this._eventCallback = function (ev) {\r\n            var type = ev.type;\r\n            _this._triggerEvent(type, ev);\r\n        };\r\n        // 在 document 处理拖拽到画布外的事件，处理从图形上移除画布未被捕捉的问题\r\n        this._onDocumentMove = function (ev) {\r\n            var canvas = _this.canvas;\r\n            var el = canvas.get('el');\r\n            if (el !== ev.target) {\r\n                // 不在 canvas 上移动\r\n                if (_this.dragging || _this.currentShape) {\r\n                    var pointInfo = _this._getPointInfo(ev);\r\n                    // 还在拖拽过程中\r\n                    if (_this.dragging) {\r\n                        _this._emitEvent('drag', ev, pointInfo, _this.draggingShape);\r\n                    }\r\n                    // 说明从某个图形直接移动到了画布外面，\r\n                    // 修复了 mouseleave 的 bug 后不再出现这种情况\r\n                    // if (this.currentShape) {\r\n                    //   this._emitEvent('mouseleave', ev, pointInfo, this.currentShape, this.currentShape, null);\r\n                    //   this.currentShape = null;\r\n                    // }\r\n                }\r\n            }\r\n        };\r\n        // 在 document 上处理拖拽到外面，释放鼠标时触发 dragend\r\n        this._onDocumentMouseUp = function (ev) {\r\n            var canvas = _this.canvas;\r\n            var el = canvas.get('el');\r\n            if (el !== ev.target) {\r\n                // 不在 canvas 上移动\r\n                if (_this.dragging) {\r\n                    var pointInfo = _this._getPointInfo(ev);\r\n                    if (_this.draggingShape) {\r\n                        // 如果存在拖拽的图形，则也触发 drop 事件\r\n                        _this._emitEvent('drop', ev, pointInfo, null);\r\n                    }\r\n                    _this._emitEvent('dragend', ev, pointInfo, _this.draggingShape);\r\n                    _this._afterDrag(_this.draggingShape, pointInfo, ev);\r\n                }\r\n            }\r\n        };\r\n        this.canvas = cfg.canvas;\r\n    }\r\n    EventController.prototype.init = function () {\r\n        this._bindEvents();\r\n    };\r\n    // 注册事件\r\n    EventController.prototype._bindEvents = function () {\r\n        var _this = this;\r\n        var el = this.canvas.get('el');\r\n        util_1.each(EVENTS, function (eventName) {\r\n            el.addEventListener(eventName, _this._eventCallback);\r\n        });\r\n        if (document) {\r\n            // 处理移动到外面没有触发 shape mouse leave 的事件\r\n            // 处理拖拽到外部的问题\r\n            document.addEventListener('mousemove', this._onDocumentMove);\r\n            // 处理拖拽过程中在外部释放鼠标的问题\r\n            document.addEventListener('mouseup', this._onDocumentMouseUp);\r\n        }\r\n    };\r\n    // 清理事件\r\n    EventController.prototype._clearEvents = function () {\r\n        var _this = this;\r\n        var el = this.canvas.get('el');\r\n        util_1.each(EVENTS, function (eventName) {\r\n            el.removeEventListener(eventName, _this._eventCallback);\r\n        });\r\n        if (document) {\r\n            document.removeEventListener('mousemove', this._onDocumentMove);\r\n            document.removeEventListener('mouseup', this._onDocumentMouseUp);\r\n        }\r\n    };\r\n    EventController.prototype._getEventObj = function (type, event, point, target, fromShape, toShape) {\r\n        var eventObj = new graph_event_1.default(type, event);\r\n        eventObj.fromShape = fromShape;\r\n        eventObj.toShape = toShape;\r\n        eventObj.x = point.x;\r\n        eventObj.y = point.y;\r\n        eventObj.clientX = point.clientX;\r\n        eventObj.clientY = point.clientY;\r\n        eventObj.propagationPath.push(target);\r\n        // 事件的x,y应该是基于画布左上角的，与canvas的matrix无关\r\n        return eventObj;\r\n    };\r\n    // 根据点获取图形，提取成独立方法，便于后续优化\r\n    EventController.prototype._getShape = function (point, ev) {\r\n        return this.canvas.getShape(point.x, point.y, ev);\r\n    };\r\n    // 获取事件的当前点的信息\r\n    EventController.prototype._getPointInfo = function (ev) {\r\n        var canvas = this.canvas;\r\n        var clientPoint = canvas.getClientByEvent(ev);\r\n        var point = canvas.getPointByEvent(ev);\r\n        return {\r\n            x: point.x,\r\n            y: point.y,\r\n            clientX: clientPoint.x,\r\n            clientY: clientPoint.y,\r\n        };\r\n    };\r\n    // 触发事件\r\n    EventController.prototype._triggerEvent = function (type, ev) {\r\n        var pointInfo = this._getPointInfo(ev);\r\n        // 每次都获取图形有一定成本，后期可以考虑进行缓存策略\r\n        var shape = this._getShape(pointInfo, ev);\r\n        var method = this[\"_on\" + type];\r\n        var leaveCanvas = false;\r\n        if (method) {\r\n            method.call(this, pointInfo, shape, ev);\r\n        }\r\n        else {\r\n            var preShape = this.currentShape;\r\n            // 如果进入、移出画布时存在图形，则要分别触发事件\r\n            if (type === 'mouseenter' || type === 'dragenter' || type === 'mouseover') {\r\n                this._emitEvent(type, ev, pointInfo, null, null, shape); // 先进入画布\r\n                if (shape) {\r\n                    this._emitEvent(type, ev, pointInfo, shape, null, shape); // 再触发图形的事件\r\n                }\r\n                if (type === 'mouseenter' && this.draggingShape) {\r\n                    // 如果正在拖拽图形, 则触发 dragleave\r\n                    this._emitEvent('dragenter', ev, pointInfo, null);\r\n                }\r\n            }\r\n            else if (type === 'mouseleave' || type === 'dragleave' || type === 'mouseout') {\r\n                leaveCanvas = true;\r\n                if (preShape) {\r\n                    this._emitEvent(type, ev, pointInfo, preShape, preShape, null); // 先触发图形的事件\r\n                }\r\n                this._emitEvent(type, ev, pointInfo, null, preShape, null); // 再触发离开画布事件\r\n                if (type === 'mouseleave' && this.draggingShape) {\r\n                    this._emitEvent('dragleave', ev, pointInfo, null);\r\n                }\r\n            }\r\n            else {\r\n                this._emitEvent(type, ev, pointInfo, shape, null, null); // 一般事件中不需要考虑 from, to\r\n            }\r\n        }\r\n        if (!leaveCanvas) {\r\n            this.currentShape = shape;\r\n        }\r\n        // 当鼠标从画布移动到 shape 或者从 preShape 移动到 shape 时，应用 shape 上的鼠标样式\r\n        if (shape && !shape.get('destroyed')) {\r\n            var canvas = this.canvas;\r\n            var el = canvas.get('el');\r\n            el.style.cursor = shape.attr('cursor') || canvas.get('cursor');\r\n        }\r\n    };\r\n    // 记录下点击的位置、图形，便于拖拽事件、click 事件的判定\r\n    EventController.prototype._onmousedown = function (pointInfo, shape, event) {\r\n        // 只有鼠标左键的 mousedown 事件才会设置 mousedownShape 等属性，避免鼠标右键的 mousedown 事件引起其他事件发生\r\n        if (event.button === LEFT_BTN_CODE) {\r\n            this.mousedownShape = shape;\r\n            this.mousedownPoint = pointInfo;\r\n            this.mousedownTimeStamp = event.timeStamp;\r\n        }\r\n        this._emitEvent('mousedown', event, pointInfo, shape, null, null); // mousedown 不考虑fromShape, toShape\r\n    };\r\n    // mouseleave 和 mouseenter 都是成对存在的\r\n    // mouseenter 和 mouseover 同时触发\r\n    EventController.prototype._emitMouseoverEvents = function (event, pointInfo, fromShape, toShape) {\r\n        var el = this.canvas.get('el');\r\n        if (fromShape !== toShape) {\r\n            if (fromShape) {\r\n                this._emitEvent('mouseout', event, pointInfo, fromShape, fromShape, toShape);\r\n                this._emitEvent('mouseleave', event, pointInfo, fromShape, fromShape, toShape);\r\n                // 当鼠标从 fromShape 移动到画布上时，重置鼠标样式\r\n                if (!toShape || toShape.get('destroyed')) {\r\n                    el.style.cursor = this.canvas.get('cursor');\r\n                }\r\n            }\r\n            if (toShape) {\r\n                this._emitEvent('mouseover', event, pointInfo, toShape, fromShape, toShape);\r\n                this._emitEvent('mouseenter', event, pointInfo, toShape, fromShape, toShape);\r\n            }\r\n        }\r\n    };\r\n    // dragover 不等同于 mouseover，而等同于 mousemove\r\n    EventController.prototype._emitDragoverEvents = function (event, pointInfo, fromShape, toShape, isCanvasEmit) {\r\n        if (toShape) {\r\n            if (toShape !== fromShape) {\r\n                if (fromShape) {\r\n                    this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\r\n                }\r\n                this._emitEvent('dragenter', event, pointInfo, toShape, fromShape, toShape);\r\n            }\r\n            if (!isCanvasEmit) {\r\n                this._emitEvent('dragover', event, pointInfo, toShape);\r\n            }\r\n        }\r\n        else if (fromShape) {\r\n            // TODO: 此处判断有问题，当 drag 图形时，也会触发一次 dragleave 事件，因为此时 toShape 为 null，这不是所期望的\r\n            // 经过空白区域\r\n            this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\r\n        }\r\n        if (isCanvasEmit) {\r\n            this._emitEvent('dragover', event, pointInfo, toShape);\r\n        }\r\n    };\r\n    // drag 完成后，需要做一些清理工作\r\n    EventController.prototype._afterDrag = function (draggingShape, pointInfo, event) {\r\n        if (draggingShape) {\r\n            draggingShape.set('capture', true); // 恢复可以拾取\r\n            this.draggingShape = null;\r\n        }\r\n        this.dragging = false;\r\n        // drag 完成后，有可能 draggingShape 已经移动到了当前位置，所以不能直接取当前图形\r\n        var shape = this._getShape(pointInfo, event);\r\n        // 拖拽完成后，进行 enter，leave 的判定\r\n        if (shape !== draggingShape) {\r\n            this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);\r\n        }\r\n        this.currentShape = shape; // 更新当前 shape，如果不处理当前图形的 mouseleave 事件可能会出问题\r\n    };\r\n    // 按键抬起时，会终止拖拽、触发点击\r\n    EventController.prototype._onmouseup = function (pointInfo, shape, event) {\r\n        // eevent.button === 0 表示鼠标左键事件，此处加上判断主要是为了避免右键鼠标会触发 mouseup 和 click 事件\r\n        // ref: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\r\n        if (event.button === LEFT_BTN_CODE) {\r\n            var draggingShape = this.draggingShape;\r\n            if (this.dragging) {\r\n                // 存在可以拖拽的图形，同时拖拽到其他图形上时触发 drag 事件\r\n                if (draggingShape) {\r\n                    this._emitEvent('drop', event, pointInfo, shape);\r\n                }\r\n                this._emitEvent('dragend', event, pointInfo, draggingShape);\r\n                this._afterDrag(draggingShape, pointInfo, event);\r\n            }\r\n            else {\r\n                this._emitEvent('mouseup', event, pointInfo, shape); // 先触发 mouseup 再触发 click\r\n                if (shape === this.mousedownShape) {\r\n                    this._emitEvent('click', event, pointInfo, shape);\r\n                }\r\n                this.mousedownShape = null;\r\n                this.mousedownPoint = null;\r\n            }\r\n        }\r\n    };\r\n    // 当触发浏览器的 dragover 事件时，不会再触发 mousemove ，所以这时候的 dragenter, dragleave 事件需要重新处理\r\n    EventController.prototype._ondragover = function (pointInfo, shape, event) {\r\n        event.preventDefault(); // 如果不对 dragover 进行 preventDefault，则不会在 canvas 上触发 drop 事件\r\n        var preShape = this.currentShape;\r\n        this._emitDragoverEvents(event, pointInfo, preShape, shape, true);\r\n    };\r\n    // 大量的图形事件，都通过 mousemove 模拟\r\n    EventController.prototype._onmousemove = function (pointInfo, shape, event) {\r\n        var canvas = this.canvas;\r\n        var preShape = this.currentShape;\r\n        var draggingShape = this.draggingShape;\r\n        // 正在拖拽时\r\n        if (this.dragging) {\r\n            // 正在拖拽中\r\n            if (draggingShape) {\r\n                // 如果拖拽了 shape 会触发 dragenter, dragleave, dragover 和 drag 事件\r\n                this._emitDragoverEvents(event, pointInfo, preShape, shape, false);\r\n            }\r\n            // 如果存在 draggingShape 则会在 draggingShape 上触发 drag 事件，冒泡到 canvas 上\r\n            // 否则在 canvas 上触发 drag 事件\r\n            this._emitEvent('drag', event, pointInfo, draggingShape);\r\n        }\r\n        else {\r\n            var mousedownPoint = this.mousedownPoint;\r\n            if (mousedownPoint) {\r\n                // 当鼠标点击下去，同时移动时，进行 drag 判定\r\n                var mousedownShape = this.mousedownShape;\r\n                var now = event.timeStamp;\r\n                var timeWindow = now - this.mousedownTimeStamp;\r\n                var dx = mousedownPoint.clientX - pointInfo.clientX;\r\n                var dy = mousedownPoint.clientY - pointInfo.clientY;\r\n                var dist = dx * dx + dy * dy;\r\n                if (timeWindow > 120 || dist > CLICK_OFFSET) {\r\n                    if (mousedownShape && mousedownShape.get('draggable')) {\r\n                        // 设置了 draggable 的 shape 才能触发 drag 相关的事件\r\n                        draggingShape = this.mousedownShape; // 拖动鼠标点下时的 shape\r\n                        draggingShape.set('capture', false); // 禁止继续拾取，否则无法进行 dragover,dragenter,dragleave,drop的判定\r\n                        this.draggingShape = draggingShape;\r\n                        this.dragging = true;\r\n                        this._emitEvent('dragstart', event, pointInfo, draggingShape);\r\n                        // 清理按下鼠标时缓存的值\r\n                        this.mousedownShape = null;\r\n                        this.mousedownPoint = null;\r\n                    }\r\n                    else if (!mousedownShape && canvas.get('draggable')) {\r\n                        // 设置了 draggable 的 canvas 才能触发 drag 相关的事件\r\n                        this.dragging = true;\r\n                        this._emitEvent('dragstart', event, pointInfo, null);\r\n                        // 清理按下鼠标时缓存的值\r\n                        this.mousedownShape = null;\r\n                        this.mousedownPoint = null;\r\n                    }\r\n                    else {\r\n                        this._emitMouseoverEvents(event, pointInfo, preShape, shape);\r\n                        this._emitEvent('mousemove', event, pointInfo, shape);\r\n                    }\r\n                }\r\n                else {\r\n                    this._emitMouseoverEvents(event, pointInfo, preShape, shape);\r\n                    this._emitEvent('mousemove', event, pointInfo, shape);\r\n                }\r\n            }\r\n            else {\r\n                // 没有按键按下时，则直接触发 mouse over 相关的各种事件\r\n                this._emitMouseoverEvents(event, pointInfo, preShape, shape);\r\n                // 始终触发移动\r\n                this._emitEvent('mousemove', event, pointInfo, shape);\r\n            }\r\n        }\r\n    };\r\n    // 触发事件\r\n    EventController.prototype._emitEvent = function (type, event, pointInfo, shape, fromShape, toShape) {\r\n        var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);\r\n        // 存在 shape 触发，则进行冒泡处理\r\n        if (shape) {\r\n            eventObj.shape = shape;\r\n            // 触发 shape 上的事件\r\n            emitTargetEvent(shape, type, eventObj);\r\n            var parent_1 = shape.getParent();\r\n            // 执行冒泡\r\n            while (parent_1) {\r\n                // 委托事件要先触发\r\n                parent_1.emitDelegation(type, eventObj);\r\n                // 事件冒泡停止，不能妨碍委托事件\r\n                if (!eventObj.propagationStopped) {\r\n                    bubbleEvent(parent_1, type, eventObj);\r\n                }\r\n                eventObj.propagationPath.push(parent_1);\r\n                parent_1 = parent_1.getParent();\r\n            }\r\n        }\r\n        else {\r\n            // 如果没有 shape 直接在 canvas 上触发\r\n            var canvas = this.canvas;\r\n            // 直接触发 canvas 上的事件\r\n            emitTargetEvent(canvas, type, eventObj);\r\n        }\r\n    };\r\n    EventController.prototype.destroy = function () {\r\n        // 清理事件\r\n        this._clearEvents();\r\n        // 清理缓存的对象\r\n        this.canvas = null;\r\n        this.currentShape = null;\r\n        this.draggingShape = null;\r\n        this.mousedownPoint = null;\r\n        this.mousedownShape = null;\r\n        this.mousedownTimeStamp = null;\r\n    };\r\n    return EventController;\r\n}());\r\nexports.default = EventController;\r\n//# sourceMappingURL=event-contoller.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar container_1 = require(\"./container\");\r\nvar AbstractGroup = /** @class */ (function (_super) {\r\n    tslib_1.__extends(AbstractGroup, _super);\r\n    function AbstractGroup() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    AbstractGroup.prototype.isGroup = function () {\r\n        return true;\r\n    };\r\n    AbstractGroup.prototype.isEntityGroup = function () {\r\n        return false;\r\n    };\r\n    AbstractGroup.prototype.clone = function () {\r\n        var clone = _super.prototype.clone.call(this);\r\n        // 获取构造函数\r\n        var children = this.getChildren();\r\n        for (var i = 0; i < children.length; i++) {\r\n            var child = children[i];\r\n            clone.add(child.clone());\r\n        }\r\n        return clone;\r\n    };\r\n    return AbstractGroup;\r\n}(container_1.default));\r\nexports.default = AbstractGroup;\r\n//# sourceMappingURL=group.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar element_1 = require(\"./element\");\r\nvar matrix_1 = require(\"../util/matrix\");\r\nvar AbstractShape = /** @class */ (function (_super) {\r\n    tslib_1.__extends(AbstractShape, _super);\r\n    function AbstractShape(cfg) {\r\n        return _super.call(this, cfg) || this;\r\n    }\r\n    // 是否在包围盒内\r\n    AbstractShape.prototype._isInBBox = function (refX, refY) {\r\n        var bbox = this.getBBox();\r\n        return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;\r\n    };\r\n    /**\r\n     * 属性更改后需要做的事情\r\n     * @protected\r\n     * @param {ShapeAttrs} targetAttrs 渲染的图像属性\r\n     */\r\n    AbstractShape.prototype.afterAttrsChange = function (targetAttrs) {\r\n        _super.prototype.afterAttrsChange.call(this, targetAttrs);\r\n        this.clearCacheBBox();\r\n    };\r\n    // 计算包围盒时，需要缓存，这是一个高频的操作\r\n    AbstractShape.prototype.getBBox = function () {\r\n        var bbox = this.cfg.bbox;\r\n        if (!bbox) {\r\n            bbox = this.calculateBBox();\r\n            this.set('bbox', bbox);\r\n        }\r\n        return bbox;\r\n    };\r\n    // 计算相对于画布的包围盒\r\n    AbstractShape.prototype.getCanvasBBox = function () {\r\n        var canvasBBox = this.cfg.canvasBBox;\r\n        if (!canvasBBox) {\r\n            canvasBBox = this.calculateCanvasBBox();\r\n            this.set('canvasBBox', canvasBBox);\r\n        }\r\n        return canvasBBox;\r\n    };\r\n    AbstractShape.prototype.applyMatrix = function (matrix) {\r\n        _super.prototype.applyMatrix.call(this, matrix);\r\n        // 清理掉缓存的包围盒\r\n        this.set('canvasBBox', null);\r\n    };\r\n    /**\r\n     * 计算相对于画布的包围盒，默认等同于 bbox\r\n     * @return {BBox} 包围盒\r\n     */\r\n    AbstractShape.prototype.calculateCanvasBBox = function () {\r\n        var bbox = this.getBBox();\r\n        var totalMatrix = this.getTotalMatrix();\r\n        var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;\r\n        if (totalMatrix) {\r\n            var topLeft = matrix_1.multiplyVec2(totalMatrix, [bbox.minX, bbox.minY]);\r\n            var topRight = matrix_1.multiplyVec2(totalMatrix, [bbox.maxX, bbox.minY]);\r\n            var bottomLeft = matrix_1.multiplyVec2(totalMatrix, [bbox.minX, bbox.maxY]);\r\n            var bottomRight = matrix_1.multiplyVec2(totalMatrix, [bbox.maxX, bbox.maxY]);\r\n            minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);\r\n            maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);\r\n            minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);\r\n            maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);\r\n        }\r\n        var attrs = this.attrs;\r\n        // 如果存在 shadow 则计算 shadow\r\n        if (attrs.shadowColor) {\r\n            var _a = attrs.shadowBlur, shadowBlur = _a === void 0 ? 0 : _a, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;\r\n            var shadowLeft = minX - shadowBlur + shadowOffsetX;\r\n            var shadowRight = maxX + shadowBlur + shadowOffsetX;\r\n            var shadowTop = minY - shadowBlur + shadowOffsetY;\r\n            var shadowBottom = maxY + shadowBlur + shadowOffsetY;\r\n            minX = Math.min(minX, shadowLeft);\r\n            maxX = Math.max(maxX, shadowRight);\r\n            minY = Math.min(minY, shadowTop);\r\n            maxY = Math.max(maxY, shadowBottom);\r\n        }\r\n        return {\r\n            x: minX,\r\n            y: minY,\r\n            minX: minX,\r\n            minY: minY,\r\n            maxX: maxX,\r\n            maxY: maxY,\r\n            width: maxX - minX,\r\n            height: maxY - minY,\r\n        };\r\n    };\r\n    /**\r\n     * @protected\r\n     * 清理缓存的 bbox\r\n     */\r\n    AbstractShape.prototype.clearCacheBBox = function () {\r\n        this.set('bbox', null);\r\n        this.set('canvasBBox', null);\r\n    };\r\n    // 实现接口\r\n    AbstractShape.prototype.isClipShape = function () {\r\n        return this.get('isClipShape');\r\n    };\r\n    /**\r\n     * @protected\r\n     * 不同的图形自己实现是否在图形内部的逻辑，要判断边和填充区域\r\n     * @param  {number}  refX 相对于图形的坐标 x\r\n     * @param  {number}  refY 相对于图形的坐标 Y\r\n     * @return {boolean} 点是否在图形内部\r\n     */\r\n    AbstractShape.prototype.isInShape = function (refX, refY) {\r\n        return false;\r\n    };\r\n    /**\r\n     * 是否仅仅使用 BBox 检测就可以判定拾取到图形\r\n     * 默认是 false，但是有些图形例如 image、marker 等都可直接使用 BBox 的检测而不需要使用图形拾取\r\n     * @return {Boolean} 仅仅使用 BBox 进行拾取\r\n     */\r\n    AbstractShape.prototype.isOnlyHitBox = function () {\r\n        return false;\r\n    };\r\n    // 不同的 Shape 各自实现\r\n    AbstractShape.prototype.isHit = function (x, y) {\r\n        var startArrowShape = this.get('startArrowShape');\r\n        var endArrowShape = this.get('endArrowShape');\r\n        var vec = [x, y, 1];\r\n        vec = this.invertFromMatrix(vec);\r\n        var refX = vec[0], refY = vec[1];\r\n        var inBBox = this._isInBBox(refX, refY);\r\n        // 跳过图形的拾取，在某些图形中可以省略一倍的检测成本\r\n        if (this.isOnlyHitBox()) {\r\n            return inBBox;\r\n        }\r\n        // 被裁减掉的和不在包围盒内的不进行计算\r\n        if (inBBox && !this.isClipped(refX, refY)) {\r\n            // 对图形进行拾取判断\r\n            if (this.isInShape(refX, refY)) {\r\n                return true;\r\n            }\r\n            // 对起始箭头进行拾取判断\r\n            if (startArrowShape && startArrowShape.isHit(refX, refY)) {\r\n                return true;\r\n            }\r\n            // 对结束箭头进行拾取判断\r\n            if (endArrowShape && endArrowShape.isHit(refX, refY)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    return AbstractShape;\r\n}(element_1.default));\r\nexports.default = AbstractShape;\r\n//# sourceMappingURL=shape.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.registerBBox = exports.getBBoxMethod = void 0;\r\nvar register_1 = require(\"./register\");\r\nObject.defineProperty(exports, \"registerBBox\", { enumerable: true, get: function () { return register_1.register; } });\r\nObject.defineProperty(exports, \"getBBoxMethod\", { enumerable: true, get: function () { return register_1.getMethod; } });\r\nvar rect_1 = require(\"./rect\");\r\nvar circle_1 = require(\"./circle\");\r\nvar polyline_1 = require(\"./polyline\");\r\nvar polygon_1 = require(\"./polygon\");\r\nvar text_1 = require(\"./text\");\r\nvar path_1 = require(\"./path\");\r\nvar line_1 = require(\"./line\");\r\nvar ellipse_1 = require(\"./ellipse\");\r\nregister_1.register('rect', rect_1.default);\r\nregister_1.register('image', rect_1.default); // image 使用 rect 的包围盒计算\r\nregister_1.register('circle', circle_1.default);\r\nregister_1.register('marker', circle_1.default); // marker 使用 circle 的计算方案\r\nregister_1.register('polyline', polyline_1.default);\r\nregister_1.register('polygon', polygon_1.default);\r\nregister_1.register('text', text_1.default);\r\nregister_1.register('path', path_1.default);\r\nregister_1.register('line', line_1.default);\r\nregister_1.register('ellipse', ellipse_1.default);\r\n//# sourceMappingURL=index.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getMethod = exports.register = void 0;\r\nvar cache = new Map();\r\n/**\r\n * 注册计算包围盒的算法\r\n * @param type 方法名\r\n * @param method 方法\r\n */\r\nfunction register(type, method) {\r\n    cache.set(type, method);\r\n}\r\nexports.register = register;\r\n/**\r\n * 获取计算包围盒的算法\r\n * @param type 方法名\r\n */\r\nfunction getMethod(type) {\r\n    return cache.get(type);\r\n}\r\nexports.getMethod = getMethod;\r\n//# sourceMappingURL=register.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction default_1(shape) {\r\n    var attrs = shape.attr();\r\n    var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height;\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        width: width,\r\n        height: height,\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=rect.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction default_1(shape) {\r\n    var _a = shape.attr(), x = _a.x, y = _a.y, r = _a.r;\r\n    return {\r\n        x: x - r,\r\n        y: y - r,\r\n        width: r * 2,\r\n        height: r * 2,\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=circle.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar g_math_1 = require(\"@antv/g-math\");\r\nvar util_1 = require(\"./util\");\r\nfunction default_1(shape) {\r\n    var attrs = shape.attr();\r\n    var points = attrs.points;\r\n    var xArr = [];\r\n    var yArr = [];\r\n    for (var i = 0; i < points.length; i++) {\r\n        var point = points[i];\r\n        xArr.push(point[0]);\r\n        yArr.push(point[1]);\r\n    }\r\n    var _a = g_math_1.Util.getBBoxByArray(xArr, yArr), x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    var bbox = {\r\n        minX: x,\r\n        minY: y,\r\n        maxX: x + width,\r\n        maxY: y + height,\r\n    };\r\n    bbox = util_1.mergeArrowBBox(shape, bbox);\r\n    return {\r\n        x: bbox.minX,\r\n        y: bbox.minY,\r\n        width: bbox.maxX - bbox.minX,\r\n        height: bbox.maxY - bbox.minY,\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=polyline.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.mergeArrowBBox = exports.mergeBBox = void 0;\r\n// 合并包围盒\r\nfunction mergeBBox(bbox1, bbox2) {\r\n    if (!bbox1 || !bbox2) {\r\n        return bbox1 || bbox2;\r\n    }\r\n    return {\r\n        minX: Math.min(bbox1.minX, bbox2.minX),\r\n        minY: Math.min(bbox1.minY, bbox2.minY),\r\n        maxX: Math.max(bbox1.maxX, bbox2.maxX),\r\n        maxY: Math.max(bbox1.maxY, bbox2.maxY),\r\n    };\r\n}\r\nexports.mergeBBox = mergeBBox;\r\n// 合并箭头的包围盒\r\nfunction mergeArrowBBox(shape, bbox) {\r\n    var startArrowShape = shape.get('startArrowShape');\r\n    var endArrowShape = shape.get('endArrowShape');\r\n    var startArrowBBox = null;\r\n    var endArrowBBox = null;\r\n    if (startArrowShape) {\r\n        startArrowBBox = startArrowShape.getCanvasBBox();\r\n        bbox = mergeBBox(bbox, startArrowBBox);\r\n    }\r\n    if (endArrowShape) {\r\n        endArrowBBox = endArrowShape.getCanvasBBox();\r\n        bbox = mergeBBox(bbox, endArrowBBox);\r\n    }\r\n    return bbox;\r\n}\r\nexports.mergeArrowBBox = mergeArrowBBox;\r\n//# sourceMappingURL=util.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar g_math_1 = require(\"@antv/g-math\");\r\nfunction default_1(shape) {\r\n    var attrs = shape.attr();\r\n    var points = attrs.points;\r\n    var xArr = [];\r\n    var yArr = [];\r\n    for (var i = 0; i < points.length; i++) {\r\n        var point = points[i];\r\n        xArr.push(point[0]);\r\n        yArr.push(point[1]);\r\n    }\r\n    return g_math_1.Util.getBBoxByArray(xArr, yArr);\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=polygon.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar text_1 = require(\"../util/text\");\r\nfunction default_1(shape) {\r\n    var attrs = shape.attr();\r\n    var x = attrs.x, y = attrs.y, text = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;\r\n    var font = attrs.font;\r\n    if (!font) {\r\n        // 如果未组装 font\r\n        font = text_1.assembleFont(attrs);\r\n    }\r\n    var width = text_1.getTextWidth(text, font);\r\n    var bbox;\r\n    if (!width) {\r\n        // 如果width不存在，四点共其实点\r\n        bbox = {\r\n            x: x,\r\n            y: y,\r\n            width: 0,\r\n            height: 0,\r\n        };\r\n    }\r\n    else {\r\n        var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;\r\n        var height = text_1.getTextHeight(text, fontSize, lineHeight); // attrs.height\r\n        // 默认左右对齐：left, 默认上下对齐 bottom\r\n        var point = {\r\n            x: x,\r\n            y: y - height,\r\n        };\r\n        if (textAlign) {\r\n            if (textAlign === 'end' || textAlign === 'right') {\r\n                point.x -= width;\r\n            }\r\n            else if (textAlign === 'center') {\r\n                point.x -= width / 2;\r\n            }\r\n        }\r\n        if (textBaseline) {\r\n            if (textBaseline === 'top') {\r\n                point.y += height;\r\n            }\r\n            else if (textBaseline === 'middle') {\r\n                point.y += height / 2;\r\n            }\r\n        }\r\n        bbox = {\r\n            x: point.x,\r\n            y: point.y,\r\n            width: width,\r\n            height: height,\r\n        };\r\n    }\r\n    return bbox;\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=text.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.assembleFont = exports.getTextWidth = exports.getLineSpaceing = exports.getTextHeight = void 0;\r\nvar util_1 = require(\"./util\");\r\nvar offscreen_1 = require(\"./offscreen\");\r\n/**\r\n * 获取文本的高度\r\n * @param text 文本\r\n * @param fontSize 字体大小\r\n * @param lineHeight 行高，可以为空\r\n */\r\nfunction getTextHeight(text, fontSize, lineHeight) {\r\n    var lineCount = 1;\r\n    if (util_1.isString(text)) {\r\n        lineCount = text.split('\\n').length;\r\n    }\r\n    if (lineCount > 1) {\r\n        var spaceingY = getLineSpaceing(fontSize, lineHeight);\r\n        return fontSize * lineCount + spaceingY * (lineCount - 1);\r\n    }\r\n    return fontSize;\r\n}\r\nexports.getTextHeight = getTextHeight;\r\n/**\r\n * 获取行间距如果文本多行，需要获取文本间距\r\n * @param fontSize 字体大小\r\n * @param lineHeight 行高\r\n */\r\nfunction getLineSpaceing(fontSize, lineHeight) {\r\n    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;\r\n}\r\nexports.getLineSpaceing = getLineSpaceing;\r\n/**\r\n * 字体宽度\r\n * @param text 文本\r\n * @param font 字体\r\n */\r\nfunction getTextWidth(text, font) {\r\n    var context = offscreen_1.getOffScreenContext(); // 获取离屏的 ctx 进行计算\r\n    var width = 0;\r\n    // null 或者 undefined 时，宽度为 0\r\n    if (util_1.isNil(text) || text === '') {\r\n        return width;\r\n    }\r\n    context.save();\r\n    context.font = font;\r\n    if (util_1.isString(text) && text.includes('\\n')) {\r\n        var textArr = text.split('\\n');\r\n        util_1.each(textArr, function (subText) {\r\n            var measureWidth = context.measureText(subText).width;\r\n            if (width < measureWidth) {\r\n                width = measureWidth;\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        width = context.measureText(text).width;\r\n    }\r\n    context.restore();\r\n    return width;\r\n}\r\nexports.getTextWidth = getTextWidth;\r\nfunction assembleFont(attrs) {\r\n    var fontSize = attrs.fontSize, fontFamily = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;\r\n    return [fontStyle, fontVariant, fontWeight, fontSize + \"px\", fontFamily].join(' ').trim();\r\n}\r\nexports.assembleFont = assembleFont;\r\n//# sourceMappingURL=text.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getOffScreenContext = void 0;\r\n// 全局设置一个唯一离屏的 ctx，用于计算 isPointInPath\r\nvar offScreenCtx = null;\r\nfunction getOffScreenContext() {\r\n    if (!offScreenCtx) {\r\n        var canvas = document.createElement('canvas');\r\n        canvas.width = 1;\r\n        canvas.height = 1;\r\n        offScreenCtx = canvas.getContext('2d');\r\n    }\r\n    return offScreenCtx;\r\n}\r\nexports.getOffScreenContext = getOffScreenContext;\r\n//# sourceMappingURL=offscreen.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar g_math_1 = require(\"@antv/g-math\");\r\nvar path_util_1 = require(\"@antv/path-util\");\r\nvar util_1 = require(\"@antv/util\");\r\nvar util_2 = require(\"./util\");\r\nfunction getPathBox(segments, lineWidth) {\r\n    var xArr = [];\r\n    var yArr = [];\r\n    var segmentsWithAngle = [];\r\n    for (var i = 0; i < segments.length; i++) {\r\n        var segment = segments[i];\r\n        var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;\r\n        var box = void 0;\r\n        switch (segment.command) {\r\n            case 'Q':\r\n                box = g_math_1.Quad.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);\r\n                break;\r\n            case 'C':\r\n                box = g_math_1.Cubic.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);\r\n                break;\r\n            case 'A':\r\n                var arcParams = segment.arcParams;\r\n                box = g_math_1.Arc.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);\r\n                break;\r\n            default:\r\n                xArr.push(currentPoint[0]);\r\n                yArr.push(currentPoint[1]);\r\n                break;\r\n        }\r\n        if (box) {\r\n            segment.box = box;\r\n            xArr.push(box.x, box.x + box.width);\r\n            yArr.push(box.y, box.y + box.height);\r\n        }\r\n        if (lineWidth && (segment.command === 'L' || segment.command === 'M') && segment.prePoint && segment.nextPoint) {\r\n            segmentsWithAngle.push(segment);\r\n        }\r\n    }\r\n    // bbox calculation should ignore NaN for path attribute\r\n    // ref: https://github.com/antvis/g/issues/210\r\n    // ref: https://github.com/antvis/G2/issues/3109\r\n    xArr = xArr.filter(function (item) { return !Number.isNaN(item) && item !== Infinity && item !== -Infinity; });\r\n    yArr = yArr.filter(function (item) { return !Number.isNaN(item) && item !== Infinity && item !== -Infinity; });\r\n    var minX = util_1.min(xArr);\r\n    var minY = util_1.min(yArr);\r\n    var maxX = util_1.max(xArr);\r\n    var maxY = util_1.max(yArr);\r\n    if (segmentsWithAngle.length === 0) {\r\n        return {\r\n            x: minX,\r\n            y: minY,\r\n            width: maxX - minX,\r\n            height: maxY - minY,\r\n        };\r\n    }\r\n    for (var i = 0; i < segmentsWithAngle.length; i++) {\r\n        var segment = segmentsWithAngle[i];\r\n        var currentPoint = segment.currentPoint;\r\n        var extra = void 0;\r\n        if (currentPoint[0] === minX) {\r\n            extra = getExtraFromSegmentWithAngle(segment, lineWidth);\r\n            minX = minX - extra.xExtra;\r\n        }\r\n        else if (currentPoint[0] === maxX) {\r\n            extra = getExtraFromSegmentWithAngle(segment, lineWidth);\r\n            maxX = maxX + extra.xExtra;\r\n        }\r\n        if (currentPoint[1] === minY) {\r\n            extra = getExtraFromSegmentWithAngle(segment, lineWidth);\r\n            minY = minY - extra.yExtra;\r\n        }\r\n        else if (currentPoint[1] === maxY) {\r\n            extra = getExtraFromSegmentWithAngle(segment, lineWidth);\r\n            maxY = maxY + extra.yExtra;\r\n        }\r\n    }\r\n    return {\r\n        x: minX,\r\n        y: minY,\r\n        width: maxX - minX,\r\n        height: maxY - minY,\r\n    };\r\n}\r\nfunction getExtraFromSegmentWithAngle(segment, lineWidth) {\r\n    var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;\r\n    var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);\r\n    var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);\r\n    var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);\r\n    // 以 currentPoint 为顶点的夹角\r\n    var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));\r\n    // 夹角为空、 0 或 PI 时，不需要计算夹角处的额外宽度\r\n    // 注意: 由于计算精度问题，夹角为 0 的情况计算出来的角度可能是一个很小的值，还需要判断其与 0 是否近似相等\r\n    if (!currentAngle || Math.sin(currentAngle) === 0 || util_1.isNumberEqual(currentAngle, 0)) {\r\n        return {\r\n            xExtra: 0,\r\n            yExtra: 0,\r\n        };\r\n    }\r\n    var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));\r\n    var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));\r\n    // 将夹角转为锐角\r\n    xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;\r\n    yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;\r\n    // 这里不考虑在水平和垂直方向的投影，直接使用最大差值\r\n    // 由于上层统一加减了二分之一线宽，这里需要进行弥补\r\n    var extra = {\r\n        // 水平方向投影\r\n        xExtra: Math.cos(currentAngle / 2 - xAngle) * ((lineWidth / 2) * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,\r\n        // 垂直方向投影\r\n        yExtra: Math.cos(yAngle - currentAngle / 2) * ((lineWidth / 2) * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,\r\n    };\r\n    return extra;\r\n}\r\nfunction default_1(shape) {\r\n    var attrs = shape.attr();\r\n    var path = attrs.path, stroke = attrs.stroke;\r\n    var lineWidth = stroke ? attrs.lineWidth : 0; // 只有有 stroke 时，lineWidth 才生效\r\n    var segments = shape.get('segments') || path_util_1.path2Segments(path);\r\n    var _a = getPathBox(segments, lineWidth), x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    var bbox = {\r\n        minX: x,\r\n        minY: y,\r\n        maxX: x + width,\r\n        maxY: y + height,\r\n    };\r\n    bbox = util_2.mergeArrowBBox(shape, bbox);\r\n    return {\r\n        x: bbox.minX,\r\n        y: bbox.minY,\r\n        width: bbox.maxX - bbox.minX,\r\n        height: bbox.maxY - bbox.minY,\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=path.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = require(\"./util\");\r\nfunction default_1(shape) {\r\n    var attrs = shape.attr();\r\n    var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2;\r\n    var minX = Math.min(x1, x2);\r\n    var maxX = Math.max(x1, x2);\r\n    var minY = Math.min(y1, y2);\r\n    var maxY = Math.max(y1, y2);\r\n    var bbox = {\r\n        minX: minX,\r\n        maxX: maxX,\r\n        minY: minY,\r\n        maxY: maxY,\r\n    };\r\n    bbox = util_1.mergeArrowBBox(shape, bbox);\r\n    return {\r\n        x: bbox.minX,\r\n        y: bbox.minY,\r\n        width: bbox.maxX - bbox.minX,\r\n        height: bbox.maxY - bbox.minY,\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=line.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction default_1(shape) {\r\n    var attrs = shape.attr();\r\n    var x = attrs.x, y = attrs.y, rx = attrs.rx, ry = attrs.ry;\r\n    return {\r\n        x: x - rx,\r\n        y: y - ry,\r\n        width: rx * 2,\r\n        height: ry * 2,\r\n    };\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=ellipse.js.map"]}