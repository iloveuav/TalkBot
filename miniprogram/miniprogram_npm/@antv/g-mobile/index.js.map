{"version":3,"sources":["index.js","shape/index.js","shape/base.js","util/util.js","util/time.js","util/draw.js","util/parse.js","util/arc-params.js","util/arrow.js","group.js","shape/circle.js","shape/ellipse.js","shape/image.js","shape/line.js","util/in-stroke/line.js","shape/marker.js","shape/path.js","util/in-path/polygon.js","util/path.js","util/in-stroke/arc.js","shape/polygon.js","util/in-stroke/polyline.js","shape/polyline.js","shape/rect.js","util/in-stroke/rect.js","util/in-stroke/rect-radius.js","shape/text.js","canvas.js","util/hit.js","events.js","util/mini-canvas-proxy.js","patch/index.js","patch/bbox/index.js","patch/bbox/text.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AGTA,ADGA;AHUA,AENA,ADGA,AGTA,ADGA;AHUA,AENA,ADGA,AGTA,ADGA;ADIA,ADGA,AIZA,ADGA,ADGA;ADIA,ADGA,AIZA,ADGA,ADGA;ADIA,ADGA,AIZA,ADGA,ADGA;ADIA,ADGA,AIZA,ACHA,AFMA,ADGA;ADIA,ADGA,AIZA,ACHA,AFMA,ADGA;ADIA,ADGA,AIZA,ACHA,AFMA,ADGA;ADIA,ADGA,AMlBA,AFMA,ACHA,AFMA,ADGA;ADIA,ADGA,AMlBA,AFMA,ACHA,AFMA,ADGA;ADIA,ADGA,AMlBA,AFMA,ACHA,AFMA,ADGA;ADIA,ADGA,AMlBA,ACHA,AHSA,ACHA,AFMA,ADGA;ADIA,ADGA,AMlBA,ACHA,AHSA,ACHA,AFMA,ADGA;ADIA,ADGA,AMlBA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,ADGA,AMlBA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,ADGA,AMlBA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AKfA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,AHSA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,AHSA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,AHSA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,AJYA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,AJYA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,AJYA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ALeA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ALeA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ALeA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,ACHA,AFMA,ADGA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,ANkBA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ARwBA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ARwBA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ARwBA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AS3BA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AHSA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AHSA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AHSA,ARwBA,AHSA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AHSA,ARwBA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AHSA,ARwBA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AHSA,ARwBA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AENA,ALeA,ARwBA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AENA,ALeA,ARwBA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AT2BA,ACHA,AHSA,AYpCA,AENA,ALeA,ARwBA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AbuCA,ACHA,AHSA,AYpCA,AENA,ALeA,ARwBA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AbuCA,ACHA,AHSA,AYpCA,AENA,AbuCA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AbuCA,ACHA,AHSA,AYpCA,AENA,AbuCA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AbuCA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AbuCA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AbuCA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,Af6CA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,Af6CA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,Af6CA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AENA,AENA,Af6CA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AENA,AENA,AGTA,AlBsDA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AIZA,AGTA,AlBsDA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AIZA,AGTA,AlBsDA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AhBgDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AMjBA,APqBA,AQxBA,ACHA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AMjBA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AwBvEA,AlBsDA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AwBvEA,AlBsDA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AwBvEA,AlBsDA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AYpCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AwBvEA,AlBsDA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AIZA,AIZA,ADGA,AlBsDA,AYpCA,Af6CA;AwBvEA,AlBsDA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AIZA,AIZA,AnByDA,AYpCA,Af6CA;AwBvEA,AlBsDA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AIZA,AIZA,AnByDA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AIZA,AIZA,AnByDA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AIZA,AIZA,AnByDA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AIZA,AIZA,AnByDA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AIZA,AIZA,AKfA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AIZA,AIZA,AKfA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,APqBA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AsBlEA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AsBlEA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AsBlEA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ADGA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ADGA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ADGA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ACHA,AFMA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ACHA,AFMA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ACHA,AFMA,A7BuFA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ACHA,A/B6FA,AS3BA,ACHA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AXiCA,AavCA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ACHA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AuBrEA,ACHA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AnByDA,ACHA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AIZA,AENA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA,Af6CA;AwBvEA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,ACHA,AENA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,ApB4DA,AwBxEA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,AlBsDA,AHSA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AENA,AxBwEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AGTA,ACHA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,ACHA,AGTA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,AuBrEA,AtBkEA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,AU9BA,AIZA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA,AYpCA;AS1BA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,AIZA,A/B6FA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AIZA,ArB+DA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA,ACHA;AqB9DA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA;AsBjEA,AENA,A3BiFA,Ac1CA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AMlBA,AjBmDA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AbuCA,AXiCA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA,AxBwEA;AsBjEA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.version = exports.getArcParams = exports.Shape = exports.Group = exports.Canvas = void 0;\r\nvar tslib_1 = require(\"tslib\");\r\nvar Shape = require(\"./shape\");\r\nexports.Shape = Shape;\r\ntslib_1.__exportStar(require(\"@antv/g-base\"), exports);\r\nvar canvas_1 = require(\"./canvas\");\r\nObject.defineProperty(exports, \"Canvas\", { enumerable: true, get: function () { return canvas_1.default; } });\r\nvar group_1 = require(\"./group\");\r\nObject.defineProperty(exports, \"Group\", { enumerable: true, get: function () { return group_1.default; } });\r\nvar arc_params_1 = require(\"./util/arc-params\");\r\nObject.defineProperty(exports, \"getArcParams\", { enumerable: true, get: function () { return arc_params_1.default; } });\r\nexports.version = '0.5.6';\r\n//# sourceMappingURL=index.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Text = exports.Rect = exports.Polyline = exports.Polygon = exports.Path = exports.Marker = exports.Line = exports.Image = exports.Ellipse = exports.Circle = exports.Base = void 0;\r\nvar base_1 = require(\"./base\");\r\nObject.defineProperty(exports, \"Base\", { enumerable: true, get: function () { return base_1.default; } });\r\nvar circle_1 = require(\"./circle\");\r\nObject.defineProperty(exports, \"Circle\", { enumerable: true, get: function () { return circle_1.default; } });\r\nvar ellipse_1 = require(\"./ellipse\");\r\nObject.defineProperty(exports, \"Ellipse\", { enumerable: true, get: function () { return ellipse_1.default; } });\r\nvar image_1 = require(\"./image\");\r\nObject.defineProperty(exports, \"Image\", { enumerable: true, get: function () { return image_1.default; } });\r\nvar line_1 = require(\"./line\");\r\nObject.defineProperty(exports, \"Line\", { enumerable: true, get: function () { return line_1.default; } });\r\nvar marker_1 = require(\"./marker\");\r\nObject.defineProperty(exports, \"Marker\", { enumerable: true, get: function () { return marker_1.default; } });\r\nvar path_1 = require(\"./path\");\r\nObject.defineProperty(exports, \"Path\", { enumerable: true, get: function () { return path_1.default; } });\r\nvar polygon_1 = require(\"./polygon\");\r\nObject.defineProperty(exports, \"Polygon\", { enumerable: true, get: function () { return polygon_1.default; } });\r\nvar polyline_1 = require(\"./polyline\");\r\nObject.defineProperty(exports, \"Polyline\", { enumerable: true, get: function () { return polyline_1.default; } });\r\nvar rect_1 = require(\"./rect\");\r\nObject.defineProperty(exports, \"Rect\", { enumerable: true, get: function () { return rect_1.default; } });\r\nvar text_1 = require(\"./text\");\r\nObject.defineProperty(exports, \"Text\", { enumerable: true, get: function () { return text_1.default; } });\r\n//# sourceMappingURL=index.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar g_base_1 = require(\"@antv/g-base\");\r\nvar util_1 = require(\"../util/util\");\r\nvar draw_1 = require(\"../util/draw\");\r\nvar g_base_2 = require(\"@antv/g-base\");\r\nvar Shape = require(\"./index\");\r\nvar group_1 = require(\"../group\");\r\nvar ShapeBase = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ShapeBase, _super);\r\n    function ShapeBase() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ShapeBase.prototype.getDefaultAttrs = function () {\r\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\r\n        // 设置默认值\r\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });\r\n    };\r\n    ShapeBase.prototype.getShapeBase = function () {\r\n        return Shape;\r\n    };\r\n    ShapeBase.prototype.getGroupBase = function () {\r\n        return group_1.default;\r\n    };\r\n    /**\r\n     * 一些方法调用会引起画布变化\r\n     * @param {ChangeType} changeType 改变的类型\r\n     */\r\n    ShapeBase.prototype.onCanvasChange = function (changeType) {\r\n        draw_1.refreshElement(this, changeType);\r\n    };\r\n    ShapeBase.prototype.calculateBBox = function () {\r\n        var type = this.get('type');\r\n        var lineWidth = this.getHitLineWidth();\r\n        // const attrs = this.attr();\r\n        var bboxMethod = g_base_2.getBBoxMethod(type);\r\n        var box = bboxMethod(this);\r\n        var halfLineWidth = lineWidth / 2;\r\n        var minX = box.x - halfLineWidth;\r\n        var minY = box.y - halfLineWidth;\r\n        var maxX = box.x + box.width + halfLineWidth;\r\n        var maxY = box.y + box.height + halfLineWidth;\r\n        return {\r\n            x: minX,\r\n            minX: minX,\r\n            y: minY,\r\n            minY: minY,\r\n            width: box.width + lineWidth,\r\n            height: box.height + lineWidth,\r\n            maxX: maxX,\r\n            maxY: maxY,\r\n        };\r\n    };\r\n    ShapeBase.prototype.isFill = function () {\r\n        return !!this.attrs['fill'] || this.isClipShape();\r\n    };\r\n    ShapeBase.prototype.isStroke = function () {\r\n        return !!this.attrs['stroke'];\r\n    };\r\n    // 同 shape 中的方法重复了\r\n    ShapeBase.prototype._applyClip = function (context, clip) {\r\n        if (clip) {\r\n            context.save();\r\n            // 将 clip 的属性挂载到 context 上\r\n            draw_1.applyAttrsToContext(context, clip);\r\n            // 绘制 clip 路径\r\n            clip.createPath(context);\r\n            context.restore();\r\n            // 裁剪\r\n            context.clip();\r\n            clip._afterDraw();\r\n        }\r\n    };\r\n    // 绘制图形时需要考虑 region 限制\r\n    ShapeBase.prototype.draw = function (context, region) {\r\n        var clip = this.cfg.clipShape;\r\n        // 如果指定了 region，同时不允许刷新时，直接返回\r\n        if (region) {\r\n            if (this.cfg.refresh === false) {\r\n                // this._afterDraw();\r\n                this.set('hasChanged', false);\r\n                return;\r\n            }\r\n            // 是否相交需要考虑 clip 的包围盒\r\n            var bbox = this.getCanvasBBox();\r\n            if (!util_1.intersectRect(region, bbox)) {\r\n                // 图形的包围盒与重绘区域不相交时，也需要清除标记\r\n                this.set('hasChanged', false);\r\n                // 存在多种情形需要更新 cacheCanvasBBox 和 isInview 的判定\r\n                // 1. 之前图形在视窗内，但是现在不再视窗内\r\n                // 2. 如果当前的图形以及父元素都没有发生过变化，refresh = false 不会走到这里，所以这里的图形都是父元素发生变化，但是没有在视图内的元素\r\n                if (this.cfg.isInView) {\r\n                    this._afterDraw();\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        context.save();\r\n        // 先将 attrs 应用到上下文中，再设置 clip。因为 clip 应该被当前元素的 matrix 所影响\r\n        draw_1.applyAttrsToContext(context, this);\r\n        this._applyClip(context, clip);\r\n        this.drawPath(context);\r\n        context.restore();\r\n        this._afterDraw();\r\n    };\r\n    ShapeBase.prototype.getCanvasViewBox = function () {\r\n        var canvas = this.cfg.canvas;\r\n        if (canvas) {\r\n            // @ts-ignore\r\n            return canvas.getViewRange();\r\n        }\r\n        return null;\r\n    };\r\n    ShapeBase.prototype.cacheCanvasBBox = function () {\r\n        var canvasBBox = this.getCanvasViewBox();\r\n        // 绘制的时候缓存包围盒\r\n        if (canvasBBox) {\r\n            var bbox = this.getCanvasBBox();\r\n            var isInView = util_1.intersectRect(bbox, canvasBBox);\r\n            this.set('isInView', isInView);\r\n            // 不再视窗内 cacheCanvasBBox 设置成 null，会提升局部渲染的性能，\r\n            // 因为在局部渲染影响的包围盒计算时不考虑这个图形的包围盒\r\n            // 父元素 cacheCanvasBBox 计算的时候也不计算\r\n            if (isInView) {\r\n                this.set('cacheCanvasBBox', bbox);\r\n            }\r\n            else {\r\n                this.set('cacheCanvasBBox', null);\r\n            }\r\n        }\r\n    };\r\n    ShapeBase.prototype._afterDraw = function () {\r\n        this.cacheCanvasBBox();\r\n        // 绘制后消除标记\r\n        this.set('hasChanged', false);\r\n        this.set('refresh', null);\r\n    };\r\n    ShapeBase.prototype.skipDraw = function () {\r\n        this.set('cacheCanvasBBox', null);\r\n        this.set('isInView', null);\r\n        this.set('hasChanged', false);\r\n    };\r\n    /**\r\n     * 绘制图形的路径\r\n     * @param {CanvasRenderingContext2D} context 上下文\r\n     */\r\n    ShapeBase.prototype.drawPath = function (context) {\r\n        this.createPath(context);\r\n        this.strokeAndFill(context);\r\n        this.afterDrawPath(context);\r\n    };\r\n    /**\r\n     * @protected\r\n     * 填充图形\r\n     * @param {CanvasRenderingContext2D} context context 上下文\r\n     */\r\n    ShapeBase.prototype.fill = function (context) {\r\n        context.fill();\r\n    };\r\n    /**\r\n     * @protected\r\n     * 绘制图形边框\r\n     * @param {CanvasRenderingContext2D} context context 上下文\r\n     */\r\n    ShapeBase.prototype.stroke = function (context) {\r\n        context.stroke();\r\n    };\r\n    // 绘制或者填充\r\n    ShapeBase.prototype.strokeAndFill = function (context) {\r\n        var _a = this.attrs, lineWidth = _a.lineWidth, opacity = _a.opacity, strokeOpacity = _a.strokeOpacity, fillOpacity = _a.fillOpacity;\r\n        if (this.isFill()) {\r\n            if (!util_1.isNil(fillOpacity) && fillOpacity !== 1) {\r\n                context.globalAlpha = fillOpacity;\r\n                this.fill(context);\r\n                context.globalAlpha = opacity;\r\n            }\r\n            else {\r\n                this.fill(context);\r\n            }\r\n        }\r\n        if (this.isStroke()) {\r\n            if (lineWidth > 0) {\r\n                if (!util_1.isNil(strokeOpacity) && strokeOpacity !== 1) {\r\n                    context.globalAlpha = strokeOpacity;\r\n                }\r\n                this.stroke(context);\r\n            }\r\n        }\r\n        this.afterDrawPath(context);\r\n    };\r\n    /**\r\n     * @protected\r\n     * 绘制图形的路径\r\n     * @param {CanvasRenderingContext2D} context 上下文\r\n     */\r\n    ShapeBase.prototype.createPath = function (context) { };\r\n    /**\r\n     * 绘制完成 path 后的操作\r\n     * @param {CanvasRenderingContext2D} context 上下文\r\n     */\r\n    ShapeBase.prototype.afterDrawPath = function (context) { };\r\n    ShapeBase.prototype.isInShape = function (refX, refY) {\r\n        // return HitUtil.isHitShape(this, refX, refY);\r\n        var isStroke = this.isStroke();\r\n        var isFill = this.isFill();\r\n        var lineWidth = this.getHitLineWidth();\r\n        return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);\r\n    };\r\n    // 之所以不拆成 isInStroke 和 isInPath 在于两者存在一些共同的计算\r\n    ShapeBase.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\r\n        return false;\r\n    };\r\n    /**\r\n     * 获取线拾取的宽度\r\n     * @returns {number} 线的拾取宽度\r\n     */\r\n    ShapeBase.prototype.getHitLineWidth = function () {\r\n        if (!this.isStroke()) {\r\n            return 0;\r\n        }\r\n        var attrs = this.attrs;\r\n        return attrs['lineWidth'] + attrs['lineAppendWidth'];\r\n    };\r\n    return ShapeBase;\r\n}(g_base_1.AbstractShape));\r\nexports.default = ShapeBase;\r\n//# sourceMappingURL=base.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isParent = exports.tick = exports.clearAnimationFrame = exports.requestAnimationFrame = exports.isNumberEqual = exports.mod = exports.toRadian = exports.each = exports.isArray = exports.isFunction = exports.isString = exports.isNil = exports.isSamePoint = exports.mergeRegion = exports.intersectRect = exports.inBox = exports.distance = exports.getPixelRatio = void 0;\r\nfunction getPixelRatio() {\r\n    return typeof window === 'object' && window.devicePixelRatio ? window.devicePixelRatio : 1;\r\n}\r\nexports.getPixelRatio = getPixelRatio;\r\n/**\r\n * 两点之间的距离\r\n * @param {number} x1 起始点 x\r\n * @param {number} y1 起始点 y\r\n * @param {number} x2 结束点 x\r\n * @param {number} y2 结束点 y\r\n */\r\nfunction distance(x1, y1, x2, y2) {\r\n    var dx = x1 - x2;\r\n    var dy = y1 - y2;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\nexports.distance = distance;\r\n/**\r\n * 是否在包围盒内\r\n * @param {number} minX   包围盒开始的点 x\r\n * @param {number} minY   包围盒开始的点 y\r\n * @param {number} width  宽度\r\n * @param {number} height 高度\r\n * @param {[type]} x      检测点的 x\r\n * @param {[type]} y      监测点的 y\r\n */\r\nfunction inBox(minX, minY, width, height, x, y) {\r\n    return x >= minX && x <= minX + width && y >= minY && y <= minY + height;\r\n}\r\nexports.inBox = inBox;\r\nfunction intersectRect(box1, box2) {\r\n    return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\r\n}\r\nexports.intersectRect = intersectRect;\r\n// 合并两个区域\r\nfunction mergeRegion(region1, region2) {\r\n    if (!region1 || !region2) {\r\n        return region1 || region2;\r\n    }\r\n    return {\r\n        minX: Math.min(region1.minX, region2.minX),\r\n        minY: Math.min(region1.minY, region2.minY),\r\n        maxX: Math.max(region1.maxX, region2.maxX),\r\n        maxY: Math.max(region1.maxY, region2.maxY),\r\n    };\r\n}\r\nexports.mergeRegion = mergeRegion;\r\n/**\r\n * 判断两个点是否重合，点坐标的格式为 [x, y]\r\n * @param {Array} point1 第一个点\r\n * @param {Array} point2 第二个点\r\n */\r\nfunction isSamePoint(point1, point2) {\r\n    return point1[0] === point2[0] && point1[1] === point2[1];\r\n}\r\nexports.isSamePoint = isSamePoint;\r\nvar util_1 = require(\"@antv/util\");\r\nObject.defineProperty(exports, \"isNil\", { enumerable: true, get: function () { return util_1.isNil; } });\r\nObject.defineProperty(exports, \"isString\", { enumerable: true, get: function () { return util_1.isString; } });\r\nObject.defineProperty(exports, \"isFunction\", { enumerable: true, get: function () { return util_1.isFunction; } });\r\nObject.defineProperty(exports, \"isArray\", { enumerable: true, get: function () { return util_1.isArray; } });\r\nObject.defineProperty(exports, \"each\", { enumerable: true, get: function () { return util_1.each; } });\r\nObject.defineProperty(exports, \"toRadian\", { enumerable: true, get: function () { return util_1.toRadian; } });\r\nObject.defineProperty(exports, \"mod\", { enumerable: true, get: function () { return util_1.mod; } });\r\nObject.defineProperty(exports, \"isNumberEqual\", { enumerable: true, get: function () { return util_1.isNumberEqual; } });\r\nvar time_1 = require(\"./time\");\r\nObject.defineProperty(exports, \"requestAnimationFrame\", { enumerable: true, get: function () { return time_1.requestAnimationFrame; } });\r\nObject.defineProperty(exports, \"clearAnimationFrame\", { enumerable: true, get: function () { return time_1.clearAnimationFrame; } });\r\nfunction tick(fn) {\r\n    if (window) {\r\n        requestAnimationFrame(fn);\r\n    }\r\n    else {\r\n        // TODO need a timeline to control time\r\n        setTimeout(fn, 16);\r\n    }\r\n}\r\nexports.tick = tick;\r\n// 是否元素的父容器\r\nfunction isParent(container, shape) {\r\n    // 所有 shape 都是 canvas 的子元素\r\n    if (container.isCanvas()) {\r\n        return true;\r\n    }\r\n    var parent = shape.getParent();\r\n    var isParent = false;\r\n    while (parent) {\r\n        if (parent === container) {\r\n            isParent = true;\r\n            break;\r\n        }\r\n        parent = parent.getParent();\r\n    }\r\n    return isParent;\r\n}\r\nexports.isParent = isParent;\r\n//# sourceMappingURL=util.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.clearAnimationFrame = exports.requestAnimationFrame = exports.setExtraFunction = void 0;\r\nvar canvas = {};\r\nfunction setExtraFunction(canvas) {\r\n    if (canvas === void 0) { canvas = {}; }\r\n    canvas = canvas;\r\n}\r\nexports.setExtraFunction = setExtraFunction;\r\nfunction requestAnimationFrame(fn) {\r\n    if (canvas === null || canvas === void 0 ? void 0 : canvas.requestAnimationFrame) {\r\n        return canvas.requestAnimationFrame(fn);\r\n    }\r\n    var method = typeof window === 'object' && window.requestAnimationFrame\r\n        ? window.requestAnimationFrame\r\n        : function (f) {\r\n            return setTimeout(f, 16);\r\n        };\r\n    return method(fn);\r\n}\r\nexports.requestAnimationFrame = requestAnimationFrame;\r\nfunction clearAnimationFrame(handler) {\r\n    if (canvas === null || canvas === void 0 ? void 0 : canvas.clearAnimationFrame) {\r\n        return canvas.clearAnimationFrame(handler);\r\n    }\r\n    var method = typeof window === 'object' && window.cancelAnimationFrame ? window.cancelAnimationFrame : clearTimeout;\r\n    return method(handler);\r\n}\r\nexports.clearAnimationFrame = clearAnimationFrame;\r\n//# sourceMappingURL=time.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.mergeView = exports.getMergedRegion = exports.getRefreshRegion = exports.refreshElement = exports.drawPath = exports.clearChanged = exports.checkChildrenRefresh = exports.checkRefresh = exports.drawChildren = exports.applyAttrsToContext = void 0;\r\nvar util_1 = require(\"@antv/util\");\r\nvar parse_1 = require(\"./parse\");\r\nvar arc_params_1 = require(\"./arc-params\");\r\nvar util_2 = require(\"./util\");\r\nvar ArrowUtil = require(\"../util/arrow\");\r\nvar SHAPE_ATTRS_MAP = {\r\n    fill: 'fillStyle',\r\n    stroke: 'strokeStyle',\r\n    opacity: 'globalAlpha',\r\n};\r\nfunction applyAttrsToContext(context, element) {\r\n    var attrs = element.attr();\r\n    for (var k in attrs) {\r\n        var v = attrs[k];\r\n        // 转换一下不与 canvas 兼容的属性名\r\n        var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;\r\n        if (name_1 === 'matrix' && v) {\r\n            // 设置矩阵\r\n            context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);\r\n        }\r\n        else if (name_1 === 'lineDash' && context.setLineDash) {\r\n            // 设置虚线，只支持数组形式，非数组形式不做任何操作\r\n            util_1.isArray(v) && context.setLineDash(v);\r\n        }\r\n        else {\r\n            if (name_1 === 'strokeStyle' || name_1 === 'fillStyle') {\r\n                // 如果存在渐变、pattern 这个开销有些大\r\n                // 可以考虑缓存机制，通过 hasUpdate 来避免一些运算\r\n                v = parse_1.parseStyle(context, element, v);\r\n            }\r\n            else if (name_1 === 'globalAlpha') {\r\n                // opacity 效果可以叠加，子元素的 opacity 需要与父元素 opacity 相乘\r\n                v = v * context.globalAlpha;\r\n            }\r\n            context[name_1] = v;\r\n        }\r\n    }\r\n}\r\nexports.applyAttrsToContext = applyAttrsToContext;\r\nfunction drawChildren(context, children, region) {\r\n    for (var i = 0; i < children.length; i++) {\r\n        var child = children[i];\r\n        if (child.cfg.visible) {\r\n            child.draw(context, region);\r\n        }\r\n        else {\r\n            child.skipDraw();\r\n        }\r\n    }\r\n}\r\nexports.drawChildren = drawChildren;\r\n// 这个地方的逻辑比较复杂，简单画了一张图：https://www.yuque.com/antv/ou292n/pcgt5g#OW1QE\r\nfunction checkRefresh(canvas, children, region) {\r\n    var refreshElements = canvas.get('refreshElements');\r\n    // 先遍历需要刷新的元素，将这些元素的父元素也设置 refresh\r\n    util_1.each(refreshElements, function (el) {\r\n        if (el !== canvas) {\r\n            var parent_1 = el.cfg.parent;\r\n            while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {\r\n                parent_1.cfg.refresh = true;\r\n                parent_1 = parent_1.cfg.parent;\r\n            }\r\n        }\r\n    });\r\n    if (refreshElements[0] === canvas) {\r\n        setChildrenRefresh(children, region);\r\n    }\r\n    else {\r\n        // 检查所有子元素是否可以刷新\r\n        checkChildrenRefresh(children, region);\r\n    }\r\n}\r\nexports.checkRefresh = checkRefresh;\r\n// 检查所有的子元素是否应该更新\r\nfunction checkChildrenRefresh(children, region) {\r\n    for (var i = 0; i < children.length; i++) {\r\n        var child = children[i];\r\n        if (child.cfg.visible) {\r\n            // 先判断 hasChanged，因为它的优先级判断应该高于 refresh\r\n            if (child.cfg.hasChanged) {\r\n                // 如果节点发生了 change，则需要级联设置子元素的 refresh\r\n                child.cfg.refresh = true;\r\n                if (child.isGroup()) {\r\n                    setChildrenRefresh(child.cfg.children, region);\r\n                }\r\n            }\r\n            else if (child.cfg.refresh) {\r\n                // 如果当前图形/分组 refresh = true，说明其子节点存在 changed\r\n                if (child.isGroup()) {\r\n                    checkChildrenRefresh(child.cfg.children, region);\r\n                }\r\n            }\r\n            else {\r\n                // 这个分支说明此次局部刷新，所有的节点和父元素没有发生变化，仅需要检查包围盒（缓存）是否相交即可\r\n                var refresh = checkElementRefresh(child, region);\r\n                child.cfg.refresh = refresh;\r\n                if (refresh && child.isGroup()) {\r\n                    // 如果需要刷新，说明子元素也需要刷新，继续进行判定\r\n                    checkChildrenRefresh(child.cfg.children, region);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.checkChildrenRefresh = checkChildrenRefresh;\r\n// 由于对改变的图形放入 refreshElements 时做了优化，判定父元素 changed 时不加入\r\n// 那么有可能会出现 elements 都为空，所以最终 group\r\nfunction clearChanged(elements) {\r\n    for (var i = 0; i < elements.length; i++) {\r\n        var el = elements[i];\r\n        el.cfg.hasChanged = false;\r\n        // 级联清理\r\n        if (el.isGroup() && !el.destroyed) {\r\n            clearChanged(el.cfg.children);\r\n        }\r\n    }\r\n}\r\nexports.clearChanged = clearChanged;\r\n// 当某个父元素发生改变时，调用这个方法级联设置 refresh\r\nfunction setChildrenRefresh(children, region) {\r\n    for (var i = 0; i < children.length; i++) {\r\n        var child = children[i];\r\n        // let refresh = true;\r\n        // 获取缓存的 bbox，如果这个 bbox 还存在则说明父元素不是矩阵发生了改变\r\n        // const bbox = child.cfg.canvasBBox;\r\n        // if (bbox) {\r\n        //   // 如果这时候\r\n        //   refresh = intersectRect(bbox, region);\r\n        // }\r\n        child.cfg.refresh = true;\r\n        // 如果需要刷新当前节点，所有的子元素设置 refresh\r\n        if (child.isGroup()) {\r\n            setChildrenRefresh(child.get('children'), region);\r\n        }\r\n    }\r\n}\r\nfunction checkElementRefresh(shape, region) {\r\n    var bbox = shape.cfg.cacheCanvasBBox;\r\n    var isAllow = shape.cfg.isInView && bbox && util_2.intersectRect(bbox, region);\r\n    return isAllow;\r\n}\r\n// 绘制 path\r\nfunction drawPath(shape, context, attrs, arcParamsCache) {\r\n    var path = attrs.path, startArrow = attrs.startArrow, endArrow = attrs.endArrow;\r\n    if (!path) {\r\n        return;\r\n    }\r\n    var currentPoint = [0, 0]; // 当前图形\r\n    var startMovePoint = [0, 0]; // 开始 M 的点，可能会有多个\r\n    var distance = {\r\n        dx: 0,\r\n        dy: 0,\r\n    };\r\n    context.beginPath();\r\n    for (var i = 0; i < path.length; i++) {\r\n        var params = path[i];\r\n        var command = params[0];\r\n        if (i === 0 && startArrow && startArrow.d) {\r\n            var tangent = shape.getStartTangent();\r\n            distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);\r\n        }\r\n        else if (i === path.length - 2 && path[i + 1][0] === 'Z' && endArrow && endArrow.d) {\r\n            // 为了防止结尾为 Z 的 segment 缩短不起效，需要取最后两个 segment 特殊处理\r\n            var lastPath = path[i + 1];\r\n            if (lastPath[0] === 'Z') {\r\n                var tangent = shape.getEndTangent();\r\n                distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);\r\n            }\r\n        }\r\n        else if (i === path.length - 1 && endArrow && endArrow.d) {\r\n            if (path[0] !== 'Z') {\r\n                var tangent = shape.getEndTangent();\r\n                distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);\r\n            }\r\n        }\r\n        var dx = distance.dx, dy = distance.dy;\r\n        // V,H,S,T 都在前面被转换成标准形式\r\n        switch (command) {\r\n            case 'M':\r\n                context.moveTo(params[1] - dx, params[2] - dy);\r\n                startMovePoint = [params[1], params[2]];\r\n                break;\r\n            case 'L':\r\n                context.lineTo(params[1] - dx, params[2] - dy);\r\n                break;\r\n            case 'Q':\r\n                context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);\r\n                break;\r\n            case 'C':\r\n                context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);\r\n                break;\r\n            case 'A': {\r\n                var arcParams = void 0;\r\n                // 为了加速绘制，可以提供参数的缓存，各个图形自己缓存\r\n                if (arcParamsCache) {\r\n                    arcParams = arcParamsCache[i];\r\n                    if (!arcParams) {\r\n                        arcParams = arc_params_1.default(currentPoint, params);\r\n                        arcParamsCache[i] = arcParams;\r\n                    }\r\n                }\r\n                else {\r\n                    arcParams = arc_params_1.default(currentPoint, params);\r\n                }\r\n                var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;\r\n                // 直接使用椭圆的 api\r\n                if (context.ellipse) {\r\n                    context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);\r\n                }\r\n                else {\r\n                    var r = rx > ry ? rx : ry;\r\n                    var scaleX = rx > ry ? 1 : rx / ry;\r\n                    var scaleY = rx > ry ? ry / rx : 1;\r\n                    context.translate(cx, cy);\r\n                    context.rotate(xRotation);\r\n                    context.scale(scaleX, scaleY);\r\n                    context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);\r\n                    context.scale(1 / scaleX, 1 / scaleY);\r\n                    context.rotate(-xRotation);\r\n                    context.translate(-cx, -cy);\r\n                }\r\n                break;\r\n            }\r\n            case 'Z':\r\n                context.closePath();\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        // 有了 Z 后，当前节点从开始 M 的点开始\r\n        if (command === 'Z') {\r\n            currentPoint = startMovePoint;\r\n        }\r\n        else {\r\n            var len = params.length;\r\n            currentPoint = [params[len - 2], params[len - 1]];\r\n        }\r\n    }\r\n}\r\nexports.drawPath = drawPath;\r\n// 刷新图形元素(Shape 或者 Group)\r\nfunction refreshElement(element, changeType) {\r\n    var canvas = element.get('canvas');\r\n    // 只有存在于 canvas 上时生效\r\n    if (canvas) {\r\n        if (changeType === 'remove') {\r\n            // 一旦 remove，则无法在 element 上拿到包围盒\r\n            // destroy 后所有属性都拿不到，所以需要暂存一下\r\n            // 这是一段 hack 的代码\r\n            element._cacheCanvasBBox = element.get('cacheCanvasBBox');\r\n        }\r\n        // 防止反复刷新\r\n        if (!element.get('hasChanged')) {\r\n            // 但是始终要标记为 hasChanged，便于后面进行局部渲染\r\n            element.set('hasChanged', true);\r\n            // 本来只有局部渲染模式下，才需要记录更新的元素队列\r\n            // if (canvas.get('localRefresh')) {\r\n            //   canvas.refreshElement(element, changeType, canvas);\r\n            // }\r\n            // 但对于 https://github.com/antvis/g/issues/422 的场景，全局渲染的模式下也需要记录更新的元素队列\r\n            // 如果当前元素的父元素发生了改变，可以不放入队列，这句话大概能够提升 15% 的初次渲染性能\r\n            if (!(element.cfg.parent && element.cfg.parent.get('hasChanged'))) {\r\n                canvas.refreshElement(element, changeType, canvas);\r\n                if (canvas.get('autoDraw')) {\r\n                    canvas.draw();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.refreshElement = refreshElement;\r\nfunction getRefreshRegion(element) {\r\n    var region;\r\n    if (!element.destroyed) {\r\n        var cacheBox = element.get('cacheCanvasBBox');\r\n        var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);\r\n        var bbox = element.getCanvasBBox();\r\n        var validBBox = bbox && !!(bbox.width && bbox.height);\r\n        // 是否是有效 bbox 判定，一些 NaN 或者 宽高为 0 的情况过滤掉\r\n        if (validCache && validBBox) {\r\n            region = util_2.mergeRegion(cacheBox, bbox);\r\n        }\r\n        else if (validCache) {\r\n            region = cacheBox;\r\n        }\r\n        else if (validBBox) {\r\n            region = bbox;\r\n        }\r\n    }\r\n    else {\r\n        // 因为元素已经销毁所以无法获取到缓存的包围盒\r\n        region = element['_cacheCanvasBBox'];\r\n    }\r\n    return region;\r\n}\r\nexports.getRefreshRegion = getRefreshRegion;\r\nfunction getMergedRegion(elements) {\r\n    if (!elements.length) {\r\n        return null;\r\n    }\r\n    var minXArr = [];\r\n    var minYArr = [];\r\n    var maxXArr = [];\r\n    var maxYArr = [];\r\n    util_1.each(elements, function (el) {\r\n        var region = getRefreshRegion(el);\r\n        if (region) {\r\n            minXArr.push(region.minX);\r\n            minYArr.push(region.minY);\r\n            maxXArr.push(region.maxX);\r\n            maxYArr.push(region.maxY);\r\n        }\r\n    });\r\n    return {\r\n        minX: Math.min.apply(null, minXArr),\r\n        minY: Math.min.apply(null, minYArr),\r\n        maxX: Math.max.apply(null, maxXArr),\r\n        maxY: Math.max.apply(null, maxYArr),\r\n    };\r\n}\r\nexports.getMergedRegion = getMergedRegion;\r\nfunction mergeView(region, viewRegion) {\r\n    if (!region || !viewRegion) {\r\n        return null;\r\n    }\r\n    // 不相交，则直接返回 null\r\n    if (!util_2.intersectRect(region, viewRegion)) {\r\n        return null;\r\n    }\r\n    return {\r\n        minX: Math.max(region.minX, viewRegion.minX),\r\n        minY: Math.max(region.minY, viewRegion.minY),\r\n        maxX: Math.min(region.maxX, viewRegion.maxX),\r\n        maxY: Math.min(region.maxY, viewRegion.maxY),\r\n    };\r\n}\r\nexports.mergeView = mergeView;\r\n//# sourceMappingURL=draw.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.parseRadius = exports.parseStyle = exports.parsePattern = exports.parseRadialGradient = exports.parseLineGradient = void 0;\r\nvar util_1 = require(\"./util\");\r\nvar regexLG = /^l\\s*\\(\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\r\nvar regexRG = /^r\\s*\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\r\nvar regexPR = /^p\\s*\\(\\s*([axyn])\\s*\\)\\s*(.*)/i;\r\nvar regexColorStop = /[\\d.]+:(#[^\\s]+|[^\\)]+\\))/gi;\r\nfunction addStop(steps, gradient) {\r\n    var arr = steps.match(regexColorStop);\r\n    util_1.each(arr, function (item) {\r\n        var itemArr = item.split(':');\r\n        gradient.addColorStop(itemArr[0], itemArr[1]);\r\n    });\r\n}\r\n/**\r\n * 将边和填充设置的颜色转换成线性渐变对象\r\n * @param {CanvasRenderingContext2D} context canvas 上下文\r\n * @param {IElement}                 element  图形元素\r\n * @param {string}                   gradientStr   颜色\r\n * @returns {any} 渐变对象\r\n */\r\nfunction parseLineGradient(context, element, gradientStr) {\r\n    var arr = regexLG.exec(gradientStr);\r\n    var angle = (parseFloat(arr[1]) % 360) * (Math.PI / 180);\r\n    var steps = arr[2];\r\n    var box = element.getBBox();\r\n    var start;\r\n    var end;\r\n    if (angle >= 0 && angle < (1 / 2) * Math.PI) {\r\n        start = {\r\n            x: box.minX,\r\n            y: box.minY,\r\n        };\r\n        end = {\r\n            x: box.maxX,\r\n            y: box.maxY,\r\n        };\r\n    }\r\n    else if ((1 / 2) * Math.PI <= angle && angle < Math.PI) {\r\n        start = {\r\n            x: box.maxX,\r\n            y: box.minY,\r\n        };\r\n        end = {\r\n            x: box.minX,\r\n            y: box.maxY,\r\n        };\r\n    }\r\n    else if (Math.PI <= angle && angle < (3 / 2) * Math.PI) {\r\n        start = {\r\n            x: box.maxX,\r\n            y: box.maxY,\r\n        };\r\n        end = {\r\n            x: box.minX,\r\n            y: box.minY,\r\n        };\r\n    }\r\n    else {\r\n        start = {\r\n            x: box.minX,\r\n            y: box.maxY,\r\n        };\r\n        end = {\r\n            x: box.maxX,\r\n            y: box.minY,\r\n        };\r\n    }\r\n    var tanTheta = Math.tan(angle);\r\n    var tanTheta2 = tanTheta * tanTheta;\r\n    var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;\r\n    var y = (tanTheta * (end.x - start.x + tanTheta * (end.y - start.y))) / (tanTheta2 + 1) + start.y;\r\n    var gradient = context.createLinearGradient(start.x, start.y, x, y);\r\n    addStop(steps, gradient);\r\n    return gradient;\r\n}\r\nexports.parseLineGradient = parseLineGradient;\r\n/**\r\n * 将边和填充设置的颜色转换成圆形渐变对象\r\n * @param {CanvasRenderingContext2D} context canvas 上下文\r\n * @param {IElement}                 element  图形元素\r\n * @param {string}                   gradientStr   颜色\r\n * @returns {any} 渐变对象\r\n */\r\nfunction parseRadialGradient(context, element, gradientStr) {\r\n    var arr = regexRG.exec(gradientStr);\r\n    var fx = parseFloat(arr[1]);\r\n    var fy = parseFloat(arr[2]);\r\n    var fr = parseFloat(arr[3]);\r\n    var steps = arr[4];\r\n    // 环半径为0时，默认无渐变，取渐变序列的最后一个颜色\r\n    if (fr === 0) {\r\n        var colors = steps.match(regexColorStop);\r\n        return colors[colors.length - 1].split(':')[1];\r\n    }\r\n    var box = element.getBBox();\r\n    var width = box.maxX - box.minX;\r\n    var height = box.maxY - box.minY;\r\n    var r = Math.sqrt(width * width + height * height) / 2;\r\n    var gradient = context.createRadialGradient(box.minX + width * fx, box.minY + height * fy, 0, box.minX + width / 2, box.minY + height / 2, fr * r);\r\n    addStop(steps, gradient);\r\n    return gradient;\r\n}\r\nexports.parseRadialGradient = parseRadialGradient;\r\n/**\r\n * 边和填充设置的颜色转换成 pattern\r\n * @param {CanvasRenderingContext2D} context canvas 上下文\r\n * @param {IElement}                 element  图形元素\r\n * @param {string}                   patternStr   生成 pattern 的字符串\r\n */\r\nfunction parsePattern(context, element, patternStr) {\r\n    // 在转换过程中进行了缓存\r\n    if (element.get('patternSource') && element.get('patternSource') === patternStr) {\r\n        return element.get('pattern');\r\n    }\r\n    var pattern;\r\n    var img;\r\n    var arr = regexPR.exec(patternStr);\r\n    var repeat = arr[1];\r\n    var source = arr[2];\r\n    // Function to be called when pattern loads\r\n    function onload() {\r\n        // Create pattern\r\n        pattern = context.createPattern(img, repeat);\r\n        element.set('pattern', pattern); // be a cache\r\n        element.set('patternSource', patternStr);\r\n    }\r\n    switch (repeat) {\r\n        case 'a':\r\n            repeat = 'repeat';\r\n            break;\r\n        case 'x':\r\n            repeat = 'repeat-x';\r\n            break;\r\n        case 'y':\r\n            repeat = 'repeat-y';\r\n            break;\r\n        case 'n':\r\n            repeat = 'no-repeat';\r\n            break;\r\n        default:\r\n            repeat = 'no-repeat';\r\n    }\r\n    img = new Image();\r\n    // If source URL is not a data URL\r\n    if (!source.match(/^data:/i)) {\r\n        // Set crossOrigin for this image\r\n        img.crossOrigin = 'Anonymous';\r\n    }\r\n    img.src = source;\r\n    if (img.complete) {\r\n        onload();\r\n    }\r\n    else {\r\n        img.onload = onload;\r\n        // Fix onload() bug in IE9\r\n        img.src = img.src;\r\n    }\r\n    return pattern;\r\n}\r\nexports.parsePattern = parsePattern;\r\nfunction parseStyle(context, element, color) {\r\n    if (util_1.isString(color)) {\r\n        if (color[1] === '(' || color[2] === '(') {\r\n            if (color[0] === 'l') {\r\n                // regexLG.test(color)\r\n                return parseLineGradient(context, element, color);\r\n            }\r\n            if (color[0] === 'r') {\r\n                // regexRG.test(color)\r\n                return parseRadialGradient(context, element, color);\r\n            }\r\n            if (color[0] === 'p') {\r\n                // regexPR.test(color)\r\n                return parsePattern(context, element, color);\r\n            }\r\n        }\r\n        return color;\r\n    }\r\n}\r\nexports.parseStyle = parseStyle;\r\nfunction parseRadius(radius) {\r\n    var r1 = 0;\r\n    var r2 = 0;\r\n    var r3 = 0;\r\n    var r4 = 0;\r\n    if (util_1.isArray(radius)) {\r\n        if (radius.length === 1) {\r\n            r1 = r2 = r3 = r4 = radius[0];\r\n        }\r\n        else if (radius.length === 2) {\r\n            r1 = r3 = radius[0];\r\n            r2 = r4 = radius[1];\r\n        }\r\n        else if (radius.length === 3) {\r\n            r1 = radius[0];\r\n            r2 = r4 = radius[1];\r\n            r3 = radius[2];\r\n        }\r\n        else {\r\n            r1 = radius[0];\r\n            r2 = radius[1];\r\n            r3 = radius[2];\r\n            r4 = radius[3];\r\n        }\r\n    }\r\n    else {\r\n        r1 = r2 = r3 = r4 = radius;\r\n    }\r\n    return [r1, r2, r3, r4];\r\n}\r\nexports.parseRadius = parseRadius;\r\n//# sourceMappingURL=parse.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = require(\"./util\");\r\n// 向量长度\r\nfunction vMag(v) {\r\n    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\r\n}\r\n// u.v/|u||v|，计算夹角的余弦值\r\nfunction vRatio(u, v) {\r\n    // 当存在一个向量的长度为 0 时，夹角也为 0，即夹角的余弦值为 1\r\n    return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;\r\n}\r\n// 向量角度\r\nfunction vAngle(u, v) {\r\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\r\n}\r\n// A 0:rx 1:ry 2:x-axis-rotation 3:large-arc-flag 4:sweep-flag 5: x 6: y\r\nfunction getArcParams(startPoint, params) {\r\n    var rx = params[1];\r\n    var ry = params[2];\r\n    var xRotation = util_1.mod(util_1.toRadian(params[3]), Math.PI * 2);\r\n    var arcFlag = params[4];\r\n    var sweepFlag = params[5];\r\n    // 弧形起点坐标\r\n    var x1 = startPoint[0];\r\n    var y1 = startPoint[1];\r\n    // 弧形终点坐标\r\n    var x2 = params[6];\r\n    var y2 = params[7];\r\n    var xp = (Math.cos(xRotation) * (x1 - x2)) / 2.0 + (Math.sin(xRotation) * (y1 - y2)) / 2.0;\r\n    var yp = (-1 * Math.sin(xRotation) * (x1 - x2)) / 2.0 + (Math.cos(xRotation) * (y1 - y2)) / 2.0;\r\n    var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\r\n    if (lambda > 1) {\r\n        rx *= Math.sqrt(lambda);\r\n        ry *= Math.sqrt(lambda);\r\n    }\r\n    var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);\r\n    var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;\r\n    if (arcFlag === sweepFlag) {\r\n        f *= -1;\r\n    }\r\n    if (isNaN(f)) {\r\n        f = 0;\r\n    }\r\n    // 旋转前的起点坐标，且当长半轴和短半轴的长度为 0 时，坐标按 (0, 0) 处理\r\n    var cxp = ry ? (f * rx * yp) / ry : 0;\r\n    var cyp = rx ? (f * -ry * xp) / rx : 0;\r\n    // 椭圆圆心坐标\r\n    var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;\r\n    var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;\r\n    // 起始点的单位向量\r\n    var u = [(xp - cxp) / rx, (yp - cyp) / ry];\r\n    // 终止点的单位向量\r\n    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\r\n    // 计算起始点和圆心的连线，与 x 轴正方向的夹角\r\n    var theta = vAngle([1, 0], u);\r\n    // 计算圆弧起始点和终止点与椭圆圆心连线的夹角\r\n    var dTheta = vAngle(u, v);\r\n    if (vRatio(u, v) <= -1) {\r\n        dTheta = Math.PI;\r\n    }\r\n    if (vRatio(u, v) >= 1) {\r\n        dTheta = 0;\r\n    }\r\n    if (sweepFlag === 0 && dTheta > 0) {\r\n        dTheta = dTheta - 2 * Math.PI;\r\n    }\r\n    if (sweepFlag === 1 && dTheta < 0) {\r\n        dTheta = dTheta + 2 * Math.PI;\r\n    }\r\n    return {\r\n        cx: cx,\r\n        cy: cy,\r\n        // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理\r\n        rx: util_1.isSamePoint(startPoint, [x2, y2]) ? 0 : rx,\r\n        ry: util_1.isSamePoint(startPoint, [x2, y2]) ? 0 : ry,\r\n        startAngle: theta,\r\n        endAngle: theta + dTheta,\r\n        xRotation: xRotation,\r\n        arcFlag: arcFlag,\r\n        sweepFlag: sweepFlag,\r\n    };\r\n}\r\nexports.default = getArcParams;\r\n//# sourceMappingURL=arc-params.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.addEndArrow = exports.addStartArrow = exports.getShortenOffset = void 0;\r\nvar tslib_1 = require(\"tslib\");\r\nvar shape_1 = require(\"../shape\");\r\nvar sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, PI = Math.PI;\r\nfunction _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {\r\n    var stroke = attrs.stroke, lineWidth = attrs.lineWidth;\r\n    var x = x1 - x2;\r\n    var y = y1 - y2;\r\n    var rad = atan2(y, x);\r\n    var arrowShape = new shape_1.Path({\r\n        type: 'path',\r\n        canvas: shape.get('canvas'),\r\n        isArrowShape: true,\r\n        attrs: {\r\n            // 默认箭头的边长为 10，夹角为 60 度\r\n            path: \"M\" + 10 * cos(PI / 6) + \",\" + 10 * sin(PI / 6) + \" L0,0 L\" + 10 * cos(PI / 6) + \",-\" + 10 * sin(PI / 6),\r\n            // 使用 shape stroke 值\r\n            stroke: stroke,\r\n            lineWidth: lineWidth,\r\n        },\r\n    });\r\n    arrowShape.translate(x2, y2);\r\n    arrowShape.rotateAtPoint(x2, y2, rad);\r\n    shape.set(isStart ? 'startArrowShape' : 'endArrowShape', arrowShape);\r\n}\r\n/**\r\n * 箭头 path 的设置要求\r\n * 1. 箭头顶点坐标需要为 (0, 0)\r\n * 2. 箭头夹角的中心分割线需要与 X 轴正方向对齐\r\n */\r\nfunction _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {\r\n    var startArrow = attrs.startArrow, endArrow = attrs.endArrow, stroke = attrs.stroke, lineWidth = attrs.lineWidth;\r\n    var arrowAttrs = isStart ? startArrow : endArrow;\r\n    var d = arrowAttrs.d, arrowFill = arrowAttrs.fill, arrowStroke = arrowAttrs.stroke, arrowLineWidth = arrowAttrs.lineWidth, restAttrs = tslib_1.__rest(arrowAttrs, [\"d\", \"fill\", \"stroke\", \"lineWidth\"]);\r\n    var x = x1 - x2;\r\n    var y = y1 - y2;\r\n    var rad = atan2(y, x);\r\n    if (d) {\r\n        x2 = x2 - cos(rad) * d;\r\n        y2 = y2 - sin(rad) * d;\r\n    }\r\n    var arrowShape = new shape_1.Path({\r\n        type: 'path',\r\n        canvas: shape.get('canvas'),\r\n        isArrowShape: true,\r\n        attrs: tslib_1.__assign(tslib_1.__assign({}, restAttrs), { \r\n            // 支持单独设置箭头的 stroke 和 lineWidth，若为空则使用 shape 的值\r\n            stroke: arrowStroke || stroke, lineWidth: arrowLineWidth || lineWidth, \r\n            // 箭头是否填充需要手动设置，不会继承自 shape 的值\r\n            fill: arrowFill }),\r\n    });\r\n    arrowShape.translate(x2, y2);\r\n    arrowShape.rotateAtPoint(x2, y2, rad);\r\n    shape.set(isStart ? 'startArrowShape' : 'endArrowShape', arrowShape);\r\n}\r\n/**\r\n * 如果自定义箭头并且有 d 需要做偏移，如果直接画，线条会超出箭头尖端，因此需要根据箭头偏移 d, 返回线需要缩短的距离\r\n * |----------------\r\n * |<|--------------\r\n * |\r\n * @param {number} x1 起始点 x\r\n * @param {number} y1 起始点 y\r\n * @param {number} x2 箭头作用点 x\r\n * @param {number} y2 箭头作用点 y\r\n * @param {number} d  箭头沿线条方向的偏移距离\r\n * @return {{dx: number, dy: number}} 返回线条偏移距离\r\n */\r\nfunction getShortenOffset(x1, y1, x2, y2, d) {\r\n    var rad = atan2(y2 - y1, x2 - x1);\r\n    return {\r\n        dx: cos(rad) * d,\r\n        dy: sin(rad) * d,\r\n    };\r\n}\r\nexports.getShortenOffset = getShortenOffset;\r\n/**\r\n * 绘制起始箭头\r\n * @param {IShape} shape 图形\r\n * @param {ShapeAttrs} attrs shape 的绘图属性\r\n * @param {number} x1 起始点 x\r\n * @param {number} y1 起始点 y\r\n * @param {number} x2 箭头作用点 x\r\n * @param {number} y2 箭头作用点 y\r\n */\r\nfunction addStartArrow(shape, attrs, x1, y1, x2, y2) {\r\n    if (typeof attrs.startArrow === 'object') {\r\n        _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);\r\n    }\r\n    else if (attrs.startArrow) {\r\n        _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);\r\n    }\r\n    else {\r\n        shape.set('startArrowShape', null);\r\n    }\r\n}\r\nexports.addStartArrow = addStartArrow;\r\n/**\r\n * 绘制结束箭头\r\n * @param {IShape} shape 图形\r\n * @param {ShapeAttrs} attrs shape 的绘图属性\r\n * @param {number} x1 起始点 x\r\n * @param {number} y1 起始点 y\r\n * @param {number} x2 箭头作用点 x\r\n * @param {number} y2 箭头作用点 y\r\n */\r\nfunction addEndArrow(shape, attrs, x1, y1, x2, y2) {\r\n    if (typeof attrs.endArrow === 'object') {\r\n        _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);\r\n    }\r\n    else if (attrs.endArrow) {\r\n        _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);\r\n    }\r\n    else {\r\n        shape.set('startArrowShape', null);\r\n    }\r\n}\r\nexports.addEndArrow = addEndArrow;\r\n//# sourceMappingURL=arrow.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar g_base_1 = require(\"@antv/g-base\");\r\nvar Shape = require(\"./shape\");\r\nvar draw_1 = require(\"./util/draw\");\r\nvar util_1 = require(\"@antv/util\");\r\nvar util_2 = require(\"./util/util\");\r\nvar Group = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Group, _super);\r\n    function Group() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * 一些方法调用会引起画布变化\r\n     * @param {ChangeType} changeType 改变的类型\r\n     */\r\n    Group.prototype.onCanvasChange = function (changeType) {\r\n        draw_1.refreshElement(this, changeType);\r\n    };\r\n    Group.prototype.getShapeBase = function () {\r\n        return Shape;\r\n    };\r\n    Group.prototype.getGroupBase = function () {\r\n        return Group;\r\n    };\r\n    // 同 shape 中的方法重复了\r\n    Group.prototype._applyClip = function (context, clip) {\r\n        if (clip) {\r\n            context.save();\r\n            // 将 clip 的属性挂载到 context 上\r\n            draw_1.applyAttrsToContext(context, clip);\r\n            // 绘制 clip 路径\r\n            clip.createPath(context);\r\n            context.restore();\r\n            // 裁剪\r\n            context.clip();\r\n            clip._afterDraw();\r\n        }\r\n    };\r\n    // 这个方法以前直接使用的 getCanvasBBox，由于 group 上没有缓存，所以每次重新计算，导致性能开销比较大\r\n    // 大概能够节省全局渲染 15-20% 的性能，如果不在这里加缓存优化后 10W 个节点无法达到 5-6 ms，大概能够 30-40ms\r\n    Group.prototype.cacheCanvasBBox = function () {\r\n        var children = this.cfg.children;\r\n        var xArr = [];\r\n        var yArr = [];\r\n        util_1.each(children, function (child) {\r\n            var bbox = child.cfg.cacheCanvasBBox;\r\n            // isInview 的判定是一旦图形或者分组渲染就要计算是否在视图内，\r\n            // 这个判定 10W 个图形下差不多能够节省 5-6 ms 的开销\r\n            if (bbox && child.cfg.isInView) {\r\n                xArr.push(bbox.minX, bbox.maxX);\r\n                yArr.push(bbox.minY, bbox.maxY);\r\n            }\r\n        });\r\n        var bbox = null;\r\n        if (xArr.length) {\r\n            var minX = Math.min.apply(null, xArr);\r\n            var maxX = Math.max.apply(null, xArr);\r\n            var minY = Math.min.apply(null, yArr);\r\n            var maxY = Math.max.apply(null, yArr);\r\n            bbox = {\r\n                minX: minX,\r\n                minY: minY,\r\n                x: minX,\r\n                y: minY,\r\n                maxX: maxX,\r\n                maxY: maxY,\r\n                width: maxX - minX,\r\n                height: maxY - minY,\r\n            };\r\n            var canvas = this.cfg.canvas;\r\n            if (canvas) {\r\n                var viewRange = canvas.getViewRange();\r\n                // 如果这个地方判定 isInView == false 设置 bbox 为 false 的话，拾取的性能会更高\r\n                // 但是目前 10W 图形的拾取在 2-5ms 内，这个优化意义不大，可以后期观察再看\r\n                this.set('isInView', util_2.intersectRect(bbox, viewRange));\r\n            }\r\n        }\r\n        else {\r\n            this.set('isInView', false);\r\n        }\r\n        this.set('cacheCanvasBBox', bbox);\r\n    };\r\n    Group.prototype.draw = function (context, region) {\r\n        var children = this.cfg.children;\r\n        var allowDraw = region ? this.cfg.refresh : true; // 局部刷新需要判定\r\n        // 这个地方需要判定，在 G6 的场景每个 group 都有 transform 的场景下性能会开销非常大\r\n        // 通过 refresh 的判定，可以不刷新没有发生过变化的分组，不在视窗内的分组等等\r\n        // 如果想进一步提升局部渲染性能，可以进一步优化 refresh 的判定，依然有潜力\r\n        if (children.length && allowDraw) {\r\n            context.save();\r\n            // group 上的矩阵和属性也会应用到上下文上\r\n            // 先将 attrs 应用到上下文中，再设置 clip。因为 clip 应该被当前元素的 matrix 所影响\r\n            draw_1.applyAttrsToContext(context, this);\r\n            this._applyClip(context, this.getClip());\r\n            draw_1.drawChildren(context, children, region);\r\n            context.restore();\r\n            this.cacheCanvasBBox();\r\n        }\r\n        // 这里的成本比较大，如果不绘制则不再\r\n        // this.set('cacheCanvasBBox', this.getCanvasBBox());\r\n        this.cfg.refresh = null;\r\n        // 绘制后，消除更新标记\r\n        this.set('hasChanged', false);\r\n    };\r\n    // 绘制时被跳过，一般发生在分组隐藏时\r\n    Group.prototype.skipDraw = function () {\r\n        this.set('cacheCanvasBBox', null);\r\n        this.set('hasChanged', false);\r\n    };\r\n    return Group;\r\n}(g_base_1.AbstractGroup));\r\nexports.default = Group;\r\n//# sourceMappingURL=group.js.map","\r\n/**\r\n * @fileoverview 圆\r\n * @author dxq613@gmail.com\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar base_1 = require(\"./base\");\r\nvar util_1 = require(\"../util/util\");\r\nvar Circle = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Circle, _super);\r\n    function Circle() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Circle.prototype.getDefaultAttrs = function () {\r\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\r\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { x: 0, y: 0, r: 0 });\r\n    };\r\n    Circle.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\r\n        var attrs = this.attr();\r\n        var cx = attrs.x;\r\n        var cy = attrs.y;\r\n        var r = attrs.r;\r\n        var halfLineWidth = lineWidth / 2;\r\n        var absDistance = util_1.distance(cx, cy, x, y);\r\n        // 直接用距离，如果同时存在边和填充时，可以减少两次计算\r\n        if (isFill && isStroke) {\r\n            return absDistance <= r + halfLineWidth;\r\n        }\r\n        if (isFill) {\r\n            return absDistance <= r;\r\n        }\r\n        if (isStroke) {\r\n            return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;\r\n        }\r\n        return false;\r\n    };\r\n    Circle.prototype.createPath = function (context) {\r\n        var attrs = this.attr();\r\n        var cx = attrs.x;\r\n        var cy = attrs.y;\r\n        var r = attrs.r;\r\n        context.beginPath();\r\n        context.arc(cx, cy, r, 0, Math.PI * 2, false);\r\n        context.closePath();\r\n    };\r\n    return Circle;\r\n}(base_1.default));\r\nexports.default = Circle;\r\n//# sourceMappingURL=circle.js.map","\r\n/**\r\n * @fileoverview 椭圆\r\n * @author dxq613@gmail.com\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar base_1 = require(\"./base\");\r\n// 根据椭圆公式计算 x*x/rx*rx + y*y/ry*ry;\r\nfunction ellipseDistance(squareX, squareY, rx, ry) {\r\n    return squareX / (rx * rx) + squareY / (ry * ry);\r\n}\r\nvar Ellipse = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Ellipse, _super);\r\n    function Ellipse() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Ellipse.prototype.getDefaultAttrs = function () {\r\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\r\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });\r\n    };\r\n    Ellipse.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\r\n        var attrs = this.attr();\r\n        var halfLineWith = lineWidth / 2;\r\n        var cx = attrs.x;\r\n        var cy = attrs.y;\r\n        var rx = attrs.rx, ry = attrs.ry;\r\n        var squareX = (x - cx) * (x - cx);\r\n        var squareY = (y - cy) * (y - cy);\r\n        // 使用椭圆的公式： x*x/rx*rx + y*y/ry*ry = 1;\r\n        if (isFill && isStroke) {\r\n            return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;\r\n        }\r\n        if (isFill) {\r\n            return ellipseDistance(squareX, squareY, rx, ry) <= 1;\r\n        }\r\n        if (isStroke) {\r\n            return (ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 &&\r\n                ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1);\r\n        }\r\n        return false;\r\n    };\r\n    Ellipse.prototype.createPath = function (context) {\r\n        var attrs = this.attr();\r\n        var cx = attrs.x;\r\n        var cy = attrs.y;\r\n        var rx = attrs.rx;\r\n        var ry = attrs.ry;\r\n        context.beginPath();\r\n        // 兼容逻辑\r\n        if (context.ellipse) {\r\n            context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);\r\n        }\r\n        else {\r\n            // 如果不支持，则使用圆来绘制，进行变形\r\n            var r = rx > ry ? rx : ry;\r\n            var scaleX = rx > ry ? 1 : rx / ry;\r\n            var scaleY = rx > ry ? ry / rx : 1;\r\n            context.save();\r\n            context.translate(cx, cy);\r\n            context.scale(scaleX, scaleY);\r\n            context.arc(0, 0, r, 0, Math.PI * 2);\r\n            context.restore();\r\n            context.closePath();\r\n        }\r\n    };\r\n    return Ellipse;\r\n}(base_1.default));\r\nexports.default = Ellipse;\r\n//# sourceMappingURL=ellipse.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.setMiniCanvas = void 0;\r\nvar tslib_1 = require(\"tslib\");\r\nvar base_1 = require(\"./base\");\r\nvar util_1 = require(\"../util/util\");\r\nfunction isCanvas(dom) {\r\n    return dom instanceof HTMLElement && util_1.isString(dom.nodeName) && dom.nodeName.toUpperCase() === 'CANVAS';\r\n}\r\nvar miniCanvas = null;\r\nfunction setMiniCanvas(canvas) {\r\n    miniCanvas = canvas;\r\n}\r\nexports.setMiniCanvas = setMiniCanvas;\r\nvar ImageShape = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ImageShape, _super);\r\n    function ImageShape() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ImageShape.prototype.getDefaultAttrs = function () {\r\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\r\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0 });\r\n    };\r\n    ImageShape.prototype.initAttrs = function (attrs) {\r\n        this._setImage(attrs.img);\r\n    };\r\n    // image 不计算 stroke\r\n    ImageShape.prototype.isStroke = function () {\r\n        return false;\r\n    };\r\n    // 仅仅使用包围盒检测来进行拾取\r\n    // 所以不需要复写 isInStrokeOrPath 的方法\r\n    ImageShape.prototype.isOnlyHitBox = function () {\r\n        return true;\r\n    };\r\n    ImageShape.prototype._afterLoading = function () {\r\n        if (this.get('toDraw') === true) {\r\n            var canvas = this.get('canvas');\r\n            if (canvas) {\r\n                // 这段应该改成局部渲染\r\n                canvas.draw();\r\n            }\r\n            else {\r\n                // 这种方式如果发生遮挡会出现问题\r\n                this.createPath(this.get('context'));\r\n            }\r\n        }\r\n    };\r\n    ImageShape.prototype._setImage = function (img) {\r\n        var _this = this;\r\n        var attrs = this.attrs;\r\n        // 1.0 小程序canvas下只能用string绘制\r\n        if ((miniCanvas === null || miniCanvas === void 0 ? void 0 : miniCanvas.isMini()) && !(miniCanvas === null || miniCanvas === void 0 ? void 0 : miniCanvas.isMiniNative())) {\r\n            this.attr('img', img);\r\n            return;\r\n        }\r\n        // 以下兼容2.0 小程序canvas\r\n        if (util_1.isString(img)) {\r\n            var image_1 = null;\r\n            if (miniCanvas === null || miniCanvas === void 0 ? void 0 : miniCanvas.isMiniNative()) {\r\n                image_1 = miniCanvas === null || miniCanvas === void 0 ? void 0 : miniCanvas.get('container').createImage();\r\n            }\r\n            else {\r\n                image_1 = new Image();\r\n            }\r\n            image_1.onload = function () {\r\n                // 图片未加载完，则已经被销毁\r\n                if (_this.destroyed) {\r\n                    return false;\r\n                }\r\n                // 缓存原始地址，可以做对比，防止重复加载图片\r\n                // 如果考虑到在加载过程中可能替换 img 属性，则情况更加复杂\r\n                // this.set('imgSrc', img);\r\n                // 这里会循环调用 _setImage 方法，但不会再走这个分支\r\n                _this.attr('img', image_1);\r\n                _this.set('loading', false);\r\n                _this._afterLoading();\r\n                var callback = _this.get('callback');\r\n                if (callback) {\r\n                    callback.call(_this);\r\n                }\r\n            };\r\n            // 设置跨域\r\n            image_1.crossOrigin = 'Anonymous';\r\n            image_1.src = img;\r\n            // loading 过程中不绘制\r\n            this.set('loading', true);\r\n        }\r\n        else if ((miniCanvas === null || miniCanvas === void 0 ? void 0 : miniCanvas.isMiniNative()) || img instanceof Image) {\r\n            if (!attrs.width) {\r\n                attrs.width = img.width;\r\n            }\r\n            if (!attrs.height) {\r\n                attrs.height = img.height;\r\n            }\r\n        }\r\n        else if (isCanvas(img)) {\r\n            // 如果设置了 canvas 对象\r\n            if (!attrs.width) {\r\n                attrs.width = Number(img.getAttribute('width'));\r\n            }\r\n            if (!attrs.height) {\r\n                attrs.height, Number(img.getAttribute('height'));\r\n            }\r\n        }\r\n    };\r\n    ImageShape.prototype.onAttrChange = function (name, value, originValue) {\r\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\r\n        // 如果加载的已经是当前图片，则不再处理\r\n        if (name === 'img') {\r\n            // 可以加缓冲，&& this.get('imgSrc') !== value\r\n            this._setImage(value);\r\n        }\r\n    };\r\n    ImageShape.prototype.createPath = function (context) {\r\n        var attrs = this.attr();\r\n        var img = attrs.img, x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height, sx = attrs.sx, sy = attrs.sy, swidth = attrs.swidth, sheight = attrs.sheight;\r\n        // 正在加载则不绘制\r\n        if (this.get('loading')) {\r\n            this.set('toDraw', true); // 加载完成后绘制\r\n            this.set('context', context);\r\n            return;\r\n        }\r\n        if (miniCanvas === null || miniCanvas === void 0 ? void 0 : miniCanvas.isMini()) {\r\n            context.drawImage(img, x, y, width, height);\r\n            return;\r\n        }\r\n        if (img instanceof Image || isCanvas(img)) {\r\n            if (!util_1.isNil(sx) && !util_1.isNil(sy) && !util_1.isNil(swidth) && !util_1.isNil(sheight)) {\r\n                context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);\r\n            }\r\n            else {\r\n                context.drawImage(img, x, y, width, height);\r\n            }\r\n        }\r\n    };\r\n    return ImageShape;\r\n}(base_1.default));\r\nexports.default = ImageShape;\r\n//# sourceMappingURL=image.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\n/**\r\n * @fileoverview 圆\r\n * @author dxq613@gmail.com\r\n */\r\nvar g_math_1 = require(\"@antv/g-math\");\r\nvar base_1 = require(\"./base\");\r\nvar line_1 = require(\"../util/in-stroke/line\");\r\nvar ArrowUtil = require(\"../util/arrow\");\r\nvar Line = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Line, _super);\r\n    function Line() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Line.prototype.getDefaultAttrs = function () {\r\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\r\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });\r\n    };\r\n    Line.prototype.initAttrs = function (attrs) {\r\n        this.setArrow();\r\n    };\r\n    // 更新属性时，检测是否更改了箭头\r\n    Line.prototype.onAttrChange = function (name, value, originValue) {\r\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\r\n        // 由于箭头的绘制依赖于 line 的诸多 attrs，因此这里不再对每个 attr 进行判断，attr 每次变化都会影响箭头的更新\r\n        this.setArrow();\r\n    };\r\n    Line.prototype.setArrow = function () {\r\n        var attrs = this.attr();\r\n        var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;\r\n        if (startArrow) {\r\n            ArrowUtil.addStartArrow(this, attrs, x2, y2, x1, y1);\r\n        }\r\n        if (endArrow) {\r\n            ArrowUtil.addEndArrow(this, attrs, x1, y1, x2, y2);\r\n        }\r\n    };\r\n    Line.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\r\n        if (!isStroke || !lineWidth) {\r\n            return false;\r\n        }\r\n        var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;\r\n        return line_1.default(x1, y1, x2, y2, lineWidth, x, y);\r\n    };\r\n    Line.prototype.createPath = function (context) {\r\n        var attrs = this.attr();\r\n        var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;\r\n        var startArrowDistance = {\r\n            dx: 0,\r\n            dy: 0,\r\n        };\r\n        var endArrowDistance = {\r\n            dx: 0,\r\n            dy: 0,\r\n        };\r\n        if (startArrow && startArrow.d) {\r\n            startArrowDistance = ArrowUtil.getShortenOffset(x1, y1, x2, y2, attrs.startArrow.d);\r\n        }\r\n        if (endArrow && endArrow.d) {\r\n            endArrowDistance = ArrowUtil.getShortenOffset(x1, y1, x2, y2, attrs.endArrow.d);\r\n        }\r\n        context.beginPath();\r\n        // 如果自定义箭头，线条相应缩进\r\n        context.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);\r\n        context.lineTo(x2 - endArrowDistance.dx, y2 - endArrowDistance.dy);\r\n    };\r\n    Line.prototype.afterDrawPath = function (context) {\r\n        var startArrowShape = this.get('startArrowShape');\r\n        var endArrowShape = this.get('endArrowShape');\r\n        if (startArrowShape) {\r\n            startArrowShape.draw(context);\r\n        }\r\n        if (endArrowShape) {\r\n            endArrowShape.draw(context);\r\n        }\r\n    };\r\n    /**\r\n     * Get length of line\r\n     * @return {number} length\r\n     */\r\n    Line.prototype.getTotalLength = function () {\r\n        var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;\r\n        return g_math_1.Line.length(x1, y1, x2, y2);\r\n    };\r\n    /**\r\n     * Get point according to ratio\r\n     * @param {number} ratio\r\n     * @return {Point} point\r\n     */\r\n    Line.prototype.getPoint = function (ratio) {\r\n        var _a = this.attr(), x1 = _a.x1, y1 = _a.y1, x2 = _a.x2, y2 = _a.y2;\r\n        return g_math_1.Line.pointAt(x1, y1, x2, y2, ratio);\r\n    };\r\n    return Line;\r\n}(base_1.default));\r\nexports.default = Line;\r\n//# sourceMappingURL=line.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar g_math_1 = require(\"@antv/g-math\");\r\nfunction inLine(x1, y1, x2, y2, lineWidth, x, y) {\r\n    var minX = Math.min(x1, x2);\r\n    var maxX = Math.max(x1, x2);\r\n    var minY = Math.min(y1, y2);\r\n    var maxY = Math.max(y1, y2);\r\n    var halfWidth = lineWidth / 2;\r\n    // 因为目前的方案是计算点到直线的距离，而有可能会在延长线上，所以要先判断是否在包围盒内\r\n    // 这种方案会在水平或者竖直的情况下载线的延长线上有半 lineWidth 的误差\r\n    if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {\r\n        return false;\r\n    }\r\n    // 因为已经计算了包围盒，所以仅需要计算到直线的距离即可，可以显著提升性能\r\n    return g_math_1.Line.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;\r\n}\r\nexports.default = inLine;\r\n//# sourceMappingURL=line.js.map","\r\n/**\r\n * @fileoverview Marker\r\n * @author dxq613@gmail.com\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar util_1 = require(\"@antv/util\");\r\nvar path_util_1 = require(\"@antv/path-util\");\r\nvar base_1 = require(\"./base\");\r\nvar util_2 = require(\"../util/util\");\r\nvar draw_1 = require(\"../util/draw\");\r\nvar Symbols = {\r\n    // 圆\r\n    circle: function (x, y, r) {\r\n        return [\r\n            ['M', x - r, y],\r\n            ['A', r, r, 0, 1, 0, x + r, y],\r\n            ['A', r, r, 0, 1, 0, x - r, y],\r\n        ];\r\n    },\r\n    // 正方形\r\n    square: function (x, y, r) {\r\n        return [['M', x - r, y - r], ['L', x + r, y - r], ['L', x + r, y + r], ['L', x - r, y + r], ['Z']];\r\n    },\r\n    // 菱形\r\n    diamond: function (x, y, r) {\r\n        return [['M', x - r, y], ['L', x, y - r], ['L', x + r, y], ['L', x, y + r], ['Z']];\r\n    },\r\n    // 三角形\r\n    triangle: function (x, y, r) {\r\n        var diffY = r * Math.sin((1 / 3) * Math.PI);\r\n        return [['M', x - r, y + diffY], ['L', x, y - diffY], ['L', x + r, y + diffY], ['Z']];\r\n    },\r\n    // 倒三角形\r\n    'triangle-down': function (x, y, r) {\r\n        var diffY = r * Math.sin((1 / 3) * Math.PI);\r\n        return [['M', x - r, y - diffY], ['L', x + r, y - diffY], ['L', x, y + diffY], ['Z']];\r\n    },\r\n};\r\nvar Marker = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Marker, _super);\r\n    function Marker() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Marker.prototype.initAttrs = function (attrs) {\r\n        this._resetParamsCache();\r\n    };\r\n    // 重置绘制 path 存储的缓存\r\n    Marker.prototype._resetParamsCache = function () {\r\n        // 为了加速 path 的绘制、拾取和计算，这个地方可以缓存很多东西\r\n        // 这些缓存都是第一次需要时计算和存储，虽然增加了复杂度，但是频繁调用的方法，性能有很大提升\r\n        this.set('paramsCache', {}); // 清理缓存\r\n    };\r\n    // 更新属性时，检测是否更改了 path\r\n    Marker.prototype.onAttrChange = function (name, value, originValue) {\r\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\r\n        if (['symbol', 'x', 'y', 'r', 'radius'].indexOf(name) !== -1) {\r\n            // path 相关属性更改时，清理缓存\r\n            this._resetParamsCache();\r\n        }\r\n    };\r\n    // 仅仅使用包围盒检测来进行拾取\r\n    // 所以不需要复写 isInStrokeOrPath 的方法\r\n    Marker.prototype.isOnlyHitBox = function () {\r\n        return true;\r\n    };\r\n    Marker.prototype._getR = function (attrs) {\r\n        // 兼容 r 和 radius 两种写法，推荐使用 r\r\n        return util_1.isNil(attrs.r) ? attrs.radius : attrs.r;\r\n    };\r\n    Marker.prototype._getPath = function () {\r\n        var attrs = this.attr();\r\n        var x = attrs.x, y = attrs.y;\r\n        var symbol = attrs.symbol || 'circle';\r\n        var r = this._getR(attrs);\r\n        var method;\r\n        var path;\r\n        if (util_2.isFunction(symbol)) {\r\n            method = symbol;\r\n            path = method(x, y, r);\r\n            // 将 path 转成绝对路径\r\n            path = path_util_1.path2Absolute(path);\r\n        }\r\n        else {\r\n            // 内置 symbol 的 path 都是绝对路径，直接绘制即可，不需要对 path 进行特殊处理\r\n            method = Marker.Symbols[symbol];\r\n            if (!method) {\r\n                console.warn(symbol + \" marker is not supported.\");\r\n                return null;\r\n            }\r\n            path = method(x, y, r);\r\n        }\r\n        return path;\r\n    };\r\n    Marker.prototype.createPath = function (context) {\r\n        var path = this._getPath();\r\n        var paramsCache = this.get('paramsCache');\r\n        draw_1.drawPath(this, context, { path: path }, paramsCache);\r\n    };\r\n    Marker.Symbols = Symbols;\r\n    return Marker;\r\n}(base_1.default));\r\nexports.default = Marker;\r\n//# sourceMappingURL=marker.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar g_math_1 = require(\"@antv/g-math\");\r\nvar util_1 = require(\"@antv/util\");\r\nvar base_1 = require(\"./base\");\r\nvar path_util_1 = require(\"@antv/path-util\");\r\nvar draw_1 = require(\"../util/draw\");\r\nvar polygon_1 = require(\"../util/in-path/polygon\");\r\nvar path_1 = require(\"../util/path\");\r\nvar ArrowUtil = require(\"../util/arrow\");\r\n// 是否在多个多边形内部\r\nfunction isInPolygons(polygons, x, y) {\r\n    var isHit = false;\r\n    for (var i = 0; i < polygons.length; i++) {\r\n        var points = polygons[i];\r\n        isHit = polygon_1.default(points, x, y);\r\n        if (isHit) {\r\n            break;\r\n        }\r\n    }\r\n    return isHit;\r\n}\r\nvar Path = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Path, _super);\r\n    function Path() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Path.prototype.getDefaultAttrs = function () {\r\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\r\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { startArrow: false, endArrow: false });\r\n    };\r\n    Path.prototype.initAttrs = function (attrs) {\r\n        this._setPathArr(attrs.path);\r\n        this.setArrow();\r\n    };\r\n    // 更新属性时，检测是否更改了 path\r\n    Path.prototype.onAttrChange = function (name, value, originValue) {\r\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\r\n        if (name === 'path') {\r\n            this._setPathArr(value);\r\n        }\r\n        // 由于箭头的绘制依赖于 line 的诸多 attrs，因此这里不再对每个 attr 进行判断，attr 每次变化都会影响箭头的更新\r\n        this.setArrow();\r\n    };\r\n    // 将 path 转换成绝对路径\r\n    Path.prototype._setPathArr = function (path) {\r\n        // 转换 path 的格式\r\n        this.attrs.path = path_util_1.path2Absolute(path);\r\n        var hasArc = path_1.default.hasArc(path);\r\n        // 为了加速 path 的绘制、拾取和计算，这个地方可以缓存很多东西\r\n        // 这些缓存都是第一次需要时计算和存储，虽然增加了复杂度，但是频繁调用的方法，性能有很大提升\r\n        this.set('hasArc', hasArc);\r\n        this.set('paramsCache', {}); // 清理缓存\r\n        this.set('segments', null); // 延迟生成 path，在动画场景下可能不会有拾取\r\n        this.set('curve', null);\r\n        this.set('tCache', null);\r\n        this.set('totalLength', null);\r\n    };\r\n    Path.prototype.getSegments = function () {\r\n        var segments = this.get('segements');\r\n        if (!segments) {\r\n            segments = path_util_1.path2Segments(this.attr('path'));\r\n            this.set('segments', segments);\r\n        }\r\n        return segments;\r\n    };\r\n    Path.prototype.setArrow = function () {\r\n        var attrs = this.attr();\r\n        var startArrow = attrs.startArrow, endArrow = attrs.endArrow;\r\n        if (startArrow) {\r\n            var tangent = this.getStartTangent();\r\n            ArrowUtil.addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);\r\n        }\r\n        if (endArrow) {\r\n            var tangent = this.getEndTangent();\r\n            ArrowUtil.addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);\r\n        }\r\n    };\r\n    Path.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\r\n        var segments = this.getSegments();\r\n        var hasArc = this.get('hasArc');\r\n        var isHit = false;\r\n        if (isStroke) {\r\n            var length_1 = this.getTotalLength();\r\n            isHit = path_1.default.isPointInStroke(segments, lineWidth, x, y, length_1);\r\n        }\r\n        if (!isHit && isFill) {\r\n            // TODO 处理hasArc的场景\r\n            var path = this.attr('path');\r\n            var extractResutl = path_1.default.extractPolygons(path);\r\n            // 提取出来的多边形包含闭合的和非闭合的，在这里统一按照多边形处理\r\n            isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);\r\n        }\r\n        return isHit;\r\n    };\r\n    Path.prototype.createPath = function (context) {\r\n        var attrs = this.attr();\r\n        var paramsCache = this.get('paramsCache'); // 由于计算圆弧的参数成本很大，所以要缓存\r\n        draw_1.drawPath(this, context, attrs, paramsCache);\r\n    };\r\n    Path.prototype.afterDrawPath = function (context) {\r\n        var startArrowShape = this.get('startArrowShape');\r\n        var endArrowShape = this.get('endArrowShape');\r\n        if (startArrowShape) {\r\n            startArrowShape.draw(context);\r\n        }\r\n        if (endArrowShape) {\r\n            endArrowShape.draw(context);\r\n        }\r\n    };\r\n    /**\r\n     * Get total length of path\r\n     * @return {number} length\r\n     */\r\n    Path.prototype.getTotalLength = function () {\r\n        var totalLength = this.get('totalLength');\r\n        if (!util_1.isNil(totalLength)) {\r\n            return totalLength;\r\n        }\r\n        this._calculateCurve();\r\n        this._setTcache();\r\n        return this.get('totalLength');\r\n    };\r\n    /**\r\n     * Get point according to ratio\r\n     * @param {number} ratio\r\n     * @return {Point} point\r\n     */\r\n    Path.prototype.getPoint = function (ratio) {\r\n        var tCache = this.get('tCache');\r\n        if (!tCache) {\r\n            this._calculateCurve();\r\n            this._setTcache();\r\n            tCache = this.get('tCache');\r\n        }\r\n        var subt;\r\n        var index;\r\n        var curve = this.get('curve');\r\n        if (!tCache || tCache.length === 0) {\r\n            if (curve) {\r\n                return {\r\n                    x: curve[0][1],\r\n                    y: curve[0][2],\r\n                };\r\n            }\r\n            return null;\r\n        }\r\n        util_1.each(tCache, function (v, i) {\r\n            if (ratio >= v[0] && ratio <= v[1]) {\r\n                subt = (ratio - v[0]) / (v[1] - v[0]);\r\n                index = i;\r\n            }\r\n        });\r\n        var seg = curve[index];\r\n        if (util_1.isNil(seg) || util_1.isNil(index)) {\r\n            return null;\r\n        }\r\n        var l = seg.length;\r\n        var nextSeg = curve[index + 1];\r\n        return g_math_1.Cubic.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);\r\n    };\r\n    Path.prototype._calculateCurve = function () {\r\n        var path = this.attr().path;\r\n        this.set('curve', path_1.default.pathToCurve(path));\r\n    };\r\n    Path.prototype._setTcache = function () {\r\n        var totalLength = 0;\r\n        var tempLength = 0;\r\n        // 每段 curve 对应起止点的长度比例列表，形如: [[0, 0.25], [0.25, 0.6]. [0.6, 0.9], [0.9, 1]]\r\n        var tCache = [];\r\n        var segmentT;\r\n        var segmentL;\r\n        var segmentN;\r\n        var l;\r\n        var curve = this.get('curve');\r\n        if (!curve) {\r\n            return;\r\n        }\r\n        util_1.each(curve, function (segment, i) {\r\n            segmentN = curve[i + 1];\r\n            l = segment.length;\r\n            if (segmentN) {\r\n                totalLength +=\r\n                    g_math_1.Cubic.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;\r\n            }\r\n        });\r\n        this.set('totalLength', totalLength);\r\n        if (totalLength === 0) {\r\n            this.set('tCache', []);\r\n            return;\r\n        }\r\n        util_1.each(curve, function (segment, i) {\r\n            segmentN = curve[i + 1];\r\n            l = segment.length;\r\n            if (segmentN) {\r\n                segmentT = [];\r\n                segmentT[0] = tempLength / totalLength;\r\n                segmentL = g_math_1.Cubic.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);\r\n                // 当 path 不连续时，segmentL 可能为空，为空时需要作为 0 处理\r\n                tempLength += segmentL || 0;\r\n                segmentT[1] = tempLength / totalLength;\r\n                tCache.push(segmentT);\r\n            }\r\n        });\r\n        this.set('tCache', tCache);\r\n    };\r\n    /**\r\n     * Get start tangent vector\r\n     * @return {Array}\r\n     */\r\n    Path.prototype.getStartTangent = function () {\r\n        var segments = this.getSegments();\r\n        var result;\r\n        if (segments.length > 1) {\r\n            var startPoint = segments[0].currentPoint;\r\n            var endPoint = segments[1].currentPoint;\r\n            var tangent = segments[1].startTangent;\r\n            result = [];\r\n            if (tangent) {\r\n                result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);\r\n                result.push([startPoint[0], startPoint[1]]);\r\n            }\r\n            else {\r\n                result.push([endPoint[0], endPoint[1]]);\r\n                result.push([startPoint[0], startPoint[1]]);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * Get end tangent vector\r\n     * @return {Array}\r\n     */\r\n    Path.prototype.getEndTangent = function () {\r\n        var segments = this.getSegments();\r\n        var length = segments.length;\r\n        var result;\r\n        if (length > 1) {\r\n            var startPoint = segments[length - 2].currentPoint;\r\n            var endPoint = segments[length - 1].currentPoint;\r\n            var tangent = segments[length - 1].endTangent;\r\n            result = [];\r\n            if (tangent) {\r\n                result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);\r\n                result.push([endPoint[0], endPoint[1]]);\r\n            }\r\n            else {\r\n                result.push([startPoint[0], startPoint[1]]);\r\n                result.push([endPoint[0], endPoint[1]]);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    return Path;\r\n}(base_1.default));\r\nexports.default = Path;\r\n//# sourceMappingURL=path.js.map","\r\n/**\r\n * @fileoverview 判断点是否在多边形内\r\n * @author dxq613@gmail.com\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// 多边形的射线检测，参考：https://blog.csdn.net/WilliamSun0122/article/details/77994526\r\nvar tolerance = 1e-6;\r\n// 三态函数，判断两个double在eps精度下的大小关系\r\nfunction dcmp(x) {\r\n    if (Math.abs(x) < tolerance) {\r\n        return 0;\r\n    }\r\n    return x < 0 ? -1 : 1;\r\n}\r\n// 判断点Q是否在p1和p2的线段上\r\nfunction onSegment(p1, p2, q) {\r\n    if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) &&\r\n        Math.min(p1[0], p2[0]) <= q[0] &&\r\n        q[0] <= Math.max(p1[0], p2[0]) &&\r\n        Math.min(p1[1], p2[1]) <= q[1] &&\r\n        q[1] <= Math.max(p1[1], p2[1])) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n// 判断点P在多边形内-射线法\r\nfunction isInPolygon(points, x, y) {\r\n    var isHit = false;\r\n    var n = points.length;\r\n    if (n <= 2) {\r\n        // svg 中点小于 3 个时，不显示，也无法被拾取\r\n        return false;\r\n    }\r\n    for (var i = 0; i < n; i++) {\r\n        var p1 = points[i];\r\n        var p2 = points[(i + 1) % n];\r\n        if (onSegment(p1, p2, [x, y])) {\r\n            // 点在多边形一条边上\r\n            return true;\r\n        }\r\n        // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\r\n        // 后一个判断被测点 在 射线与边交点 的左边\r\n        if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 &&\r\n            dcmp(x - ((y - p1[1]) * (p1[0] - p2[0])) / (p1[1] - p2[1]) - p1[0]) < 0) {\r\n            isHit = !isHit;\r\n        }\r\n    }\r\n    return isHit;\r\n}\r\nexports.default = isInPolygon;\r\n//# sourceMappingURL=polygon.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\n/**\r\n * @fileoverview path 的一些工具\r\n * @author dxq613@gmail.com\r\n */\r\nvar g_base_1 = require(\"@antv/g-base\");\r\nvar g_math_1 = require(\"@antv/g-math\");\r\nvar g_math_2 = require(\"@antv/g-math\");\r\nvar matrix_util_1 = require(\"@antv/matrix-util\");\r\nvar vec3 = require(\"gl-matrix/vec3\");\r\nvar util_1 = require(\"./util\");\r\nvar line_1 = require(\"./in-stroke/line\");\r\nvar arc_1 = require(\"./in-stroke/arc\");\r\nvar transform = matrix_util_1.ext.transform;\r\nfunction hasArc(path) {\r\n    var hasArc = false;\r\n    var count = path.length;\r\n    for (var i = 0; i < count; i++) {\r\n        var params = path[i];\r\n        var cmd = params[0];\r\n        if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {\r\n            hasArc = true;\r\n            break;\r\n        }\r\n    }\r\n    return hasArc;\r\n}\r\nfunction isPointInStroke(segments, lineWidth, x, y, length) {\r\n    var isHit = false;\r\n    var halfWidth = lineWidth / 2;\r\n    for (var i = 0; i < segments.length; i++) {\r\n        var segment = segments[i];\r\n        var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box = segment.box;\r\n        // 如果在前面已经生成过包围盒，直接按照包围盒计算\r\n        if (box && !util_1.inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, x, y)) {\r\n            continue;\r\n        }\r\n        switch (segment.command) {\r\n            // L 和 Z 都是直线， M 不进行拾取\r\n            case 'L':\r\n            case 'Z':\r\n                isHit = line_1.default(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);\r\n                break;\r\n            case 'Q':\r\n                var qDistance = g_math_1.Quad.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);\r\n                isHit = qDistance <= lineWidth / 2;\r\n                break;\r\n            case 'C':\r\n                var cDistance = g_math_2.Cubic.pointDistance(prePoint[0], // 上一段结束位置, 即 C 的起始点\r\n                prePoint[1], params[1], // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点\r\n                params[2], params[3], params[4], params[5], params[6], x, y, length);\r\n                isHit = cDistance <= lineWidth / 2;\r\n                break;\r\n            case 'A':\r\n                // 计算点到椭圆圆弧的距离，暂时使用近似算法，后面可以改成切割法求最近距离\r\n                var arcParams = segment.arcParams;\r\n                var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;\r\n                var p = [x, y, 1];\r\n                var r = rx > ry ? rx : ry;\r\n                var scaleX = rx > ry ? 1 : rx / ry;\r\n                var scaleY = rx > ry ? ry / rx : 1;\r\n                var m = transform(null, [\r\n                    ['t', -cx, -cy],\r\n                    ['r', -xRotation],\r\n                    ['s', 1 / scaleX, 1 / scaleY],\r\n                ]);\r\n                vec3.transformMat3(p, p, m);\r\n                isHit = arc_1.default(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        if (isHit) {\r\n            break;\r\n        }\r\n    }\r\n    return isHit;\r\n}\r\n/**\r\n * 提取出内部的闭合多边形和非闭合的多边形，假设 path 不存在圆弧\r\n * @param {Array} path 路径\r\n * @returns {Array} 点的集合\r\n */\r\nfunction extractPolygons(path) {\r\n    var count = path.length;\r\n    var polygons = [];\r\n    var polylines = [];\r\n    var points = []; // 防止第一个命令不是 'M'\r\n    for (var i = 0; i < count; i++) {\r\n        var params = path[i];\r\n        var cmd = params[0];\r\n        if (cmd === 'M') {\r\n            // 遇到 'M' 判定是否是新数组，新数组中没有点\r\n            if (points.length) {\r\n                // 如果存在点，则说明没有遇到 'Z'，开始了一个新的多边形\r\n                polylines.push(points);\r\n                points = []; // 创建新的点\r\n            }\r\n            points.push([params[1], params[2]]);\r\n        }\r\n        else if (cmd === 'Z') {\r\n            if (points.length) {\r\n                // 存在点\r\n                polygons.push(points);\r\n                points = []; // 开始新的点集合\r\n            }\r\n            // 如果不存在点，同时 'Z'，则说明是错误，不处理\r\n        }\r\n        else {\r\n            points.push([params[1], params[2]]);\r\n        }\r\n    }\r\n    // 说明 points 未放入 polygons 或者 polyline\r\n    // 仅当只有一个 M，没有 Z 时会发生这种情况\r\n    if (points.length > 0) {\r\n        polylines.push(points);\r\n    }\r\n    return {\r\n        polygons: polygons,\r\n        polylines: polylines,\r\n    };\r\n}\r\nexports.default = tslib_1.__assign({ hasArc: hasArc, extractPolygons: extractPolygons, isPointInStroke: isPointInStroke }, g_base_1.PathUtil);\r\n//# sourceMappingURL=path.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = require(\"../util\");\r\nfunction arc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {\r\n    var angle = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2); // 转换到 0 - 2 * Math.PI 之间\r\n    if (angle < startAngle || angle > endAngle) {\r\n        return false;\r\n    }\r\n    var point = {\r\n        x: cx + r * Math.cos(angle),\r\n        y: cy + r * Math.sin(angle),\r\n    };\r\n    return util_1.distance(point.x, point.y, x, y) <= lineWidth / 2;\r\n}\r\nexports.default = arc;\r\n//# sourceMappingURL=arc.js.map","\r\n/**\r\n * @fileoverview 多边形\r\n * @author dxq613@gmail.com\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar base_1 = require(\"./base\");\r\nvar polyline_1 = require(\"../util/in-stroke/polyline\");\r\nvar polygon_1 = require(\"../util/in-path/polygon\");\r\nvar Polygon = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Polygon, _super);\r\n    function Polygon() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Polygon.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\r\n        var points = this.attr().points;\r\n        var isHit = false;\r\n        if (isStroke) {\r\n            isHit = polyline_1.default(points, lineWidth, x, y, true);\r\n        }\r\n        if (!isHit && isFill) {\r\n            isHit = polygon_1.default(points, x, y);\r\n        }\r\n        return isHit;\r\n    };\r\n    Polygon.prototype.createPath = function (context) {\r\n        var attrs = this.attr();\r\n        var points = attrs.points;\r\n        if (points.length < 2) {\r\n            return;\r\n        }\r\n        context.beginPath();\r\n        for (var i = 0; i < points.length; i++) {\r\n            var point = points[i];\r\n            if (i === 0) {\r\n                context.moveTo(point[0], point[1]);\r\n            }\r\n            else {\r\n                context.lineTo(point[0], point[1]);\r\n            }\r\n        }\r\n        context.closePath();\r\n    };\r\n    return Polygon;\r\n}(base_1.default));\r\nexports.default = Polygon;\r\n//# sourceMappingURL=polygon.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar line_1 = require(\"./line\");\r\nfunction inPolyline(points, lineWidth, x, y, isClose) {\r\n    var count = points.length;\r\n    if (count < 2) {\r\n        return false;\r\n    }\r\n    for (var i = 0; i < count - 1; i++) {\r\n        var x1 = points[i][0];\r\n        var y1 = points[i][1];\r\n        var x2 = points[i + 1][0];\r\n        var y2 = points[i + 1][1];\r\n        if (line_1.default(x1, y1, x2, y2, lineWidth, x, y)) {\r\n            return true;\r\n        }\r\n    }\r\n    // 如果封闭，则计算起始点和结束点的边\r\n    if (isClose) {\r\n        var first = points[0];\r\n        var last = points[count - 1];\r\n        if (line_1.default(first[0], first[1], last[0], last[1], lineWidth, x, y)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexports.default = inPolyline;\r\n//# sourceMappingURL=polyline.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar g_math_1 = require(\"@antv/g-math\");\r\nvar g_math_2 = require(\"@antv/g-math\");\r\nvar util_1 = require(\"@antv/util\");\r\nvar base_1 = require(\"./base\");\r\nvar polyline_1 = require(\"../util/in-stroke/polyline\");\r\nvar ArrowUtil = require(\"../util/arrow\");\r\nvar PolyLine = /** @class */ (function (_super) {\r\n    tslib_1.__extends(PolyLine, _super);\r\n    function PolyLine() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    PolyLine.prototype.getDefaultAttrs = function () {\r\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\r\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { startArrow: false, endArrow: false });\r\n    };\r\n    PolyLine.prototype.initAttrs = function (attrs) {\r\n        this.setArrow();\r\n    };\r\n    // 更新属性时，检测是否更改了 points\r\n    PolyLine.prototype.onAttrChange = function (name, value, originValue) {\r\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\r\n        this.setArrow();\r\n        if (['points'].indexOf(name) !== -1) {\r\n            this._resetCache();\r\n        }\r\n    };\r\n    PolyLine.prototype._resetCache = function () {\r\n        this.set('totalLength', null);\r\n        this.set('tCache', null);\r\n    };\r\n    PolyLine.prototype.setArrow = function () {\r\n        var attrs = this.attr();\r\n        var _a = this.attrs, points = _a.points, startArrow = _a.startArrow, endArrow = _a.endArrow;\r\n        var length = points.length;\r\n        var x1 = points[0][0];\r\n        var y1 = points[0][1];\r\n        var x2 = points[length - 1][0];\r\n        var y2 = points[length - 1][1];\r\n        if (startArrow) {\r\n            ArrowUtil.addStartArrow(this, attrs, points[1][0], points[1][1], x1, y1);\r\n        }\r\n        if (endArrow) {\r\n            ArrowUtil.addEndArrow(this, attrs, points[length - 2][0], points[length - 2][1], x2, y2);\r\n        }\r\n    };\r\n    // 不允许 fill\r\n    PolyLine.prototype.isFill = function () {\r\n        return false;\r\n    };\r\n    PolyLine.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\r\n        // 没有设置 stroke 不能被拾取, 没有线宽不能被拾取\r\n        if (!isStroke || !lineWidth) {\r\n            return false;\r\n        }\r\n        var points = this.attr().points;\r\n        return polyline_1.default(points, lineWidth, x, y, false);\r\n    };\r\n    // 始终填充\r\n    PolyLine.prototype.isStroke = function () {\r\n        return true;\r\n    };\r\n    PolyLine.prototype.createPath = function (context) {\r\n        var _a = this.attr(), points = _a.points, startArrow = _a.startArrow, endArrow = _a.endArrow;\r\n        var length = points.length;\r\n        if (points.length < 2) {\r\n            return;\r\n        }\r\n        var x1 = points[0][0];\r\n        var y1 = points[0][1];\r\n        var x2 = points[length - 1][0];\r\n        var y2 = points[length - 1][1];\r\n        // 如果定义了箭头，并且是自定义箭头，线条相应缩进\r\n        if (startArrow && startArrow.d) {\r\n            var distance = ArrowUtil.getShortenOffset(x1, y1, points[1][0], points[1][1], startArrow.d);\r\n            x1 += distance.dx;\r\n            y1 += distance.dy;\r\n        }\r\n        if (endArrow && endArrow.d) {\r\n            var distance = ArrowUtil.getShortenOffset(points[length - 2][0], points[length - 2][1], x2, y2, endArrow.d);\r\n            x2 -= distance.dx;\r\n            y2 -= distance.dy;\r\n        }\r\n        context.beginPath();\r\n        context.moveTo(x1, y1);\r\n        for (var i = 0; i < length - 1; i++) {\r\n            var point = points[i];\r\n            context.lineTo(point[0], point[1]);\r\n        }\r\n        context.lineTo(x2, y2);\r\n    };\r\n    PolyLine.prototype.afterDrawPath = function (context) {\r\n        var startArrowShape = this.get('startArrowShape');\r\n        var endArrowShape = this.get('endArrowShape');\r\n        if (startArrowShape) {\r\n            startArrowShape.draw(context);\r\n        }\r\n        if (endArrowShape) {\r\n            endArrowShape.draw(context);\r\n        }\r\n    };\r\n    /**\r\n     * Get length of polyline\r\n     * @return {number} length\r\n     */\r\n    PolyLine.prototype.getTotalLength = function () {\r\n        var points = this.attr().points;\r\n        // get totalLength from cache\r\n        var totalLength = this.get('totalLength');\r\n        if (!util_1.isNil(totalLength)) {\r\n            return totalLength;\r\n        }\r\n        this.set('totalLength', g_math_2.Polyline.length(points));\r\n        return this.get('totalLength');\r\n    };\r\n    /**\r\n     * Get point according to ratio\r\n     * @param {number} ratio\r\n     * @return {Point} point\r\n     */\r\n    PolyLine.prototype.getPoint = function (ratio) {\r\n        var points = this.attr().points;\r\n        // get tCache from cache\r\n        var tCache = this.get('tCache');\r\n        if (!tCache) {\r\n            this._setTcache();\r\n            tCache = this.get('tCache');\r\n        }\r\n        var subt;\r\n        var index;\r\n        util_1.each(tCache, function (v, i) {\r\n            if (ratio >= v[0] && ratio <= v[1]) {\r\n                subt = (ratio - v[0]) / (v[1] - v[0]);\r\n                index = i;\r\n            }\r\n        });\r\n        return g_math_1.Line.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);\r\n    };\r\n    PolyLine.prototype._setTcache = function () {\r\n        var points = this.attr().points;\r\n        if (!points || points.length === 0) {\r\n            return;\r\n        }\r\n        var totalLength = this.getTotalLength();\r\n        if (totalLength <= 0) {\r\n            return;\r\n        }\r\n        var tempLength = 0;\r\n        var tCache = [];\r\n        var segmentT;\r\n        var segmentL;\r\n        util_1.each(points, function (p, i) {\r\n            if (points[i + 1]) {\r\n                segmentT = [];\r\n                segmentT[0] = tempLength / totalLength;\r\n                segmentL = g_math_1.Line.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);\r\n                tempLength += segmentL;\r\n                segmentT[1] = tempLength / totalLength;\r\n                tCache.push(segmentT);\r\n            }\r\n        });\r\n        this.set('tCache', tCache);\r\n    };\r\n    /**\r\n     * Get start tangent vector\r\n     * @return {Array}\r\n     */\r\n    PolyLine.prototype.getStartTangent = function () {\r\n        var points = this.attr().points;\r\n        var result = [];\r\n        result.push([points[1][0], points[1][1]]);\r\n        result.push([points[0][0], points[0][1]]);\r\n        return result;\r\n    };\r\n    /**\r\n     * Get end tangent vector\r\n     * @return {Array}\r\n     */\r\n    PolyLine.prototype.getEndTangent = function () {\r\n        var points = this.attr().points;\r\n        var l = points.length - 1;\r\n        var result = [];\r\n        result.push([points[l - 1][0], points[l - 1][1]]);\r\n        result.push([points[l][0], points[l][1]]);\r\n        return result;\r\n    };\r\n    return PolyLine;\r\n}(base_1.default));\r\nexports.default = PolyLine;\r\n//# sourceMappingURL=polyline.js.map","\r\n/**\r\n * @fileoverview 矩形\r\n * @author dxq613@gmail.com\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar base_1 = require(\"./base\");\r\nvar parse_1 = require(\"../util/parse\");\r\nvar util_1 = require(\"../util/util\");\r\nvar rect_1 = require(\"../util/in-stroke/rect\");\r\nvar rect_radius_1 = require(\"../util/in-stroke/rect-radius\");\r\nvar Rect = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Rect, _super);\r\n    function Rect() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Rect.prototype.getDefaultAttrs = function () {\r\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\r\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });\r\n    };\r\n    Rect.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\r\n        var attrs = this.attr();\r\n        var minX = attrs.x;\r\n        var minY = attrs.y;\r\n        var width = attrs.width;\r\n        var height = attrs.height;\r\n        var radius = attrs.radius;\r\n        // 无圆角时的策略\r\n        if (!radius) {\r\n            var halfWidth = lineWidth / 2;\r\n            // 同时填充和带有边框\r\n            if (isFill && isStroke) {\r\n                return util_1.inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x, y);\r\n            }\r\n            // 仅填充\r\n            if (isFill) {\r\n                return util_1.inBox(minX, minY, width, height, x, y);\r\n            }\r\n            if (isStroke) {\r\n                return rect_1.default(minX, minY, width, height, lineWidth, x, y);\r\n            }\r\n        }\r\n        else {\r\n            var isHit = false;\r\n            if (isStroke) {\r\n                isHit = rect_radius_1.default(minX, minY, width, height, radius, lineWidth, x, y);\r\n            }\r\n            // 仅填充时带有圆角的矩形直接通过图形拾取\r\n            // 以后可以改成纯数学的近似拾取，将圆弧切割成多边形\r\n            if (!isHit && isFill) {\r\n                // TODO 简单判断，后续补\r\n                isHit = util_1.inBox(minX, minY, width, height, x, y);\r\n            }\r\n            return isHit;\r\n        }\r\n    };\r\n    Rect.prototype.createPath = function (context) {\r\n        var attrs = this.attr();\r\n        var x = attrs.x;\r\n        var y = attrs.y;\r\n        var width = attrs.width;\r\n        var height = attrs.height;\r\n        var radius = attrs.radius;\r\n        context.beginPath();\r\n        if (radius === 0) {\r\n            // 改成原生的rect方法\r\n            context.rect(x, y, width, height);\r\n        }\r\n        else {\r\n            var _a = parse_1.parseRadius(radius), r1 = _a[0], r2 = _a[1], r3 = _a[2], r4 = _a[3];\r\n            context.moveTo(x + r1, y);\r\n            context.lineTo(x + width - r2, y);\r\n            r2 !== 0 && context.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);\r\n            context.lineTo(x + width, y + height - r3);\r\n            r3 !== 0 && context.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);\r\n            context.lineTo(x + r4, y + height);\r\n            r4 !== 0 && context.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);\r\n            context.lineTo(x, y + r1);\r\n            r1 !== 0 && context.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);\r\n            context.closePath();\r\n        }\r\n    };\r\n    return Rect;\r\n}(base_1.default));\r\nexports.default = Rect;\r\n//# sourceMappingURL=rect.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = require(\"../util\");\r\nfunction inRect(minX, minY, width, height, lineWidth, x, y) {\r\n    var halfWidth = lineWidth / 2;\r\n    // 将四个边看做矩形来检测，比边的检测算法要快\r\n    return (util_1.inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || // 上边\r\n        util_1.inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || // 右边\r\n        util_1.inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || // 下边\r\n        util_1.inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y)); // 左边\r\n}\r\nexports.default = inRect;\r\n//# sourceMappingURL=rect.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar line_1 = require(\"./line\");\r\nvar arc_1 = require(\"./arc\");\r\nfunction rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y) {\r\n    var halfWidth = lineWidth / 2;\r\n    return (line_1.default(minX + radius, minY, minX + width - radius, minY, lineWidth, x, y) ||\r\n        line_1.default(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x, y) ||\r\n        line_1.default(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x, y) ||\r\n        line_1.default(minX, minY + height - radius, minX, minY + radius, lineWidth, x, y) ||\r\n        arc_1.default(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) ||\r\n        arc_1.default(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x, y) ||\r\n        arc_1.default(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x, y) ||\r\n        arc_1.default(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x, y));\r\n}\r\nexports.default = rectWithRadius;\r\n//# sourceMappingURL=rect-radius.js.map","\r\n/**\r\n * @fileoverview 文本\r\n * @author dxq613@gmail.com\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar base_1 = require(\"./base\");\r\nvar util_1 = require(\"../util/util\");\r\nvar g_base_1 = require(\"@antv/g-base\");\r\nvar Text = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Text, _super);\r\n    function Text() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // 默认文本属性\r\n    Text.prototype.getDefaultAttrs = function () {\r\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\r\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: 'sans-serif', fontStyle: 'normal', fontWeight: 'normal', fontVariant: 'normal', textAlign: 'start', textBaseline: 'bottom' });\r\n    };\r\n    // 仅仅使用包围盒检测来进行拾取\r\n    Text.prototype.isOnlyHitBox = function () {\r\n        return true;\r\n    };\r\n    // 初始化时组合 font，同时判断 text 是否换行\r\n    Text.prototype.initAttrs = function (attrs) {\r\n        this._assembleFont();\r\n        if (attrs.text) {\r\n            this._setText(attrs.text);\r\n        }\r\n    };\r\n    // 组装字体\r\n    Text.prototype._assembleFont = function () {\r\n        var attrs = this.attrs;\r\n        attrs.font = g_base_1.assembleFont(attrs);\r\n    };\r\n    // 如果文本换行，则缓存数组\r\n    Text.prototype._setText = function (text) {\r\n        var textArr = null;\r\n        if (util_1.isString(text) && text.indexOf('\\n') !== -1) {\r\n            textArr = text.split('\\n');\r\n        }\r\n        this.set('textArr', textArr);\r\n    };\r\n    // 更新属性时，检测是否更改了 font、text\r\n    Text.prototype.onAttrChange = function (name, value, originValue) {\r\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\r\n        if (name.startsWith('font')) {\r\n            this._assembleFont();\r\n        }\r\n        if (name === 'text') {\r\n            this._setText(value);\r\n        }\r\n    };\r\n    // 这个方法在 text 时没有可以做的事情，如果要支持文字背景时可以考虑\r\n    // createPath(context) {\r\n    // }\r\n    // 如果文本多行，需要获取文本间距\r\n    Text.prototype._getSpaceingY = function () {\r\n        var attrs = this.attrs;\r\n        var lineHeight = attrs.lineHeight;\r\n        var fontSize = attrs.fontSize * 1;\r\n        return lineHeight ? lineHeight - fontSize : fontSize * 0.14;\r\n    };\r\n    // 绘制文本，考虑多行的场景\r\n    Text.prototype._drawTextArr = function (context, textArr, isFill) {\r\n        var attrs = this.attrs;\r\n        var textBaseline = attrs.textBaseline;\r\n        var x = attrs.x;\r\n        var y = attrs.y;\r\n        var fontSize = attrs.fontSize * 1;\r\n        var spaceingY = this._getSpaceingY();\r\n        var height = g_base_1.getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);\r\n        var subY;\r\n        util_1.each(textArr, function (subText, index) {\r\n            subY = y + index * (spaceingY + fontSize) - height + fontSize; // bottom;\r\n            if (textBaseline === 'middle')\r\n                subY += height - fontSize - (height - fontSize) / 2;\r\n            if (textBaseline === 'top')\r\n                subY += height - fontSize;\r\n            if (isFill) {\r\n                context.fillText(subText, x, subY);\r\n            }\r\n            else {\r\n                context.strokeText(subText, x, subY);\r\n            }\r\n        });\r\n    };\r\n    // 绘制文本，同时考虑填充和绘制边框\r\n    Text.prototype._drawText = function (context, isFill) {\r\n        var attrs = this.attr();\r\n        var x = attrs.x;\r\n        var y = attrs.y;\r\n        var textArr = this.get('textArr');\r\n        if (textArr) {\r\n            this._drawTextArr(context, textArr, isFill);\r\n        }\r\n        else {\r\n            var text = attrs.text;\r\n            if (isFill) {\r\n                context.fillText(text, x, y);\r\n            }\r\n            else {\r\n                context.strokeText(text, x, y);\r\n            }\r\n        }\r\n    };\r\n    // 复写绘制和填充的逻辑：对于文本，应该先绘制边框，再进行填充\r\n    Text.prototype.strokeAndFill = function (context) {\r\n        var _a = this.attrs, lineWidth = _a.lineWidth, opacity = _a.opacity, strokeOpacity = _a.strokeOpacity, fillOpacity = _a.fillOpacity;\r\n        if (this.isStroke()) {\r\n            if (lineWidth > 0) {\r\n                if (!util_1.isNil(strokeOpacity) && strokeOpacity !== 1) {\r\n                    context.globalAlpha = opacity;\r\n                }\r\n                this.stroke(context);\r\n            }\r\n        }\r\n        if (this.isFill()) {\r\n            if (!util_1.isNil(fillOpacity) && fillOpacity !== 1) {\r\n                context.globalAlpha = fillOpacity;\r\n                this.fill(context);\r\n                context.globalAlpha = opacity;\r\n            }\r\n            else {\r\n                this.fill(context);\r\n            }\r\n        }\r\n        this.afterDrawPath(context);\r\n    };\r\n    // 复写填充逻辑\r\n    Text.prototype.fill = function (context) {\r\n        this._drawText(context, true);\r\n    };\r\n    // 复写绘制边框的逻辑\r\n    Text.prototype.stroke = function (context) {\r\n        this._drawText(context, false);\r\n    };\r\n    return Text;\r\n}(base_1.default));\r\nexports.default = Text;\r\n//# sourceMappingURL=text.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = require(\"tslib\");\r\nvar g_base_1 = require(\"@antv/g-base\");\r\nvar hit_1 = require(\"./util/hit\");\r\nvar Shape = require(\"./shape\");\r\nvar group_1 = require(\"./group\");\r\nvar util_1 = require(\"./util/util\");\r\nvar time_1 = require(\"./util/time\");\r\nvar draw_1 = require(\"./util/draw\");\r\nvar events_1 = require(\"./events\");\r\nvar mini_canvas_proxy_1 = require(\"./util/mini-canvas-proxy\");\r\nvar patch_1 = require(\"./patch\");\r\nvar Canvas = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Canvas, _super);\r\n    function Canvas(cfg) {\r\n        var _this = _super.call(this, cfg) || this;\r\n        var ctx = _this.get('context');\r\n        if (_this.isMini()) {\r\n            if (_this.isMiniNative()) {\r\n                // TODO 这里会传递过来extra，里面包含一些来自各个平台的优化函数\r\n                time_1.setExtraFunction(_this.get('container'));\r\n            }\r\n            else {\r\n                // 小程序使用了自定义的canvas api，不兼容w3c标准\r\n                _this.set('context', new Proxy(ctx, new mini_canvas_proxy_1.default()));\r\n            }\r\n            // 架构调整前，打一些patch\r\n            patch_1.default(ctx, _this);\r\n        }\r\n        return _this;\r\n    }\r\n    Canvas.prototype.isMiniNative = function () {\r\n        return this.get('renderer') === 'mini-native';\r\n    };\r\n    Canvas.prototype.isMini = function () {\r\n        return this.get('renderer').startsWith('mini');\r\n    };\r\n    Canvas.prototype.getDefaultCfg = function () {\r\n        var cfg = _super.prototype.getDefaultCfg.call(this);\r\n        // 设置渲染引擎为 canvas(h5)/mini(小程序)，只读属性\r\n        cfg['renderer'] = 'canvas';\r\n        // 是否自动绘制，不需要用户调用 draw 方法\r\n        cfg['autoDraw'] = true;\r\n        // 是否允许局部刷新图表\r\n        cfg['localRefresh'] = true;\r\n        cfg['refreshElements'] = [];\r\n        // 是否在视图内自动裁剪\r\n        cfg['clipView'] = true;\r\n        // 是否使用快速拾取的方案，默认为 false，上层可以打开\r\n        cfg['quickHit'] = false;\r\n        // 给一个默认的rect，防止出现问题\r\n        cfg['boundingClientRect'] = {\r\n            width: 0,\r\n            height: 0,\r\n            left: 0,\r\n            top: 0,\r\n            bottom: 0,\r\n            right: 0,\r\n        };\r\n        return cfg;\r\n    };\r\n    /**\r\n     * @protected\r\n     * 初始化绑定的事件\r\n     */\r\n    Canvas.prototype.initEvents = function () {\r\n        var eventController = new events_1.default({\r\n            canvas: this,\r\n        });\r\n        this.set('eventController', eventController);\r\n    };\r\n    Canvas.prototype.registerEventCallback = function (e) {\r\n        var eventController = this.get('eventController');\r\n        eventController.handleEvent(e);\r\n    };\r\n    /**\r\n     * @protected\r\n     * 清理所有的事件\r\n     */\r\n    Canvas.prototype.clearEvents = function () {\r\n        var eventController = this.get('eventController');\r\n        eventController.destroy();\r\n    };\r\n    /**\r\n     * 一些方法调用会引起画布变化\r\n     * @param {ChangeType} changeType 改变的类型\r\n     */\r\n    Canvas.prototype.onCanvasChange = function (changeType) {\r\n        /**\r\n         * 触发画布更新的三种 changeType\r\n         * 1. attr: 修改画布的绘图属性\r\n         * 2. sort: 画布排序，图形的层次会发生变化\r\n         * 3. changeSize: 改变画布大小\r\n         */\r\n        if (changeType === 'attr' || changeType === 'sort' || changeType === 'changeSize') {\r\n            this.set('refreshElements', [this]);\r\n            this.draw();\r\n        }\r\n    };\r\n    Canvas.prototype.getShapeBase = function () {\r\n        return Shape;\r\n    };\r\n    Canvas.prototype.getGroupBase = function () {\r\n        return group_1.default;\r\n    };\r\n    /**\r\n     * 获取屏幕像素比\r\n     */\r\n    Canvas.prototype.getPixelRatio = function () {\r\n        var pixelRatio = this.get('pixelRatio') || util_1.getPixelRatio();\r\n        // 不足 1 的取 1，超出 1 的取整\r\n        return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;\r\n    };\r\n    Canvas.prototype.getViewRange = function () {\r\n        return {\r\n            minX: 0,\r\n            minY: 0,\r\n            maxX: this.cfg.width,\r\n            maxY: this.cfg.height,\r\n        };\r\n    };\r\n    Canvas.prototype.initDom = function () {\r\n        if (this.isMini()) {\r\n            var context = this.get('context');\r\n            var pixelRatio = this.getPixelRatio();\r\n            // 设置 canvas 元素的宽度和高度，会重置缩放，因此 context.scale 需要在每次设置宽、高后调用\r\n            if (pixelRatio > 1) {\r\n                context.scale(pixelRatio, pixelRatio);\r\n            }\r\n            return;\r\n        }\r\n        _super.prototype.initDom.call(this);\r\n    };\r\n    // 复写基类的方法生成标签（非 mini renderer 的 super.initDom 调用）\r\n    Canvas.prototype.createDom = function () {\r\n        var element = document.createElement('canvas');\r\n        var context = element.getContext('2d');\r\n        // 缓存 context 对象\r\n        this.set('context', context);\r\n        return element;\r\n    };\r\n    Canvas.prototype.setDOMSize = function (width, height) {\r\n        _super.prototype.setDOMSize.call(this, width, height);\r\n        var context = this.get('context');\r\n        var el = this.get('el');\r\n        var pixelRatio = this.getPixelRatio();\r\n        el.width = pixelRatio * width;\r\n        el.height = pixelRatio * height;\r\n        // 设置 canvas 元素的宽度和高度，会重置缩放，因此 context.scale 需要在每次设置宽、高后调用\r\n        if (pixelRatio > 1) {\r\n            context.scale(pixelRatio, pixelRatio);\r\n        }\r\n    };\r\n    // 复写基类方法\r\n    Canvas.prototype.clear = function () {\r\n        _super.prototype.clear.call(this);\r\n        this._clearFrame(); // 需要清理掉延迟绘制的帧\r\n        var context = this.get('context');\r\n        context.clearRect(0, 0, this.get('width'), this.get('height'));\r\n    };\r\n    Canvas.prototype.getShape = function (x, y) {\r\n        var shape;\r\n        if (this.get('quickHit')) {\r\n            shape = hit_1.getShape(this, x, y);\r\n        }\r\n        else {\r\n            shape = _super.prototype.getShape.call(this, x, y, null);\r\n        }\r\n        return shape;\r\n    };\r\n    // 对绘制区域边缘取整，避免浮点数问题\r\n    Canvas.prototype._getRefreshRegion = function () {\r\n        var elements = this.get('refreshElements');\r\n        var viewRegion = this.getViewRange();\r\n        var region;\r\n        // 如果是当前画布整体发生了变化，则直接重绘整个画布\r\n        if (elements.length && elements[0] === this) {\r\n            region = viewRegion;\r\n        }\r\n        else {\r\n            region = draw_1.getMergedRegion(elements);\r\n            if (region) {\r\n                region.minX = Math.floor(region.minX);\r\n                region.minY = Math.floor(region.minY);\r\n                region.maxX = Math.ceil(region.maxX);\r\n                region.maxY = Math.ceil(region.maxY);\r\n                region.maxY += 1; // 在很多环境下字体的高低会不一致，附加一像素，避免残影\r\n                var clipView = this.get('clipView');\r\n                // 自动裁剪不在 view 内的区域\r\n                if (clipView) {\r\n                    region = draw_1.mergeView(region, viewRegion);\r\n                }\r\n            }\r\n        }\r\n        return region;\r\n    };\r\n    // 清理还在进行的绘制\r\n    Canvas.prototype._clearFrame = function () {\r\n        var drawFrame = this.get('drawFrame');\r\n        if (drawFrame) {\r\n            // 如果全部渲染时，存在局部渲染，则抛弃掉局部渲染\r\n            time_1.clearAnimationFrame(drawFrame);\r\n            this.set('drawFrame', null);\r\n            this.set('refreshElements', []);\r\n        }\r\n    };\r\n    // 手工调用绘制接口\r\n    Canvas.prototype.draw = function () {\r\n        var drawFrame = this.get('drawFrame');\r\n        if (this.get('autoDraw') && drawFrame) {\r\n            return;\r\n        }\r\n        this._startDraw();\r\n    };\r\n    // 触发绘制\r\n    Canvas.prototype._startDraw = function () {\r\n        var _this = this;\r\n        var drawFrame = this.get('drawFrame');\r\n        if (!drawFrame) {\r\n            drawFrame = time_1.requestAnimationFrame(function () {\r\n                if (_this.get('localRefresh')) {\r\n                    _this._drawRegion();\r\n                }\r\n                else {\r\n                    _this._drawAll();\r\n                }\r\n                // 可能存在setInterval的情况\r\n                time_1.clearAnimationFrame(drawFrame);\r\n                _this.set('drawFrame', null);\r\n            });\r\n            this.set('drawFrame', drawFrame);\r\n        }\r\n    };\r\n    // 绘制局部\r\n    Canvas.prototype._drawRegion = function () {\r\n        var context = this.get('context');\r\n        var refreshElements = this.get('refreshElements');\r\n        var children = this.getChildren();\r\n        var region = this._getRefreshRegion();\r\n        // 需要注意可能没有 region 的场景\r\n        // 一般发生在设置了 localRefresh ,在没有图形发生变化的情况下，用户调用了 draw\r\n        if (region) {\r\n            // 清理指定区域\r\n            context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);\r\n            // 保存上下文，设置 clip\r\n            context.save();\r\n            context.beginPath();\r\n            context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);\r\n            context.clip();\r\n            draw_1.applyAttrsToContext(context, this);\r\n            // 确认更新的元素，这个优化可以提升 10 倍左右的性能，10W 个带有 group 的节点，局部渲染会从 90ms 下降到 5-6 ms\r\n            draw_1.checkRefresh(this, children, region);\r\n            // 绘制子元素\r\n            draw_1.drawChildren(context, children, region);\r\n            context.restore();\r\n        }\r\n        else if (refreshElements.length) {\r\n            // 防止发生改变的 elements 没有 region 的场景，这会发生在多个情况下\r\n            // 1. 空的 group\r\n            // 2. 所有 elements 没有在绘图区域\r\n            // 3. group 下面的 elements 隐藏掉\r\n            // 如果不进行清理 hasChanged 的状态会不正确\r\n            draw_1.clearChanged(refreshElements);\r\n        }\r\n        util_1.each(refreshElements, function (element) {\r\n            if (element.get('hasChanged')) {\r\n                // 在视窗外的 Group 元素会加入到更新队列里，但实际却没有执行 draw() 逻辑，也就没有清除 hasChanged 标记\r\n                // 即已经重绘完、但 hasChanged 标记没有清除的元素，需要统一清除掉。主要是 Group 存在问题，具体原因待排查\r\n                element.set('hasChanged', false);\r\n            }\r\n        });\r\n        // 针对小程序需要手动调用一次draw方法\r\n        if (this.isMini() && !this.isMiniNative()) {\r\n            context.draw(true);\r\n        }\r\n        this.set('refreshElements', []);\r\n    };\r\n    // 绘制所有图形\r\n    Canvas.prototype._drawAll = function () {\r\n        var context = this.get('context');\r\n        var children = this.getChildren();\r\n        context.clearRect(0, 0, this.get('width'), this.get('height'));\r\n        draw_1.applyAttrsToContext(context, this);\r\n        draw_1.drawChildren(context, children);\r\n        // 针对小程序需要手动调用一次draw方法\r\n        if (this.isMini() && !this.isMiniNative()) {\r\n            context.draw(true);\r\n        }\r\n        // 对于 https://github.com/antvis/g/issues/422 的场景，全局渲染的模式下也会记录更新的元素队列，因此全局渲染完后也需要置空\r\n        this.set('refreshElements', []);\r\n    };\r\n    Canvas.prototype.skipDraw = function () { };\r\n    /**\r\n     * 刷新图形元素，这里仅仅是放入队列，下次绘制时进行绘制\r\n     * @param {IElement} element 图形元素\r\n     */\r\n    Canvas.prototype.refreshElement = function (element) {\r\n        var refreshElements = this.get('refreshElements');\r\n        refreshElements.push(element);\r\n        // if (this.get('autoDraw')) {\r\n        //   this._startDraw();\r\n        // }\r\n    };\r\n    // 实现接口\r\n    Canvas.prototype.getPointByEvent = function (ev) {\r\n        if (this.isMini()) {\r\n            var _a = this.getClientByEvent(ev), clientX = _a.x, clientY = _a.y;\r\n            return this.getPointByClient(clientX, clientY);\r\n        }\r\n        return _super.prototype.getPointByEvent.call(this, ev);\r\n    };\r\n    // 获取 touch 事件的 clientX 和 clientY 需要单独处理\r\n    Canvas.prototype.getClientByEvent = function (event) {\r\n        // 这里需要转换成原始event\r\n        var ev = event.srcEvent;\r\n        var clientInfo = null;\r\n        if (ev.touches) {\r\n            if (ev.type === 'touchend') {\r\n                clientInfo = ev.changedTouches[0];\r\n            }\r\n            else {\r\n                clientInfo = ev.touches[0];\r\n            }\r\n        }\r\n        if (!clientInfo) {\r\n            return {};\r\n        }\r\n        return {\r\n            x: clientInfo.clientX,\r\n            y: clientInfo.clientY,\r\n        };\r\n    };\r\n    // 实现接口\r\n    Canvas.prototype.getPointByClient = function (clientX, clientY) {\r\n        if (this.isMini()) {\r\n            var rect = this.get('boundingClientRect');\r\n            return {\r\n                x: clientX + rect.left,\r\n                y: clientY + rect.top,\r\n            };\r\n        }\r\n        var el = this.get('el');\r\n        var bbox = el.getBoundingClientRect();\r\n        return {\r\n            x: clientX - bbox.left,\r\n            y: clientY - bbox.top,\r\n        };\r\n    };\r\n    Canvas.prototype.removeDom = function () {\r\n        if (!this.isMini()) {\r\n            _super.prototype.removeDom.call(this);\r\n        }\r\n    };\r\n    // 实现接口\r\n    Canvas.prototype.getClientByPoint = function (x, y) {\r\n        if (this.isMini()) {\r\n            // 小程序内需计算处理canvas的位置信息\r\n            var rect = this.get('boundingClientRect');\r\n            return {\r\n                x: x + rect.left,\r\n                y: y + rect.top,\r\n            };\r\n        }\r\n        var el = this.get('el');\r\n        var bbox = el.getBoundingClientRect();\r\n        return {\r\n            x: x + bbox.left,\r\n            y: y + bbox.top,\r\n        };\r\n    };\r\n    return Canvas;\r\n}(g_base_1.AbstractCanvas));\r\nexports.default = Canvas;\r\n//# sourceMappingURL=canvas.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getShape = void 0;\r\nvar g_base_1 = require(\"@antv/g-base\");\r\nfunction invertFromMatrix(v, matrix) {\r\n    if (matrix) {\r\n        var invertMatrix = g_base_1.invert(matrix);\r\n        return g_base_1.multiplyVec2(invertMatrix, v);\r\n    }\r\n    return v;\r\n}\r\nfunction getRefXY(element, x, y) {\r\n    // @ts-ignore\r\n    var totalMatrix = element.getTotalMatrix();\r\n    if (totalMatrix) {\r\n        var _a = invertFromMatrix([x, y, 1], totalMatrix), refX = _a[0], refY = _a[1];\r\n        return [refX, refY];\r\n    }\r\n    return [x, y];\r\n}\r\n// 拾取前的检测，只有通过检测才能继续拾取\r\nfunction preTest(element, x, y) {\r\n    // @ts-ignore\r\n    if (element.isCanvas && element.isCanvas()) {\r\n        return true;\r\n    }\r\n    // 不允许被拾取，则返回 null\r\n    // @ts-ignore\r\n    if (!g_base_1.isAllowCapture(element) || element.cfg.isInView === false) {\r\n        return false;\r\n    }\r\n    if (element.cfg.clipShape) {\r\n        // 如果存在 clip\r\n        var _a = getRefXY(element, x, y), refX = _a[0], refY = _a[1];\r\n        if (element.isClipped(refX, refY)) {\r\n            return false;\r\n        }\r\n    }\r\n    // @ts-ignore ，这个地方调用过于频繁\r\n    var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox();\r\n    // 如果没有缓存 bbox，则说明不可见\r\n    // 注释掉的这段可能会加速拾取，上面的语句改写成 const bbox = element.cfg.cacheCanvasBBox;\r\n    // 这时候的拾取假设图形/分组在上一次绘制都在视窗内，但是上面已经判定了 isInView 所以意义不大\r\n    // 现在还调用 element.getCanvasBBox(); 一个很大的原因是便于单元测试\r\n    // if (!bbox) {\r\n    //   return false;\r\n    // }\r\n    if (!(x >= bbox.minX && x <= bbox.maxX && y >= bbox.minY && y <= bbox.maxY)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n// 这个方法复写了 g-base 的 getShape\r\nfunction getShape(container, x, y) {\r\n    // 没有通过检测，则返回 null\r\n    if (!preTest(container, x, y)) {\r\n        return null;\r\n    }\r\n    var shape = null;\r\n    var children = container.getChildren();\r\n    var count = children.length;\r\n    for (var i = count - 1; i >= 0; i--) {\r\n        var child = children[i];\r\n        if (child.isGroup()) {\r\n            shape = getShape(child, x, y);\r\n        }\r\n        else if (preTest(child, x, y)) {\r\n            var curShape = child;\r\n            var _a = getRefXY(child, x, y), refX = _a[0], refY = _a[1];\r\n            // @ts-ignore\r\n            if (curShape.isInShape(refX, refY)) {\r\n                shape = child;\r\n            }\r\n        }\r\n        if (shape) {\r\n            break;\r\n        }\r\n    }\r\n    return shape;\r\n}\r\nexports.getShape = getShape;\r\n//# sourceMappingURL=hit.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar f6_hammerjs_1 = require(\"@antv/f6-hammerjs\");\r\nvar g_base_1 = require(\"@antv/g-base\");\r\nvar util_1 = require(\"./util/util\");\r\nvar CLICK_OFFSET = 40;\r\nvar LEFT_BTN_CODE = 0;\r\nvar DELEGATION_SPLIT = ':';\r\n// 是否有委托事件监听\r\nfunction hasDelegation(events, type) {\r\n    for (var key in events) {\r\n        if (events.hasOwnProperty(key) && key.indexOf(DELEGATION_SPLIT + type) >= 0) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n// 触发目标事件，目标只能是 shape 或 canvas\r\nfunction emitTargetEvent(target, type, eventObj) {\r\n    eventObj.name = type;\r\n    eventObj.target = target;\r\n    eventObj.currentTarget = target;\r\n    eventObj.delegateTarget = target;\r\n    target.emit(type, eventObj);\r\n}\r\n// 事件冒泡, enter 和 leave 需要对 fromShape 和 toShape 进行判同\r\nfunction bubbleEvent(container, type, eventObj) {\r\n    if (eventObj.bubbles) {\r\n        var relativeShape = void 0;\r\n        var isOverEvent = false;\r\n        if (container.isCanvas() && isOverEvent) {\r\n            return;\r\n        }\r\n        // 如果相关图形同当前图形在同一个容器内，不触发事件\r\n        if (relativeShape && util_1.isParent(container, relativeShape)) {\r\n            // 阻止继续向上冒泡\r\n            eventObj.bubbles = false;\r\n            return;\r\n        }\r\n        // 事件名称可能在委托过程中被修改，因此事件冒泡时需要重新设置事件名称\r\n        eventObj.name = type;\r\n        eventObj.currentTarget = container;\r\n        eventObj.delegateTarget = container;\r\n        container.emit(type, eventObj);\r\n    }\r\n}\r\nvar EventController = /** @class */ (function () {\r\n    function EventController(cfg) {\r\n        var _this = this;\r\n        // 正在被拖拽的图形\r\n        this.draggingShape = null;\r\n        this.dragging = false;\r\n        // 当前鼠标/touch所在位置的图形\r\n        this.currentShape = null;\r\n        this.panstartShape = null;\r\n        this.panstartPoint = null;\r\n        // 统一处理所有的回调\r\n        this.handleEvent = function (ev) {\r\n            _this.hammerRuntime.emit(\"origin_input:\" + ev.type, ev);\r\n        };\r\n        this.canvas = cfg.canvas;\r\n        this._initEvent();\r\n    }\r\n    EventController.prototype._initEvent = function () {\r\n        var _this = this;\r\n        this.hammerRuntime = new f6_hammerjs_1.default({}, {\r\n            inputClass: f6_hammerjs_1.TouchInput,\r\n        });\r\n        this.hammerRuntime.add(new f6_hammerjs_1.default.Pan({ threshold: 0, pointers: 1 }));\r\n        this.hammerRuntime.add(new f6_hammerjs_1.default.Swipe()).recognizeWith(this.hammerRuntime.get('pan'));\r\n        //this.hammerRuntime.add(new Hammer.Rotate({ threshold: 0 })).recognizeWith(this.hammerRuntime.get('pan'));\r\n        this.hammerRuntime.add(new f6_hammerjs_1.default.Pinch({ threshold: 0, pointers: 2 }));\r\n        //.recognizeWith([this.hammerRuntime.get('pan'), this.hammerRuntime.get('rotate')]);\r\n        this.hammerRuntime.add(new f6_hammerjs_1.default.Tap({ event: 'dbltap', taps: 2 }));\r\n        this.hammerRuntime.add(new f6_hammerjs_1.default.Tap());\r\n        this.hammerRuntime.add(new f6_hammerjs_1.default.Press({ time: 500 }));\r\n        this.hammerRuntime.on('panstart panmove panend pancancel', function (e) {\r\n            e.srcEvent.extra = e;\r\n            var pointInfo = _this._getPointInfo(e);\r\n            var shape = _this._getShape(pointInfo, e);\r\n            // 结束拖拽\r\n            if (e.type === 'panend' || e.type === 'pancancel') {\r\n                _this._onpanend(pointInfo, shape, e);\r\n            }\r\n            // 开始拖拽\r\n            if (e.type === 'panstart') {\r\n                // 兜底, hammer解析的事件可能缺失一次panend，所以做个兜底\r\n                if (_this.dragging) {\r\n                    _this.draggingShape = null;\r\n                    _this.dragging = false;\r\n                    _this.panstartShape = null;\r\n                    _this.panstartPoint = null;\r\n                }\r\n                _this._onpanstart(pointInfo, shape, e);\r\n            }\r\n            // 拖拽中\r\n            if (e.type === 'panmove') {\r\n                _this._onpanmove(pointInfo, shape, e);\r\n            }\r\n            _this.currentShape = shape;\r\n        });\r\n        this.hammerRuntime.on('tap dbltap press swipe rotatestart rotatemove', function (e) {\r\n            _this._emitMobileEvent(e.type, e);\r\n        });\r\n        this.hammerRuntime.on('pinchstart pinchmove pinchend pinchcancel', function (e) {\r\n            if (e.type === 'pinchend' || e.type === 'pinchcancel') {\r\n                _this._emitMobileEvent(e.type, e);\r\n                return;\r\n            }\r\n            e.srcEvent.extra = {\r\n                scale: e.scale,\r\n            };\r\n            _this._emitMobileEvent(e.type, e);\r\n        });\r\n    };\r\n    EventController.prototype._emitMobileEvent = function (type, ev) {\r\n        var pointInfo = this._getPointInfo(ev);\r\n        var shape = this._getShape(pointInfo, ev);\r\n        this._emitEvent(type, ev, pointInfo, shape);\r\n    };\r\n    EventController.prototype._getEventObj = function (type, event, point, target, fromShape, toShape) {\r\n        var eventObj = new g_base_1.Event(type, event);\r\n        eventObj.fromShape = fromShape;\r\n        eventObj.toShape = toShape;\r\n        eventObj.x = point.x;\r\n        eventObj.y = point.y;\r\n        eventObj.clientX = point.clientX;\r\n        eventObj.clientY = point.clientY;\r\n        eventObj.propagationPath.push(target);\r\n        // 事件的x,y应该是基于画布左上角的，与canvas的matrix无关\r\n        return eventObj;\r\n    };\r\n    // 根据点获取图形，提取成独立方法，便于后续优化\r\n    EventController.prototype._getShape = function (point, event) {\r\n        var ev = event.srcEvent;\r\n        return this.canvas.getShape(point.x, point.y, ev);\r\n    };\r\n    // 获取事件的当前点的信息\r\n    EventController.prototype._getPointInfo = function (ev) {\r\n        var canvas = this.canvas;\r\n        var clientPoint = canvas.getClientByEvent(ev);\r\n        var point = canvas.getPointByEvent(ev);\r\n        return {\r\n            x: point.x,\r\n            y: point.y,\r\n            clientX: clientPoint.x,\r\n            clientY: clientPoint.y,\r\n        };\r\n    };\r\n    // 触发事件\r\n    EventController.prototype._triggerEvent = function (type, ev) {\r\n        var pointInfo = this._getPointInfo(ev);\r\n        // 每次都获取图形有一定成本，后期可以考虑进行缓存策略\r\n        var shape = this._getShape(pointInfo, ev);\r\n        var method = this[\"_on\" + type];\r\n        if (method) {\r\n            method.call(this, pointInfo, shape, ev);\r\n        }\r\n        else {\r\n            var preShape = this.currentShape;\r\n            // 如果进入、移出画布时存在图形，则要分别触发事件\r\n            if (type === 'panstart' || type === 'dragenter') {\r\n                this._emitEvent(type, ev, pointInfo, null, null, shape); // 先进入画布\r\n                if (shape) {\r\n                    this._emitEvent(type, ev, pointInfo, shape, null, shape); // 再触发图形的事件\r\n                }\r\n                if (type === 'panstart' && this.draggingShape) {\r\n                    // 如果正在拖拽图形, 则触发 dragleave\r\n                    this._emitEvent('dragenter', ev, pointInfo, null);\r\n                }\r\n            }\r\n            else if (type === 'panend' || type === 'dragleave') {\r\n                if (preShape) {\r\n                    this._emitEvent(type, ev, pointInfo, preShape, preShape, null); // 先触发图形的事件\r\n                }\r\n                this._emitEvent(type, ev, pointInfo, null, preShape, null); // 再触发离开画布事件\r\n                if (type === 'panend' && this.draggingShape) {\r\n                    this._emitEvent('dragleave', ev, pointInfo, null);\r\n                }\r\n            }\r\n            else {\r\n                this._emitEvent(type, ev, pointInfo, shape, null, null); // 一般事件中不需要考虑 from, to\r\n            }\r\n        }\r\n    };\r\n    // 记录下点击的位置、图形，便于拖拽事件、click 事件的判定\r\n    EventController.prototype._onpanstart = function (pointInfo, shape, event) {\r\n        this.panstartShape = shape;\r\n        this.panstartPoint = pointInfo;\r\n        this.panstartTimeStamp = event.timeStamp;\r\n        this._emitEvent('panstart', event, pointInfo, shape, null, null);\r\n    };\r\n    EventController.prototype._emitDragoverEvents = function (event, pointInfo, fromShape, toShape, isCanvasEmit) {\r\n        if (toShape) {\r\n            if (toShape !== fromShape) {\r\n                if (fromShape) {\r\n                    this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\r\n                }\r\n                this._emitEvent('dragenter', event, pointInfo, toShape, fromShape, toShape);\r\n            }\r\n            if (!isCanvasEmit) {\r\n                this._emitEvent('dragover', event, pointInfo, toShape);\r\n            }\r\n        }\r\n        else if (fromShape) {\r\n            // TODO: 此处判断有问题，当 drag 图形时，也会触发一次 dragleave 事件，因为此时 toShape 为 null，这不是所期望的\r\n            // 经过空白区域\r\n            this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\r\n        }\r\n        if (isCanvasEmit) {\r\n            this._emitEvent('dragover', event, pointInfo, toShape);\r\n        }\r\n    };\r\n    // drag 完成后，需要做一些清理工作\r\n    EventController.prototype._afterDrag = function (draggingShape, pointInfo, event) {\r\n        if (draggingShape) {\r\n            draggingShape.set('capture', true); // 恢复可以拾取\r\n            this.draggingShape = null;\r\n        }\r\n        this.dragging = false;\r\n        // drag 完成后，有可能 draggingShape 已经移动到了当前位置，所以不能直接取当前图形\r\n        var shape = this._getShape(pointInfo, event);\r\n        this.currentShape = shape;\r\n    };\r\n    // 按键抬起时，会终止拖拽、触发点击\r\n    EventController.prototype._onpanend = function (pointInfo, shape, event) {\r\n        var draggingShape = this.draggingShape;\r\n        if (this.dragging) {\r\n            // 存在可以拖拽的图形，同时拖拽到其他图形上时触发 drag 事件\r\n            if (draggingShape) {\r\n                this._emitEvent('drop', event, pointInfo, shape);\r\n            }\r\n            this._emitEvent('dragend', event, pointInfo, draggingShape);\r\n            this._afterDrag(draggingShape, pointInfo, event);\r\n        }\r\n        this._emitEvent('panend', event, pointInfo, shape);\r\n        this.panstartShape = null;\r\n        this.panstartPoint = null;\r\n    };\r\n    // 大量的图形事件，都通过 mousemove 模拟\r\n    EventController.prototype._onpanmove = function (pointInfo, shape, event) {\r\n        var canvas = this.canvas;\r\n        var preShape = this.currentShape;\r\n        var draggingShape = this.draggingShape;\r\n        // 正在拖拽时\r\n        if (this.dragging) {\r\n            // 正在拖拽中\r\n            if (draggingShape) {\r\n                // 如果拖拽了 shape 会触发 dragenter, dragleave, dragover 和 drag 事件\r\n                this._emitDragoverEvents(event, pointInfo, preShape, shape, false);\r\n            }\r\n            // 如果存在 draggingShape 则会在 draggingShape 上触发 drag 事件，冒泡到 canvas 上\r\n            // 否则在 canvas 上触发 drag 事件\r\n            this._emitEvent('drag', event, pointInfo, draggingShape);\r\n        }\r\n        else {\r\n            var panstartPoint = this.panstartPoint;\r\n            if (panstartPoint) {\r\n                // 当鼠标点击下去，同时移动时，进行 drag 判定\r\n                var panstartShape = this.panstartShape;\r\n                var now = event.timeStamp;\r\n                var timeWindow = now - this.panstartTimeStamp;\r\n                var dx = panstartPoint.clientX - pointInfo.clientX;\r\n                var dy = panstartPoint.clientY - pointInfo.clientY;\r\n                var dist = dx * dx + dy * dy;\r\n                if (timeWindow > 120 || dist > CLICK_OFFSET) {\r\n                    if (panstartShape && panstartShape.get('draggable')) {\r\n                        // 设置了 draggable 的 shape 才能触发 drag 相关的事件\r\n                        draggingShape = this.panstartShape; // 拖动鼠标点下时的 shape\r\n                        draggingShape.set('capture', false); // 禁止继续拾取，否则无法进行 dragover,dragenter,dragleave,drop的判定\r\n                        this.draggingShape = draggingShape;\r\n                        this.dragging = true;\r\n                        this._emitEvent('dragstart', event, pointInfo, draggingShape);\r\n                        // 清理按下鼠标时缓存的值\r\n                        this.panstartShape = null;\r\n                        this.panstartPoint = null;\r\n                    }\r\n                    else if (!panstartShape && canvas.get('draggable')) {\r\n                        // 设置了 draggable 的 canvas 才能触发 drag 相关的事件\r\n                        this.dragging = true;\r\n                        this._emitEvent('dragstart', event, pointInfo, null);\r\n                        // 清理按下鼠标时缓存的值\r\n                        this.panstartShape = null;\r\n                        this.panstartPoint = null;\r\n                    }\r\n                    else {\r\n                        this._emitEvent('panmove', event, pointInfo, shape);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._emitEvent('panmove', event, pointInfo, shape);\r\n    };\r\n    // 触发事件\r\n    EventController.prototype._emitEvent = function (type, event, pointInfo, shape, fromShape, toShape) {\r\n        var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);\r\n        // 存在 shape 触发，则进行冒泡处理\r\n        if (shape) {\r\n            eventObj.shape = shape;\r\n            // 触发 shape 上的事件\r\n            emitTargetEvent(shape, type, eventObj);\r\n            var parent_1 = shape.getParent();\r\n            // 执行冒泡\r\n            while (parent_1) {\r\n                // 委托事件要先触发\r\n                parent_1.emitDelegation(type, eventObj);\r\n                // 事件冒泡停止，不能妨碍委托事件\r\n                if (!eventObj.propagationStopped) {\r\n                    bubbleEvent(parent_1, type, eventObj);\r\n                }\r\n                eventObj.propagationPath.push(parent_1);\r\n                parent_1 = parent_1.getParent();\r\n            }\r\n        }\r\n        else {\r\n            // 如果没有 shape 直接在 canvas 上触发\r\n            var canvas = this.canvas;\r\n            // 直接触发 canvas 上的事件\r\n            emitTargetEvent(canvas, type, eventObj);\r\n        }\r\n    };\r\n    EventController.prototype.destroy = function () {\r\n        // 清理缓存的对象\r\n        this.canvas = null;\r\n        this.currentShape = null;\r\n        this.draggingShape = null;\r\n        this.panstartPoint = null;\r\n        this.panstartShape = null;\r\n        this.panstartTimeStamp = null;\r\n    };\r\n    return EventController;\r\n}());\r\nexports.default = EventController;\r\n//# sourceMappingURL=events.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/***\r\n * 小程序canvas的handler，用于做兼容兜底\r\n */\r\nvar MiniCanvasProxy = /** @class */ (function () {\r\n    function MiniCanvasProxy() {\r\n    }\r\n    MiniCanvasProxy.prototype.set = function (obj, prop, value) {\r\n        switch (prop) {\r\n            case 'strokeStyle':\r\n                obj['setStrokeStyle'](value);\r\n                break;\r\n            case 'fillStyle':\r\n                obj['setFillStyle'](value);\r\n                break;\r\n            case 'lineWidth':\r\n                obj['setLineWidth'](value);\r\n                break;\r\n            case 'lineDash':\r\n                obj['setLineDash'](value);\r\n                break;\r\n            case 'globalAlpha':\r\n                if (value || value === 0) {\r\n                    obj['globalAlpha'] = value;\r\n                    obj['setGlobalAlpha'](value);\r\n                }\r\n                break;\r\n            case 'fontSize':\r\n                obj['setFontSize'](value);\r\n                break;\r\n            case 'textAlign':\r\n                obj['setTextAlign'](value);\r\n                break;\r\n            case 'fontStyle':\r\n            case 'font':\r\n                obj['setFont'](value);\r\n                break;\r\n            case 'textBaseline':\r\n                obj['setTextBaseline'](value);\r\n                break;\r\n            default:\r\n                obj[prop] = value;\r\n        }\r\n        return true;\r\n    };\r\n    MiniCanvasProxy.prototype.get = function (obj, prop) {\r\n        if (prop === 'globalAlpha' && obj[prop] === undefined)\r\n            return 1;\r\n        if (typeof obj[prop] === 'function') {\r\n            return obj[prop].bind(obj);\r\n        }\r\n        return obj[prop];\r\n    };\r\n    return MiniCanvasProxy;\r\n}());\r\nexports.default = MiniCanvasProxy;\r\n//# sourceMappingURL=mini-canvas-proxy.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar bbox_1 = require(\"./bbox\");\r\nvar image_1 = require(\"../shape/image\");\r\nexports.default = (function (context, canvas) {\r\n    image_1.setMiniCanvas(canvas);\r\n    bbox_1.default(context);\r\n});\r\n//# sourceMappingURL=index.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar g_base_1 = require(\"@antv/g-base\");\r\nvar text_1 = require(\"./text\");\r\nexports.default = (function (context) {\r\n    text_1.cacheCanvasContext(context);\r\n    g_base_1.registerBBox('text', text_1.default);\r\n});\r\n//# sourceMappingURL=index.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.cacheCanvasContext = void 0;\r\nvar util_1 = require(\"@antv/util\");\r\nvar text_1 = require(\"@antv/g-base/lib/util/text\");\r\nvar context = null;\r\nfunction cacheCanvasContext(ctx) {\r\n    context = ctx;\r\n}\r\nexports.cacheCanvasContext = cacheCanvasContext;\r\n/**\r\n * 字体宽度\r\n * @param text 文本\r\n * @param font 字体\r\n */\r\nfunction getTextWidth(text, font) {\r\n    var width = 0;\r\n    // null 或者 undefined 时，宽度为 0\r\n    if (util_1.isNil(text) || text === '') {\r\n        return width;\r\n    }\r\n    context.save();\r\n    context.font = font;\r\n    if (util_1.isString(text) && text.includes('\\n')) {\r\n        var textArr = text.split('\\n');\r\n        util_1.each(textArr, function (subText) {\r\n            var measureWidth = context.measureText(subText).width;\r\n            if (width < measureWidth) {\r\n                width = measureWidth;\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        width = context.measureText(text).width;\r\n    }\r\n    context.restore();\r\n    return width;\r\n}\r\nfunction default_1(shape) {\r\n    var attrs = shape.attr();\r\n    var x = attrs.x, y = attrs.y, text = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;\r\n    var font = attrs.font;\r\n    if (!font) {\r\n        // 如果未组装 font\r\n        font = text_1.assembleFont(attrs);\r\n    }\r\n    var width = getTextWidth(text, font);\r\n    var bbox;\r\n    if (!width) {\r\n        // 如果width不存在，四点共其实点\r\n        bbox = {\r\n            x: x,\r\n            y: y,\r\n            width: 0,\r\n            height: 0,\r\n        };\r\n    }\r\n    else {\r\n        var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;\r\n        var height = text_1.getTextHeight(text, fontSize, lineHeight); // attrs.height\r\n        // 默认左右对齐：left, 默认上下对齐 bottom\r\n        var point = {\r\n            x: x,\r\n            y: y - height,\r\n        };\r\n        if (textAlign) {\r\n            if (textAlign === 'end' || textAlign === 'right') {\r\n                point.x -= width;\r\n            }\r\n            else if (textAlign === 'center') {\r\n                point.x -= width / 2;\r\n            }\r\n        }\r\n        if (textBaseline) {\r\n            if (textBaseline === 'top') {\r\n                point.y += height;\r\n            }\r\n            else if (textBaseline === 'middle') {\r\n                point.y += height / 2;\r\n            }\r\n        }\r\n        bbox = {\r\n            x: point.x,\r\n            y: point.y,\r\n            width: width,\r\n            height: height,\r\n        };\r\n    }\r\n    return bbox;\r\n}\r\nexports.default = default_1;\r\n//# sourceMappingURL=text.js.map"]}