{"version":3,"sources":["index.js","behavior/index.js","behavior/behavior.js","behavior/behaviorOption.js","graph/graph.js","util/math.js","util/validation.js","util/graphic.js","global.js","util/letterAspectRatio.js","graph/controller/index.js","graph/controller/mode.js","graph/controller/view.js","util/base.js","interface/behavior.js","graph/controller/item.js","item/edge.js","item/item.js","element/shape.js","element/xml.js","item/node.js","item/combo.js","graph/controller/state.js","item/hull.js","util/path.js","element/hull/convexHull.js","element/hull/bubbleset.js","element/index.js","element/node.js","element/shapeBase.js","element/edge.js","element/combo.js","element/combos/index.js","element/combos/circle.js","element/combos/rect.js","element/nodes/index.js","element/nodes/simple-circle.js","element/nodes/simple-rect.js","element/nodes/image.js","element/arrow.js","element/marker.js","util/index.js","util/color.js","graph/controller/layout.js","graph/controller/event.js","types/index.js","interface/index.js","interface/graph.js","interface/item.js","interface/shape.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,AGTA,AJYA;AELA,ACHA,AFMA,AGTA,AJYA;AELA,ACHA,AFMA,AGTA,AJYA;AELA,ACHA,AFMA,AGTA,AJYA,AKfA;AHUA,ACHA,ACHA,AJYA,AKfA;AHUA,ACHA,ACHA,AJYA,AKfA;AHUA,ACHA,ACHA,AJYA,AKfA,ACHA;AJaA,ACHA,ACHA,AJYA,AKfA,ACHA;AJaA,ACHA,ACHA,AJYA,AKfA,ACHA;AJaA,ACHA,ACHA,AJYA,AOrBA,AFMA,ACHA;AJaA,ACHA,ACHA,AJYA,AOrBA,AFMA,ACHA;AJaA,ACHA,ACHA,AJYA,AOrBA,AFMA,ACHA;AJaA,ACHA,AKfA,AJYA,AJYA,AOrBA,AFMA,ACHA;AJaA,ACHA,AKfA,AJYA,AJYA,AOrBA,AFMA,ACHA;AJaA,ACHA,AKfA,AJYA,AJYA,AOrBA,AFMA,ACHA;AJaA,ACHA,AKfA,AJYA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AJYA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AJYA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ANkBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ANkBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ANkBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,APqBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,APqBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,APqBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,AavCA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,AavCA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,AavCA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,Ac1CA,ADGA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,Ac1CA,ADGA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,Ac1CA,ADGA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,ADGA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,ADGA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,ADGA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,AHSA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,AHSA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,AHSA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,AV8BA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,AV8BA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,AV8BA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,Ae7CA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,Ae7CA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AsBlEA,APqBA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AsBlEA,APqBA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AsBlEA,APqBA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,APqBA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,APqBA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,APqBA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,AT2BA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,AT2BA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,AT2BA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,ACHA,AV8BA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,ACHA,AV8BA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,ACHA,AV8BA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AwBvEA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AwBvEA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AwBvEA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,ADGA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,ADGA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,ADGA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,ACHA,AFMA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,ACHA,AFMA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,ACHA,AFMA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ADGA,AFMA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ADGA,AFMA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,AHSA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AOrBA,AjBmDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AOrBA,AjBmDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AOrBA,AjBmDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AOrBA,ACHA,AlBsDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AOrBA,ACHA,AlBsDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AOrBA,ACHA,AlBsDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AOrBA,ACHA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AQxBA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AQxBA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AiClGA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AiClGA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AiClGA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AiClGA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AiClGA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AiClGA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AiClGA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AkCtGA,AhCgGA,AJYA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AkCtGA,AhCgGA,AJYA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AkCtGA,AhCgGA,AJYA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,A6BvFA,AnCyGA,AkCtGA,AhCgGA,AJYA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,A6BvFA,AnCyGA,AkCtGA,AhCgGA,AJYA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,A6BvFA,AnCyGA,AkCtGA,AhCgGA,AJYA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,A6BvFA,AnCyGA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,A6BvFA,AnCyGA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,A6BvFA,AnCyGA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,A6BvFA,AnCyGA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,A6BvFA,AnCyGA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A+C7IA,ADGA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A+C7IA,ADGA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,Ac1CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A+C7IA,ADGA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,Ac1CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A+C7IA,ADGA,AENA,A3BiFA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A+C7IA,ADGA,AENA,A3BiFA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AENA,A3BiFA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AENA,ACHA,A5BoFA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AENA,ACHA,A5BoFA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AGTA,A5BoFA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AGTA,A5BoFA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AGTA,A5BoFA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AmBzDA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AmBzDA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AmBzDA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  registerNode: true,\n  registerCombo: true,\n  registerEdge: true,\n  registerBehavior: true,\n  BaseGlobal: true,\n  AbstractGraph: true,\n  Shape: true,\n  Arrow: true,\n  Marker: true,\n  Util: true,\n  AbstractLayout: true,\n  AbstractEvent: true,\n  Node: true,\n  Edge: true,\n  Hull: true,\n  Combo: true\n};\nObject.defineProperty(exports, \"AbstractGraph\", {\n  enumerable: true,\n  get: function get() {\n    return _graph.default;\n  }\n});\nObject.defineProperty(exports, \"Shape\", {\n  enumerable: true,\n  get: function get() {\n    return _element.default;\n  }\n});\nObject.defineProperty(exports, \"Arrow\", {\n  enumerable: true,\n  get: function get() {\n    return _element.Arrow;\n  }\n});\nObject.defineProperty(exports, \"Marker\", {\n  enumerable: true,\n  get: function get() {\n    return _element.Marker;\n  }\n});\nObject.defineProperty(exports, \"Util\", {\n  enumerable: true,\n  get: function get() {\n    return _util.default;\n  }\n});\nObject.defineProperty(exports, \"AbstractLayout\", {\n  enumerable: true,\n  get: function get() {\n    return _layout.default;\n  }\n});\nObject.defineProperty(exports, \"AbstractEvent\", {\n  enumerable: true,\n  get: function get() {\n    return _event.default;\n  }\n});\nObject.defineProperty(exports, \"Node\", {\n  enumerable: true,\n  get: function get() {\n    return _node.default;\n  }\n});\nObject.defineProperty(exports, \"Edge\", {\n  enumerable: true,\n  get: function get() {\n    return _edge.default;\n  }\n});\nObject.defineProperty(exports, \"Hull\", {\n  enumerable: true,\n  get: function get() {\n    return _hull.default;\n  }\n});\nObject.defineProperty(exports, \"Combo\", {\n  enumerable: true,\n  get: function get() {\n    return _combo.default;\n  }\n});\nexports.default = exports.BaseGlobal = exports.registerBehavior = exports.registerEdge = exports.registerCombo = exports.registerNode = void 0;\n\nvar _behavior = _interopRequireDefault(require(\"./behavior\"));\n\nvar _graph = _interopRequireDefault(require(\"./graph/graph\"));\n\nvar _element = _interopRequireWildcard(require(\"./element\"));\n\nvar _global = _interopRequireDefault(require(\"./global\"));\n\nvar _util = _interopRequireDefault(require(\"./util\"));\n\nvar _layout = _interopRequireDefault(require(\"./graph/controller/layout\"));\n\nvar _event = _interopRequireDefault(require(\"./graph/controller/event\"));\n\nvar _node = _interopRequireDefault(require(\"./item/node\"));\n\nvar _edge = _interopRequireDefault(require(\"./item/edge\"));\n\nvar _hull = _interopRequireDefault(require(\"./item/hull\"));\n\nvar _combo = _interopRequireDefault(require(\"./item/combo\"));\n\nvar _types = require(\"./types\");\n\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _types[key];\n    }\n  });\n});\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// 用于 PC 和 Mobile 端分别实现 layout 和 updateLayoutCfg 方法\nvar registerNode = _element.default.registerNode;\nexports.registerNode = registerNode;\nvar registerEdge = _element.default.registerEdge;\nexports.registerEdge = registerEdge;\nvar registerCombo = _element.default.registerCombo;\nexports.registerCombo = registerCombo;\nvar registerBehavior = _behavior.default.registerBehavior;\nexports.registerBehavior = registerBehavior;\nvar BaseGlobal = _global.default;\nexports.BaseGlobal = BaseGlobal;\nvar _default = {\n  version: _global.default.version,\n  AbstractGraph: _graph.default,\n  BaseGlobal: BaseGlobal,\n  Util: _util.default,\n  Shape: _element.default,\n  Node: _node.default,\n  Edge: _edge.default,\n  Combo: _combo.default,\n  Hull: _hull.default,\n  registerNode: _element.default.registerNode,\n  registerEdge: _element.default.registerEdge,\n  registerCombo: _element.default.registerCombo,\n  registerBehavior: _behavior.default.registerBehavior,\n  Arrow: _element.Arrow,\n  Marker: _element.Marker,\n  AbstractLayout: _layout.default,\n  AbstractEvent: _event.default\n};\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _behavior = _interopRequireDefault(require(\"./behavior\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _default = _behavior.default;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@antv/util\");\n\nvar _behaviorOption = _interopRequireDefault(require(\"./behaviorOption\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Behavior =\n/** @class */\nfunction () {\n  function Behavior() {}\n  /**\n   * 自定义 Behavior\n   * @param type Behavior 名称\n   * @param behavior Behavior 定义的方法集合\n   */\n\n\n  Behavior.registerBehavior = function (type, behavior) {\n    if (!behavior) {\n      throw new Error(\"please specify handler for this behavior: \" + type);\n    }\n\n    var prototype = (0, _util.clone)(_behaviorOption.default);\n    Object.assign(prototype, behavior); // eslint-disable-next-line func-names\n\n    var base = function base(cfg) {\n      var _this = this;\n\n      Object.assign(this, this.getDefaultCfg(), cfg);\n      var events = this.getEvents();\n      this.events = null;\n      var eventsToBind = {};\n\n      if (events) {\n        (0, _util.each)(events, function (handle, event) {\n          eventsToBind[event] = (0, _util.wrapBehavior)(_this, handle);\n        });\n        this.events = eventsToBind;\n      }\n    };\n\n    base.prototype = prototype;\n    Behavior.types[type] = base;\n  };\n\n  Behavior.hasBehavior = function (type) {\n    return !!Behavior.types[type];\n  };\n\n  Behavior.getBehavior = function (type) {\n    return Behavior.types[type];\n  }; // 所有自定义的 Behavior 的实例\n\n\n  Behavior.types = {};\n  return Behavior;\n}();\n\nvar _default = Behavior;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@antv/util\");\n\n// 自定义 Behavior 时候共有的方法\nvar _default = {\n  getDefaultCfg: function getDefaultCfg() {\n    return {};\n  },\n\n  /**\n   * register event handler, behavior will auto bind events\n   * for example:\n   * return {\n   *  click: 'onClick'\n   * }\n   */\n  getEvents: function getEvents() {\n    return {};\n  },\n  updateCfg: function updateCfg(cfg) {\n    Object.assign(this, cfg);\n    return true;\n  },\n  shouldBegin: function shouldBegin() {\n    return true;\n  },\n  shouldUpdate: function shouldUpdate() {\n    return true;\n  },\n  shouldEnd: function shouldEnd() {\n    return true;\n  },\n\n  /**\n   * auto bind events when register behavior\n   * @param graph Graph instance\n   */\n  bind: function bind(graph) {\n    var _this = this;\n\n    var events = this.events;\n    this.graph = graph;\n\n    if (this.type === 'drag-canvas' || this.type === 'brush-select' || this.type === 'lasso-select') {\n      graph.get('canvas').set('draggable', true);\n    }\n\n    (0, _util.each)(events, function (handler, event) {\n      graph.on(event, handler);\n    }); // To avoid the tabs switching makes the keydown related behaviors disable\n\n    document.addEventListener('visibilitychange', function () {\n      _this.keydown = false;\n    });\n  },\n  unbind: function unbind(graph) {\n    var events = this.events;\n\n    if (this.type === 'drag-canvas' || this.type === 'brush-select' || this.type === 'lasso-select') {\n      graph.get('canvas').set('draggable', false);\n    }\n\n    (0, _util.each)(events, function (handler, event) {\n      graph.off(event, handler);\n    });\n  },\n  get: function get(val) {\n    return this[val];\n  },\n  set: function set(key, val) {\n    this[key] = val;\n    return this;\n  }\n};\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _eventEmitter = _interopRequireDefault(require(\"@antv/event-emitter\"));\n\nvar _matrixUtil = require(\"@antv/matrix-util\");\n\nvar _util = require(\"@antv/util\");\n\nvar _algorithm = require(\"@antv/algorithm\");\n\nvar _math = require(\"../util/math\");\n\nvar _validation = require(\"../util/validation\");\n\nvar _global = _interopRequireDefault(require(\"../global\"));\n\nvar _controller = require(\"./controller\");\n\nvar _graphic = require(\"../util/graphic\");\n\nvar _hull = _interopRequireDefault(require(\"../item/hull\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar transform = _matrixUtil.ext.transform;\nvar NODE = 'node';\n\nvar AbstractGraph =\n/** @class */\nfunction (_super) {\n  (0, _tslib.__extends)(AbstractGraph, _super);\n\n  function AbstractGraph(cfg) {\n    var _this = _super.call(this) || this;\n\n    _this.cfg = (0, _util.deepMix)(_this.getDefaultCfg(), cfg);\n\n    _this.init();\n\n    _this.animating = false;\n    _this.destroyed = false; // 启用 stack 后，实例化 undoStack 和 redoStack\n\n    if (_this.cfg.enabledStack) {\n      // 实例化 undo 和 redo 栈\n      _this.undoStack = new _algorithm.Stack(_this.cfg.maxStep);\n      _this.redoStack = new _algorithm.Stack(_this.cfg.maxStep);\n    }\n\n    return _this;\n  }\n\n  AbstractGraph.prototype.init = function () {\n    this.initCanvas(); // instance controller\n\n    var viewController = new _controller.ViewController(this);\n    var modeController = new _controller.ModeController(this);\n    var itemController = new _controller.ItemController(this);\n    var stateController = new _controller.StateController(this);\n    this.set({\n      viewController: viewController,\n      modeController: modeController,\n      itemController: itemController,\n      stateController: stateController\n    }); // 初始化布局机制\n\n    this.initLayoutController(); // 初始化事件机制\n\n    this.initEventController();\n    this.initGroups();\n    /** 初始化插件 */\n\n    this.initPlugins();\n  }; // 初始化所有 Group\n\n\n  AbstractGraph.prototype.initGroups = function () {\n    var canvas = this.get('canvas');\n    var el = this.get('canvas').get('el');\n    var id = el.id;\n    var group = canvas.addGroup({\n      id: id + \"-root\",\n      className: _global.default.rootContainerClassName\n    });\n\n    if (this.get('groupByTypes')) {\n      var edgeGroup = group.addGroup({\n        id: id + \"-edge\",\n        className: _global.default.edgeContainerClassName\n      });\n      var nodeGroup = group.addGroup({\n        id: id + \"-node\",\n        className: _global.default.nodeContainerClassName\n      });\n      var comboGroup = group.addGroup({\n        id: id + \"-combo\",\n        className: _global.default.comboContainerClassName\n      }); // 用于存储自定义的群组\n\n      comboGroup.toBack();\n      this.set({\n        nodeGroup: nodeGroup,\n        edgeGroup: edgeGroup,\n        comboGroup: comboGroup\n      });\n    }\n\n    var delegateGroup = group.addGroup({\n      id: id + \"-delegate\",\n      className: _global.default.delegateContainerClassName\n    });\n    this.set({\n      delegateGroup: delegateGroup\n    });\n    this.set('group', group);\n  }; // eslint-disable-next-line class-methods-use-this\n\n\n  AbstractGraph.prototype.getDefaultCfg = function () {\n    return {\n      /**\n       * Container could be dom object or dom id\n       */\n      container: undefined,\n\n      /**\n       * Canvas width\n       * unit pixel if undefined force fit width\n       */\n      width: undefined,\n\n      /**\n       * Canvas height\n       * unit pixel if undefined force fit height\n       */\n      height: undefined,\n\n      /**\n       * renderer canvas or svg\n       * @type {string}\n       */\n      renderer: 'canvas',\n\n      /**\n       * control graph behaviors\n       */\n      modes: {},\n\n      /**\n       * 注册插件\n       */\n      plugins: [],\n\n      /**\n       * source data\n       */\n      data: {},\n\n      /**\n       * Fit view padding (client scale)\n       */\n      fitViewPadding: 10,\n\n      /**\n       * Minimum scale size\n       */\n      minZoom: 0.2,\n\n      /**\n       * Maxmum scale size\n       */\n      maxZoom: 10,\n\n      /**\n       *  capture events\n       */\n      event: true,\n\n      /**\n       * group node & edges into different graphic groups\n       */\n      groupByTypes: true,\n\n      /**\n       * determine if it's a directed graph\n       */\n      directed: false,\n\n      /**\n       * when data or shape changed, should canvas draw automatically\n       */\n      autoPaint: true,\n\n      /**\n       * store all the node instances\n       */\n      nodes: [],\n\n      /**\n       * store all the edge instances\n       */\n      edges: [],\n\n      /**\n       * store all the combo instances\n       */\n      combos: [],\n\n      /**\n       * store all the edge instances which are virtual edges related to collapsed combo\n       */\n      vedges: [],\n\n      /**\n       * all the instances indexed by id\n       */\n      itemMap: {},\n\n      /**\n       * 边直接连接到节点的中心，不再考虑锚点\n       */\n      linkCenter: false,\n\n      /**\n       * 默认的节点配置，data 上定义的配置会覆盖这些配置。例如：\n       * defaultNode: {\n       *  type: 'rect',\n       *  size: [60, 40],\n       *  style: {\n       *    //... 样式配置项\n       *  }\n       * }\n       * 若数据项为 { id: 'node', x: 100, y: 100 }\n       * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'rect', size: [60, 40] }\n       * 若数据项为 { id: 'node', x: 100, y: 100, type: 'circle' }\n       * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'circle', size: [60, 40] }\n       */\n      defaultNode: {},\n\n      /**\n       * 默认边配置，data 上定义的配置会覆盖这些配置。用法同 defaultNode\n       */\n      defaultEdge: {},\n\n      /**\n       * 节点默认样式，也可以添加状态样式\n       * 例如：\n       * const graph = new G6.Graph({\n       *  nodeStateStyles: {\n       *    selected: { fill: '#ccc', stroke: '#666' },\n       *    active: { lineWidth: 2 }\n       *  },\n       *  ...\n       * });\n       *\n       */\n      nodeStateStyles: {},\n\n      /**\n       * 边默认样式，用法同nodeStateStyle\n       */\n      edgeStateStyles: {},\n\n      /**\n       * graph 状态\n       */\n      states: {},\n\n      /**\n       * 是否启用全局动画\n       */\n      animate: false,\n\n      /**\n       * 动画设置,仅在 animate 为 true 时有效\n       */\n      animateCfg: {\n        /**\n         * 帧回调函数，用于自定义节点运动路径，为空时线性运动\n         */\n        onFrame: undefined,\n\n        /**\n         * 动画时长(ms)\n         */\n        duration: 500,\n\n        /**\n         * 指定动画动效\n         */\n        easing: 'easeLinear'\n      },\n      callback: undefined,\n      // 默认不启用 undo & redo 功能\n      enabledStack: false,\n      // 只有当 enabledStack 为 true 时才起作用\n      maxStep: 10,\n      // 存储图上的 tooltip dom，方便销毁\n      tooltips: []\n    };\n  };\n  /**\n   * 将值设置到 this.cfg 变量上面\n   * @param key 键 或 对象值\n   * @param val 值\n   */\n\n\n  AbstractGraph.prototype.set = function (key, val) {\n    if ((0, _util.isPlainObject)(key)) {\n      this.cfg = (0, _tslib.__assign)((0, _tslib.__assign)({}, this.cfg), key);\n    } else {\n      this.cfg[key] = val;\n    }\n\n    return this;\n  };\n  /**\n   * 获取 this.cfg 中的值\n   * @param key 键\n   */\n\n\n  AbstractGraph.prototype.get = function (key) {\n    return this.cfg[key];\n  };\n  /**\n   * 获取 graph 的根图形分组\n   * @return 根 group\n   */\n\n\n  AbstractGraph.prototype.getGroup = function () {\n    return this.get('group');\n  };\n  /**\n   * 获取 graph 的 DOM 容器\n   * @return DOM 容器\n   */\n\n\n  AbstractGraph.prototype.getContainer = function () {\n    return this.get('container');\n  };\n  /**\n   * 获取 graph 的最小缩放比例\n   * @return minZoom\n   */\n\n\n  AbstractGraph.prototype.getMinZoom = function () {\n    return this.get('minZoom');\n  };\n  /**\n   * 设置 graph 的最小缩放比例\n   * @return minZoom\n   */\n\n\n  AbstractGraph.prototype.setMinZoom = function (ratio) {\n    return this.set('minZoom', ratio);\n  };\n  /**\n   * 获取 graph 的最大缩放比例\n   * @param maxZoom\n   */\n\n\n  AbstractGraph.prototype.getMaxZoom = function () {\n    return this.get('maxZoom');\n  };\n  /**\n   * 设置 graph 的最大缩放比例\n   * @param maxZoom\n   */\n\n\n  AbstractGraph.prototype.setMaxZoom = function (ratio) {\n    return this.set('maxZoom', ratio);\n  };\n  /**\n   * 获取 graph 的宽度\n   * @return width\n   */\n\n\n  AbstractGraph.prototype.getWidth = function () {\n    return this.get('width');\n  };\n  /**\n   * 获取 graph 的高度\n   * @return width\n   */\n\n\n  AbstractGraph.prototype.getHeight = function () {\n    return this.get('height');\n  };\n  /**\n   * 清理元素多个状态\n   * @param {string|Item} item 元素id或元素实例\n   * @param {string[]} states 状态\n   */\n\n\n  AbstractGraph.prototype.clearItemStates = function (item, states) {\n    if ((0, _util.isString)(item)) {\n      item = this.findById(item);\n    }\n\n    var itemController = this.get('itemController');\n\n    if (!states) {\n      states = item.get('states');\n    }\n\n    itemController.clearItemStates(item, states);\n    var stateController = this.get('stateController');\n    stateController.updateStates(item, states, false);\n  };\n  /**\n   * 设置各个节点样式，以及在各种状态下节点 keyShape 的样式。\n   * 若是自定义节点切在各种状态下\n   * graph.node(node => {\n   *  return {\n   *    type: 'rect',\n   *    label: node.id,\n   *    style: { fill: '#666' },\n   *    stateStyles: {\n   *       selected: { fill: 'blue' },\n   *       custom: { fill: 'green' }\n   *     }\n   *   }\n   * });\n   * @param {function} nodeFn 指定每个节点样式\n   */\n\n\n  AbstractGraph.prototype.node = function (nodeFn) {\n    if (typeof nodeFn === 'function') {\n      this.set('nodeMapper', nodeFn);\n    }\n  };\n  /**\n   * 设置各个边样式\n   * @param {function} edgeFn 指定每个边的样式,用法同 node\n   */\n\n\n  AbstractGraph.prototype.edge = function (edgeFn) {\n    if (typeof edgeFn === 'function') {\n      this.set('edgeMapper', edgeFn);\n    }\n  };\n  /**\n   * 设置各个 combo 的配置\n   * @param comboFn\n   */\n\n\n  AbstractGraph.prototype.combo = function (comboFn) {\n    if (typeof comboFn === 'function') {\n      this.set('comboMapper', comboFn);\n    }\n  };\n  /**\n   * 根据 ID 查询图元素实例\n   * @param id 图元素 ID\n   */\n\n\n  AbstractGraph.prototype.findById = function (id) {\n    return this.get('itemMap')[id];\n  };\n  /**\n   * 根据对应规则查找单个元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge | group)\n   * @param {(item: T, index: number) => T} fn 指定规则\n   * @return {T} 元素实例\n   */\n\n\n  AbstractGraph.prototype.find = function (type, fn) {\n    var result;\n    var items = this.get(type + \"s\"); // eslint-disable-next-line consistent-return\n\n    (0, _util.each)(items, function (item, i) {\n      if (fn(item, i)) {\n        result = item;\n        return result;\n      }\n    });\n    return result;\n  };\n  /**\n   * 查找所有满足规则的元素\n   * @param {string} type 元素类型(node|edge)\n   * @param {string} fn 指定规则\n   * @return {array} 元素实例\n   */\n\n\n  AbstractGraph.prototype.findAll = function (type, fn) {\n    var result = [];\n    (0, _util.each)(this.get(type + \"s\"), function (item, i) {\n      if (fn(item, i)) {\n        result.push(item);\n      }\n    });\n    return result;\n  };\n  /**\n   * 查找所有处于指定状态的元素\n   * @param {string} type 元素类型(node|edge)\n   * @param {string} state 状态\n   * @return {object} 元素实例\n   */\n\n\n  AbstractGraph.prototype.findAllByState = function (type, state) {\n    return this.findAll(type, function (item) {\n      return item.hasState(state);\n    });\n  };\n  /**\n   * 平移画布\n   * @param dx 水平方向位移\n   * @param dy 垂直方向位移\n   */\n\n\n  AbstractGraph.prototype.translate = function (dx, dy) {\n    var group = this.get('group');\n    var matrix = (0, _util.clone)(group.getMatrix());\n\n    if (!matrix) {\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    matrix = transform(matrix, [['t', dx, dy]]);\n    group.setMatrix(matrix);\n    this.emit('viewportchange', {\n      action: 'translate',\n      matrix: group.getMatrix()\n    });\n    this.autoPaint();\n  };\n  /**\n   * 平移画布到某点\n   * @param {number} x 水平坐标\n   * @param {number} y 垂直坐标\n   */\n\n\n  AbstractGraph.prototype.moveTo = function (x, y) {\n    var group = this.get('group');\n    (0, _math.move)(group, {\n      x: x,\n      y: y\n    });\n    this.emit('viewportchange', {\n      action: 'move',\n      matrix: group.getMatrix()\n    });\n  };\n  /**\n   * 调整视口适应视图\n   * @param {object} padding 四周围边距\n   */\n\n\n  AbstractGraph.prototype.fitView = function (padding) {\n    if (padding) {\n      this.set('fitViewPadding', padding);\n    }\n\n    var viewController = this.get('viewController');\n    viewController.fitView();\n    this.autoPaint();\n  };\n  /**\n   * 调整视口适应视图，不缩放，仅将图 bbox 中心对齐到画布中心\n   */\n\n\n  AbstractGraph.prototype.fitCenter = function () {\n    var viewController = this.get('viewController');\n    viewController.fitCenter();\n    this.autoPaint();\n  };\n  /**\n   * 新增行为\n   * @param {string | ModeOption | ModeType[]} behaviors 添加的行为\n   * @param {string | string[]} modes 添加到对应的模式\n   * @return {Graph} Graph\n   */\n\n\n  AbstractGraph.prototype.addBehaviors = function (behaviors, modes) {\n    var modeController = this.get('modeController');\n    modeController.manipulateBehaviors(behaviors, modes, true);\n    return this;\n  };\n  /**\n   * 移除行为\n   * @param {string | ModeOption | ModeType[]} behaviors 移除的行为\n   * @param {string | string[]} modes 从指定的模式中移除\n   * @return {Graph} Graph\n   */\n\n\n  AbstractGraph.prototype.removeBehaviors = function (behaviors, modes) {\n    var modeController = this.get('modeController');\n    modeController.manipulateBehaviors(behaviors, modes, false);\n    return this;\n  };\n  /**\n   * 更新行为参数\n   * @param {string | ModeOption | ModeType} behavior 需要更新的行为\n   * @param {string | string[]} modes 指定的模式中的行为，不指定则为 default\n   * @return {Graph} Graph\n   */\n\n\n  AbstractGraph.prototype.updateBehavior = function (behavior, newCfg, mode) {\n    var modeController = this.get('modeController');\n    modeController.updateBehavior(behavior, newCfg, mode);\n    return this;\n  };\n  /**\n   * 伸缩窗口\n   * @param ratio 伸缩比例\n   * @param center 以center的x, y坐标为中心缩放\n   */\n\n\n  AbstractGraph.prototype.zoom = function (ratio, center) {\n    var group = this.get('group');\n    var matrix = (0, _util.clone)(group.getMatrix());\n    var minZoom = this.get('minZoom');\n    var maxZoom = this.get('maxZoom');\n\n    if (!matrix) {\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    if (center) {\n      matrix = transform(matrix, [['t', -center.x, -center.y], ['s', ratio, ratio], ['t', center.x, center.y]]);\n    } else {\n      matrix = transform(matrix, [['s', ratio, ratio]]);\n    }\n\n    if (minZoom && matrix[0] < minZoom || maxZoom && matrix[0] > maxZoom) {\n      return;\n    } // matrix = [2, 0, 0, 0, 2, 0, -125, -125, 1];\n\n\n    group.setMatrix(matrix);\n    this.emit('viewportchange', {\n      action: 'zoom',\n      matrix: matrix\n    });\n    this.autoPaint();\n  };\n  /**\n   * 伸缩视口到一固定比例\n   * @param {number} toRatio 伸缩比例\n   * @param {Point} center 以center的x, y坐标为中心缩放\n   */\n\n\n  AbstractGraph.prototype.zoomTo = function (toRatio, center) {\n    var ratio = toRatio / this.getZoom();\n    this.zoom(ratio, center);\n  };\n  /**\n   * 将元素移动到视口中心\n   * @param {Item} item 指定元素\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n\n\n  AbstractGraph.prototype.focusItem = function (item, animate, animateCfg) {\n    var viewController = this.get('viewController');\n    var isAnimate = false;\n    if (animate) isAnimate = true;else if (animate === undefined) isAnimate = this.get('animate');\n    var curAniamteCfg = {};\n    if (animateCfg) curAniamteCfg = animateCfg;else if (animateCfg === undefined) curAniamteCfg = this.get('animateCfg');\n    viewController.focus(item, isAnimate, curAniamteCfg);\n    this.autoPaint();\n  };\n  /**\n   * 自动重绘\n   * @internal 仅供内部更新机制调用，外部根据需求调用 render 或 paint 接口\n   */\n\n\n  AbstractGraph.prototype.autoPaint = function () {\n    if (this.get('autoPaint')) {\n      this.paint();\n    }\n  };\n  /**\n   * 仅画布重新绘制\n   */\n\n\n  AbstractGraph.prototype.paint = function () {\n    this.emit('beforepaint');\n    this.get('canvas').draw();\n    this.emit('afterpaint');\n  };\n  /**\n   * 将屏幕坐标转换为视口坐标\n   * @param {number} clientX 屏幕x坐标\n   * @param {number} clientY 屏幕y坐标\n   * @return {Point} 视口坐标\n   */\n\n\n  AbstractGraph.prototype.getPointByClient = function (clientX, clientY) {\n    var viewController = this.get('viewController');\n    return viewController.getPointByClient(clientX, clientY);\n  };\n  /**\n   * 将绘制坐标转换为屏幕坐标\n   * @param {number} x 绘制坐标 x\n   * @param {number} y 绘制坐标 y\n   * @return {Point} 绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getClientByPoint = function (x, y) {\n    var viewController = this.get('viewController');\n    return viewController.getClientByPoint(x, y);\n  };\n  /**\n   * 将画布坐标转换为绘制坐标\n   * @param {number} canvasX 画布 x 坐标\n   * @param {number} canvasY 画布 y 坐标\n   * @return {object} 绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getPointByCanvas = function (canvasX, canvasY) {\n    var viewController = this.get('viewController');\n    return viewController.getPointByCanvas(canvasX, canvasY);\n  };\n  /**\n   * 将绘制坐标转换为画布坐标\n   * @param {number} x 绘制坐标 x\n   * @param {number} y 绘制坐标 y\n   * @return {object} 画布坐标\n   */\n\n\n  AbstractGraph.prototype.getCanvasByPoint = function (x, y) {\n    var viewController = this.get('viewController');\n    return viewController.getCanvasByPoint(x, y);\n  };\n  /**\n   * 获取图内容的中心绘制坐标\n   * @return {object} 中心绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getGraphCenterPoint = function () {\n    var bbox = this.get('group').getCanvasBBox();\n    return {\n      x: (bbox.minX + bbox.maxX) / 2,\n      y: (bbox.minY + bbox.maxY) / 2\n    };\n  };\n  /**\n   * 获取视口中心绘制坐标\n   * @return {object} 视口中心绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getViewPortCenterPoint = function () {\n    return this.getPointByCanvas(this.get('width') / 2, this.get('height') / 2);\n  };\n  /**\n   * 显示元素\n   * @param {Item} item 指定元素\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.showItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var itemController = this.get('itemController');\n    var object = itemController.changeItemVisibility(item, true);\n\n    if (stack && this.get('enabledStack')) {\n      var id = object.getID();\n      var type = object.getType();\n      var before = {};\n      var after = {};\n\n      switch (type) {\n        case 'node':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.nodes = [{\n            id: id,\n            visible: true\n          }];\n          break;\n\n        case 'edge':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.edges = [{\n            id: id,\n            visible: true\n          }];\n          break;\n\n        case 'combo':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.combos = [{\n            id: id,\n            visible: true\n          }];\n          break;\n\n        default:\n          break;\n      }\n\n      this.pushStack('visible', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 隐藏元素\n   * @param {Item} item 指定元素\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.hideItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var itemController = this.get('itemController');\n    var object = itemController.changeItemVisibility(item, false);\n\n    if (stack && this.get('enabledStack')) {\n      var id = object.getID();\n      var type = object.getType();\n      var before = {};\n      var after = {};\n\n      switch (type) {\n        case 'node':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.nodes = [{\n            id: id,\n            visible: false\n          }];\n          break;\n\n        case 'edge':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.edges = [{\n            id: id,\n            visible: false\n          }];\n          break;\n\n        case 'combo':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.combos = [{\n            id: id,\n            visible: false\n          }];\n          break;\n\n        default:\n          break;\n      }\n\n      this.pushStack('visible', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 刷新元素\n   * @param {string|object} item 元素id或元素实例\n   */\n\n\n  AbstractGraph.prototype.refreshItem = function (item) {\n    var itemController = this.get('itemController');\n    itemController.refreshItem(item);\n  };\n  /**\n   * 设置是否在更新/刷新后自动重绘\n   * @param {boolean} auto 自动重绘\n   */\n\n\n  AbstractGraph.prototype.setAutoPaint = function (auto) {\n    var self = this;\n    self.set('autoPaint', auto);\n    var canvas = self.get('canvas');\n    canvas.set('autoDraw', auto);\n  };\n  /**\n   * 删除元素\n   * @param {Item} item 元素id或元素实例\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.remove = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    this.removeItem(item, stack);\n  };\n  /**\n   * 删除元素\n   * @param {Item} item 元素id或元素实例\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.removeItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var nodeItem = item;\n    if ((0, _util.isString)(item)) nodeItem = this.findById(item);\n\n    if (!nodeItem && (0, _util.isString)(item)) {\n      console.warn('The item to be removed does not exist!');\n    } else if (nodeItem) {\n      var type = '';\n      if (nodeItem.getType) type = nodeItem.getType(); // 将删除的元素入栈\n\n      if (stack && this.get('enabledStack')) {\n        var deletedModel = (0, _tslib.__assign)((0, _tslib.__assign)({}, nodeItem.getModel()), {\n          itemType: type\n        });\n        var before = {};\n\n        switch (type) {\n          case 'node':\n            {\n              before.nodes = [deletedModel];\n              before.edges = [];\n              var edges = nodeItem.getEdges();\n\n              for (var i = edges.length - 1; i >= 0; i--) {\n                before.edges.push((0, _tslib.__assign)((0, _tslib.__assign)({}, edges[i].getModel()), {\n                  itemType: 'edge'\n                }));\n              }\n\n              break;\n            }\n\n          case 'edge':\n            before.edges = [deletedModel];\n            break;\n\n          case 'combo':\n            before.combos = [deletedModel];\n            break;\n\n          default:\n            break;\n        }\n\n        this.pushStack('delete', {\n          before: before,\n          after: {}\n        });\n      }\n\n      if (type === 'node') {\n        var model = nodeItem.getModel(); // 如果删除的是节点，且该节点存在于某个 Combo 中，则需要先将 node 从 combo 中移除，否则删除节点后，操作 combo 会出错\n\n        if (model.comboId) {\n          this.updateComboTree(nodeItem);\n        }\n      }\n\n      var itemController = this.get('itemController');\n      itemController.removeItem(nodeItem);\n\n      if (type === 'combo') {\n        var newComboTrees = (0, _graphic.reconstructTree)(this.get('comboTrees'));\n        this.set('comboTrees', newComboTrees);\n      }\n    }\n  };\n  /**\n   * 新增元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge)\n   * @param {ModelConfig} model 元素数据模型\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   * @param {boolean} sortCombo 本次操作是否需要更新 combo 层级顺序，内部参数，用户在外部使用 addItem 时始终时需要更新\n   * @return {Item} 元素实例\n   */\n\n\n  AbstractGraph.prototype.addItem = function (type, model, stack, sortCombo) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n\n    var currentComboSorted = this.get('comboSorted');\n    this.set('comboSorted', currentComboSorted && !sortCombo);\n    var itemController = this.get('itemController'); // 添加节点、边或combo之前，先验证数据是否符合规范\n\n    if (!(0, _validation.singleDataValidation)(type, model)) {\n      return false;\n    }\n\n    if (model.id && this.findById(model.id)) {\n      console.warn(\"This item exists already. Be sure the id %c\" + model.id + \"%c is unique.\", 'font-size: 20px; color: red;', '');\n      return;\n    }\n\n    var item;\n    var comboTrees = this.get('comboTrees');\n    if (!comboTrees) comboTrees = [];\n\n    if (type === 'combo') {\n      var itemMap_1 = this.get('itemMap');\n      var foundParent_1 = false;\n      comboTrees.forEach(function (ctree) {\n        if (foundParent_1) return; // terminate the forEach after the tree containing the item is done\n\n        (0, _graphic.traverseTreeUp)(ctree, function (child) {\n          // find the parent\n          if (model.parentId === child.id) {\n            foundParent_1 = true;\n            var newCombo = (0, _tslib.__assign)({\n              id: model.id,\n              depth: child.depth + 2\n            }, model);\n            if (child.children) child.children.push(newCombo);else child.children = [newCombo];\n            model.depth = newCombo.depth;\n            item = itemController.addItem(type, model);\n          }\n\n          var childItem = itemMap_1[child.id]; // after the parent is found, update all the ancestors\n\n          if (foundParent_1 && childItem && childItem.getType && childItem.getType() === 'combo') {\n            itemController.updateCombo(childItem, child.children);\n          }\n\n          return true;\n        });\n      }); // if the parent is not found, add it to the root\n\n      if (!foundParent_1) {\n        var newCombo = (0, _tslib.__assign)({\n          id: model.id,\n          depth: 0\n        }, model);\n        model.depth = newCombo.depth;\n        comboTrees.push(newCombo);\n        item = itemController.addItem(type, model);\n      }\n\n      this.set('comboTrees', comboTrees);\n    } else if (type === 'node' && (0, _util.isString)(model.comboId) && comboTrees) {\n      var parentCombo = this.findById(model.comboId);\n\n      if (parentCombo && parentCombo.getType && parentCombo.getType() !== 'combo') {\n        console.warn(\"'\" + model.comboId + \"' is not a id of a combo in the graph, the node will be added without combo.\");\n      }\n\n      item = itemController.addItem(type, model);\n      var itemMap_2 = this.get('itemMap');\n      var foundParent_2 = false,\n          foundNode_1 = false;\n      (comboTrees || []).forEach(function (ctree) {\n        if (foundNode_1 || foundParent_2) return; // terminate the forEach\n\n        (0, _graphic.traverseTreeUp)(ctree, function (child) {\n          if (child.id === model.id) {\n            // if the item exists in the tree already, terminate\n            foundNode_1 = true;\n            return false;\n          }\n\n          if (model.comboId === child.id && !foundNode_1) {\n            // found the parent, add the item to the children of its parent in the tree\n            foundParent_2 = true;\n            var cloneNode = (0, _util.clone)(model);\n            cloneNode.itemType = 'node';\n            if (child.children) child.children.push(cloneNode);else child.children = [cloneNode];\n            cloneNode.depth = child.depth + 1;\n          } // update the size of all the ancestors\n\n\n          if (foundParent_2 && itemMap_2[child.id].getType && itemMap_2[child.id].getType() === 'combo') {\n            itemController.updateCombo(itemMap_2[child.id], child.children);\n          }\n\n          return true;\n        });\n      });\n    } else {\n      item = itemController.addItem(type, model);\n    }\n\n    if (type === 'node' && model.comboId || type === 'combo' && model.parentId) {\n      // add the combo to the parent's children array\n      var parentCombo = this.findById(model.comboId || model.parentId);\n      if (parentCombo && parentCombo.getType && parentCombo.getType() === 'combo') parentCombo.addChild(item);\n    }\n\n    var combos = this.get('combos');\n\n    if (combos && combos.length > 0) {\n      this.sortCombos();\n    }\n\n    this.autoPaint();\n\n    if (stack && this.get('enabledStack')) {\n      var addedModel = (0, _tslib.__assign)((0, _tslib.__assign)({}, item.getModel()), {\n        itemType: type\n      });\n      var after = {};\n\n      switch (type) {\n        case 'node':\n          after.nodes = [addedModel];\n          break;\n\n        case 'edge':\n          after.edges = [addedModel];\n          break;\n\n        case 'combo':\n          after.combos = [addedModel];\n          break;\n\n        default:\n          break;\n      }\n\n      this.pushStack('add', {\n        before: {},\n        after: after\n      });\n    }\n\n    return item;\n  };\n  /**\n   * 新增元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge)\n   * @param {ModelConfig} model 元素数据模型\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   * @return {Item} 元素实例\n   */\n\n\n  AbstractGraph.prototype.add = function (type, model, stack, sortCombo) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n\n    return this.addItem(type, model, stack, sortCombo);\n  };\n  /**\n   * 更新元素\n   * @param {Item} item 元素id或元素实例\n   * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\n   */\n\n\n  AbstractGraph.prototype.updateItem = function (item, cfg, stack) {\n    var _this = this;\n\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var itemController = this.get('itemController');\n    var currentItem;\n\n    if ((0, _util.isString)(item)) {\n      currentItem = this.findById(item);\n    } else {\n      currentItem = item;\n    }\n\n    var UnupdateModel = (0, _util.clone)(currentItem.getModel());\n    var type = '';\n    if (currentItem.getType) type = currentItem.getType();\n    var states = (0, _tslib.__spreadArray)([], currentItem.getStates());\n\n    if (type === 'combo') {\n      (0, _util.each)(states, function (state) {\n        return _this.setItemState(currentItem, state, false);\n      });\n    }\n\n    itemController.updateItem(currentItem, cfg);\n\n    if (type === 'combo') {\n      (0, _util.each)(states, function (state) {\n        return _this.setItemState(currentItem, state, true);\n      });\n    }\n\n    if (stack && this.get('enabledStack')) {\n      var before = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n      var after = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n      var afterModel = (0, _tslib.__assign)({\n        id: UnupdateModel.id\n      }, cfg);\n\n      switch (type) {\n        case 'node':\n          before.nodes.push(UnupdateModel);\n          after.nodes.push(afterModel);\n          break;\n\n        case 'edge':\n          before.edges.push(UnupdateModel);\n          after.edges.push(afterModel);\n          break;\n\n        case 'combo':\n          before.combos.push(UnupdateModel);\n          after.combos.push(afterModel);\n          break;\n\n        default:\n          break;\n      }\n\n      if (type === 'node') {\n        before.nodes.push(UnupdateModel);\n      }\n\n      this.pushStack('update', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 更新元素\n   * @param {Item} item 元素id或元素实例\n   * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.update = function (item, cfg, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    this.updateItem(item, cfg, stack);\n  };\n  /**\n   * 设置元素状态\n   * @param {Item} item 元素id或元素实例\n   * @param {string} state 状态名称\n   * @param {string | boolean} value 是否启用状态 或 状态值\n   */\n\n\n  AbstractGraph.prototype.setItemState = function (item, state, value) {\n    if ((0, _util.isString)(item)) {\n      item = this.findById(item);\n    }\n\n    var itemController = this.get('itemController');\n    itemController.setItemState(item, state, value);\n    var stateController = this.get('stateController');\n\n    if ((0, _util.isString)(value)) {\n      stateController.updateState(item, state + \":\" + value, true);\n    } else {\n      stateController.updateState(item, state, value);\n    }\n  };\n  /**\n   * 将指定状态的优先级提升为最高优先级\n   * @param {Item} item 元素id或元素实例\n   * @param state 状态名称\n   */\n\n\n  AbstractGraph.prototype.priorityState = function (item, state) {\n    var itemController = this.get('itemController');\n    itemController.priorityState(item, state);\n  };\n  /**\n   * 设置视图初始化数据\n   * @param {GraphData} data 初始化数据\n   */\n\n\n  AbstractGraph.prototype.data = function (data) {\n    (0, _validation.dataValidation)(data);\n    this.set('data', data);\n  };\n  /**\n   * 根据data接口的数据渲染视图\n   */\n\n\n  AbstractGraph.prototype.render = function () {\n    var self = this;\n    this.set('comboSorted', false);\n    var data = this.get('data');\n\n    if (this.get('enabledStack')) {\n      // render 之前清空 redo 和 undo 栈\n      this.clearStack();\n    }\n\n    if (!data) {\n      throw new Error('data must be defined first');\n    }\n\n    var _a = data.nodes,\n        nodes = _a === void 0 ? [] : _a,\n        _b = data.edges,\n        edges = _b === void 0 ? [] : _b,\n        _c = data.combos,\n        combos = _c === void 0 ? [] : _c;\n    this.clear(true);\n    this.emit('beforerender');\n    (0, _util.each)(nodes, function (node) {\n      self.add('node', node, false, false);\n    }); // process the data to tree structure\n\n    if (combos && combos.length !== 0) {\n      var comboTrees = (0, _graphic.plainCombosToTrees)(combos, nodes);\n      this.set('comboTrees', comboTrees); // add combos\n\n      self.addCombos(combos);\n    }\n\n    (0, _util.each)(edges, function (edge) {\n      self.add('edge', edge, false, false);\n    });\n    var animate = self.get('animate');\n\n    if (self.get('fitView') || self.get('fitCenter')) {\n      self.set('animate', false);\n    } // layout\n\n\n    var layoutController = self.get('layoutController');\n\n    if (layoutController) {\n      layoutController.layout(success);\n      if (this.destroyed) return;\n    } else {\n      if (self.get('fitView')) {\n        self.fitView();\n      }\n\n      if (self.get('fitCenter')) {\n        self.fitCenter();\n      }\n\n      self.emit('afterrender');\n      self.set('animate', animate);\n    } // 将在 onLayoutEnd 中被调用\n\n\n    function success() {\n      // fitView 与 fitCenter 共存时，fitView 优先，fitCenter 不再执行\n      if (self.get('fitView')) {\n        self.fitView();\n      } else if (self.get('fitCenter')) {\n        self.fitCenter();\n      }\n\n      self.autoPaint();\n      self.emit('afterrender');\n\n      if (self.get('fitView') || self.get('fitCenter')) {\n        self.set('animate', animate);\n      }\n    }\n\n    if (!this.get('groupByTypes')) {\n      if (combos && combos.length !== 0) {\n        this.sortCombos();\n      } else {\n        // 为提升性能，选择数量少的进行操作\n        if (data.nodes && data.edges && data.nodes.length < data.edges.length) {\n          var nodesArr = this.getNodes(); // 遍历节点实例，将所有节点提前。\n\n          nodesArr.forEach(function (node) {\n            node.toFront();\n          });\n        } else {\n          var edgesArr = this.getEdges(); // 遍历节点实例，将所有节点提前。\n\n          edgesArr.forEach(function (edge) {\n            edge.toBack();\n          });\n        }\n      }\n    }\n\n    if (this.get('enabledStack')) {\n      this.pushStack('render');\n    }\n  };\n  /**\n   * 接收数据进行渲染\n   * @Param {Object} data 初始化数据\n   */\n\n\n  AbstractGraph.prototype.read = function (data) {\n    this.data(data);\n    this.render();\n  }; // 比较item\n\n\n  AbstractGraph.prototype.diffItems = function (type, items, models) {\n    var self = this;\n    var item;\n    var itemMap = this.get('itemMap');\n    (0, _util.each)(models, function (model) {\n      item = itemMap[model.id];\n\n      if (item) {\n        if (self.get('animate') && type === NODE) {\n          var containerMatrix = item.getContainer().getMatrix();\n          if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          item.set('originAttrs', {\n            x: containerMatrix[6],\n            y: containerMatrix[7]\n          });\n        }\n\n        self.updateItem(item, model, false);\n      } else {\n        item = self.addItem(type, model, false);\n      }\n\n      if (item) items[type + \"s\"].push(item);\n    });\n  };\n  /**\n   * 更改源数据，根据新数据重新渲染视图\n   * @param {GraphData | TreeGraphData} data 源数据\n   * @param {boolean} 是否入栈，默认为true\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.changeData = function (data, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var self = this;\n\n    if (!(0, _validation.dataValidation)(data)) {\n      return this;\n    }\n\n    if (stack && this.get('enabledStack')) {\n      this.pushStack('changedata', {\n        before: self.save(),\n        after: data\n      });\n    }\n\n    this.set('comboSorted', false); // 删除 hulls\n\n    this.removeHulls(); // 更改数据源后，取消所有状态\n\n    this.getNodes().map(function (node) {\n      return self.clearItemStates(node);\n    });\n    this.getEdges().map(function (edge) {\n      return self.clearItemStates(edge);\n    });\n    var canvas = this.get('canvas');\n    var localRefresh = canvas.get('localRefresh');\n    canvas.set('localRefresh', false);\n\n    if (!self.get('data')) {\n      self.data(data);\n      self.render();\n    }\n\n    var itemMap = this.get('itemMap');\n    var items = {\n      nodes: [],\n      edges: []\n    };\n    var combosData = data.combos;\n\n    if (combosData) {\n      var comboTrees = (0, _graphic.plainCombosToTrees)(combosData, data.nodes);\n      this.set('comboTrees', comboTrees);\n    }\n\n    this.diffItems('node', items, data.nodes);\n    (0, _util.each)(itemMap, function (item, id) {\n      itemMap[id].getModel().depth = 0;\n      if (item.getType && item.getType() === 'edge') return;\n\n      if (item.getType && item.getType() === 'combo') {\n        delete itemMap[id];\n        item.destroy();\n      } else if (items.nodes.indexOf(item) < 0) {\n        delete itemMap[id];\n        self.remove(item, false);\n      }\n    }); // clear the destroyed combos here to avoid removing sub nodes before removing the parent combo\n\n    var comboItems = this.getCombos();\n    var combosLength = comboItems.length;\n\n    for (var i = combosLength - 1; i >= 0; i--) {\n      if (comboItems[i].destroyed) {\n        comboItems.splice(i, 1);\n      }\n    } // process the data to tree structure\n\n\n    if (combosData) {\n      // add combos\n      self.addCombos(combosData);\n\n      if (!this.get('groupByTypes')) {\n        this.sortCombos();\n      }\n    }\n\n    this.diffItems('edge', items, data.edges);\n    (0, _util.each)(itemMap, function (item, id) {\n      if (item.getType && (item.getType() === 'node' || item.getType() === 'combo')) return;\n\n      if (items.edges.indexOf(item) < 0) {\n        delete itemMap[id];\n        self.remove(item, false);\n      }\n    });\n    this.set({\n      nodes: items.nodes,\n      edges: items.edges\n    });\n    var layoutController = this.get('layoutController');\n\n    if (layoutController) {\n      layoutController.changeData();\n\n      if (self.get('animate') && !layoutController.getLayoutType()) {\n        // 如果没有指定布局\n        self.positionsAnimate();\n      } else {\n        self.autoPaint();\n      }\n    }\n\n    setTimeout(function () {\n      canvas.set('localRefresh', localRefresh);\n    }, 16);\n    return this;\n  };\n  /**\n   * 私有方法，在 render 和 changeData 的时候批量添加数据中所有平铺的 combos\n   * @param {ComboConfig[]} combos 平铺的 combos 数据\n   */\n\n\n  AbstractGraph.prototype.addCombos = function (combos) {\n    var self = this;\n    var comboTrees = self.get('comboTrees');\n    var itemController = this.get('itemController');\n    itemController.addCombos(comboTrees, combos);\n  };\n  /**\n   * 根据已经存在的节点或 combo 创建新的 combo\n   * @param combo combo ID 或 Combo 配置\n   * @param children 添加到 Combo 中的元素，包括节点和 combo\n   */\n\n\n  AbstractGraph.prototype.createCombo = function (combo, children) {\n    var _this = this;\n\n    this.set('comboSorted', false); // step 1: 创建新的 Combo\n\n    var comboId = '';\n    var comboConfig;\n    if (!combo) return;\n\n    if ((0, _util.isString)(combo)) {\n      comboId = combo;\n      comboConfig = {\n        id: combo\n      };\n    } else {\n      comboId = combo.id;\n\n      if (!comboId) {\n        console.warn('Create combo failed. Please assign a unique string id for the adding combo.');\n        return;\n      }\n\n      comboConfig = combo;\n    } // step2: 更新 children，根据类型添加 comboId 或 parentId\n\n\n    var trees = children.map(function (elementId) {\n      var item = _this.findById(elementId);\n\n      var model = item.getModel();\n      var type = '';\n      if (item.getType) type = item.getType();\n      var cItem = {\n        id: item.getID(),\n        itemType: type\n      };\n\n      if (type === 'combo') {\n        cItem.parentId = comboId;\n        model.parentId = comboId;\n      } else if (type === 'node') {\n        cItem.comboId = comboId;\n        model.comboId = comboId;\n      }\n\n      return cItem;\n    });\n    comboConfig.children = trees; // step 3: 添加 Combo，addItem 时会将子将元素添加到 Combo 中\n\n    this.addItem('combo', comboConfig, false);\n    this.set('comboSorted', false); // step4: 更新 comboTrees 结构\n\n    var comboTrees = this.get('comboTrees');\n    (comboTrees || []).forEach(function (ctree) {\n      (0, _graphic.traverseTreeUp)(ctree, function (child) {\n        if (child.id === comboId) {\n          child.itemType = 'combo';\n          child.children = trees;\n          return false;\n        }\n\n        return true;\n      });\n    });\n\n    if (comboTrees) {\n      this.sortCombos();\n    }\n  };\n  /**\n   * 解散 combo\n   * @param {String | INode | ICombo} combo 需要被解散的 Combo item 或 id\n   */\n\n\n  AbstractGraph.prototype.uncombo = function (combo) {\n    var _this = this;\n\n    var self = this;\n    var comboItem = combo;\n\n    if ((0, _util.isString)(combo)) {\n      comboItem = this.findById(combo);\n    }\n\n    if (!comboItem || comboItem.getType && comboItem.getType() !== 'combo') {\n      console.warn('The item is not a combo!');\n      return;\n    }\n\n    var parentId = comboItem.getModel().parentId;\n    var comboTrees = self.get('comboTrees');\n    if (!comboTrees) comboTrees = [];\n    var itemMap = this.get('itemMap');\n    var comboId = comboItem.get('id');\n    var treeToBeUncombo;\n    var brothers = [];\n    var comboItems = this.get('combos');\n    var parentItem = this.findById(parentId);\n    comboTrees.forEach(function (ctree) {\n      if (treeToBeUncombo) return; // terminate the forEach\n\n      (0, _graphic.traverseTreeUp)(ctree, function (subtree) {\n        // find the combo to be uncomboed, delete the combo from map and cache\n        if (subtree.id === comboId) {\n          treeToBeUncombo = subtree; // delete the related edges\n\n          var edges = comboItem.getEdges();\n          edges.forEach(function (edge) {\n            _this.removeItem(edge, false);\n          });\n          var index = comboItems.indexOf(combo);\n          comboItems.splice(index, 1);\n          delete itemMap[comboId];\n          comboItem.destroy();\n        } // find the parent to remove the combo from the combo's brothers array and add the combo's children to the combo's brothers array in the tree\n\n\n        if (parentId && treeToBeUncombo && subtree.id === parentId) {\n          parentItem.removeCombo(comboItem);\n          brothers = subtree.children; // the combo's brothers\n          // remove the combo from its brothers array\n\n          var index = brothers.indexOf(treeToBeUncombo);\n\n          if (index !== -1) {\n            brothers.splice(index, 1);\n          } // append the combo's children to the combo's brothers array\n\n\n          treeToBeUncombo.children.forEach(function (child) {\n            var item = _this.findById(child.id);\n\n            var childModel = item.getModel();\n\n            if (item.getType && item.getType() === 'combo') {\n              child.parentId = parentId;\n              delete child.comboId;\n              childModel.parentId = parentId; // update the parentId of the model\n\n              delete childModel.comboId;\n            } else if (item.getType && item.getType() === 'node') {\n              child.comboId = parentId;\n              childModel.comboId = parentId; // update the parentId of the model\n            }\n\n            parentItem.addChild(item);\n            brothers.push(child);\n          });\n          return false;\n        }\n\n        return true;\n      });\n    }); // if the parentId is not found, remove the combo from the roots\n\n    if (!parentId && treeToBeUncombo) {\n      var index = comboTrees.indexOf(treeToBeUncombo);\n      comboTrees.splice(index, 1); // modify the parentId of the children\n\n      treeToBeUncombo.children.forEach(function (child) {\n        child.parentId = undefined;\n\n        var childModel = _this.findById(child.id).getModel();\n\n        delete childModel.parentId; // update the parentId of the model\n\n        delete childModel.comboId; // update the comboId of the model\n\n        if (child.itemType !== 'node') comboTrees.push(child);\n      });\n    }\n  };\n  /**\n   * 根据节点的 bbox 更新所有 combos 的绘制，包括 combos 的位置和范围\n   */\n\n\n  AbstractGraph.prototype.updateCombos = function () {\n    var _this = this;\n\n    var self = this;\n    var comboTrees = this.get('comboTrees');\n    var itemController = self.get('itemController');\n    var itemMap = self.get('itemMap');\n    (comboTrees || []).forEach(function (ctree) {\n      (0, _graphic.traverseTreeUp)(ctree, function (child) {\n        if (!child) {\n          return true;\n        }\n\n        var childItem = itemMap[child.id];\n\n        if (childItem && childItem.getType && childItem.getType() === 'combo') {\n          // 更新具体的 Combo 之前先清除所有的已有状态，以免将 state 中的样式更新为 Combo 的样式\n          var states = (0, _tslib.__spreadArray)([], childItem.getStates());\n          (0, _util.each)(states, function (state) {\n            return _this.setItemState(childItem, state, false);\n          }); // 更新具体的 Combo\n\n          itemController.updateCombo(childItem, child.children); // 更新 Combo 后，还原已有的状态\n\n          (0, _util.each)(states, function (state) {\n            return _this.setItemState(childItem, state, true);\n          });\n        }\n\n        return true;\n      });\n    });\n    self.sortCombos();\n  };\n  /**\n   * 根据节点的 bbox 更新 combo 及其祖先 combos 的绘制，包括 combos 的位置和范围\n   * @param {String | ICombo} combo 需要被更新的 Combo 或 id，若指定，则该 Combo 及所有祖先 Combod 都会被更新\n   */\n\n\n  AbstractGraph.prototype.updateCombo = function (combo) {\n    var _this = this;\n\n    var self = this;\n    var comboItem = combo;\n    var comboId;\n\n    if ((0, _util.isString)(combo)) {\n      comboItem = this.findById(combo);\n    }\n\n    if (!comboItem || comboItem.getType && comboItem.getType() !== 'combo') {\n      console.warn('The item to be updated is not a combo!');\n      return;\n    }\n\n    comboId = comboItem.get('id');\n    var comboTrees = this.get('comboTrees');\n    var itemController = self.get('itemController');\n    var itemMap = self.get('itemMap');\n    (comboTrees || []).forEach(function (ctree) {\n      (0, _graphic.traverseTreeUp)(ctree, function (child) {\n        if (!child) {\n          return true;\n        }\n\n        var childItem = itemMap[child.id];\n\n        if (comboId === child.id && childItem && childItem.getType && childItem.getType() === 'combo') {\n          // 更新具体的 Combo 之前先清除所有的已有状态，以免将 state 中的样式更新为 Combo 的样式\n          var states = (0, _tslib.__spreadArray)([], childItem.getStates()); // || !item.getStateStyle(stateName)\n\n          (0, _util.each)(states, function (state) {\n            if (childItem.getStateStyle(state)) {\n              _this.setItemState(childItem, state, false);\n            }\n          }); // 更新具体的 Combo\n\n          itemController.updateCombo(childItem, child.children); // 更新 Combo 后，还原已有的状态\n\n          (0, _util.each)(states, function (state) {\n            if (childItem.getStateStyle(state)) {\n              _this.setItemState(childItem, state, true);\n            }\n          });\n          if (comboId) comboId = child.parentId;\n        }\n\n        return true;\n      });\n    });\n  };\n  /**\n   * 更新树结构，例如移动子树等\n   * @param {String | INode | ICombo} item 需要被更新的 Combo 或 节点 id\n   * @param {string | undefined} parentId 新的父 combo id，undefined 代表没有父 combo\n   */\n\n\n  AbstractGraph.prototype.updateComboTree = function (item, parentId, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var self = this;\n    this.set('comboSorted', false);\n    var uItem;\n\n    if ((0, _util.isString)(item)) {\n      uItem = self.findById(item);\n    } else {\n      uItem = item;\n    }\n\n    var model = uItem.getModel();\n    var oldParentId = model.comboId || model.parentId;\n    var type = '';\n    if (uItem.getType) type = uItem.getType(); // 若 item 是 Combo，且 parentId 是其子孙 combo 的 id，则警告并终止\n\n    if (parentId && type === 'combo') {\n      var comboTrees = this.get('comboTrees');\n      var valid_1 = true;\n      var itemSubTree_1;\n      (comboTrees || []).forEach(function (ctree) {\n        if (itemSubTree_1) return;\n        (0, _graphic.traverseTree)(ctree, function (subTree) {\n          if (itemSubTree_1) return; // 找到从 item 开始的子树\n\n          if (subTree.id === uItem.getID()) {\n            itemSubTree_1 = subTree;\n          }\n\n          return true;\n        });\n      }); // 在以 item 为根的子树中寻找与 parentId 相同的后继元素\n\n      (0, _graphic.traverseTree)(itemSubTree_1, function (subTree) {\n        if (subTree.id === parentId) {\n          valid_1 = false;\n          return false;\n        }\n\n        return true;\n      }); // parentId 是 item 的一个后继元素，不能进行更新\n\n      if (!valid_1) {\n        console.warn('Failed to update the combo tree! The parentId points to a descendant of the combo!');\n        return;\n      }\n    }\n\n    if (stack && this.get('enabledStack')) {\n      var beforeData = {},\n          afterData = {};\n\n      if (type === 'combo') {\n        beforeData.combos = [{\n          id: model.id,\n          parentId: model.parentId\n        }];\n        afterData.combos = [{\n          id: model.id,\n          parentId: parentId\n        }];\n      } else if (type === 'node') {\n        beforeData.nodes = [{\n          id: model.id,\n          parentId: model.comboId\n        }];\n        afterData.nodes = [{\n          id: model.id,\n          parentId: parentId\n        }];\n      }\n\n      this.pushStack('updateComboTree', {\n        before: beforeData,\n        after: afterData\n      });\n    } // 当 combo 存在 parentId 或 comboId 时，才将其移除\n\n\n    if (model.parentId || model.comboId) {\n      var combo = this.findById(model.parentId || model.comboId);\n\n      if (combo) {\n        combo.removeChild(uItem);\n      }\n    }\n\n    if (type === 'combo') {\n      model.parentId = parentId;\n    } else if (type === 'node') {\n      model.comboId = parentId;\n    } // 只有当移入到指定 combo 时才添加\n\n\n    if (parentId) {\n      var parentCombo = this.findById(parentId);\n\n      if (parentCombo) {\n        // 将元素添加到 parentCombo 中\n        parentCombo.addChild(uItem);\n      }\n    } // 如果原先有父亲 combo，则从原父 combo 的子元素数组中删除\n\n\n    if (oldParentId) {\n      var parentCombo = this.findById(oldParentId);\n\n      if (parentCombo) {\n        // 将元素从 parentCombo 中移除\n        parentCombo.removeChild(uItem);\n      }\n    }\n\n    var newComboTrees = (0, _graphic.reconstructTree)(this.get('comboTrees'), model.id, parentId);\n    this.set('comboTrees', newComboTrees);\n    this.updateCombos();\n  };\n  /**\n   * 导出图数据\n   * @return {object} data\n   */\n\n\n  AbstractGraph.prototype.save = function () {\n    var nodes = [];\n    var edges = [];\n    var combos = [];\n    (0, _util.each)(this.get('nodes'), function (node) {\n      nodes.push(node.getModel());\n    });\n    (0, _util.each)(this.get('edges'), function (edge) {\n      edges.push(edge.getModel());\n    });\n    (0, _util.each)(this.get('combos'), function (combo) {\n      combos.push(combo.getModel());\n    });\n    return {\n      nodes: nodes,\n      edges: edges,\n      combos: combos\n    };\n  };\n  /**\n   * 改变画布大小\n   * @param  {number} width  画布宽度\n   * @param  {number} height 画布高度\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.changeSize = function (width, height) {\n    var viewController = this.get('viewController');\n    viewController.changeSize(width, height);\n    return this;\n  };\n  /**\n   * 当源数据在外部发生变更时，根据新数据刷新视图。但是不刷新节点位置\n   */\n\n\n  AbstractGraph.prototype.refresh = function () {\n    var self = this;\n    self.emit('beforegraphrefresh');\n\n    if (self.get('animate')) {\n      self.positionsAnimate();\n    } else {\n      var nodes = self.get('nodes');\n      var edges = self.get('edges');\n      var vedges = self.get('edges');\n      (0, _util.each)(nodes, function (node) {\n        node.refresh();\n      });\n      (0, _util.each)(edges, function (edge) {\n        edge.refresh();\n      });\n      (0, _util.each)(vedges, function (vedge) {\n        vedge.refresh();\n      });\n    }\n\n    self.emit('aftergraphrefresh');\n    self.autoPaint();\n  };\n  /**\n   * 获取当前图中所有节点的item实例\n   * @return {INode} item数组\n   */\n\n\n  AbstractGraph.prototype.getNodes = function () {\n    return this.get('nodes');\n  };\n  /**\n   * 获取当前图中所有边的item实例\n   * @return {IEdge} item数组\n   */\n\n\n  AbstractGraph.prototype.getEdges = function () {\n    return this.get('edges');\n  };\n  /**\n   * 获取图中所有的 combo 实例\n   */\n\n\n  AbstractGraph.prototype.getCombos = function () {\n    return this.get('combos');\n  };\n  /**\n   * 获取指定 Combo 中所有的节点\n   * @param comboId combo ID\n   */\n\n\n  AbstractGraph.prototype.getComboChildren = function (combo) {\n    if ((0, _util.isString)(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo || combo.getType && combo.getType() !== 'combo') {\n      console.warn('The combo does not exist!');\n      return;\n    }\n\n    return combo.getChildren();\n  };\n  /**\n   * 根据 graph 上的 animateCfg 进行视图中节点位置动画接口\n   */\n\n\n  AbstractGraph.prototype.positionsAnimate = function () {\n    var self = this;\n    self.emit('beforeanimate');\n    var animateCfg = self.get('animateCfg');\n    var onFrame = animateCfg.onFrame;\n    var nodes = self.getNodes();\n    var toNodes = nodes.map(function (node) {\n      var model = node.getModel();\n      return {\n        id: model.id,\n        x: model.x,\n        y: model.y\n      };\n    });\n\n    if (self.isAnimating()) {\n      self.stopAnimate();\n    }\n\n    var canvas = self.get('canvas');\n    canvas.animate(function (ratio) {\n      (0, _util.each)(toNodes, function (data) {\n        var node = self.findById(data.id);\n\n        if (!node || node.destroyed) {\n          return;\n        }\n\n        var originAttrs = node.get('originAttrs');\n        var model = node.get('model');\n\n        if (!originAttrs) {\n          var containerMatrix = node.getContainer().getMatrix();\n          if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          originAttrs = {\n            x: containerMatrix[6],\n            y: containerMatrix[7]\n          };\n          node.set('originAttrs', originAttrs);\n        }\n\n        if (onFrame) {\n          var attrs = onFrame(node, ratio, data, originAttrs);\n          node.set('model', Object.assign(model, attrs));\n        } else {\n          model.x = originAttrs.x + (data.x - originAttrs.x) * ratio;\n          model.y = originAttrs.y + (data.y - originAttrs.y) * ratio;\n        }\n      });\n      self.refreshPositions();\n    }, {\n      duration: animateCfg.duration,\n      easing: animateCfg.easing,\n      callback: function callback() {\n        (0, _util.each)(nodes, function (node) {\n          node.set('originAttrs', null);\n        });\n\n        if (animateCfg.callback) {\n          animateCfg.callback();\n        }\n\n        self.emit('afteranimate');\n        self.animating = false;\n      }\n    });\n  };\n  /**\n   * 当节点位置在外部发生改变时，刷新所有节点位置，重计算边\n   */\n\n\n  AbstractGraph.prototype.refreshPositions = function () {\n    var self = this;\n    self.emit('beforegraphrefreshposition');\n    var nodes = self.get('nodes');\n    var edges = self.get('edges');\n    var vedges = self.get('vedges');\n    var combos = self.get('combos');\n    var model;\n    var updatedNodes = {};\n    (0, _util.each)(nodes, function (node) {\n      model = node.getModel();\n      var originAttrs = node.get('originAttrs');\n\n      if (originAttrs && model.x === originAttrs.x && model.y === originAttrs.y) {\n        return;\n      }\n\n      var changed = node.updatePosition({\n        x: model.x,\n        y: model.y\n      });\n      updatedNodes[model.id] = changed;\n      if (model.comboId) updatedNodes[model.comboId] = updatedNodes[model.comboId] || changed;\n    });\n\n    if (combos && combos.length !== 0) {\n      self.updateCombos();\n    }\n\n    (0, _util.each)(edges, function (edge) {\n      var sourceModel = edge.getSource().getModel();\n      var target = edge.getTarget(); // 避免 target 是纯对象的情况下调用 getModel 方法\n      // 拖动生成边的时候 target 会是纯对象\n\n      if (!(0, _util.isPlainObject)(target)) {\n        var targetModel = target.getModel();\n\n        if (updatedNodes[sourceModel.id] || updatedNodes[targetModel.id] || edge.getModel().isComboEdge) {\n          edge.refresh();\n        }\n      }\n    });\n    (0, _util.each)(vedges, function (vedge) {\n      vedge.refresh();\n    });\n    self.emit('aftergraphrefreshposition');\n    self.autoPaint();\n  };\n\n  AbstractGraph.prototype.stopAnimate = function () {\n    this.get('canvas').stopAnimate();\n  };\n\n  AbstractGraph.prototype.isAnimating = function () {\n    return this.animating;\n  };\n  /**\n   * 获取当前视口伸缩比例\n   * @return {number} 比例\n   */\n\n\n  AbstractGraph.prototype.getZoom = function () {\n    var matrix = this.get('group').getMatrix();\n    return matrix ? matrix[0] : 1;\n  };\n  /**\n   * 获取当前的行为模式\n   * @return {string} 当前行为模式\n   */\n\n\n  AbstractGraph.prototype.getCurrentMode = function () {\n    var modeController = this.get('modeController');\n    return modeController.getMode();\n  };\n  /**\n   * 切换行为模式\n   * @param {string} mode 指定模式\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.setMode = function (mode) {\n    var modeController = this.get('modeController');\n    modeController.setMode(mode);\n    return this;\n  };\n  /**\n   * 清除画布元素\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.clear = function (avoidEmit) {\n    if (avoidEmit === void 0) {\n      avoidEmit = false;\n    }\n\n    var canvas = this.get('canvas');\n    canvas.clear();\n    this.initGroups(); // 清空画布时同时清除数据\n\n    this.set({\n      itemMap: {},\n      nodes: [],\n      edges: [],\n      groups: [],\n      combos: [],\n      comboTrees: []\n    });\n    if (!avoidEmit) this.emit('afterrender');\n    return this;\n  };\n  /**\n   * 更换布局配置项\n   * @param {object} cfg 新布局配置项\n   * 若 cfg 含有 type 字段或为 String 类型，且与现有布局方法不同，则更换布局\n   * 若 cfg 不包括 type ，则保持原有布局方法，仅更新布局配置项\n   */\n\n\n  AbstractGraph.prototype.updateLayout = function (cfg) {\n    var layoutController = this.get('layoutController');\n\n    if ((0, _util.isString)(cfg)) {\n      cfg = {\n        type: cfg\n      };\n    }\n\n    var oriLayoutCfg = this.get('layout');\n    var layoutCfg = {};\n    Object.assign(layoutCfg, oriLayoutCfg, cfg);\n    this.set('layout', layoutCfg);\n\n    if (layoutController.isLayoutTypeSame(layoutCfg) && layoutCfg.gpuEnabled === oriLayoutCfg.gpuEnabled) {\n      // no type or same type, or switch the gpu and cpu, update layout\n      layoutController.updateLayoutCfg(layoutCfg);\n    } else {\n      // has different type, change layout\n      layoutController.changeLayout(layoutCfg);\n    }\n  };\n  /**\n   * 销毁布局，changeData 时不会再使用原来的布局方法对新数据进行布局\n   */\n\n\n  AbstractGraph.prototype.destroyLayout = function () {\n    var layoutController = this.get('layoutController');\n    layoutController.destroyLayout();\n  };\n  /**\n   * 重新以当前示例中配置的属性进行一次布局\n   */\n\n\n  AbstractGraph.prototype.layout = function () {\n    var layoutController = this.get('layoutController');\n    var layoutCfg = this.get('layout');\n    if (!layoutCfg || !layoutController) return;\n\n    if (layoutCfg.workerEnabled) {\n      // 如果使用web worker布局\n      layoutController.layout();\n      return;\n    }\n\n    if (layoutController.layoutMethod) {\n      layoutController.relayout(true);\n    } else {\n      layoutController.layout();\n    }\n  };\n  /**\n   * 收起指定的 combo\n   * @param {string | ICombo} combo combo ID 或 combo item\n   */\n\n\n  AbstractGraph.prototype.collapseCombo = function (combo) {\n    var _this = this;\n\n    if ((0, _util.isString)(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo) {\n      console.warn('The combo to be collapsed does not exist!');\n      return;\n    }\n\n    this.emit('beforecollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n    var comboModel = combo.getModel();\n    var itemController = this.get('itemController');\n    itemController.collapseCombo(combo);\n    comboModel.collapsed = true; // add virtual edges\n\n    var edges = this.getEdges().concat(this.get('vedges')); // find all the descendant nodes and combos\n\n    var cnodes = [];\n    var ccombos = [];\n    var comboTrees = this.get('comboTrees');\n    var found = false;\n    (comboTrees || []).forEach(function (ctree) {\n      if (found) return; // if the combo is found, terminate the forEach\n\n      (0, _graphic.traverseTree)(ctree, function (subTree) {\n        // if the combo is found and it is traversing the other branches, terminate\n        if (found && subTree.depth <= comboModel.depth) return false; // if the combo is found\n\n        if (comboModel.id === subTree.id) found = true;\n\n        if (found) {\n          // if the combo is found, concat the descendant nodes and combos\n          var item = _this.findById(subTree.id);\n\n          if (item && item.getType && item.getType() === 'combo') {\n            cnodes = cnodes.concat(item.getNodes());\n            ccombos = ccombos.concat(item.getCombos());\n          }\n        }\n\n        return true;\n      });\n    });\n    var edgeWeightMap = {};\n    var addedVEdges = [];\n    edges.forEach(function (edge) {\n      if (edge.isVisible() && !edge.getModel().isVEdge) return;\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if ((cnodes.includes(source) || ccombos.includes(source)) && !cnodes.includes(target) && !ccombos.includes(target) || source.getModel().id === comboModel.id) {\n        var edgeModel = edge.getModel();\n\n        if (edgeModel.isVEdge) {\n          _this.removeItem(edge, false);\n\n          return;\n        }\n\n        var targetModel = target.getModel();\n\n        while (!target.isVisible()) {\n          target = _this.findById(targetModel.parentId || targetModel.comboId);\n          if (!target || !targetModel.parentId && !targetModel.comboId) return; // all the ancestors are hidden, then ignore the edge\n\n          targetModel = target.getModel();\n        }\n\n        var targetId = targetModel.id;\n\n        if (edgeWeightMap[comboModel.id + \"-\" + targetId]) {\n          edgeWeightMap[comboModel.id + \"-\" + targetId] += edgeModel.size || 1;\n          return;\n        } // the source is in the combo, the target is not\n\n\n        var vedge = _this.addItem('vedge', {\n          source: comboModel.id,\n          target: targetId,\n          isVEdge: true\n        }, false);\n\n        edgeWeightMap[comboModel.id + \"-\" + targetId] = edgeModel.size || 1;\n        addedVEdges.push(vedge);\n      } else if (!cnodes.includes(source) && !ccombos.includes(source) && (cnodes.includes(target) || ccombos.includes(target)) || target.getModel().id === comboModel.id) {\n        var edgeModel = edge.getModel();\n\n        if (edgeModel.isVEdge) {\n          _this.removeItem(edge, false);\n\n          return;\n        }\n\n        var sourceModel = source.getModel();\n\n        while (!source.isVisible()) {\n          source = _this.findById(sourceModel.parentId || sourceModel.comboId);\n          if (!source || !sourceModel.parentId && !sourceModel.comboId) return; // all the ancestors are hidden, then ignore the edge\n\n          sourceModel = source.getModel();\n        }\n\n        var sourceId = sourceModel.id;\n\n        if (edgeWeightMap[sourceId + \"-\" + comboModel.id]) {\n          edgeWeightMap[sourceId + \"-\" + comboModel.id] += edgeModel.size || 1;\n          return;\n        } // the target is in the combo, the source is not\n\n\n        var vedge = _this.addItem('vedge', {\n          target: comboModel.id,\n          source: sourceId,\n          isVEdge: true\n        }, false);\n\n        edgeWeightMap[sourceId + \"-\" + comboModel.id] = edgeModel.size || 1;\n        addedVEdges.push(vedge);\n      }\n    }); // update the width of the virtual edges, which is the sum of merged actual edges\n    // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n\n    addedVEdges.forEach(function (vedge) {\n      var vedgeModel = vedge.getModel();\n\n      _this.updateItem(vedge, {\n        size: edgeWeightMap[vedgeModel.source + \"-\" + vedgeModel.target]\n      }, false);\n    });\n    this.emit('aftercollapseexpandcombo', {\n      action: 'collapse',\n      item: combo\n    });\n  };\n  /**\n   * 展开指定的 combo\n   * @param {string | ICombo} combo combo ID 或 combo item\n   */\n\n\n  AbstractGraph.prototype.expandCombo = function (combo) {\n    var _this = this;\n\n    if ((0, _util.isString)(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo || combo.getType && combo.getType() !== 'combo') {\n      console.warn('The combo to be collapsed does not exist!');\n      return;\n    }\n\n    this.emit('beforecollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n    var comboModel = combo.getModel();\n    var itemController = this.get('itemController');\n    itemController.expandCombo(combo);\n    comboModel.collapsed = false; // add virtual edges\n\n    var edges = this.getEdges().concat(this.get('vedges')); // find all the descendant nodes and combos\n\n    var cnodes = [];\n    var ccombos = [];\n    var comboTrees = this.get('comboTrees');\n    var found = false;\n    (comboTrees || []).forEach(function (ctree) {\n      if (found) return; // if the combo is found, terminate\n\n      (0, _graphic.traverseTree)(ctree, function (subTree) {\n        // if the combo is found and it is traversing the other branches, terminate\n        if (found && subTree.depth <= comboModel.depth) return false;\n        if (comboModel.id === subTree.id) found = true;\n\n        if (found) {\n          var item = _this.findById(subTree.id);\n\n          if (item && item.getType && item.getType() === 'combo') {\n            cnodes = cnodes.concat(item.getNodes());\n            ccombos = ccombos.concat(item.getCombos());\n          }\n        }\n\n        return true;\n      });\n    });\n    var edgeWeightMap = {};\n    var addedVEdges = {};\n    edges.forEach(function (edge) {\n      if (edge.isVisible() && !edge.getModel().isVEdge) return;\n      var source = edge.getSource();\n      var target = edge.getTarget();\n      var sourceId = source.get('id');\n      var targetId = target.get('id');\n\n      if ((cnodes.includes(source) || ccombos.includes(source)) && !cnodes.includes(target) && !ccombos.includes(target) || sourceId === comboModel.id) {\n        // the source is in the combo, the target is not\n        // ignore the virtual edges\n        if (edge.getModel().isVEdge) {\n          _this.removeItem(edge, false);\n\n          return;\n        }\n\n        var targetModel = target.getModel(); // find the nearest visible ancestor\n\n        while (!target.isVisible()) {\n          target = _this.findById(targetModel.comboId || targetModel.parentId);\n\n          if (!target || !targetModel.parentId && !targetModel.comboId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          targetModel = target.getModel();\n        }\n\n        targetId = targetModel.id;\n        var sourceModel = source.getModel(); // find the nearest visible ancestor\n\n        while (!source.isVisible()) {\n          source = _this.findById(sourceModel.comboId || sourceModel.parentId);\n\n          if (!source || !sourceModel.parentId && !sourceModel.comboId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          if (sourceModel.comboId === comboModel.id || sourceModel.parentId === comboModel.id) {\n            break; // if the next ancestor is the combo, break the while\n          }\n\n          sourceModel = source.getModel();\n        }\n\n        sourceId = sourceModel.id;\n\n        if (targetId) {\n          var vedgeId = sourceId + \"-\" + targetId; // update the width of the virtual edges, which is the sum of merged actual edges\n          // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n\n          if (edgeWeightMap[vedgeId]) {\n            edgeWeightMap[vedgeId] += edge.getModel().size || 1;\n\n            _this.updateItem(addedVEdges[vedgeId], {\n              size: edgeWeightMap[vedgeId]\n            }, false);\n\n            return;\n          }\n\n          var vedge = _this.addItem('vedge', {\n            source: sourceId,\n            target: targetId,\n            isVEdge: true\n          }, false);\n\n          edgeWeightMap[vedgeId] = edge.getModel().size || 1;\n          addedVEdges[vedgeId] = vedge;\n        }\n      } else if (!cnodes.includes(source) && !ccombos.includes(source) && (cnodes.includes(target) || ccombos.includes(target)) || targetId === comboModel.id) {\n        // the target is in the combo, the source is not\n        // ignore the virtual edges\n        if (edge.getModel().isVEdge) {\n          _this.removeItem(edge, false);\n\n          return;\n        }\n\n        var sourceModel = source.getModel(); // find the nearest visible ancestor\n\n        while (!source.isVisible()) {\n          source = _this.findById(sourceModel.comboId || sourceModel.parentId);\n\n          if (!source || !sourceModel.parentId && !sourceModel.comboId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          sourceModel = source.getModel();\n        }\n\n        sourceId = sourceModel.id;\n        var targetModel = target.getModel(); // find the nearest visible ancestor\n\n        while (!target.isVisible()) {\n          target = _this.findById(targetModel.comboId || targetModel.parentId);\n\n          if (!target || !targetModel.parentId && !targetModel.comboId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          if (targetModel.comboId === comboModel.id || targetModel.parentId === comboModel.id) {\n            break; // if the next ancestor is the combo, break the while\n          }\n\n          targetModel = target.getModel();\n        }\n\n        targetId = targetModel.id;\n\n        if (sourceId) {\n          var vedgeId = sourceId + \"-\" + targetId; // update the width of the virtual edges, which is the sum of merged actual edges\n          // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n\n          if (edgeWeightMap[vedgeId]) {\n            edgeWeightMap[vedgeId] += edge.getModel().size || 1;\n\n            _this.updateItem(addedVEdges[vedgeId], {\n              size: edgeWeightMap[vedgeId]\n            }, false);\n\n            return;\n          }\n\n          var vedge = _this.addItem('vedge', {\n            target: targetId,\n            source: sourceId,\n            isVEdge: true\n          }, false);\n\n          edgeWeightMap[vedgeId] = edge.getModel().size || 1;\n          addedVEdges[vedgeId] = vedge;\n        }\n      } else if ((cnodes.includes(source) || ccombos.includes(source)) && (cnodes.includes(target) || ccombos.includes(target))) {\n        // both source and target are in the combo, if the target and source are both visible, show the edge\n        if (source.isVisible() && target.isVisible()) {\n          edge.show();\n        }\n      }\n    });\n    this.emit('aftercollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n  };\n\n  AbstractGraph.prototype.collapseExpandCombo = function (combo) {\n    if ((0, _util.isString)(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo || combo.getType && combo.getType() !== 'combo') return;\n    var comboModel = combo.getModel(); // if one ancestor combo of the combo is collapsed, it should not be collapsed or expanded\n\n    var parentItem = this.findById(comboModel.parentId);\n\n    while (parentItem) {\n      var parentModel = parentItem.getModel();\n\n      if (parentModel.collapsed) {\n        console.warn(\"Fail to expand the combo since it's ancestor combo is collapsed.\");\n        parentItem = undefined;\n        return;\n      }\n\n      parentItem = this.findById(parentModel.parentId);\n    }\n\n    var collapsed = comboModel.collapsed; // 该群组已经处于收起状态，需要展开\n\n    if (collapsed) {\n      this.expandCombo(combo);\n    } else {\n      this.collapseCombo(combo);\n    }\n\n    this.updateCombo(combo);\n  };\n  /**\n   * 根据 comboTree 结构整理 Combo 相关的图形绘制层级，包括 Combo 本身、节点、边\n   * @param {GraphData} data 数据\n   */\n\n\n  AbstractGraph.prototype.sortCombos = function () {\n    var _this = this;\n\n    var comboSorted = this.get('comboSorted');\n    if (comboSorted) return;\n    this.set('comboSorted', true);\n    var depthMap = [];\n    var dataDepthMap = {};\n    var comboTrees = this.get('comboTrees');\n    (comboTrees || []).forEach(function (cTree) {\n      (0, _graphic.traverseTree)(cTree, function (child) {\n        if (depthMap[child.depth]) depthMap[child.depth].push(child.id);else depthMap[child.depth] = [child.id];\n        dataDepthMap[child.id] = child.depth;\n        return true;\n      });\n    });\n    var edges = this.getEdges().concat(this.get('vedges'));\n    (edges || []).forEach(function (edgeItem) {\n      var edge = edgeItem.getModel();\n      var sourceDepth = dataDepthMap[edge.source] || 0;\n      var targetDepth = dataDepthMap[edge.target] || 0;\n      var depth = Math.max(sourceDepth, targetDepth);\n      if (depthMap[depth]) depthMap[depth].push(edge.id);else depthMap[depth] = [edge.id];\n    });\n    depthMap.forEach(function (array) {\n      if (!array || !array.length) return;\n\n      for (var i = array.length - 1; i >= 0; i--) {\n        var item = _this.findById(array[i]);\n\n        if (item) item.toFront();\n      }\n    });\n  };\n  /**\n   * 获取节点所有的邻居节点\n   *\n   * @param {(string | INode)} node 节点 ID 或实例\n   * @returns {INode[]}\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getNeighbors = function (node, type) {\n    var item = node;\n\n    if ((0, _util.isString)(node)) {\n      item = this.findById(node);\n    }\n\n    return item.getNeighbors(type);\n  };\n  /**\n   * 获取 node 的度数\n   *\n   * @param {(string | INode)} node 节点 ID 或实例\n   * @param {('in' | 'out' | 'total' | 'all' | undefined)} 度数类型，in 入度，out 出度，total 总度数，all 返回三种类型度数的对象\n   * @returns {Number | Object} 该节点的度数\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getNodeDegree = function (node, type, refresh) {\n    if (type === void 0) {\n      type = undefined;\n    }\n\n    if (refresh === void 0) {\n      refresh = false;\n    }\n\n    var item = node;\n\n    if ((0, _util.isString)(node)) {\n      item = this.findById(node);\n    }\n\n    var degrees = this.get('degrees');\n\n    if (!degrees || refresh) {\n      degrees = (0, _algorithm.getDegree)(this.save());\n      this.set('degrees', degrees);\n    }\n\n    var nodeDegrees = degrees[item.getID()];\n    var res = 0; // 如果是通过 addItem 后面新增加的节点，此时它的所有度数都为 0\n\n    if (!nodeDegrees) {\n      return 0;\n    }\n\n    switch (type) {\n      case 'in':\n        res = nodeDegrees.inDegree;\n        break;\n\n      case 'out':\n        res = nodeDegrees.outDegree;\n        break;\n\n      case 'all':\n        res = nodeDegrees;\n        break;\n\n      default:\n        res = nodeDegrees.degree;\n        break;\n    }\n\n    return res;\n  };\n\n  AbstractGraph.prototype.getUndoStack = function () {\n    return this.undoStack;\n  };\n\n  AbstractGraph.prototype.getRedoStack = function () {\n    return this.redoStack;\n  };\n  /**\n   * 获取 undo 和 redo 栈的数据\n   */\n\n\n  AbstractGraph.prototype.getStackData = function () {\n    if (!this.get('enabledStack')) {\n      return null;\n    }\n\n    return {\n      undoStack: this.undoStack.toArray(),\n      redoStack: this.redoStack.toArray()\n    };\n  };\n  /**\n   * 清空 undo stack & redo stack\n   */\n\n\n  AbstractGraph.prototype.clearStack = function () {\n    if (this.get('enabledStack')) {\n      this.undoStack.clear();\n      this.redoStack.clear();\n    }\n  };\n  /**\n   * 将操作类型和操作数据入栈\n   * @param action 操作类型\n   * @param data 入栈的数据\n   * @param stackType 栈的类型\n   */\n\n\n  AbstractGraph.prototype.pushStack = function (action, data, stackType) {\n    if (action === void 0) {\n      action = 'update';\n    }\n\n    if (stackType === void 0) {\n      stackType = 'undo';\n    }\n\n    if (!this.get('enabledStack')) {\n      console.warn('请先启用 undo & redo 功能，在实例化 Graph 时候配置 enabledStack: true !');\n      return;\n    }\n\n    var stackData = data ? (0, _util.clone)(data) : {\n      before: {},\n      after: (0, _util.clone)(this.save())\n    };\n\n    if (stackType === 'redo') {\n      this.redoStack.push({\n        action: action,\n        data: stackData\n      });\n    } else {\n      this.undoStack.push({\n        action: action,\n        data: stackData\n      });\n    }\n\n    this.emit('stackchange', {\n      undoStack: this.undoStack,\n      redoStack: this.redoStack\n    });\n  };\n  /**\n   * 获取邻接矩阵\n   *\n   * @param {boolean} cache 是否使用缓存的\n   * @param {boolean} directed 是否是有向图，默认取 graph.directed\n   * @returns {Matrix} 邻接矩阵\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getAdjMatrix = function (cache, directed) {\n    if (cache === void 0) {\n      cache = true;\n    }\n\n    if (directed === undefined) directed = this.get('directed');\n    var currentAdjMatrix = this.get('adjMatrix');\n\n    if (!currentAdjMatrix || !cache) {\n      currentAdjMatrix = (0, _algorithm.getAdjMatrix)(this.save(), directed);\n      this.set('adjMatrix', currentAdjMatrix);\n    }\n\n    return currentAdjMatrix;\n  };\n  /**\n   * 获取最短路径矩阵\n   *\n   * @param {boolean} cache 是否使用缓存的\n   * @param {boolean} directed 是否是有向图，默认取 graph.directed\n   * @returns {Matrix} 最短路径矩阵\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getShortestPathMatrix = function (cache, directed) {\n    if (cache === void 0) {\n      cache = true;\n    }\n\n    if (directed === undefined) directed = this.get('directed');\n    var currentAdjMatrix = this.get('adjMatrix');\n    var currentShourtestPathMatrix = this.get('shortestPathMatrix');\n\n    if (!currentAdjMatrix || !cache) {\n      currentAdjMatrix = (0, _algorithm.getAdjMatrix)(this.save(), directed);\n      this.set('adjMatrix', currentAdjMatrix);\n    }\n\n    if (!currentShourtestPathMatrix || !cache) {\n      currentShourtestPathMatrix = (0, _algorithm.floydWarshall)(this.save(), directed);\n      this.set('shortestPathMatrix', currentShourtestPathMatrix);\n    }\n\n    return currentShourtestPathMatrix;\n  };\n  /**\n   * 重新定义监听函数，复写参数类型\n   */\n\n\n  AbstractGraph.prototype.on = function (eventName, callback, once) {\n    return _super.prototype.on.call(this, eventName, callback, once);\n  };\n  /**\n   * 销毁画布\n   */\n\n\n  AbstractGraph.prototype.destroy = function () {\n    this.clear(); // 清空栈数据\n\n    this.clearStack();\n    this.get('itemController').destroy();\n    this.get('modeController').destroy();\n    this.get('viewController').destroy();\n    this.get('stateController').destroy();\n    this.get('canvas').destroy();\n    this.cfg = null;\n    this.destroyed = true;\n    this.redoStack = null;\n    this.undoStack = null;\n  };\n  /**\n   * 创建凸包或凹包轮廓\n   * @param cfg HullCfg 轮廓配置项\n   */\n\n\n  AbstractGraph.prototype.createHull = function (cfg) {\n    if (!cfg.members || cfg.members.length < 1) {\n      console.warn('Create hull failed! The members is empty.');\n      return;\n    }\n\n    var parent = this.get('hullGroup');\n    var hullMap = this.get('hullMap');\n\n    if (!hullMap) {\n      hullMap = {};\n      this.set('hullMap', hullMap);\n    }\n\n    if (!parent || parent.get('destroyed')) {\n      parent = this.get('group').addGroup({\n        id: 'hullGroup'\n      });\n      parent.toBack();\n      this.set('hullGroup', parent);\n    }\n\n    if (hullMap[cfg.id]) {\n      console.warn('Existed hull id.');\n      return hullMap[cfg.id];\n    }\n\n    var group = parent.addGroup({\n      id: cfg.id + \"-container\"\n    });\n    var hull = new _hull.default(this, (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {\n      group: group\n    }));\n    var hullId = hull.id;\n    hullMap[hullId] = hull;\n    return hull;\n  };\n  /**\n   * 获取当前 graph 中存在的包裹轮廓\n   * @return {[key: string]: Hull} Hull 的 map，hullId 对应的 hull 实例\n   */\n\n\n  AbstractGraph.prototype.getHulls = function () {\n    return this.get('hullMap');\n  };\n  /**\n   * 根据 hullId 获取对应的 hull\n   * @return Hull\n   */\n\n\n  AbstractGraph.prototype.getHullById = function (hullId) {\n    return this.get('hullMap')[hullId];\n  };\n\n  AbstractGraph.prototype.removeHull = function (hull) {\n    var hullInstance;\n\n    if ((0, _util.isString)(hull)) {\n      hullInstance = this.getHullById(hull);\n    } else {\n      hullInstance = hull;\n    }\n\n    var hullMap = this.get('hullMap');\n    delete hullMap[hullInstance.id];\n    hullInstance.destroy();\n  };\n\n  AbstractGraph.prototype.removeHulls = function () {\n    var hulls = this.getHulls();\n    if (!hulls || !Object.keys(hulls).length) return;\n    Object.keys(hulls).forEach(function (key) {\n      var hull = hulls[key];\n      hull.destroy();\n    });\n    this.set('hullMap', {});\n  };\n\n  return AbstractGraph;\n}(_eventEmitter.default);\n\nvar _default = AbstractGraph;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pointLineDistance = exports.pointRectSquareDist = exports.isPointsOverlap = exports.pointLineSquareDist = exports.squareDist = exports.getPointsCenter = exports.fractionToLine = exports.itemIntersectByLine = exports.getBBoxBoundLine = exports.Line = exports.isPolygonsIntersect = exports.intersectBBox = exports.isPointInPolygon = exports.getDegree = exports.rotate = exports.scale = exports.move = exports.translate = exports.getAdjMatrix = exports.floydWarshall = exports.scaleMatrix = exports.distance = exports.getCircleCenterByPoints = exports.invertMatrix = exports.applyMatrix = exports.getEllipseIntersectByPoint = exports.getCircleIntersectByPoint = exports.getRectIntersectByPoint = exports.getLineIntersect = exports.compare = void 0;\n\nvar _matrixUtil = require(\"@antv/matrix-util\");\n\nvar _util = require(\"@antv/util\");\n\nvar transform = _matrixUtil.ext.transform;\n/**\n * 对比对象，用于对象数组排序\n * @param   {string}       attributeName  排序依据的字段名称\n * @param   {number}       min    最小值\n * @param   {number}       max    最大值\n * @return  {boolean}      bool   布尔\n */\n\nvar compare = function compare(attributeName) {\n  return function (m, n) {\n    return m[attributeName] - n[attributeName];\n  };\n};\n/**\n * 是否在区间内\n * @param   {number}       value  值\n * @param   {number}       min    最小值\n * @param   {number}       max    最大值\n * @return  {boolean}      bool   布尔\n */\n\n\nexports.compare = compare;\n\nvar isBetween = function isBetween(value, min, max) {\n  return value >= min && value <= max;\n};\n/**\n * 获取两条线段的交点\n * @param  {Point}  p0 第一条线段起点\n * @param  {Point}  p1 第一条线段终点\n * @param  {Point}  p2 第二条线段起点\n * @param  {Point}  p3 第二条线段终点\n * @return {Point}  交点\n */\n\n\nvar getLineIntersect = function getLineIntersect(p0, p1, p2, p3) {\n  var tolerance = 0.0001;\n  var E = {\n    x: p2.x - p0.x,\n    y: p2.y - p0.y\n  };\n  var D0 = {\n    x: p1.x - p0.x,\n    y: p1.y - p0.y\n  };\n  var D1 = {\n    x: p3.x - p2.x,\n    y: p3.y - p2.y\n  };\n  var kross = D0.x * D1.y - D0.y * D1.x;\n  var sqrKross = kross * kross;\n  var invertKross = 1 / kross;\n  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;\n  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;\n\n  if (sqrKross > tolerance * sqrLen0 * sqrLen1) {\n    var s = (E.x * D1.y - E.y * D1.x) * invertKross;\n    var t = (E.x * D0.y - E.y * D0.x) * invertKross;\n    if (!isBetween(s, 0, 1) || !isBetween(t, 0, 1)) return null;\n    return {\n      x: p0.x + s * D0.x,\n      y: p0.y + s * D0.y\n    };\n  }\n\n  return null;\n};\n/**\n * point and rectangular intersection point\n * @param  {IRect} rect  rect\n * @param  {Point} point point\n * @return {PointPoint} rst;\n */\n\n\nexports.getLineIntersect = getLineIntersect;\n\nvar getRectIntersectByPoint = function getRectIntersectByPoint(rect, point) {\n  var x = rect.x,\n      y = rect.y,\n      width = rect.width,\n      height = rect.height;\n  var cx = x + width / 2;\n  var cy = y + height / 2;\n  var points = [];\n  var center = {\n    x: cx,\n    y: cy\n  };\n  points.push({\n    x: x,\n    y: y\n  });\n  points.push({\n    x: x + width,\n    y: y\n  });\n  points.push({\n    x: x + width,\n    y: y + height\n  });\n  points.push({\n    x: x,\n    y: y + height\n  });\n  points.push({\n    x: x,\n    y: y\n  });\n  var rst = null;\n\n  for (var i = 1; i < points.length; i++) {\n    rst = getLineIntersect(points[i - 1], points[i], center, point);\n\n    if (rst) {\n      break;\n    }\n  }\n\n  return rst;\n};\n/**\n * get point and circle inIntersect\n * @param {ICircle} circle 圆点，x,y,r\n * @param {Point} point 点 x,y\n * @return {Point} applied point\n */\n\n\nexports.getRectIntersectByPoint = getRectIntersectByPoint;\n\nvar getCircleIntersectByPoint = function getCircleIntersectByPoint(circle, point) {\n  var cx = circle.x,\n      cy = circle.y,\n      r = circle.r;\n  var x = point.x,\n      y = point.y;\n  var dx = x - cx;\n  var dy = y - cy;\n  var d = Math.sqrt(dx * dx + dy * dy);\n\n  if (d < r) {\n    return null;\n  }\n\n  var signX = Math.sign(dx);\n  var signY = Math.sign(dy);\n  var angle = Math.atan(dy / dx);\n  return {\n    x: cx + Math.abs(r * Math.cos(angle)) * signX,\n    y: cy + Math.abs(r * Math.sin(angle)) * signY\n  };\n};\n/**\n * get point and ellipse inIntersect\n * @param {Object} ellipse 椭圆 x,y,rx,ry\n * @param {Object} point 点 x,y\n * @return {object} applied point\n */\n\n\nexports.getCircleIntersectByPoint = getCircleIntersectByPoint;\n\nvar getEllipseIntersectByPoint = function getEllipseIntersectByPoint(ellipse, point) {\n  var a = ellipse.rx;\n  var b = ellipse.ry;\n  var cx = ellipse.x;\n  var cy = ellipse.y;\n  var dx = point.x - cx;\n  var dy = point.y - cy; // 直接通过 x,y 求夹角，求出来的范围是 -PI, PI\n\n  var angle = Math.atan2(dy / b, dx / a);\n\n  if (angle < 0) {\n    angle += 2 * Math.PI; // 转换到 0，2PI\n  }\n\n  return {\n    x: cx + a * Math.cos(angle),\n    y: cy + b * Math.sin(angle)\n  };\n};\n/**\n * coordinate matrix transformation\n * @param  {number} point   coordinate\n * @param  {Matrix} matrix  matrix\n * @param  {number} tag     could be 0 or 1\n * @return {Point} transformed point\n */\n\n\nexports.getEllipseIntersectByPoint = getEllipseIntersectByPoint;\n\nvar applyMatrix = function applyMatrix(point, matrix, tag) {\n  if (tag === void 0) {\n    tag = 1;\n  }\n\n  var vector = [point.x, point.y, tag];\n\n  if (!matrix || isNaN(matrix[0])) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  _matrixUtil.vec3.transformMat3(vector, vector, matrix);\n\n  return {\n    x: vector[0],\n    y: vector[1]\n  };\n};\n/**\n * coordinate matrix invert transformation\n * @param  {number} point   coordinate\n * @param  {number} matrix  matrix\n * @param  {number} tag     could be 0 or 1\n * @return {object} transformed point\n */\n\n\nexports.applyMatrix = applyMatrix;\n\nvar invertMatrix = function invertMatrix(point, matrix, tag) {\n  if (tag === void 0) {\n    tag = 1;\n  }\n\n  if (!matrix || isNaN(matrix[0])) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var inversedMatrix = _matrixUtil.mat3.invert([1, 0, 0, 0, 1, 0, 0, 0, 1], matrix);\n\n  if (!inversedMatrix) {\n    inversedMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var vector = [point.x, point.y, tag];\n\n  _matrixUtil.vec3.transformMat3(vector, vector, inversedMatrix);\n\n  return {\n    x: vector[0],\n    y: vector[1]\n  };\n};\n/**\n *\n * @param p1 First coordinate\n * @param p2 second coordinate\n * @param p3 three coordinate\n */\n\n\nexports.invertMatrix = invertMatrix;\n\nvar getCircleCenterByPoints = function getCircleCenterByPoints(p1, p2, p3) {\n  var a = p1.x - p2.x;\n  var b = p1.y - p2.y;\n  var c = p1.x - p3.x;\n  var d = p1.y - p3.y;\n  var e = (p1.x * p1.x - p2.x * p2.x - p2.y * p2.y + p1.y * p1.y) / 2;\n  var f = (p1.x * p1.x - p3.x * p3.x - p3.y * p3.y + p1.y * p1.y) / 2;\n  var denominator = b * c - a * d;\n  return {\n    x: -(d * e - b * f) / denominator,\n    y: -(a * f - c * e) / denominator\n  };\n};\n/**\n * get distance by two points\n * @param p1 first point\n * @param p2 second point\n */\n\n\nexports.getCircleCenterByPoints = getCircleCenterByPoints;\n\nvar distance = function distance(p1, p2) {\n  var vx = p1.x - p2.x;\n  var vy = p1.y - p2.y;\n  return Math.sqrt(vx * vx + vy * vy);\n};\n/**\n * scale matrix\n * @param matrix [ [], [], [] ]\n * @param ratio\n */\n\n\nexports.distance = distance;\n\nvar scaleMatrix = function scaleMatrix(matrix, ratio) {\n  var result = [];\n  matrix.forEach(function (row) {\n    var newRow = [];\n    row.forEach(function (v) {\n      newRow.push(v * ratio);\n    });\n    result.push(newRow);\n  });\n  return result;\n};\n/**\n * Floyd Warshall algorithm for shortest path distances matrix\n * @param  {array} adjMatrix   adjacency matrix\n * @return {array} distances   shortest path distances matrix\n */\n\n\nexports.scaleMatrix = scaleMatrix;\n\nvar floydWarshall = function floydWarshall(adjMatrix) {\n  // initialize\n  var dist = [];\n  var size = adjMatrix.length;\n\n  for (var i = 0; i < size; i += 1) {\n    dist[i] = [];\n\n    for (var j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  } // floyd\n\n\n  for (var k = 0; k < size; k += 1) {\n    for (var i = 0; i < size; i += 1) {\n      for (var j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n\n  return dist;\n};\n/**\n * get adjacency matrix\n * @param data graph data\n * @param directed whether it's a directed graph\n */\n\n\nexports.floydWarshall = floydWarshall;\n\nvar getAdjMatrix = function getAdjMatrix(data, directed) {\n  var nodes = data.nodes,\n      edges = data.edges;\n  var matrix = []; // map node with index in data.nodes\n\n  var nodeMap = {};\n\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n\n  if (nodes) {\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = i;\n      var row = [];\n      matrix.push(row);\n    });\n  }\n\n  if (edges) {\n    edges.forEach(function (e) {\n      var source = e.source,\n          target = e.target;\n      var sIndex = nodeMap[source];\n      var tIndex = nodeMap[target];\n      matrix[sIndex][tIndex] = 1;\n\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n\n  return matrix;\n};\n/**\n * 平移group\n * @param group Group 实例\n * @param vec 移动向量\n */\n\n\nexports.getAdjMatrix = getAdjMatrix;\n\nvar translate = function translate(group, vec) {\n  group.translate(vec.x, vec.y);\n};\n/**\n * 移动到指定坐标点\n * @param group Group 实例\n * @param point 移动到的坐标点\n */\n\n\nexports.translate = translate;\n\nvar move = function move(group, point) {\n  var matrix = group.getMatrix();\n\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var bbox = group.getCanvasBBox();\n  var vx = point.x - bbox.minX;\n  var vy = point.y - bbox.minY;\n  var movedMatrix = transform(matrix, [['t', vx, vy]]);\n  group.setMatrix(movedMatrix);\n};\n/**\n * 缩放 group\n * @param group Group 实例\n * @param point 在x 和 y 方向上的缩放比例\n */\n\n\nexports.move = move;\n\nvar scale = function scale(group, ratio) {\n  var matrix = group.getMatrix();\n\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var scaleXY = ratio;\n\n  if (!(0, _util.isArray)(ratio)) {\n    scaleXY = [ratio, ratio];\n  }\n\n  if ((0, _util.isArray)(ratio) && ratio.length === 1) {\n    scaleXY = [ratio[0], ratio[0]];\n  }\n\n  matrix = transform(matrix, [['s', scaleXY[0], scaleXY[1]]]);\n  group.setMatrix(matrix);\n};\n/**\n *\n * @param group Group 实例\n * @param ratio 选择角度\n */\n\n\nexports.scale = scale;\n\nvar rotate = function rotate(group, angle) {\n  var matrix = group.getMatrix();\n\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  matrix = transform(matrix, [['r', angle]]);\n  group.setMatrix(matrix);\n};\n\nexports.rotate = rotate;\n\nvar getDegree = function getDegree(n, nodeIdxMap, edges) {\n  var degrees = [];\n\n  for (var i = 0; i < n; i++) {\n    degrees[i] = 0;\n  }\n\n  edges.forEach(function (e) {\n    if (e.source) {\n      degrees[nodeIdxMap[e.source]] += 1;\n    }\n\n    if (e.target) {\n      degrees[nodeIdxMap[e.target]] += 1;\n    }\n  });\n  return degrees;\n}; // 判断点Q是否在p1和p2的线段上\n\n\nexports.getDegree = getDegree;\n\nfunction onSegment(p1, p2, q) {\n  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * 判断点P在多边形内-射线法. Borrow from https://github.com/antvis/util/blob/master/packages/path-util/src/point-in-polygon.ts\n * @param points\n * @param x\n * @param y\n */\n\n\nvar isPointInPolygon = function isPointInPolygon(points, x, y) {\n  var isHit = false;\n  var n = points.length; // 判断两个double在eps精度下的大小关系\n\n  var tolerance = 1e-6;\n\n  function dcmp(xValue) {\n    if (Math.abs(xValue) < tolerance) {\n      return 0;\n    }\n\n    return xValue < 0 ? -1 : 1;\n  }\n\n  if (n <= 2) {\n    // svg 中点小于 3 个时，不显示，也无法被拾取\n    return false;\n  }\n\n  for (var i = 0; i < n; i++) {\n    var p1 = points[i];\n    var p2 = points[(i + 1) % n];\n\n    if (onSegment(p1, p2, [x, y])) {\n      // 点在多边形一条边上\n      return true;\n    } // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\n    // 后一个判断被测点 在 射线与边交点 的左边\n\n\n    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {\n      isHit = !isHit;\n    }\n  }\n\n  return isHit;\n}; // 判断两个BBox是否相交\n\n\nexports.isPointInPolygon = isPointInPolygon;\n\nvar intersectBBox = function intersectBBox(box1, box2) {\n  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n};\n\nexports.intersectBBox = intersectBBox;\n\nvar lineIntersectPolygon = function lineIntersectPolygon(lines, line) {\n  var isIntersect = false;\n  (0, _util.each)(lines, function (l) {\n    if (getLineIntersect(l.from, l.to, line.from, line.to)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n};\n/**\n * 判断两个polygon是否相交。\n * borrow from @antv/path-util\n * @param points1 polygon1的顶点数组\n * @param points2 polygon2的顶点数组\n */\n\n\nvar isPolygonsIntersect = function isPolygonsIntersect(points1, points2) {\n  var getBBox = function getBBox(points) {\n    var xArr = points.map(function (p) {\n      return p[0];\n    });\n    var yArr = points.map(function (p) {\n      return p[1];\n    });\n    return {\n      minX: Math.min.apply(null, xArr),\n      maxX: Math.max.apply(null, xArr),\n      minY: Math.min.apply(null, yArr),\n      maxY: Math.max.apply(null, yArr)\n    };\n  };\n\n  var parseToLines = function parseToLines(points) {\n    var lines = [];\n    var count = points.length;\n\n    for (var i = 0; i < count - 1; i++) {\n      var point = points[i];\n      var next = points[i + 1];\n      lines.push({\n        from: {\n          x: point[0],\n          y: point[1]\n        },\n        to: {\n          x: next[0],\n          y: next[1]\n        }\n      });\n    }\n\n    if (lines.length > 1) {\n      var first = points[0];\n      var last = points[count - 1];\n      lines.push({\n        from: {\n          x: last[0],\n          y: last[1]\n        },\n        to: {\n          x: first[0],\n          y: first[1]\n        }\n      });\n    }\n\n    return lines;\n  }; // 空数组，或者一个点返回 false\n\n\n  if (points1.length < 2 || points2.length < 2) {\n    return false;\n  }\n\n  var bbox1 = getBBox(points1);\n  var bbox2 = getBBox(points2); // 判定包围盒是否相交，比判定点是否在多边形内要快的多，可以筛选掉大多数情况\n\n  if (!intersectBBox(bbox1, bbox2)) {\n    return false;\n  }\n\n  var isIn = false; // 判定点是否在多边形内部，一旦有一个点在另一个多边形内，则返回\n\n  (0, _util.each)(points2, function (point) {\n    if (isPointInPolygon(points1, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n\n  if (isIn) {\n    return true;\n  }\n\n  (0, _util.each)(points1, function (point) {\n    if (isPointInPolygon(points2, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n\n  if (isIn) {\n    return true;\n  }\n\n  var lines1 = parseToLines(points1);\n  var lines2 = parseToLines(points2);\n  var isIntersect = false;\n  (0, _util.each)(lines2, function (line) {\n    if (lineIntersectPolygon(lines1, line)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n};\n\nexports.isPolygonsIntersect = isPolygonsIntersect;\n\nvar Line =\n/** @class */\nfunction () {\n  function Line(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  Line.prototype.getBBox = function () {\n    var minX = Math.min(this.x1, this.x2);\n    var minY = Math.min(this.y1, this.y2);\n    var maxX = Math.max(this.x1, this.x2);\n    var maxY = Math.max(this.y1, this.y2);\n    var res = {\n      x: minX,\n      y: minY,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n    return res;\n  };\n\n  return Line;\n}();\n\nexports.Line = Line;\n\nvar getBBoxBoundLine = function getBBoxBoundLine(bbox, direction) {\n  var bounds = {\n    top: [bbox.minX, bbox.minY, bbox.maxX, bbox.minY],\n    left: [bbox.minX, bbox.minY, bbox.minX, bbox.maxY],\n    bottom: [bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY],\n    right: [bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY]\n  };\n  return bounds[direction];\n};\n/**\n * 计算两条线段相交时，相交点对第一条线段上的分割比例\n */\n\n\nexports.getBBoxBoundLine = getBBoxBoundLine;\n\nvar fractionAlongLineA = function fractionAlongLineA(la, lb) {\n  var uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);\n  var ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);\n  var uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);\n\n  if (uB) {\n    var ua = uaT / uB;\n    var ub = ubT / uB;\n\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n      return ua;\n    }\n  }\n\n  return Number.POSITIVE_INFINITY;\n};\n\nvar itemIntersectByLine = function itemIntersectByLine(item, line) {\n  var directions = ['top', 'left', 'bottom', 'right'];\n  var bbox = item.getBBox();\n  var countIntersections = 0;\n  var intersections = [];\n\n  for (var i = 0; i < 4; i++) {\n    var _a = getBBoxBoundLine(bbox, directions[i]),\n        x1 = _a[0],\n        y1 = _a[1],\n        x2 = _a[2],\n        y2 = _a[3];\n\n    intersections[i] = getLineIntersect({\n      x: line.x1,\n      y: line.y1\n    }, {\n      x: line.x2,\n      y: line.y2\n    }, {\n      x: x1,\n      y: y1\n    }, {\n      x: x2,\n      y: y2\n    });\n\n    if (intersections[i]) {\n      countIntersections += 1;\n    }\n  }\n\n  return [intersections, countIntersections];\n};\n\nexports.itemIntersectByLine = itemIntersectByLine;\n\nvar fractionToLine = function fractionToLine(item, line) {\n  var directions = ['top', 'left', 'bottom', 'right'];\n  var bbox = item.getBBox();\n  var minDistance = Number.POSITIVE_INFINITY;\n  var countIntersections = 0;\n\n  for (var i = 0; i < 4; i++) {\n    var _a = getBBoxBoundLine(bbox, directions[i]),\n        x1 = _a[0],\n        y1 = _a[1],\n        x2 = _a[2],\n        y2 = _a[3];\n\n    var testDistance = fractionAlongLineA(line, new Line(x1, y1, x2, y2));\n    testDistance = Math.abs(testDistance - 0.5);\n\n    if (testDistance >= 0 && testDistance <= 1) {\n      countIntersections += 1;\n      minDistance = testDistance < minDistance ? testDistance : minDistance;\n    }\n  }\n\n  if (countIntersections === 0) return -1;\n  return minDistance;\n};\n\nexports.fractionToLine = fractionToLine;\n\nvar getPointsCenter = function getPointsCenter(points) {\n  var centerX = 0;\n  var centerY = 0;\n\n  if (points.length > 0) {\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n      var point = points_1[_i];\n      centerX += point.x;\n      centerY += point.y;\n    }\n\n    centerX /= points.length;\n    centerY /= points.length;\n  }\n\n  return {\n    x: centerX,\n    y: centerY\n  };\n};\n\nexports.getPointsCenter = getPointsCenter;\n\nvar squareDist = function squareDist(a, b) {\n  return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);\n};\n\nexports.squareDist = squareDist;\n\nvar pointLineSquareDist = function pointLineSquareDist(point, line) {\n  var x1 = line.x1;\n  var y1 = line.y1;\n  var x2 = line.x2 - x1;\n  var y2 = line.y2 - y1;\n  var px = point.x - x1;\n  var py = point.y - y1;\n  var dotprod = px * x2 + py * y2;\n  var projlenSq;\n\n  if (dotprod <= 0) {\n    projlenSq = 0;\n  } else {\n    px = x2 - px;\n    py = y2 - py;\n    dotprod = px * x2 + py * y2;\n\n    if (dotprod <= 0) {\n      projlenSq = 0;\n    } else {\n      projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n    }\n  }\n\n  var lenSq = px * px + py * py - projlenSq;\n\n  if (lenSq < 0) {\n    lenSq = 0;\n  }\n\n  return lenSq;\n};\n\nexports.pointLineSquareDist = pointLineSquareDist;\n\nvar isPointsOverlap = function isPointsOverlap(p1, p2, e) {\n  if (e === void 0) {\n    e = 1e-3;\n  }\n\n  return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) < Math.pow(e, 2);\n};\n/**\n * 点到矩形的距离的平方：矩形内部点视作距离为0，外部的点若投影落在矩形边上则为点到矩形边的最近的垂直距离，否则为点到矩形顶点的距离，\n * @param point IPoint\n * @param rect IRect\n */\n\n\nexports.isPointsOverlap = isPointsOverlap;\n\nvar pointRectSquareDist = function pointRectSquareDist(point, rect) {\n  var isLeft = point.x < rect.x;\n  var isRight = point.x > rect.x + rect.width;\n  var isTop = point.y > rect.y + rect.height;\n  var isBottom = point.y < rect.y;\n  var isPointOutside = isLeft || isRight || isTop || isBottom;\n\n  if (!isPointOutside) {\n    return 0;\n  }\n\n  if (isTop && !isLeft && !isRight) {\n    return Math.pow(rect.y + rect.height - point.y, 2);\n  }\n\n  if (isBottom && !isLeft && !isRight) {\n    return Math.pow(point.y - rect.y, 2);\n  }\n\n  if (isLeft && !isTop && !isBottom) {\n    return Math.pow(rect.x - point.x, 2);\n  }\n\n  if (isRight && !isTop && !isBottom) {\n    return Math.pow(rect.x + rect.width - point.x, 2);\n  }\n\n  var dx = Math.min(Math.abs(rect.x - point.x), Math.abs(rect.x + rect.width - point.x));\n  var dy = Math.min(Math.abs(rect.y - point.y), Math.abs(rect.y + rect.height - point.y));\n  return dx * dx + dy * dy;\n};\n/**\n * point to line distance\n * @param  {array} line 线的四个顶点 [x1, y1, x2, y2]\n * @param  {object} point 坐标点 {x, y}\n * @return {Number|NaN} distance\n */\n\n\nexports.pointRectSquareDist = pointRectSquareDist;\n\nvar pointLineDistance = function pointLineDistance(line, point) {\n  var x1 = line[0],\n      y1 = line[1],\n      x2 = line[2],\n      y2 = line[3];\n  var x = point.x,\n      y = point.y;\n  var d = [x2 - x1, y2 - y1];\n\n  if (_matrixUtil.vec2.exactEquals(d, [0, 0])) {\n    return NaN;\n  }\n\n  var u = [-d[1], d[0]]; // @ts-ignore\n\n  _matrixUtil.vec2.normalize(u, u);\n\n  var a = [x - x1, y - y1]; // @ts-ignore\n\n  return Math.abs(_matrixUtil.vec2.dot(a, u));\n};\n\nexports.pointLineDistance = pointLineDistance;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.singleDataValidation = exports.dataValidation = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _graphic = require(\"./graphic\");\n\n/**\n * 验证关系图或树图数据的合法性，必须符合以下规则才会渲染图：\n * 1. 必须传入数据\n * 2. 节点的 ID 必须为字符串，暂不支持数字类型，如果支持数字类型，会出现类似 123 与 '123' 是否相等的问题\n * 3. 边的 source 和 target 值必须在节点 ID 中存在\n * @param data 关系图或树图数据\n * @return boolean 全部验证通过返回 true，否则返回 false\n */\nvar dataValidation = function dataValidation(data) {\n  // 1. 必须传入数据\n  if (!data) {\n    console.error('G6 Error Tips: the data must be defined');\n    return false;\n  } // 2. 节点的 ID 必须为字符串或数字类型\n\n\n  var nodes = data.nodes,\n      edges = data.edges,\n      _a = data.combos,\n      combos = _a === void 0 ? [] : _a;\n\n  if (!nodes && !edges) {\n    var validated_1 = true; // 不存在 nodes 和 edges，则说明是 TreeGraphData，按 TreeGraphData 规则验证\n\n    (0, _graphic.traverseTree)(data, function (param) {\n      if (!(0, _util.isString)(param.id)) {\n        validated_1 = false;\n        return false;\n      }\n\n      return true;\n    });\n    return validated_1;\n  }\n\n  var nonNode = (nodes || []).find(function (node) {\n    return !(0, _util.isString)(node.id);\n  });\n\n  if (nonNode) {\n    console.warn(\"G6 Warning Tips: missing 'id' property, or %c\" + nonNode.id + \"%c is not a string.\", 'font-size: 20px; color: red;', '');\n    return false;\n  } // 3. 边的 source 和 target 必须存在于节点 或 Combo中\n\n\n  var nodeIds = (nodes || []).map(function (node) {\n    return node.id;\n  });\n  var comboIds = combos.map(function (combo) {\n    return combo.id;\n  });\n  var ids = (0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], nodeIds), comboIds);\n  var nonEdges = (edges || []).find(function (edge) {\n    return !ids.includes(edge.source) || !ids.includes(edge.target);\n  });\n\n  if (nonEdges) {\n    console.warn(\"G6 Warning Tips: The source %c\" + nonEdges.source + \"%c or the target %c\" + nonEdges.target + \"%c of the edge do not exist in the nodes or combos.\", 'font-size: 20px; color: red;', '', 'font-size: 20px; color: red;', '');\n    return false;\n  }\n\n  return true;\n};\n/**\n * 验证添加节点、边或从combo时的数据\n * @param type 节点、边或从combo\n * @param data 添加的单条数据\n * @return boolean 全部验证通过返回 true，否则返回 false\n */\n\n\nexports.dataValidation = dataValidation;\n\nvar singleDataValidation = function singleDataValidation(type, data) {\n  if (type === 'node' || type === 'combo') {\n    // 必须有 id 字段，且id必须为字符串类型\n    if (data.id && !(0, _util.isString)(data.id)) {\n      console.warn(\"G6 Warning Tips: missing 'id' property, or the 'id' %c\" + data.id + \"%c is not a string.\", 'font-size: 20px; color: red;', '');\n      return false;\n    }\n  } else if (type === 'edge') {\n    // 必须有 source 和 target 字段\n    if (!data.source || !data.target) {\n      console.warn(\"G6 Warning Tips: missing 'source' or 'target' for the edge.\");\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexports.singleDataValidation = singleDataValidation;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cloneBesidesImg = exports.shouldRefreshEdge = exports.getComboBBox = exports.reconstructTree = exports.plainCombosToTrees = exports.getTextSize = exports.getLetterWidth = exports.traverseTreeUp = exports.traverseTree = exports.getLabelPosition = exports.getLoopCfgs = exports.getBBox = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _matrixUtil = require(\"@antv/matrix-util\");\n\nvar _global = _interopRequireDefault(require(\"../global\"));\n\nvar _math = require(\"./math\");\n\nvar _letterAspectRatio = _interopRequireDefault(require(\"./letterAspectRatio\"));\n\nvar _util = require(\"@antv/util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar PI = Math.PI,\n    sin = Math.sin,\n    cos = Math.cos; // 一共支持8个方向的自环，每个环占的角度是45度，在计算时再二分，为22.5度\n\nvar SELF_LINK_SIN = sin(PI / 8);\nvar SELF_LINK_COS = cos(PI / 8);\n\nvar getBBox = function getBBox(element, group) {\n  var bbox = element.getBBox();\n  var leftTop = {\n    x: bbox.minX,\n    y: bbox.minY\n  };\n  var rightBottom = {\n    x: bbox.maxX,\n    y: bbox.maxY\n  }; // 根据父元素变换矩阵\n\n  if (group) {\n    var matrix = group.getMatrix();\n\n    if (!matrix) {\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    leftTop = (0, _math.applyMatrix)(leftTop, matrix);\n    rightBottom = (0, _math.applyMatrix)(rightBottom, matrix);\n  }\n\n  var lx = leftTop.x,\n      ly = leftTop.y;\n  var rx = rightBottom.x,\n      ry = rightBottom.y;\n  return {\n    x: lx,\n    y: ly,\n    minX: lx,\n    minY: ly,\n    maxX: rx,\n    maxY: ry,\n    width: rx - lx,\n    height: ry - ly\n  };\n};\n/**\n * get loop edge config\n * @param cfg edge config\n */\n\n\nexports.getBBox = getBBox;\n\nvar getLoopCfgs = function getLoopCfgs(cfg) {\n  var item = cfg.sourceNode || cfg.targetNode;\n  var container = item.get('group');\n  var containerMatrix = container.getMatrix();\n  if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  var keyShape = item.getKeyShape();\n  var bbox = keyShape.getBBox();\n  var loopCfg = cfg.loopCfg || {}; // 距离keyShape边的最高距离\n\n  var dist = loopCfg.dist || Math.max(bbox.width, bbox.height) * 2; // 自环边与keyShape的相对位置关系\n\n  var position = loopCfg.position || _global.default.defaultLoopPosition; // 中心取group上真实位置\n\n  var center = [containerMatrix[6], containerMatrix[7]];\n  var startPoint = [cfg.startPoint.x, cfg.startPoint.y];\n  var endPoint = [cfg.endPoint.x, cfg.endPoint.y];\n  var rstart = bbox.height / 2;\n  var rend = bbox.height / 2;\n  var sinDeltaStart = rstart * SELF_LINK_SIN;\n  var cosDeltaStart = rstart * SELF_LINK_COS;\n  var sinDeltaEnd = rend * SELF_LINK_SIN;\n  var cosDeltaEnd = rend * SELF_LINK_COS; // 如果定义了锚点的，直接用锚点坐标，否则，根据自环的 cfg 计算\n\n  if (startPoint[0] === endPoint[0] && startPoint[1] === endPoint[1]) {\n    switch (position) {\n      case 'top':\n        startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];\n        endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];\n        break;\n\n      case 'top-right':\n        rstart = bbox.height / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + sinDeltaStart, center[1] - cosDeltaStart];\n        endPoint = [center[0] + cosDeltaEnd, center[1] - sinDeltaEnd];\n        break;\n\n      case 'right':\n        rstart = bbox.width / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + cosDeltaStart, center[1] - sinDeltaStart];\n        endPoint = [center[0] + cosDeltaEnd, center[1] + sinDeltaEnd];\n        break;\n\n      case 'bottom-right':\n        rstart = bbox.width / 2;\n        rend = bbox.height / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + cosDeltaStart, center[1] + sinDeltaStart];\n        endPoint = [center[0] + sinDeltaEnd, center[1] + cosDeltaEnd];\n        break;\n\n      case 'bottom':\n        rstart = bbox.height / 2;\n        rend = bbox.height / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + sinDeltaStart, center[1] + cosDeltaStart];\n        endPoint = [center[0] - sinDeltaEnd, center[1] + cosDeltaEnd];\n        break;\n\n      case 'bottom-left':\n        rstart = bbox.height / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - sinDeltaStart, center[1] + cosDeltaStart];\n        endPoint = [center[0] - cosDeltaEnd, center[1] + sinDeltaEnd];\n        break;\n\n      case 'left':\n        rstart = bbox.width / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - cosDeltaStart, center[1] + sinDeltaStart];\n        endPoint = [center[0] - cosDeltaEnd, center[1] - sinDeltaEnd];\n        break;\n\n      case 'top-left':\n        rstart = bbox.width / 2;\n        rend = bbox.height / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - cosDeltaStart, center[1] - sinDeltaStart];\n        endPoint = [center[0] - sinDeltaEnd, center[1] - cosDeltaEnd];\n        break;\n\n      default:\n        rstart = bbox.width / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];\n        endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];\n    } // 如果逆时针画，交换起点和终点\n\n\n    if (loopCfg.clockwise === false) {\n      var swap = [startPoint[0], startPoint[1]];\n      startPoint = [endPoint[0], endPoint[1]];\n      endPoint = [swap[0], swap[1]];\n    }\n  }\n\n  var startVec = [startPoint[0] - center[0], startPoint[1] - center[1]];\n  var scaleRateStart = (rstart + dist) / rstart;\n  var scaleRateEnd = (rend + dist) / rend;\n\n  if (loopCfg.clockwise === false) {\n    scaleRateStart = (rend + dist) / rend;\n    scaleRateEnd = (rstart + dist) / rstart;\n  }\n\n  var startExtendVec = _matrixUtil.vec2.scale([0, 0], startVec, scaleRateStart);\n\n  var controlPoint1 = [center[0] + startExtendVec[0], center[1] + startExtendVec[1]];\n  var endVec = [endPoint[0] - center[0], endPoint[1] - center[1]];\n\n  var endExtendVec = _matrixUtil.vec2.scale([0, 0], endVec, scaleRateEnd);\n\n  var controlPoint2 = [center[0] + endExtendVec[0], center[1] + endExtendVec[1]];\n  cfg.startPoint = {\n    x: startPoint[0],\n    y: startPoint[1]\n  };\n  cfg.endPoint = {\n    x: endPoint[0],\n    y: endPoint[1]\n  };\n  cfg.controlPoints = [{\n    x: controlPoint1[0],\n    y: controlPoint1[1]\n  }, {\n    x: controlPoint2[0],\n    y: controlPoint2[1]\n  }];\n  return cfg;\n};\n/**\n * 根据 label 所在线条的位置百分比，计算 label 坐标\n * @param {object}  pathShape  G 的 path 实例，一般是 Edge 实例的 keyShape\n * @param {number}  percent    范围 0 - 1 的线条百分比\n * @param {number}  refX     x 轴正方向为基准的 label 偏移\n * @param {number}  refY     y 轴正方向为基准的 label 偏移\n * @param {boolean} rotate     是否根据线条斜率旋转文本\n * @return {object} 文本的 x, y, 文本的旋转角度\n */\n\n\nexports.getLoopCfgs = getLoopCfgs;\n\nvar getLabelPosition = function getLabelPosition(pathShape, percent, refX, refY, rotate) {\n  var TAN_OFFSET = 0.0001;\n  var vector = [];\n  var point = pathShape.getPoint(percent);\n\n  if (point === null) {\n    return {\n      x: 0,\n      y: 0,\n      angle: 0\n    };\n  } // 头尾最可能，放在最前面，使用 g path 上封装的方法\n\n\n  if (percent < TAN_OFFSET) {\n    vector = pathShape.getStartTangent().reverse();\n  } else if (percent > 1 - TAN_OFFSET) {\n    vector = pathShape.getEndTangent();\n  } else {\n    // 否则取指定位置的点,与少量偏移的点，做微分向量\n    var offsetPoint = pathShape.getPoint(percent + TAN_OFFSET);\n    vector.push([point.x, point.y]);\n    vector.push([offsetPoint.x, offsetPoint.y]);\n  }\n\n  var rad = Math.atan2(vector[1][1] - vector[0][1], vector[1][0] - vector[0][0]);\n\n  if (rad < 0) {\n    rad += PI * 2;\n  }\n\n  if (refX) {\n    point.x += cos(rad) * refX;\n    point.y += sin(rad) * refX;\n  }\n\n  if (refY) {\n    // 默认方向是 x 轴正方向，法线是 求出角度 - 90°\n    var normal = rad - PI / 2; // 若法线角度在 y 轴负方向，切到正方向，保证 refY 相对于 y 轴正方向\n\n    if (rad > 1 / 2 * PI && rad < 3 * 1 / 2 * PI) {\n      normal -= PI;\n    }\n\n    point.x += cos(normal) * refY;\n    point.y += sin(normal) * refY;\n  }\n\n  var result = {\n    x: point.x,\n    y: point.y,\n    angle: rad\n  };\n\n  if (rotate) {\n    if (rad > 1 / 2 * PI && rad < 3 * 1 / 2 * PI) {\n      rad -= PI;\n    }\n\n    return (0, _tslib.__assign)({\n      rotate: rad\n    }, result);\n  }\n\n  return result;\n};\n/**\n * depth first traverse, from root to leaves, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\n\nexports.getLabelPosition = getLabelPosition;\n\nvar traverse = function traverse(data, fn) {\n  if (fn(data) === false) {\n    return false;\n  }\n\n  if (data && data.children) {\n    for (var i = data.children.length - 1; i >= 0; i--) {\n      if (!traverse(data.children[i], fn)) return false;\n    }\n  }\n\n  return true;\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\n\nvar traverseUp = function traverseUp(data, fn) {\n  if (data && data.children) {\n    for (var i = data.children.length - 1; i >= 0; i--) {\n      if (!traverseUp(data.children[i], fn)) return;\n    }\n  }\n\n  if (fn(data) === false) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * depth first traverse, from root to leaves, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\n\nvar traverseTree = function traverseTree(data, fn) {\n  if (typeof fn !== 'function') {\n    return;\n  }\n\n  traverse(data, fn);\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n * if the fn returns false, terminate the traverse\n */\n\n\nexports.traverseTree = traverseTree;\n\nvar traverseTreeUp = function traverseTreeUp(data, fn) {\n  if (typeof fn !== 'function') {\n    return;\n  }\n\n  traverseUp(data, fn);\n};\n/**\n *\n * @param letter the letter\n * @param fontSize\n * @return the letter's width\n */\n\n\nexports.traverseTreeUp = traverseTreeUp;\n\nvar getLetterWidth = function getLetterWidth(letter, fontSize) {\n  return fontSize * (_letterAspectRatio.default[letter] || 1);\n};\n/**\n *\n * @param text the text\n * @param fontSize\n * @return the text's size\n */\n\n\nexports.getLetterWidth = getLetterWidth;\n\nvar getTextSize = function getTextSize(text, fontSize) {\n  var width = 0;\n  var pattern = new RegExp(\"[\\u4E00-\\u9FA5]+\");\n  text.split('').forEach(function (letter) {\n    if (pattern.test(letter)) {\n      // 中文字符\n      width += fontSize;\n    } else {\n      width += getLetterWidth(letter, fontSize);\n    }\n  });\n  return [width, fontSize];\n};\n/**\n * construct the trees from combos data\n * @param array the combos array\n * @param nodes the nodes array\n * @return the tree\n */\n\n\nexports.getTextSize = getTextSize;\n\nvar plainCombosToTrees = function plainCombosToTrees(array, nodes) {\n  var result = [];\n  var addedMap = {};\n  var modelMap = {};\n  array.forEach(function (d) {\n    modelMap[d.id] = d;\n  });\n  array.forEach(function (d, i) {\n    var cd = (0, _util.clone)(d);\n    cd.itemType = 'combo';\n    cd.children = undefined;\n\n    if (cd.parentId === cd.id) {\n      console.warn(\"The parentId for combo \" + cd.id + \" can not be the same as the combo's id\");\n      delete cd.parentId;\n    } else if (cd.parentId && !modelMap[cd.parentId]) {\n      console.warn(\"The parent combo for combo \" + cd.id + \" does not exist!\");\n      delete cd.parentId;\n    }\n\n    var mappedObj = addedMap[cd.id];\n\n    if (mappedObj) {\n      cd.children = mappedObj.children;\n      addedMap[cd.id] = cd;\n      mappedObj = cd;\n\n      if (!mappedObj.parentId) {\n        result.push(mappedObj);\n        return;\n      }\n\n      var mappedParent = addedMap[mappedObj.parentId];\n\n      if (mappedParent) {\n        if (mappedParent.children) mappedParent.children.push(cd);else mappedParent.children = [cd];\n      } else {\n        var parent_1 = {\n          id: mappedObj.parentId,\n          children: [mappedObj]\n        };\n        addedMap[mappedObj.parentId] = parent_1;\n        addedMap[cd.id] = cd;\n      }\n\n      return;\n    }\n\n    if ((0, _util.isString)(d.parentId)) {\n      var parent_2 = addedMap[d.parentId];\n\n      if (parent_2) {\n        if (parent_2.children) parent_2.children.push(cd);else parent_2.children = [cd];\n        addedMap[cd.id] = cd;\n      } else {\n        var pa = {\n          id: d.parentId,\n          children: [cd]\n        };\n        addedMap[pa.id] = pa;\n        addedMap[cd.id] = cd;\n      }\n    } else {\n      result.push(cd);\n      addedMap[cd.id] = cd;\n    }\n  }); // proccess the nodes\n\n  var nodeMap = {};\n  (nodes || []).forEach(function (node) {\n    nodeMap[node.id] = node;\n    var combo = addedMap[node.comboId];\n\n    if (combo) {\n      var cnode = {\n        id: node.id,\n        comboId: node.comboId\n      };\n      if (combo.children) combo.children.push(cnode);else combo.children = [cnode];\n      cnode.itemType = 'node';\n      addedMap[node.id] = cnode;\n    }\n  }); // assign the depth for each element\n\n  var maxDepth = 0;\n  result.forEach(function (tree) {\n    tree.depth = maxDepth + 10;\n    traverse(tree, function (child) {\n      var parent;\n      var itemType = addedMap[child.id].itemType;\n\n      if (itemType === 'node') {\n        parent = addedMap[child.comboId];\n      } else {\n        parent = addedMap[child.parentId];\n      }\n\n      if (parent) {\n        if (itemType === 'node') child.depth = maxDepth + 1;else child.depth = maxDepth + 10;\n      } else {\n        child.depth = maxDepth + 10;\n      }\n\n      if (maxDepth < child.depth) maxDepth = child.depth;\n      var oriNodeModel = nodeMap[child.id];\n\n      if (oriNodeModel) {\n        oriNodeModel.depth = child.depth;\n      }\n\n      return true;\n    });\n  });\n  return result;\n};\n\nexports.plainCombosToTrees = plainCombosToTrees;\n\nvar reconstructTree = function reconstructTree(trees, subtreeId, newParentId) {\n  var brothers = trees;\n  var subtree;\n  var comboChildsMap = {\n    root: {\n      children: trees\n    }\n  };\n  var foundSubTree = false;\n  var oldParentId = 'root';\n  (trees || []).forEach(function (tree) {\n    if (foundSubTree) return;\n\n    if (tree.id === subtreeId) {\n      subtree = tree;\n\n      if (tree.itemType === 'combo') {\n        subtree.parentId = newParentId;\n      } else {\n        subtree.comboId = newParentId;\n      }\n\n      foundSubTree = true;\n      return;\n    }\n\n    traverseTree(tree, function (child) {\n      comboChildsMap[child.id] = {\n        children: child.children\n      }; // store the old parent id to delete the subtree from the old parent's children in next recursion\n\n      brothers = comboChildsMap[child.parentId || child.comboId || 'root'].children;\n\n      if (child && (child.removed || subtreeId === child.id) && brothers) {\n        oldParentId = child.parentId || child.comboId || 'root';\n        subtree = child; // re-assign the parentId or comboId for the moved subtree\n\n        if (child.itemType === 'combo') {\n          subtree.parentId = newParentId;\n        } else {\n          subtree.comboId = newParentId;\n        }\n\n        foundSubTree = true;\n        return false;\n      }\n\n      return true;\n    });\n  });\n  brothers = comboChildsMap[oldParentId].children;\n  var index = brothers ? brothers.indexOf(subtree) : -1;\n  if (index > -1) brothers.splice(index, 1); // 如果遍历完整棵树还没有找到，说明之前就不在树中\n\n  if (!foundSubTree) {\n    subtree = {\n      id: subtreeId,\n      itemType: 'node',\n      comboId: newParentId\n    };\n    comboChildsMap[subtreeId] = {\n      children: undefined\n    };\n  } // append to new parent\n\n\n  if (subtreeId) {\n    var found_1 = false; // newParentId is undefined means the subtree will have no parent\n\n    if (newParentId) {\n      var newParentDepth_1 = 0;\n      (trees || []).forEach(function (tree) {\n        if (found_1) return; // terminate\n\n        traverseTree(tree, function (child) {\n          // append subtree to the new parent ans assign the depth to the subtree\n          if (newParentId === child.id) {\n            found_1 = true;\n            if (child.children) child.children.push(subtree);else child.children = [subtree];\n            newParentDepth_1 = child.depth;\n            if (subtree.itemType === 'node') subtree.depth = newParentDepth_1 + 2;else subtree.depth = newParentDepth_1 + 1;\n            return false; // terminate\n          }\n\n          return true;\n        });\n      });\n    } else if ((!newParentId || !found_1) && subtree.itemType !== 'node') {\n      // if the newParentId is undefined or it is not found in the tree, add the subTree to the root\n      trees.push(subtree);\n    } // update the depth of the subtree and its children from the subtree\n\n\n    var currentDepth_1 = subtree.depth;\n    traverseTree(subtree, function (child) {\n      if (child.itemType === 'node') currentDepth_1 += 2;else currentDepth_1 += 1;\n      child.depth = currentDepth_1;\n      return true;\n    });\n  }\n\n  return trees;\n};\n\nexports.reconstructTree = reconstructTree;\n\nvar getComboBBox = function getComboBBox(children, graph) {\n  var comboBBox = {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity,\n    x: undefined,\n    y: undefined,\n    width: undefined,\n    height: undefined,\n    centerX: undefined,\n    centerY: undefined\n  };\n\n  if (!children || children.length === 0) {\n    return comboBBox;\n  }\n\n  children.forEach(function (child) {\n    var childItem = graph.findById(child.id);\n    if (!childItem || !childItem.isVisible()) return; // ignore hidden children\n\n    childItem.set('bboxCanvasCache', undefined);\n    var childBBox = childItem.getCanvasBBox();\n    if (childBBox.x && comboBBox.minX > childBBox.minX) comboBBox.minX = childBBox.minX;\n    if (childBBox.y && comboBBox.minY > childBBox.minY) comboBBox.minY = childBBox.minY;\n    if (childBBox.x && comboBBox.maxX < childBBox.maxX) comboBBox.maxX = childBBox.maxX;\n    if (childBBox.y && comboBBox.maxY < childBBox.maxY) comboBBox.maxY = childBBox.maxY;\n  });\n  comboBBox.x = (comboBBox.minX + comboBBox.maxX) / 2;\n  comboBBox.y = (comboBBox.minY + comboBBox.maxY) / 2;\n  comboBBox.width = comboBBox.maxX - comboBBox.minX;\n  comboBBox.height = comboBBox.maxY - comboBBox.minY;\n  comboBBox.centerX = (comboBBox.minX + comboBBox.maxX) / 2;\n  comboBBox.centerY = (comboBBox.minY + comboBBox.maxY) / 2;\n  Object.keys(comboBBox).forEach(function (key) {\n    if (comboBBox[key] === Infinity || comboBBox[key] === -Infinity) {\n      comboBBox[key] = undefined;\n    }\n  });\n  return comboBBox;\n};\n\nexports.getComboBBox = getComboBBox;\n\nvar shouldRefreshEdge = function shouldRefreshEdge(cfg) {\n  var refreshEdge = (0, _util.isNumber)(cfg.x) || (0, _util.isNumber)(cfg.y) || cfg.type || cfg.anchorPoints || cfg.size;\n  if (cfg.style) refreshEdge = refreshEdge || (0, _util.isNumber)(cfg.style.r) || (0, _util.isNumber)(cfg.style.width) || (0, _util.isNumber)(cfg.style.height) || (0, _util.isNumber)(cfg.style.rx) || (0, _util.isNumber)(cfg.style.ry);\n  return refreshEdge;\n};\n\nexports.shouldRefreshEdge = shouldRefreshEdge;\n\nvar cloneBesidesImg = function cloneBesidesImg(obj) {\n  var clonedObj = {};\n  Object.keys(obj).forEach(function (key1) {\n    var obj2 = obj[key1];\n\n    if ((0, _util.isObject)(obj2)) {\n      var clonedObj2_1 = {};\n      Object.keys(obj2).forEach(function (key2) {\n        var v = obj2[key2];\n        if (key2 === 'img' && !(0, _util.isString)(v)) return;\n        clonedObj2_1[key2] = (0, _util.clone)(v);\n      });\n      clonedObj[key1] = clonedObj2_1;\n    } else {\n      clonedObj[key1] = (0, _util.clone)(obj2);\n    }\n  });\n  return clonedObj;\n};\n\nexports.cloneBesidesImg = cloneBesidesImg;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar subjectColor = 'rgb(95, 149, 255)';\nvar backColor = 'rgb(255, 255, 255)';\nvar textColor = 'rgb(0, 0, 0)';\nvar activeFill = 'rgb(247, 250, 255)';\nvar nodeMainFill = 'rgb(239, 244, 255)';\nvar comboFill = 'rgb(253, 253, 253)';\nvar disabledFill = 'rgb(250, 250, 250)';\nvar edgeMainStroke = 'rgb(224, 224, 224)';\nvar edgeInactiveStroke = 'rgb(234, 234, 234)';\nvar edgeDisablesStroke = 'rgb(245, 245, 245)';\nvar inactiveStroke = 'rgb(191, 213, 255)';\nvar highlightStroke = '#4572d9';\nvar highlightFill = 'rgb(223, 234, 255)';\nvar colorSet = {\n  // for nodes\n  mainStroke: subjectColor,\n  mainFill: nodeMainFill,\n  activeStroke: subjectColor,\n  activeFill: activeFill,\n  inactiveStroke: inactiveStroke,\n  inactiveFill: activeFill,\n  selectedStroke: subjectColor,\n  selectedFill: backColor,\n  highlightStroke: highlightStroke,\n  highlightFill: highlightFill,\n  disableStroke: edgeMainStroke,\n  disableFill: disabledFill,\n  // for edges\n  edgeMainStroke: edgeMainStroke,\n  edgeActiveStroke: subjectColor,\n  edgeInactiveStroke: edgeInactiveStroke,\n  edgeSelectedStroke: subjectColor,\n  edgeHighlightStroke: subjectColor,\n  edgeDisableStroke: edgeDisablesStroke,\n  // for combos\n  comboMainStroke: edgeMainStroke,\n  comboMainFill: comboFill,\n  comboActiveStroke: subjectColor,\n  comboActiveFill: activeFill,\n  comboInactiveStroke: edgeMainStroke,\n  comboInactiveFill: comboFill,\n  comboSelectedStroke: subjectColor,\n  comboSelectedFill: comboFill,\n  comboHighlightStroke: highlightStroke,\n  comboHighlightFill: comboFill,\n  comboDisableStroke: edgeInactiveStroke,\n  comboDisableFill: disabledFill\n};\nvar _default = {\n  version: '0.3.0',\n  rootContainerClassName: 'root-container',\n  nodeContainerClassName: 'node-container',\n  edgeContainerClassName: 'edge-container',\n  comboContainerClassName: 'combo-container',\n  delegateContainerClassName: 'delegate-container',\n  defaultLoopPosition: 'top',\n  nodeLabel: {\n    style: {\n      fill: '#000',\n      fontSize: 12,\n      textAlign: 'center',\n      textBaseline: 'middle'\n    },\n    offset: 4 // 节点的默认文本不居中时的偏移量\n\n  },\n  defaultNode: {\n    type: 'circle',\n    style: {\n      lineWidth: 1,\n      stroke: colorSet.mainStroke,\n      fill: nodeMainFill\n    },\n    size: 20,\n    color: colorSet.mainStroke,\n    linkPoints: {\n      size: 8,\n      lineWidth: 1,\n      fill: colorSet.activeFill,\n      stroke: colorSet.activeStroke\n    }\n  },\n  // 节点应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展\n  nodeStateStyles: {\n    active: {\n      fill: colorSet.activeFill,\n      stroke: colorSet.activeStroke,\n      lineWidth: 2,\n      shadowColor: colorSet.mainStroke,\n      shadowBlur: 10\n    },\n    selected: {\n      fill: colorSet.selectedFill,\n      stroke: colorSet.selectedStroke,\n      lineWidth: 4,\n      shadowColor: colorSet.selectedStroke,\n      shadowBlur: 10,\n      'text-shape': {\n        fontWeight: 500\n      }\n    },\n    highlight: {\n      fill: colorSet.highlightFill,\n      stroke: colorSet.highlightStroke,\n      lineWidth: 2,\n      'text-shape': {\n        fontWeight: 500\n      }\n    },\n    inactive: {\n      fill: colorSet.inactiveFill,\n      stroke: colorSet.inactiveStroke,\n      lineWidth: 1\n    },\n    disable: {\n      fill: colorSet.disableFill,\n      stroke: colorSet.disableStroke,\n      lineWidth: 1\n    }\n  },\n  edgeLabel: {\n    style: {\n      fill: textColor,\n      textAlign: 'center',\n      textBaseline: 'middle',\n      fontSize: 12\n    }\n  },\n  defaultEdge: {\n    type: 'line',\n    size: 1,\n    style: {\n      stroke: colorSet.edgeMainStroke,\n      lineAppendWidth: 2\n    },\n    color: colorSet.edgeMainStroke\n  },\n  // 边应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展\n  edgeStateStyles: {\n    active: {\n      stroke: colorSet.edgeActiveStroke,\n      lineWidth: 1\n    },\n    selected: {\n      stroke: colorSet.edgeSelectedStroke,\n      lineWidth: 2,\n      shadowColor: colorSet.edgeSelectedStroke,\n      shadowBlur: 10,\n      'text-shape': {\n        fontWeight: 500\n      }\n    },\n    highlight: {\n      stroke: colorSet.edgeHighlightStroke,\n      lineWidth: 2,\n      'text-shape': {\n        fontWeight: 500\n      }\n    },\n    inactive: {\n      stroke: colorSet.edgeInactiveStroke,\n      lineWidth: 1\n    },\n    disable: {\n      stroke: colorSet.edgeDisableStroke,\n      lineWidth: 1\n    }\n  },\n  comboLabel: {\n    style: {\n      fill: textColor,\n      // textAlign: 'center',\n      textBaseline: 'middle',\n      fontSize: 12\n    },\n    refY: 10,\n    refX: 10 // Combo 的默认文本不居中时的偏移量\n\n  },\n  defaultCombo: {\n    type: 'circle',\n    style: {\n      fill: colorSet.comboMainFill,\n      lineWidth: 1,\n      stroke: colorSet.comboMainStroke,\n      r: 5,\n      width: 20,\n      height: 10\n    },\n    size: [20, 5],\n    color: colorSet.comboMainStroke,\n    padding: [25, 20, 15, 20]\n  },\n  // combo 应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展\n  comboStateStyles: {\n    active: {\n      stroke: colorSet.comboActiveStroke,\n      lineWidth: 1,\n      fill: colorSet.comboActiveFill\n    },\n    selected: {\n      stroke: colorSet.comboSelectedStroke,\n      lineWidth: 2,\n      fill: colorSet.comboSelectedFill,\n      shadowColor: colorSet.comboSelectedStroke,\n      shadowBlur: 10,\n      'text-shape': {\n        fontWeight: 500\n      }\n    },\n    highlight: {\n      stroke: colorSet.comboHighlightStroke,\n      lineWidth: 2,\n      fill: colorSet.comboHighlightFill,\n      'text-shape': {\n        fontWeight: 500\n      }\n    },\n    inactive: {\n      stroke: colorSet.comboInactiveStroke,\n      fill: colorSet.comboInactiveFill,\n      lineWidth: 1\n    },\n    disable: {\n      stroke: colorSet.comboDisableStroke,\n      fill: colorSet.comboDisableFill,\n      lineWidth: 1\n    }\n  },\n  delegateStyle: {\n    fill: '#F3F9FF',\n    fillOpacity: 0.5,\n    stroke: '#1890FF',\n    strokeOpacity: 0.9,\n    lineDash: [5, 5]\n  }\n};\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = {\n  ' ': 0.3329986572265625,\n  a: 0.5589996337890625,\n  A: 0.6569992065429687,\n  b: 0.58599853515625,\n  B: 0.6769989013671875,\n  c: 0.5469985961914062,\n  C: 0.7279998779296875,\n  d: 0.58599853515625,\n  D: 0.705999755859375,\n  e: 0.554998779296875,\n  E: 0.63699951171875,\n  f: 0.37299957275390627,\n  F: 0.5769989013671875,\n  g: 0.5909988403320312,\n  G: 0.7479995727539063,\n  h: 0.555999755859375,\n  H: 0.7199996948242188,\n  i: 0.255999755859375,\n  I: 0.23699951171875,\n  j: 0.26699981689453123,\n  J: 0.5169998168945312,\n  k: 0.5289993286132812,\n  K: 0.6899993896484375,\n  l: 0.23499908447265624,\n  L: 0.5879989624023437,\n  m: 0.854998779296875,\n  M: 0.8819992065429687,\n  n: 0.5589996337890625,\n  N: 0.7189987182617188,\n  o: 0.58599853515625,\n  O: 0.7669998168945312,\n  p: 0.58599853515625,\n  P: 0.6419998168945312,\n  q: 0.58599853515625,\n  Q: 0.7669998168945312,\n  r: 0.3649993896484375,\n  R: 0.6759994506835938,\n  s: 0.504998779296875,\n  S: 0.6319992065429687,\n  t: 0.354998779296875,\n  T: 0.6189987182617187,\n  u: 0.5599990844726562,\n  U: 0.7139999389648437,\n  v: 0.48199920654296874,\n  V: 0.6389999389648438,\n  w: 0.754998779296875,\n  W: 0.929998779296875,\n  x: 0.5089996337890625,\n  X: 0.63699951171875,\n  y: 0.4959991455078125,\n  Y: 0.66199951171875,\n  z: 0.48699951171875,\n  Z: 0.6239990234375,\n  '0': 0.6,\n  '1': 0.40099945068359377,\n  '2': 0.6,\n  '3': 0.6,\n  '4': 0.6,\n  '5': 0.6,\n  '6': 0.6,\n  '7': 0.5469985961914062,\n  '8': 0.6,\n  '9': 0.6,\n  '[': 0.3329986572265625,\n  ']': 0.3329986572265625,\n  ',': 0.26399993896484375,\n  '.': 0.26399993896484375,\n  ';': 0.26399993896484375,\n  ':': 0.26399993896484375,\n  '{': 0.3329986572265625,\n  '}': 0.3329986572265625,\n  '\\\\': 0.5,\n  '|': 0.19499969482421875,\n  '=': 0.604998779296875,\n  '+': 0.604998779296875,\n  '-': 0.604998779296875,\n  _: 0.5,\n  '`': 0.3329986572265625,\n  ' ~': 0.8329986572265625,\n  '!': 0.3329986572265625,\n  '@': 0.8579986572265625,\n  '#': 0.6,\n  $: 0.6,\n  '%': 0.9699996948242188,\n  '^': 0.517999267578125,\n  '&': 0.7259994506835937,\n  '*': 0.505999755859375,\n  '(': 0.3329986572265625,\n  ')': 0.3329986572265625,\n  '<': 0.604998779296875,\n  '>': 0.604998779296875,\n  '/': 0.5,\n  '?': 0.53699951171875\n};\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"ModeController\", {\n  enumerable: true,\n  get: function get() {\n    return _mode.default;\n  }\n});\nObject.defineProperty(exports, \"ViewController\", {\n  enumerable: true,\n  get: function get() {\n    return _view.default;\n  }\n});\nObject.defineProperty(exports, \"ItemController\", {\n  enumerable: true,\n  get: function get() {\n    return _item.default;\n  }\n});\nObject.defineProperty(exports, \"StateController\", {\n  enumerable: true,\n  get: function get() {\n    return _state.default;\n  }\n});\n\nvar _mode = _interopRequireDefault(require(\"./mode\"));\n\nvar _view = _interopRequireDefault(require(\"./view\"));\n\nvar _item = _interopRequireDefault(require(\"./item\"));\n\nvar _state = _interopRequireDefault(require(\"./state\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@antv/util\");\n\nvar _behavior = _interopRequireDefault(require(\"../../behavior/behavior\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ModeController =\n/** @class */\nfunction () {\n  function ModeController(graph) {\n    this.graph = graph;\n    this.destroyed = false;\n    this.modes = graph.get('modes') || {\n      default: []\n    };\n    this.formatModes();\n    this.mode = graph.get('defaultMode') || 'default';\n    this.currentBehaves = [];\n    this.setMode(this.mode);\n  }\n\n  ModeController.prototype.formatModes = function () {\n    var modes = this.modes;\n    (0, _util.each)(modes, function (mode) {\n      (0, _util.each)(mode, function (behavior, i) {\n        if ((0, _util.isString)(behavior)) {\n          mode[i] = {\n            type: behavior\n          };\n        }\n      });\n    });\n  };\n\n  ModeController.prototype.setBehaviors = function (mode) {\n    var graph = this.graph;\n    var behaviors = this.modes[mode];\n    var behaves = [];\n    var behave;\n    (0, _util.each)(behaviors || [], function (behavior) {\n      var BehaviorInstance = _behavior.default.getBehavior(behavior.type || behavior);\n\n      if (!BehaviorInstance) {\n        return;\n      }\n\n      behave = new BehaviorInstance(behavior);\n\n      if (behave) {\n        behave.bind(graph);\n        behaves.push(behave);\n      }\n    });\n    this.currentBehaves = behaves;\n  };\n\n  ModeController.mergeBehaviors = function (modeBehaviors, behaviors) {\n    (0, _util.each)(behaviors, function (behavior) {\n      if (modeBehaviors.indexOf(behavior) < 0) {\n        if ((0, _util.isString)(behavior)) {\n          behavior = {\n            type: behavior\n          };\n        }\n\n        modeBehaviors.push(behavior);\n      }\n    });\n    return modeBehaviors;\n  };\n\n  ModeController.filterBehaviors = function (modeBehaviors, behaviors) {\n    var result = [];\n    modeBehaviors.forEach(function (behavior) {\n      var type = '';\n\n      if ((0, _util.isString)(behavior)) {\n        type = behavior;\n      } else {\n        // eslint-disable-next-line prefer-destructuring\n        type = behavior.type;\n      }\n\n      if (behaviors.indexOf(type) < 0) {\n        result.push(behavior);\n      }\n    });\n    return result;\n  };\n\n  ModeController.prototype.setMode = function (mode) {\n    var _a = this,\n        modes = _a.modes,\n        graph = _a.graph;\n\n    var current = mode;\n    var behaviors = modes[current];\n\n    if (!behaviors) {\n      return;\n    }\n\n    graph.emit('beforemodechange', {\n      mode: mode\n    });\n    (0, _util.each)(this.currentBehaves, function (behave) {\n      if (behave.delegate) behave.delegate.remove();\n      behave.unbind(graph);\n    });\n    this.setBehaviors(current);\n    graph.emit('aftermodechange', {\n      mode: mode\n    });\n    this.mode = mode;\n  };\n\n  ModeController.prototype.getMode = function () {\n    return this.mode;\n  };\n  /**\n   * 动态增加或删除 Behavior\n   *\n   * @param {ModeType[]} behaviors\n   * @param {(ModeType[] | ModeType)} modes\n   * @param {boolean} isAdd\n   * @returns {Mode}\n   * @memberof Mode\n   */\n\n\n  ModeController.prototype.manipulateBehaviors = function (behaviors, modes, isAdd) {\n    var _this = this;\n\n    var behaves;\n\n    if (!(0, _util.isArray)(behaviors)) {\n      behaves = [behaviors];\n    } else {\n      behaves = behaviors;\n    }\n\n    if ((0, _util.isArray)(modes)) {\n      (0, _util.each)(modes, function (mode) {\n        if (!_this.modes[mode]) {\n          if (isAdd) {\n            _this.modes[mode] = behaves;\n          }\n        } else if (isAdd) {\n          _this.modes[mode] = ModeController.mergeBehaviors(_this.modes[mode] || [], behaves);\n        } else {\n          _this.modes[mode] = ModeController.filterBehaviors(_this.modes[mode] || [], behaves);\n        }\n      });\n      return this;\n    }\n\n    var currentMode = modes;\n\n    if (!modes) {\n      currentMode = this.mode; // isString(this.mode) ? this.mode : this.mode.type\n    }\n\n    if (!this.modes[currentMode]) {\n      if (isAdd) {\n        this.modes[currentMode] = behaves;\n      }\n    }\n\n    if (isAdd) {\n      this.modes[currentMode] = ModeController.mergeBehaviors(this.modes[currentMode] || [], behaves);\n    } else {\n      this.modes[currentMode] = ModeController.filterBehaviors(this.modes[currentMode] || [], behaves);\n    }\n\n    this.setMode(this.mode);\n    return this;\n  };\n  /**\n   * 更新行为参数\n   * @param {string | ModeOption | ModeType} behavior 需要更新的行为\n   * @param {string | string[]} modes 指定的模式中的行为，不指定则为 default\n   * @return {Graph} Graph\n   */\n\n\n  ModeController.prototype.updateBehavior = function (behavior, newCfg, mode) {\n    if ((0, _util.isString)(behavior)) {\n      behavior = {\n        type: behavior\n      };\n    }\n\n    var behaviorSet = [];\n\n    if (!mode || mode === this.mode || mode === 'default') {\n      behaviorSet = this.currentBehaves;\n\n      if (!behaviorSet || !behaviorSet.length) {\n        console.warn('Update behavior failed! There is no behaviors in this mode on the graph.');\n        return this;\n      }\n\n      var length_1 = behaviorSet.length;\n\n      for (var i = 0; i < length_1; i++) {\n        var behave = behaviorSet[i];\n\n        if (behave.type === behavior.type) {\n          behave.updateCfg(newCfg);\n          return this;\n        }\n\n        if (i === length_1 - 1) console.warn('Update behavior failed! There is no such behavior in the mode');\n      }\n    } else {\n      behaviorSet = this.modes[mode];\n\n      if (!behaviorSet || !behaviorSet.length) {\n        console.warn('Update behavior failed! There is no behaviors in this mode on the graph.');\n        return this;\n      }\n\n      var length_2 = behaviorSet.length;\n\n      for (var i = 0; i < length_2; i++) {\n        var behave = behaviorSet[i];\n\n        if (behave.type === behavior.type || behave === behavior.type) {\n          if (behave === behavior.type) behave = {\n            type: behave\n          };\n          Object.assign(behave, newCfg);\n          behaviorSet[i] = behave;\n          return this;\n        }\n\n        if (i === length_2 - 1) console.warn('Update behavior failed! There is no such behavior in the mode');\n      }\n    }\n\n    return this;\n  };\n\n  ModeController.prototype.destroy = function () {\n    this.graph = null;\n    this.modes = null;\n    this.currentBehaves = null;\n    this.destroyed = true;\n  };\n\n  return ModeController;\n}();\n\nvar _default = ModeController;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _domUtil = require(\"@antv/dom-util\");\n\nvar _base = require(\"../../util/base\");\n\nvar _math = require(\"../../util/math\");\n\nvar ViewController =\n/** @class */\nfunction () {\n  function ViewController(graph) {\n    this.destroyed = false;\n    this.graph = graph;\n    this.destroyed = false;\n  } // get view center coordinate\n\n\n  ViewController.prototype.getViewCenter = function () {\n    var padding = this.getFormatPadding();\n    var graph = this.graph;\n    var width = this.graph.get('width');\n    var height = graph.get('height');\n    return {\n      x: (width - padding[1] - padding[3]) / 2 + padding[3],\n      y: (height - padding[0] - padding[2]) / 2 + padding[0]\n    };\n  };\n\n  ViewController.prototype.fitCenter = function () {\n    var graph = this.graph;\n    var group = graph.get('group');\n    group.resetMatrix();\n    var bbox = group.getCanvasBBox();\n    if (bbox.width === 0 || bbox.height === 0) return;\n    var viewCenter = this.getViewCenter();\n    var groupCenter = {\n      x: bbox.x + bbox.width / 2,\n      y: bbox.y + bbox.height / 2\n    };\n    graph.translate(viewCenter.x - groupCenter.x, viewCenter.y - groupCenter.y);\n  }; // fit view graph\n\n\n  ViewController.prototype.fitView = function () {\n    var graph = this.graph;\n    var padding = this.getFormatPadding();\n    var width = graph.get('width');\n    var height = graph.get('height');\n    var group = graph.get('group');\n    group.resetMatrix();\n    var bbox = group.getCanvasBBox();\n    if (bbox.width === 0 || bbox.height === 0) return;\n    var viewCenter = this.getViewCenter();\n    var groupCenter = {\n      x: bbox.x + bbox.width / 2,\n      y: bbox.y + bbox.height / 2\n    };\n    graph.translate(viewCenter.x - groupCenter.x, viewCenter.y - groupCenter.y);\n    var w = (width - padding[1] - padding[3]) / bbox.width;\n    var h = (height - padding[0] - padding[2]) / bbox.height;\n    var ratio = w;\n\n    if (w > h) {\n      ratio = h;\n    }\n\n    graph.zoom(ratio, viewCenter);\n  };\n\n  ViewController.prototype.getFormatPadding = function () {\n    var padding = this.graph.get('fitViewPadding');\n    return (0, _base.formatPadding)(padding);\n  };\n\n  ViewController.prototype.focusPoint = function (point, animate, animateCfg) {\n    var _this = this;\n\n    var viewCenter = this.getViewCenter();\n    var modelCenter = this.getPointByCanvas(viewCenter.x, viewCenter.y);\n    var viewportMatrix = this.graph.get('group').getMatrix();\n    if (!viewportMatrix) viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n    if (animate) {\n      var dx_1 = (modelCenter.x - point.x) * viewportMatrix[0];\n      var dy_1 = (modelCenter.y - point.y) * viewportMatrix[4];\n      var lastX_1 = 0;\n      var lastY_1 = 0;\n      var newX_1 = 0;\n      var newY_1 = 0; // 动画每次平移一点，直到目标位置\n\n      this.graph.get('canvas').animate(function (ratio) {\n        newX_1 = dx_1 * ratio;\n        newY_1 = dy_1 * ratio;\n\n        _this.graph.translate(newX_1 - lastX_1, newY_1 - lastY_1);\n\n        lastX_1 = newX_1;\n        lastY_1 = newY_1;\n      }, (0, _tslib.__assign)({}, animateCfg));\n    } else {\n      this.graph.translate((modelCenter.x - point.x) * viewportMatrix[0], (modelCenter.y - point.y) * viewportMatrix[4]);\n    }\n  };\n  /**\n   * 将 Canvas 坐标转成视口坐标\n   * @param canvasX canvas x 坐标\n   * @param canvasY canvas y 坐标\n   */\n\n\n  ViewController.prototype.getPointByCanvas = function (canvasX, canvasY) {\n    var viewportMatrix = this.graph.get('group').getMatrix();\n\n    if (!viewportMatrix) {\n      viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    var point = (0, _math.invertMatrix)({\n      x: canvasX,\n      y: canvasY\n    }, viewportMatrix);\n    return point;\n  };\n  /**\n   * 将页面坐标转成视口坐标\n   * @param clientX 页面 x 坐标\n   * @param clientY 页面 y 坐标\n   */\n\n\n  ViewController.prototype.getPointByClient = function (clientX, clientY) {\n    var canvas = this.graph.get('canvas');\n    var canvasPoint = canvas.getPointByClient(clientX, clientY);\n    return this.getPointByCanvas(canvasPoint.x, canvasPoint.y);\n  };\n  /**\n   * 将视口坐标转成页面坐标\n   * @param x 视口 x 坐标\n   * @param y 视口 y 坐标\n   */\n\n\n  ViewController.prototype.getClientByPoint = function (x, y) {\n    var canvas = this.graph.get('canvas');\n    var canvasPoint = this.getCanvasByPoint(x, y);\n    var point = canvas.getClientByPoint(canvasPoint.x, canvasPoint.y);\n    return {\n      x: point.x,\n      y: point.y\n    };\n  };\n  /**\n   * 将视口坐标转成 Canvas 坐标\n   * @param x 视口 x 坐标\n   * @param y 视口 y 坐标\n   */\n\n\n  ViewController.prototype.getCanvasByPoint = function (x, y) {\n    var viewportMatrix = this.graph.get('group').getMatrix();\n\n    if (!viewportMatrix) {\n      viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    return (0, _math.applyMatrix)({\n      x: x,\n      y: y\n    }, viewportMatrix);\n  };\n  /**\n   * 将元素移动到画布中心\n   * @param item Item 实例或 id\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n\n\n  ViewController.prototype.focus = function (item, animate, animateCfg) {\n    if ((0, _util.isString)(item)) {\n      item = this.graph.findById(item);\n    }\n\n    if (item) {\n      var x = 0,\n          y = 0;\n\n      if (item.getType && item.getType() === 'edge') {\n        var sourceMatrix = item.getSource().get('group').getMatrix();\n        var targetMatrix = item.getTarget().get('group').getMatrix();\n\n        if (sourceMatrix && targetMatrix) {\n          x = (sourceMatrix[6] + targetMatrix[6]) / 2;\n          y = (sourceMatrix[7] + targetMatrix[7]) / 2;\n        } else if (sourceMatrix || targetMatrix) {\n          x = sourceMatrix ? sourceMatrix[6] : targetMatrix[6];\n          y = sourceMatrix ? sourceMatrix[7] : targetMatrix[7];\n        }\n      } else {\n        var group = item.get('group');\n        var matrix = group.getMatrix();\n        if (!matrix) matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n        x = matrix[6];\n        y = matrix[7];\n      } // 用实际位置而不是model中的x,y,防止由于拖拽等的交互导致model的x,y并不是当前的x,y\n\n\n      this.focusPoint({\n        x: x,\n        y: y\n      }, animate, animateCfg);\n    }\n  };\n  /**\n   * 改变 canvas 画布的宽度和高度\n   * @param width canvas 宽度\n   * @param height canvas 高度\n   */\n\n\n  ViewController.prototype.changeSize = function (width, height) {\n    var graph = this.graph;\n\n    if (!(0, _util.isNumber)(width) || !(0, _util.isNumber)(height)) {\n      throw Error('invalid canvas width & height, please make sure width & height type is number');\n    }\n\n    graph.set({\n      width: width,\n      height: height\n    });\n    var canvas = graph.get('canvas');\n    canvas.changeSize(width, height); // change the size of grid plugin if it exists on graph\n\n    var plugins = graph.get('plugins');\n    plugins.forEach(function (plugin) {\n      if (plugin.get('gridContainer')) {\n        var minZoom = graph.get('minZoom');\n        (0, _domUtil.modifyCSS)(plugin.get('container'), {\n          width: width + \"px\",\n          height: height + \"px\"\n        });\n        (0, _domUtil.modifyCSS)(plugin.get('gridContainer'), {\n          width: width / minZoom + \"px\",\n          height: height / minZoom + \"px\",\n          left: 0,\n          top: 0\n        });\n      }\n    });\n  };\n\n  ViewController.prototype.destroy = function () {\n    this.graph = null;\n    this.destroyed = false;\n  };\n\n  return ViewController;\n}();\n\nvar _default = ViewController;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.processParallelEdges = exports.calculationItemsBBox = exports.isNaN = exports.isViewportChanged = exports.cloneEvent = exports.formatPadding = exports.uniqueId = void 0;\n\nvar _util = require(\"@antv/util\");\n\nvar _behavior = require(\"../interface/behavior\");\n\nvar uniqueId = function uniqueId(type) {\n  return type + \"-\" + Math.random() + Date.now();\n};\n/**\n * turn padding into [top, right, bottom, right]\n * @param  {Number|Array} padding input padding\n * @return {array} output\n */\n\n\nexports.uniqueId = uniqueId;\n\nvar formatPadding = function formatPadding(padding) {\n  var top = 0;\n  var left = 0;\n  var right = 0;\n  var bottom = 0;\n\n  if ((0, _util.isNumber)(padding)) {\n    top = left = right = bottom = padding;\n  } else if ((0, _util.isString)(padding)) {\n    var intPadding = parseInt(padding, 10);\n    top = left = right = bottom = intPadding;\n  } else if ((0, _util.isArray)(padding)) {\n    top = padding[0];\n    right = !(0, _util.isNil)(padding[1]) ? padding[1] : padding[0];\n    bottom = !(0, _util.isNil)(padding[2]) ? padding[2] : padding[0];\n    left = !(0, _util.isNil)(padding[3]) ? padding[3] : right;\n  }\n\n  return [top, right, bottom, left];\n};\n/**\n * clone event\n * @param e\n */\n\n\nexports.formatPadding = formatPadding;\n\nvar cloneEvent = function cloneEvent(e) {\n  var event = new _behavior.G6GraphEvent(e.type, e);\n  event.clientX = e.clientX;\n  event.clientY = e.clientY;\n  event.x = e.x;\n  event.y = e.y;\n  event.target = e.target;\n  event.currentTarget = e.currentTarget;\n  event.bubbles = true;\n  event.item = e.item;\n  return event;\n};\n/**\n * 判断 viewport 是否改变，通过和单位矩阵对比\n * @param matrix Viewport 的 Matrix\n */\n\n\nexports.cloneEvent = cloneEvent;\n\nvar isViewportChanged = function isViewportChanged(matrix) {\n  // matrix 为 null， 则说明没有变化\n  if (!matrix) {\n    return false;\n  }\n\n  var MATRIX_LEN = 9;\n  var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n  for (var i = 0; i < MATRIX_LEN; i++) {\n    if (matrix[i] !== ORIGIN_MATRIX[i]) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nexports.isViewportChanged = isViewportChanged;\n\nvar isNaN = function isNaN(input) {\n  return Number.isNaN(Number(input));\n};\n/**\n * 计算一组 Item 的 BBox\n * @param items 选中的一组Item，可以是 node 或 combo\n */\n\n\nexports.isNaN = isNaN;\n\nvar calculationItemsBBox = function calculationItemsBBox(items) {\n  var minx = Infinity;\n  var maxx = -Infinity;\n  var miny = Infinity;\n  var maxy = -Infinity; // 获取已节点的所有最大最小x y值\n\n  for (var i = 0; i < items.length; i++) {\n    var element = items[i];\n    var bbox = element.getBBox();\n    var minX = bbox.minX,\n        minY = bbox.minY,\n        maxX = bbox.maxX,\n        maxY = bbox.maxY;\n\n    if (minX < minx) {\n      minx = minX;\n    }\n\n    if (minY < miny) {\n      miny = minY;\n    }\n\n    if (maxX > maxx) {\n      maxx = maxX;\n    }\n\n    if (maxY > maxy) {\n      maxy = maxY;\n    }\n  }\n\n  var x = Math.floor(minx);\n  var y = Math.floor(miny);\n  var width = Math.ceil(maxx) - Math.floor(minx);\n  var height = Math.ceil(maxy) - Math.floor(miny);\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    minX: minx,\n    minY: miny,\n    maxX: maxx,\n    maxY: maxy\n  };\n};\n/**\n * 若 edges 中存在两端点相同的边，使用 quadratic 边并自动计算 curveOffset 使它们不相互重叠\n * 文档: https://g6.antv.vision/en/docs/api/Util\n * @param edges 边数据集合\n * @param offsetDiff 相邻两边的 offset 之差\n * @param multiEdgeType\n * @param singleEdgeType\n * @param loopEdgeType\n */\n\n\nexports.calculationItemsBBox = calculationItemsBBox;\n\nvar processParallelEdges = function processParallelEdges(edges, offsetDiff, multiEdgeType, singleEdgeType, loopEdgeType) {\n  if (offsetDiff === void 0) {\n    offsetDiff = 15;\n  }\n\n  if (multiEdgeType === void 0) {\n    multiEdgeType = 'quadratic';\n  }\n\n  if (singleEdgeType === void 0) {\n    singleEdgeType = undefined;\n  }\n\n  if (loopEdgeType === void 0) {\n    loopEdgeType = undefined;\n  }\n\n  var len = edges.length;\n  var cod = offsetDiff * 2;\n  var loopPosition = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];\n  var edgeMap = {};\n  var tags = [];\n  var reverses = {};\n\n  for (var i = 0; i < len; i++) {\n    var edge = edges[i];\n    var source = edge.source,\n        target = edge.target;\n    var sourceTarget = source + \"-\" + target;\n    if (tags[i]) continue;\n\n    if (!edgeMap[sourceTarget]) {\n      edgeMap[sourceTarget] = [];\n    }\n\n    tags[i] = true;\n    edgeMap[sourceTarget].push(edge);\n\n    for (var j = 0; j < len; j++) {\n      if (i === j) continue;\n      var sedge = edges[j];\n      var src = sedge.source;\n      var dst = sedge.target; // 两个节点之间共同的边\n      // 第一条的source = 第二条的target\n      // 第一条的target = 第二条的source\n\n      if (!tags[j]) {\n        if (source === dst && target === src) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n          reverses[src + \"|\" + dst + \"|\" + (edgeMap[sourceTarget].length - 1)] = true;\n        } else if (source === src && target === dst) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n        }\n      }\n    }\n  }\n\n  for (var key in edgeMap) {\n    var arcEdges = edgeMap[key];\n    var length_1 = arcEdges.length;\n\n    for (var k = 0; k < length_1; k++) {\n      var current = arcEdges[k];\n\n      if (current.source === current.target) {\n        if (loopEdgeType) current.type = loopEdgeType; // 超过8条自环边，则需要重新处理\n\n        current.loopCfg = {\n          position: loopPosition[k % 8],\n          dist: Math.floor(k / 8) * 20 + 50\n        };\n        continue;\n      }\n\n      if (length_1 === 1 && singleEdgeType && current.source !== current.target) {\n        current.type = singleEdgeType;\n        continue;\n      }\n\n      current.type = multiEdgeType;\n      var sign = (k % 2 === 0 ? 1 : -1) * (reverses[current.source + \"|\" + current.target + \"|\" + k] ? -1 : 1);\n\n      if (length_1 % 2 === 1) {\n        current.curveOffset = sign * Math.ceil(k / 2) * cod;\n      } else {\n        current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\n      }\n    }\n  }\n\n  return edges;\n};\n\nexports.processParallelEdges = processParallelEdges;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.G6GraphEvent = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _gBase = require(\"@antv/g-base\");\n\nvar G6GraphEvent =\n/** @class */\nfunction (_super) {\n  (0, _tslib.__extends)(G6GraphEvent, _super);\n\n  function G6GraphEvent(type, event) {\n    var _this = _super.call(this, type, event) || this;\n\n    _this.item = event.item;\n    _this.canvasX = event.canvasX;\n    _this.canvasY = event.canvasY;\n    _this.wheelDelta = event.wheelDelta;\n    _this.detail = event.detail;\n    return _this;\n  }\n\n  return G6GraphEvent;\n}(_gBase.Event);\n\nexports.G6GraphEvent = G6GraphEvent;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _edge = _interopRequireDefault(require(\"../../item/edge\"));\n\nvar _node = _interopRequireDefault(require(\"../../item/node\"));\n\nvar _combo = _interopRequireDefault(require(\"../../item/combo\"));\n\nvar _graphic = require(\"../../util/graphic\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar NODE = 'node';\nvar EDGE = 'edge';\nvar VEDGE = 'vedge';\nvar COMBO = 'combo';\nvar CFG_PREFIX = 'default';\nvar MAPPER_SUFFIX = 'Mapper';\nvar STATE_SUFFIX = 'stateStyles';\n\nvar ItemController =\n/** @class */\nfunction () {\n  function ItemController(graph) {\n    this.graph = graph;\n    this.destroyed = false;\n  }\n  /**\n   * 增加 Item 实例\n   *\n   * @param {ITEM_TYPE} type 实例类型，node 或 edge\n   * @param {(NodeConfig & EdgeConfig)} model 数据模型\n   * @returns {(Item)}\n   * @memberof ItemController\n   */\n\n\n  ItemController.prototype.addItem = function (type, model) {\n    var graph = this.graph;\n    var vType = type === VEDGE ? EDGE : type;\n    var parent = graph.get(vType + \"Group\") || graph.get('group');\n    var upperType = (0, _util.upperFirst)(vType);\n    var item = null; // 获取 this.get('styles') 中的值\n\n    var styles = graph.get(vType + (0, _util.upperFirst)(STATE_SUFFIX)) || {};\n    var defaultModel = graph.get(CFG_PREFIX + upperType);\n\n    if (model[STATE_SUFFIX]) {\n      // 设置 this.get('styles') 中的值\n      styles = model[STATE_SUFFIX];\n    }\n\n    if (defaultModel) {\n      // 很多布局会直接修改原数据模型，所以不能用 merge 的形式，逐个写入原 model 中\n      (0, _util.each)(defaultModel, function (val, cfg) {\n        if ((0, _util.isObject)(val) && !(0, _util.isArray)(val)) {\n          model[cfg] = (0, _util.deepMix)({}, val, model[cfg]);\n        } else if ((0, _util.isArray)(val)) {\n          model[cfg] = model[cfg] || (0, _util.clone)(defaultModel[cfg]);\n        } else {\n          model[cfg] = model[cfg] || defaultModel[cfg];\n        }\n      });\n    }\n\n    var mapper = graph.get(vType + MAPPER_SUFFIX);\n\n    if (mapper) {\n      var mappedModel_1 = mapper(model);\n\n      if (mappedModel_1[STATE_SUFFIX]) {\n        // 设置 this.get('styles') 中的值\n        styles = mappedModel_1[STATE_SUFFIX];\n        delete mappedModel_1[STATE_SUFFIX];\n      } // 如果配置了 defaultEdge 或 defaultNode，则将默认配置的数据也合并进去\n\n\n      (0, _util.each)(mappedModel_1, function (val, cfg) {\n        if ((0, _util.isObject)(val) && !(0, _util.isArray)(val)) {\n          model[cfg] = (0, _util.deepMix)({}, model[cfg], val);\n        } else {\n          model[cfg] = mappedModel_1[cfg] || model[cfg];\n        }\n      });\n    }\n\n    graph.emit('beforeadditem', {\n      type: type,\n      model: model\n    });\n\n    if (type === EDGE || type === VEDGE) {\n      var source = void 0;\n      var target = void 0;\n      source = model.source; // eslint-disable-line prefer-destructuring\n\n      target = model.target; // eslint-disable-line prefer-destructuring\n\n      if (source && (0, _util.isString)(source)) {\n        source = graph.findById(source);\n      }\n\n      if (target && (0, _util.isString)(target)) {\n        target = graph.findById(target);\n      }\n\n      if (!source || !target) {\n        console.warn(\"The source or target node of edge \" + model.id + \" does not exist!\");\n        return;\n      }\n\n      if (source.getType && source.getType() === 'combo') {\n        model.isComboEdge = true; // graph.updateCombo(source as ICombo);\n      }\n\n      if (target.getType && target.getType() === 'combo') {\n        model.isComboEdge = true; // graph.updateCombo(target as ICombo);\n      }\n\n      item = new _edge.default({\n        model: model,\n        source: source,\n        target: target,\n        styles: styles,\n        linkCenter: graph.get('linkCenter'),\n        group: parent.addGroup()\n      });\n    } else if (type === NODE) {\n      item = new _node.default({\n        model: model,\n        styles: styles,\n        group: parent.addGroup()\n      });\n    } else if (type === COMBO) {\n      var children = model.children;\n      var comboBBox = (0, _graphic.getComboBBox)(children, graph);\n      if (!isNaN(comboBBox.x)) model.x = comboBBox.x;else if (isNaN(model.x)) model.x = Math.random() * 100;\n      if (!isNaN(comboBBox.y)) model.y = comboBBox.y;else if (isNaN(model.y)) model.y = Math.random() * 100;\n      var comboGroup = parent.addGroup();\n      comboGroup.setZIndex(model.depth);\n      item = new _combo.default({\n        model: model,\n        styles: styles,\n        bbox: model.collapsed ? (0, _graphic.getComboBBox)([], graph) : comboBBox,\n        group: comboGroup\n      });\n      var comboModel_1 = item.getModel();\n      (children || []).forEach(function (child) {\n        var childItem = graph.findById(child.id);\n        item.addChild(childItem);\n        child.depth = comboModel_1.depth + 2;\n      }); // collapse the combo if the collapsed is true in the model\n\n      if (model.collapsed) {\n        setTimeout(function () {\n          graph.collapseCombo(item);\n        }, 16);\n      }\n    }\n\n    if (item) {\n      graph.get(type + \"s\").push(item);\n      graph.get('itemMap')[item.get('id')] = item;\n      graph.emit('afteradditem', {\n        item: item,\n        model: model\n      }); // eslint-disable-next-line consistent-return\n\n      return item;\n    }\n  };\n  /**\n   * 更新节点或边\n   *\n   * @param {Item} item ID 或 实例\n   * @param {(EdgeConfig | Partial<NodeConfig>)} cfg 数据模型\n   * @returns\n   * @memberof ItemController\n   */\n\n\n  ItemController.prototype.updateItem = function (item, cfg) {\n    var _a, _b;\n\n    var graph = this.graph;\n\n    if ((0, _util.isString)(item)) {\n      item = graph.findById(item);\n    }\n\n    if (!item || item.destroyed) {\n      return;\n    } // 更新的 item 的类型\n\n\n    var type = '';\n    if (item.getType) type = item.getType();\n    var mapper = graph.get(type + MAPPER_SUFFIX);\n    var model = item.getModel();\n    var isOnlyMove = item.isOnlyMove(cfg);\n\n    if (mapper) {\n      var result = (0, _util.deepMix)({}, model, cfg);\n      var mappedModel = mapper(result); // 将 update 时候用户传入的参数与mapperModel做deepMix，以便复用之前设置的参数值\n\n      var newModel = (0, _util.deepMix)({}, model, mappedModel, cfg);\n\n      if (mappedModel[STATE_SUFFIX]) {\n        item.set('styles', newModel[STATE_SUFFIX]);\n        delete newModel[STATE_SUFFIX];\n      }\n\n      (0, _util.each)(newModel, function (val, key) {\n        cfg[key] = val;\n      });\n    } else {\n      // merge update传进来的对象参数，model中没有的数据不做处理，对象和字符串值也不做处理，直接替换原来的\n      (0, _util.each)(cfg, function (val, key) {\n        if (model[key]) {\n          if ((0, _util.isObject)(val) && !(0, _util.isArray)(val)) {\n            cfg[key] = (0, _tslib.__assign)((0, _tslib.__assign)({}, model[key]), cfg[key]);\n          }\n        }\n      });\n    } // emit beforeupdateitem 事件\n\n\n    graph.emit('beforeupdateitem', {\n      item: item,\n      cfg: cfg\n    });\n\n    if (type === EDGE) {\n      // 若是边要更新source || target, 为了不影响示例内部model，并且重新计算startPoint和endPoint，手动设置\n      if (cfg.source) {\n        var source = cfg.source;\n\n        if ((0, _util.isString)(source)) {\n          source = graph.findById(source);\n        }\n\n        item.setSource(source);\n      }\n\n      if (cfg.target) {\n        var target = cfg.target;\n\n        if ((0, _util.isString)(target)) {\n          target = graph.findById(target);\n        }\n\n        item.setTarget(target);\n      }\n\n      item.update(cfg);\n    } // item.update(cfg);\n\n\n    if (type === NODE || type === COMBO) {\n      item.update(cfg, isOnlyMove);\n      var edges_1 = item.getEdges();\n      var refreshEdge = (0, _graphic.shouldRefreshEdge)(cfg);\n      if (refreshEdge && type === NODE) (0, _util.each)(edges_1, function (edge) {\n        edge.refresh();\n      });else if (refreshEdge && type === COMBO) {\n        var shapeFactory = item.get('shapeFactory');\n        var shapeType = model.type || 'circle';\n        var comboAnimate = model.animate === undefined || cfg.animate === undefined ? (_b = (_a = shapeFactory[shapeType]) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.animate : model.animate || cfg.animate;\n\n        if (comboAnimate) {\n          setTimeout(function () {\n            if (!item || item.destroyed) return;\n            var keyShape = item.getKeyShape();\n            if (!keyShape || keyShape.destroyed) return;\n            (0, _util.each)(edges_1, function (edge) {\n              if (edge && !edge.destroyed) edge.refresh();\n            });\n          }, 201);\n        } else {\n          (0, _util.each)(edges_1, function (edge) {\n            edge.refresh();\n          });\n        }\n      }\n    }\n\n    graph.emit('afterupdateitem', {\n      item: item,\n      cfg: cfg\n    });\n  };\n  /**\n   * 根据 combo 的子元素更新 combo 的位置及大小\n   *\n   * @param {ICombo} combo ID 或 实例\n   * @returns\n   * @memberof ItemController\n   */\n\n\n  ItemController.prototype.updateCombo = function (combo, children) {\n    var _this = this;\n\n    var _a, _b;\n\n    var graph = this.graph;\n\n    if ((0, _util.isString)(combo)) {\n      combo = graph.findById(combo);\n    }\n\n    if (!combo || combo.destroyed) {\n      return;\n    }\n\n    var model = combo.getModel();\n    var comboBBox = (0, _graphic.getComboBBox)(model.collapsed ? [] : children, graph);\n    combo.set('bbox', comboBBox);\n    combo.update({\n      x: comboBBox.x,\n      y: comboBBox.y\n    });\n    var shapeFactory = combo.get('shapeFactory');\n    var shapeType = model.type || 'circle';\n    var comboAnimate = model.animate === undefined ? (_b = (_a = shapeFactory[shapeType]) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.animate : model.animate;\n\n    if (comboAnimate) {\n      setTimeout(function () {\n        if (!combo || combo.destroyed) return;\n        var keyShape = combo.getKeyShape();\n        if (!keyShape || keyShape.destroyed) return;\n        combo.getShapeCfg(model); // 更新 combo 缓存的 size\n\n        _this.updateComboEdges(combo);\n      }, 201);\n    } else {\n      this.updateComboEdges(combo);\n    }\n  };\n\n  ItemController.prototype.updateComboEdges = function (combo) {\n    var combEdges = combo.getEdges() || [];\n\n    for (var i = 0; i < combEdges.length; i++) {\n      var edge = combEdges[i];\n\n      if (edge && !edge.destroyed) {\n        var edgeSF = edge.get('shapeFactory');\n        var edgeCfg = edge.getShapeCfg(edge.getModel());\n        var edgeGroup = edge.getContainer();\n        edgeGroup.clear();\n        var keyShape = edgeSF.draw(edgeCfg.type, edgeCfg, edgeGroup);\n        edge.set('keyShape', keyShape);\n        keyShape.set('isKeyShape', true);\n        keyShape.set('draggable', true);\n        edge.setOriginStyle();\n      }\n    }\n  };\n  /**\n   * 收起 combo，隐藏相关元素\n   */\n\n\n  ItemController.prototype.collapseCombo = function (combo) {\n    var graph = this.graph;\n\n    if ((0, _util.isString)(combo)) {\n      combo = graph.findById(combo);\n    }\n\n    var children = combo.getChildren();\n    children.nodes.forEach(function (node) {\n      graph.hideItem(node);\n    });\n    children.combos.forEach(function (c) {\n      graph.hideItem(c);\n    });\n  };\n  /**\n   * 展开 combo，相关元素出现\n   * 若子 combo 原先是收起状态，则保持它的收起状态\n   */\n\n\n  ItemController.prototype.expandCombo = function (combo) {\n    var graph = this.graph;\n\n    if ((0, _util.isString)(combo)) {\n      combo = graph.findById(combo);\n    }\n\n    var children = combo.getChildren();\n    children.nodes.forEach(function (node) {\n      graph.showItem(node);\n    });\n    children.combos.forEach(function (c) {\n      if (c.getModel().collapsed) {\n        c.show();\n      } else {\n        graph.showItem(c);\n      }\n    });\n  };\n  /**\n   * 删除指定的节点或边\n   *\n   * @param {Item} item item ID 或实例\n   * @returns {void}\n   * @memberof ItemController\n   */\n\n\n  ItemController.prototype.removeItem = function (item) {\n    var _this = this;\n\n    var graph = this.graph;\n\n    if ((0, _util.isString)(item)) {\n      item = graph.findById(item);\n    }\n\n    if (!item || item.destroyed) {\n      return;\n    }\n\n    var itemModel = (0, _util.clone)(item.getModel());\n    graph.emit('beforeremoveitem', {\n      item: itemModel\n    });\n    var type = '';\n    if (item.getType) type = item.getType();\n    var items = graph.get(type + \"s\");\n    var index = items.indexOf(item);\n    if (index > -1) items.splice(index, 1);\n\n    if (type === EDGE) {\n      var vitems = graph.get(\"v\" + type + \"s\");\n      var vindex = vitems.indexOf(item);\n      if (vindex > -1) vitems.splice(vindex, 1);\n    }\n\n    var itemId = item.get('id');\n    var itemMap = graph.get('itemMap');\n    delete itemMap[itemId];\n    var comboTrees = graph.get('comboTrees');\n    var id = item.get('id');\n\n    if (type === NODE) {\n      var comboId = item.getModel().comboId;\n\n      if (comboTrees && comboId) {\n        var brothers_1 = comboTrees;\n        var found_1 = false; // the flag to terminate the forEach circulation\n        // remove the node from the children array of its parent fromt he tree\n\n        comboTrees.forEach(function (ctree) {\n          if (found_1) return;\n          (0, _graphic.traverseTree)(ctree, function (combo) {\n            if (combo.id === id && brothers_1) {\n              var bidx = brothers_1.indexOf(combo);\n              brothers_1.splice(bidx, 1);\n              found_1 = true;\n              return false; // terminate the traverse\n            }\n\n            brothers_1 = combo.children;\n            return true;\n          });\n        });\n      } // 若移除的是节点，需要将与之相连的边一同删除\n\n\n      var edges = item.getEdges();\n\n      for (var i = edges.length - 1; i >= 0; i--) {\n        graph.removeItem(edges[i], false);\n      }\n\n      if (comboId) graph.updateCombo(comboId);\n    } else if (type === COMBO) {\n      var parentId = item.getModel().parentId;\n      var comboInTree_1; // find the subtree rooted at the item to be removed\n\n      var found_2 = false; // the flag to terminate the forEach circulation\n\n      (comboTrees || []).forEach(function (ctree) {\n        if (found_2) return;\n        (0, _graphic.traverseTree)(ctree, function (combo) {\n          if (combo.id === id) {\n            comboInTree_1 = combo;\n            found_2 = true;\n            return false; // terminate the traverse\n          }\n\n          return true;\n        });\n      });\n      comboInTree_1.removed = true;\n\n      if (comboInTree_1 && comboInTree_1.children) {\n        comboInTree_1.children.forEach(function (child) {\n          _this.removeItem(child.id);\n        });\n      } // 若移除的是 combo，需要将与之相连的边一同删除\n\n\n      var edges = item.getEdges();\n\n      for (var i = edges.length; i >= 0; i--) {\n        graph.removeItem(edges[i], false);\n      }\n\n      if (parentId) graph.updateCombo(parentId);\n    }\n\n    item.destroy();\n    graph.emit('afterremoveitem', {\n      item: itemModel\n    });\n  };\n  /**\n   * 更新 item 状态\n   *\n   * @param {Item} item Item 实例\n   * @param {string} state 状态名称\n   * @param {boolean} value 是否启用状态或状态值\n   * @returns {void}\n   * @memberof ItemController\n   */\n\n\n  ItemController.prototype.setItemState = function (item, state, value) {\n    var graph = this.graph;\n    var stateName = state;\n\n    if ((0, _util.isString)(value)) {\n      stateName = state + \":\" + value;\n    } // 已经存在要设置的 state，或不存在 state 的样式为 undefined\n\n\n    if (item.hasState(stateName) === value && value || // 当该状态已经存在且现在需要设置为 true 时，不需要继续。当该状态不存在，且设置为 false 时，需要继续\n    (0, _util.isString)(value) && item.hasState(stateName)) {\n      // 当该状态 value 是字符串，且已经存在该状态，不需要继续\n      return;\n    }\n\n    graph.emit('beforeitemstatechange', {\n      item: item,\n      state: stateName,\n      enabled: value\n    });\n    item.setState(state, value);\n    graph.autoPaint();\n    graph.emit('afteritemstatechange', {\n      item: item,\n      state: stateName,\n      enabled: value\n    });\n  };\n  /**\n   * 将指定状态的优先级提升为最高优先级\n   * @param {Item} item 元素id或元素实例\n   * @param state 状态名称\n   */\n\n\n  ItemController.prototype.priorityState = function (item, state) {\n    var graph = this.graph;\n    var currentItem = item;\n\n    if ((0, _util.isString)(item)) {\n      currentItem = graph.findById(item);\n    } // 先取消已有的 state\n\n\n    this.setItemState(currentItem, state, false); // 再设置state，则此时该优先级为最高\n\n    this.setItemState(currentItem, state, true);\n  };\n  /**\n   * 清除所有指定的状态\n   *\n   * @param {Item} item Item 实例\n   * @param {string[]} states 状态名称集合\n   * @memberof ItemController\n   */\n\n\n  ItemController.prototype.clearItemStates = function (item, states) {\n    var graph = this.graph;\n\n    if ((0, _util.isString)(item)) {\n      item = graph.findById(item);\n    }\n\n    graph.emit('beforeitemstatesclear', {\n      item: item,\n      states: states\n    });\n    item.clearStates(states);\n    graph.emit('afteritemstatesclear', {\n      item: item,\n      states: states\n    });\n  };\n  /**\n   * 刷新指定的 Item\n   *\n   * @param {Item} item Item ID 或 实例\n   * @memberof ItemController\n   */\n\n\n  ItemController.prototype.refreshItem = function (item) {\n    var graph = this.graph;\n\n    if ((0, _util.isString)(item)) {\n      item = graph.findById(item);\n    }\n\n    graph.emit('beforeitemrefresh', {\n      item: item\n    }); // 调用 Item 的 refresh 方法，实现刷新功能\n\n    item.refresh();\n    graph.emit('afteritemrefresh', {\n      item: item\n    });\n  };\n  /**\n   * 根据 graph 上用 combos 数据生成的 comboTree 来增加所有 combos\n   *\n   * @param {ComboTree[]} comboTrees graph 上用 combos 数据生成的 comboTree\n   * @param {ComboConfig[]} comboModels combos 数据\n   * @memberof ItemController\n   */\n\n\n  ItemController.prototype.addCombos = function (comboTrees, comboModels) {\n    var _this = this;\n\n    var graph = this.graph;\n    (comboTrees || []).forEach(function (ctree) {\n      (0, _graphic.traverseTreeUp)(ctree, function (child) {\n        var comboModel;\n        comboModels.forEach(function (model) {\n          if (model.id === child.id) {\n            model.children = child.children;\n            model.depth = child.depth;\n            comboModel = model;\n          }\n        });\n\n        if (comboModel) {\n          _this.addItem('combo', comboModel);\n        }\n\n        return true;\n      });\n    });\n    var comboGroup = graph.get('comboGroup');\n    if (comboGroup) comboGroup.sort();\n  };\n  /**\n   * 改变Item的显示状态\n   *\n   * @param {Item} item Item ID 或 实例\n   * @param {boolean} visible 是否显示\n   * @memberof ItemController\n   */\n\n\n  ItemController.prototype.changeItemVisibility = function (item, visible) {\n    var _this = this;\n\n    var graph = this.graph;\n\n    if ((0, _util.isString)(item)) {\n      item = graph.findById(item);\n    }\n\n    if (!item) {\n      console.warn('The item to be shown or hidden does not exist!');\n      return;\n    }\n\n    graph.emit('beforeitemvisibilitychange', {\n      item: item,\n      visible: visible\n    });\n    item.changeVisibility(visible);\n\n    if (item.getType && item.getType() === NODE) {\n      var edges = item.getEdges();\n      (0, _util.each)(edges, function (edge) {\n        // 若隐藏节点，则将与之关联的边也隐藏\n        // 若显示节点，则将与之关联的边也显示，但是需要判断边两端的节点都是可见的\n        if (visible && !(edge.get('source').isVisible() && edge.get('target').isVisible())) {\n          return;\n        }\n\n        _this.changeItemVisibility(edge, visible);\n      });\n    } else if (item.getType && item.getType() === COMBO) {\n      var comboTrees = graph.get('comboTrees');\n      var id_1 = item.get('id');\n      var children_1 = [];\n      var found_3 = false; // flag the terminate the forEach\n\n      (comboTrees || []).forEach(function (ctree) {\n        if (found_3) return;\n        if (!ctree.children || ctree.children.length === 0) return;\n        (0, _graphic.traverseTree)(ctree, function (combo) {\n          if (combo.id === id_1) {\n            children_1 = combo.children;\n            found_3 = true;\n            return false; // terminate the traverse\n          }\n\n          return true;\n        });\n      });\n\n      if (children_1 && (!visible || visible && !item.getModel().collapsed)) {\n        children_1.forEach(function (child) {\n          var childItem = graph.findById(child.id);\n\n          _this.changeItemVisibility(childItem, visible);\n        });\n      }\n\n      var edges = item.getEdges();\n      (0, _util.each)(edges, function (edge) {\n        // 若隐藏 combo，则将与 combo 本身关联的边也隐藏\n        // 若显示 combo，则将与 combo 本身关联的边也显示，但是需要判断边两端的节点都是可见的\n        if (visible && !(edge.get('source').isVisible() && edge.get('target').isVisible())) {\n          return;\n        }\n\n        _this.changeItemVisibility(edge, visible);\n      });\n    }\n\n    graph.emit('afteritemvisibilitychange', {\n      item: item,\n      visible: visible\n    });\n    return item;\n  };\n\n  ItemController.prototype.destroy = function () {\n    this.graph = null;\n    this.destroyed = true;\n  };\n\n  return ItemController;\n}();\n\nvar _default = ItemController;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _item = _interopRequireDefault(require(\"./item\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar END_MAP = {\n  source: 'start',\n  target: 'end'\n};\nvar ITEM_NAME_SUFFIX = 'Node'; // 端点的后缀，如 sourceNode, targetNode\n\nvar POINT_NAME_SUFFIX = 'Point'; // 起点或者结束点的后缀，如 startPoint, endPoint\n\nvar ANCHOR_NAME_SUFFIX = 'Anchor';\n\nvar Edge =\n/** @class */\nfunction (_super) {\n  (0, _tslib.__extends)(Edge, _super);\n\n  function Edge() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Edge.prototype.getDefaultCfg = function () {\n    return {\n      type: 'edge',\n      sourceNode: null,\n      targetNode: null,\n      startPoint: null,\n      endPoint: null,\n      linkCenter: false\n    };\n  };\n\n  Edge.prototype.setEnd = function (name, value) {\n    var pointName = END_MAP[name] + POINT_NAME_SUFFIX;\n    var itemName = name + ITEM_NAME_SUFFIX;\n    var preItem = this.get(itemName);\n\n    if (preItem && !preItem.destroyed) {\n      // 如果之前存在节点，则移除掉边\n      preItem.removeEdge(this);\n    }\n\n    if ((0, _util.isPlainObject)(value)) {\n      // 如果设置成具体的点，则清理节点\n      this.set(pointName, value);\n      this.set(itemName, null);\n    } else {\n      value.addEdge(this);\n      this.set(itemName, value);\n      this.set(pointName, null);\n    }\n  };\n  /**\n   * 获取连接点的坐标\n   * @param name source | target\n   * @param model 边的数据模型\n   * @param controlPoints 控制点\n   */\n\n\n  Edge.prototype.getLinkPoint = function (name, model, controlPoints) {\n    var pointName = END_MAP[name] + POINT_NAME_SUFFIX;\n    var itemName = name + ITEM_NAME_SUFFIX;\n    var point = this.get(pointName);\n\n    if (!point) {\n      var item = this.get(itemName);\n      var anchorName = name + ANCHOR_NAME_SUFFIX;\n      var prePoint = this.getPrePoint(name, controlPoints);\n      var anchorIndex = model[anchorName];\n\n      if (!(0, _util.isNil)(anchorIndex)) {\n        // 如果有锚点，则使用锚点索引获取连接点\n        point = item.getLinkPointByAnchor(anchorIndex);\n      } // 如果锚点没有对应的点或者没有锚点，则直接计算连接点\n\n\n      point = point || item.getLinkPoint(prePoint);\n\n      if (!(0, _util.isNil)(point.index)) {\n        this.set(name + \"AnchorIndex\", point.index);\n      }\n    }\n\n    return point;\n  };\n  /**\n   * 获取同端点进行连接的点，计算交汇点\n   * @param name\n   * @param controlPoints\n   */\n\n\n  Edge.prototype.getPrePoint = function (name, controlPoints) {\n    if (controlPoints && controlPoints.length) {\n      var index = name === 'source' ? 0 : controlPoints.length - 1;\n      return controlPoints[index];\n    }\n\n    var oppositeName = name === 'source' ? 'target' : 'source'; // 取另一个节点的位置\n\n    return this.getEndPoint(oppositeName);\n  };\n  /**\n   * 获取端点的位置\n   * @param name\n   */\n\n\n  Edge.prototype.getEndPoint = function (name) {\n    var itemName = name + ITEM_NAME_SUFFIX;\n    var pointName = END_MAP[name] + POINT_NAME_SUFFIX;\n    var item = this.get(itemName); // 如果有端点，直接使用 model\n\n    if (item) {\n      return item.get('model');\n    } // 否则直接使用点\n\n\n    return this.get(pointName);\n  };\n  /**\n   * 通过端点的中心获取控制点\n   * @param model\n   */\n\n\n  Edge.prototype.getControlPointsByCenter = function (model) {\n    var sourcePoint = this.getEndPoint('source');\n    var targetPoint = this.getEndPoint('target');\n    var shapeFactory = this.get('shapeFactory');\n    var type = model.type;\n    return shapeFactory.getControlPoints(type, {\n      startPoint: sourcePoint,\n      endPoint: targetPoint\n    });\n  };\n\n  Edge.prototype.getEndCenter = function (name) {\n    var itemName = name + ITEM_NAME_SUFFIX;\n    var pointName = END_MAP[name] + POINT_NAME_SUFFIX;\n    var item = this.get(itemName); // 如果有端点，直接使用 model\n\n    if (item) {\n      var bbox = item.getBBox();\n      return {\n        x: bbox.centerX,\n        y: bbox.centerY\n      };\n    } // 否则直接使用点\n\n\n    return this.get(pointName);\n  };\n\n  Edge.prototype.init = function () {\n    _super.prototype.init.call(this); // 初始化两个端点\n\n\n    this.setSource(this.get('source'));\n    this.setTarget(this.get('target'));\n  };\n\n  Edge.prototype.getShapeCfg = function (model) {\n    var self = this;\n    var linkCenter = self.get('linkCenter'); // 如果连接到中心，忽视锚点、忽视控制点\n\n    var cfg = _super.prototype.getShapeCfg.call(this, model);\n\n    if (linkCenter) {\n      cfg.startPoint = self.getEndCenter('source');\n      cfg.endPoint = self.getEndCenter('target');\n    } else {\n      var controlPoints = cfg.controlPoints || self.getControlPointsByCenter(cfg);\n      cfg.startPoint = self.getLinkPoint('source', model, controlPoints);\n      cfg.endPoint = self.getLinkPoint('target', model, controlPoints);\n    }\n\n    cfg.sourceNode = self.get('sourceNode');\n    cfg.targetNode = self.get('targetNode');\n    return cfg;\n  };\n  /**\n   * 获取边的数据模型\n   */\n\n\n  Edge.prototype.getModel = function () {\n    var out = this.get('model');\n    var sourceItem = this.get(\"source\" + ITEM_NAME_SUFFIX);\n    var targetItem = this.get(\"target\" + ITEM_NAME_SUFFIX);\n\n    if (sourceItem) {\n      delete out[\"source\" + ITEM_NAME_SUFFIX];\n    } else {\n      out.source = this.get(\"start\" + POINT_NAME_SUFFIX);\n    }\n\n    if (targetItem) {\n      delete out[\"target\" + ITEM_NAME_SUFFIX];\n    } else {\n      out.target = this.get(\"end\" + POINT_NAME_SUFFIX);\n    }\n\n    if (!(0, _util.isString)(out.source) && !(0, _util.isPlainObject)(out.source)) {\n      out.source = out.source.getID();\n    }\n\n    if (!(0, _util.isString)(out.target) && !(0, _util.isPlainObject)(out.target)) {\n      out.target = out.target.getID();\n    }\n\n    return out;\n  };\n\n  Edge.prototype.setSource = function (source) {\n    this.setEnd('source', source);\n    this.set('source', source);\n  };\n\n  Edge.prototype.setTarget = function (target) {\n    this.setEnd('target', target);\n    this.set('target', target);\n  };\n\n  Edge.prototype.getSource = function () {\n    return this.get('source');\n  };\n\n  Edge.prototype.getTarget = function () {\n    return this.get('target');\n  };\n\n  Edge.prototype.updatePosition = function () {\n    return false;\n  };\n  /**\n   * 边不需要重计算容器位置，直接重新计算 path 位置\n   * @param {object} cfg 待更新数据\n   */\n\n\n  Edge.prototype.update = function (cfg, onlyMove) {\n    if (onlyMove === void 0) {\n      onlyMove = false;\n    }\n\n    var model = this.get('model');\n    var oriVisible = model.visible;\n    var cfgVisible = cfg.visible;\n    if (oriVisible !== cfgVisible && cfgVisible !== undefined) this.changeVisibility(cfgVisible);\n    var styles = this.get('styles');\n\n    if (cfg.stateStyles) {\n      // 更新 item 时更新 this.get('styles') 中的值\n      var stateStyles = cfg.stateStyles;\n      (0, _util.mix)(styles, stateStyles);\n      delete cfg.stateStyles;\n    }\n\n    Object.assign(model, cfg);\n    this.updateShape();\n    this.afterUpdate();\n    this.clearCache();\n  };\n\n  Edge.prototype.destroy = function () {\n    var sourceItem = this.get(\"source\" + ITEM_NAME_SUFFIX);\n    var targetItem = this.get(\"target\" + ITEM_NAME_SUFFIX);\n\n    if (sourceItem && !sourceItem.destroyed) {\n      sourceItem.removeEdge(this);\n    }\n\n    if (targetItem && !targetItem.destroyed) {\n      targetItem.removeEdge(this);\n    }\n\n    _super.prototype.destroy.call(this);\n  };\n\n  return Edge;\n}(_item.default);\n\nvar _default = Edge;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _shape = _interopRequireDefault(require(\"../element/shape\"));\n\nvar _graphic = require(\"../util/graphic\");\n\nvar _math = require(\"../util/math\");\n\nvar _base = require(\"../util/base\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar CACHE_BBOX = 'bboxCache';\nvar CACHE_CANVAS_BBOX = 'bboxCanvasCache';\nvar ARROWS = ['startArrow', 'endArrow'];\n\nvar ItemBase =\n/** @class */\nfunction () {\n  function ItemBase(cfg) {\n    this._cfg = {};\n    this.destroyed = false;\n    var defaultCfg = {\n      /**\n       * id\n       * @type {string}\n       */\n      id: undefined,\n\n      /**\n       * 类型\n       * @type {string}\n       */\n      type: 'item',\n\n      /**\n       * data model\n       * @type {object}\n       */\n      model: {},\n\n      /**\n       * g group\n       * @type {G.Group}\n       */\n      group: undefined,\n\n      /**\n       * is open animate\n       * @type {boolean}\n       */\n      animate: false,\n\n      /**\n       * visible - not group visible\n       * @type {boolean}\n       */\n      visible: true,\n\n      /**\n       * locked - lock node\n       * @type {boolean}\n       */\n      locked: false,\n\n      /**\n       * capture event\n       * @type {boolean}\n       */\n      event: true,\n\n      /**\n       * key shape to calculate item's bbox\n       * @type object\n       */\n      keyShape: undefined,\n\n      /**\n       * item's states, such as selected or active\n       * @type Array\n       */\n      states: []\n    };\n    this._cfg = Object.assign(defaultCfg, this.getDefaultCfg(), cfg);\n    var model = this.get('model');\n    var id = model.id;\n    var itemType = this.get('type');\n\n    if (!id) {\n      id = (0, _base.uniqueId)(itemType);\n      this.get('model').id = id;\n    }\n\n    this.set('id', id);\n    var group = cfg.group;\n\n    if (group) {\n      group.set('item', this);\n      group.set('id', id);\n    }\n\n    this.init();\n    this.draw();\n    var shapeType = model.shape || model.type || (itemType === 'edge' ? 'line' : 'circle');\n    var shapeFactory = this.get('shapeFactory');\n\n    if (shapeFactory && shapeFactory[shapeType]) {\n      var options = shapeFactory[shapeType].options; // merge the stateStyles from item and shape\n\n      if (options && options.stateStyles) {\n        var styles = this.get('styles') || model.stateStyles;\n        styles = (0, _util.deepMix)({}, options.stateStyles, styles);\n        this.set('styles', styles);\n      }\n    }\n  }\n  /**\n   * 根据 keyshape 计算包围盒\n   */\n\n\n  ItemBase.prototype.calculateBBox = function () {\n    var keyShape = this.get('keyShape');\n    var group = this.get('group'); // 因为 group 可能会移动，所以必须通过父元素计算才能计算出正确的包围盒\n\n    var bbox = (0, _graphic.getBBox)(keyShape, group);\n    bbox.x = bbox.minX;\n    bbox.y = bbox.minY;\n    bbox.width = bbox.maxX - bbox.minX;\n    bbox.height = bbox.maxY - bbox.minY;\n    bbox.centerX = (bbox.minX + bbox.maxX) / 2;\n    bbox.centerY = (bbox.minY + bbox.maxY) / 2;\n    return bbox;\n  };\n  /**\n   * 根据 keyshape 计算包围盒\n   */\n\n\n  ItemBase.prototype.calculateCanvasBBox = function () {\n    var keyShape = this.get('keyShape');\n    var group = this.get('group'); // 因为 group 可能会移动，所以必须通过父元素计算才能计算出正确的包围盒\n\n    var bbox = (0, _graphic.getBBox)(keyShape, group);\n    bbox.x = bbox.minX;\n    bbox.y = bbox.minY;\n    bbox.width = bbox.maxX - bbox.minX;\n    bbox.height = bbox.maxY - bbox.minY;\n    bbox.centerX = (bbox.minX + bbox.maxX) / 2;\n    bbox.centerY = (bbox.minY + bbox.maxY) / 2;\n    return bbox;\n  };\n  /**\n   * draw shape\n   */\n\n\n  ItemBase.prototype.drawInner = function () {\n    var self = this;\n    var shapeFactory = self.get('shapeFactory');\n    var group = self.get('group');\n    var model = self.get('model');\n    group.clear();\n    var visible = model.visible;\n    if (visible !== undefined && !visible) self.changeVisibility(visible);\n\n    if (!shapeFactory) {\n      return;\n    }\n\n    self.updatePosition(model);\n    var cfg = self.getShapeCfg(model); // 可能会附加额外信息\n\n    var shapeType = cfg.type;\n    var keyShape = shapeFactory.draw(shapeType, cfg, group);\n\n    if (keyShape) {\n      self.set('keyShape', keyShape);\n      keyShape.set('isKeyShape', true);\n      keyShape.set('draggable', true);\n    }\n\n    this.setOriginStyle(); // 防止由于用户外部修改 model 中的 shape 导致 shape 不更新\n\n    this.set('currentShape', shapeType);\n    this.restoreStates(shapeFactory, shapeType);\n  };\n  /**\n   * 设置图元素原始样式\n   * @param keyShape 图元素 keyShape\n   * @param group Group 容器\n   */\n\n\n  ItemBase.prototype.setOriginStyle = function () {\n    var group = this.get('group');\n    var children = group.get('children');\n    var keyShape = this.getKeyShape();\n    var self = this;\n    var keyShapeName = keyShape.get('name');\n\n    if (!this.get('originStyle')) {\n      // 第一次 set originStyle，直接拿首次渲染所有图形的 attrs\n      var originStyles_1 = {};\n      (0, _util.each)(children, function (child) {\n        var shapeType = child.get('type');\n        var name = child.get('name');\n\n        if (name && name !== keyShapeName) {\n          originStyles_1[name] = shapeType !== 'image' ? (0, _util.clone)(child.attr()) : self.getShapeStyleByName(name);\n        } else {\n          // !name || name === keyShape\n          var keyShapeStyle = self.getShapeStyleByName(); // 可优化，需要去除 child.attr 中其他 shape 名的对象\n\n          if (keyShapeStyle.path) delete keyShapeStyle.path;\n          if (keyShapeStyle.matrix) delete keyShapeStyle.matrix;\n\n          if (!keyShapeName) {\n            Object.assign(originStyles_1, keyShapeStyle);\n          } else {\n            // 若 keyShape 有 name 且 !name，这个图形不是 keyShape，给这个图形一个 name\n            if (!name) {\n              var shapeName = (0, _base.uniqueId)('shape');\n              child.set('name', shapeName);\n              originStyles_1[shapeName] = shapeType !== 'image' ? (0, _util.clone)(child.attr()) : self.getShapeStyleByName(name);\n            } else originStyles_1[keyShapeName] = keyShapeStyle;\n          }\n        }\n      });\n      self.set('originStyle', originStyles_1);\n    } else {\n      // 第二次 set originStyles，需要找到不是 stateStyles 的样式，更新到 originStyles 中\n      // 上一次设置的 originStyle，是初始的 shape attrs\n      var styles_1 = this.getOriginStyle(); // let styles: ShapeStyle = {};\n\n      if (keyShapeName && !styles_1[keyShapeName]) styles_1[keyShapeName] = {}; // 获取当前状态样式\n\n      var currentStatesStyle_1 = this.getCurrentStatesStyle(); // 遍历当前所有图形的 attrs，找到不是 stateStyles 的样式更新到 originStyles 中\n\n      (0, _util.each)(children, function (child) {\n        var name = child.get('name');\n        var shapeAttrs = child.attr();\n\n        if (name && name !== keyShapeName) {\n          // 有 name 的非 keyShape 图形\n          var shapeStateStyle_1 = currentStatesStyle_1[name];\n          if (!styles_1[name]) styles_1[name] = {};\n\n          if (shapeStateStyle_1) {\n            Object.keys(shapeAttrs).forEach(function (key) {\n              var value = shapeAttrs[key];\n              if (value !== shapeStateStyle_1[key]) styles_1[name][key] = value;\n            });\n          } else {\n            styles_1[name] = child.get('type') !== 'image' ? (0, _util.clone)(shapeAttrs) : self.getShapeStyleByName(name);\n          }\n        } else {\n          var shapeAttrs_1 = child.attr();\n          var keyShapeStateStyles_1 = (0, _tslib.__assign)((0, _tslib.__assign)({}, currentStatesStyle_1), currentStatesStyle_1[keyShapeName]);\n          Object.keys(shapeAttrs_1).forEach(function (key) {\n            var value = shapeAttrs_1[key]; // 如果是对象且不是 arrow，则是其他 shape 的样式\n            // if (isPlainObject(value) && ARROWS.indexOf(name) === -1) return;\n\n            if (keyShapeStateStyles_1[key] !== value) {\n              if (keyShapeName) styles_1[keyShapeName][key] = value;else styles_1[key] = value;\n            }\n          });\n        }\n      });\n      if (styles_1.path) delete styles_1.path;\n      if (styles_1.matrix) delete styles_1.matrix;\n      if (styles_1.x) delete styles_1.x;\n      if (styles_1.y) delete styles_1.y;\n      if (styles_1[keyShapeName] && styles_1[keyShapeName].x) delete styles_1[keyShapeName].x;\n      if (styles_1[keyShapeName] && styles_1[keyShapeName].y) delete styles_1[keyShapeName].y;\n      self.set('originStyle', styles_1);\n    }\n  };\n  /**\n   * restore shape states\n   * @param shapeFactory\n   * @param shapeType\n   */\n\n\n  ItemBase.prototype.restoreStates = function (shapeFactory, shapeType) {\n    var self = this;\n    var states = self.get('states');\n    (0, _util.each)(states, function (state) {\n      shapeFactory.setState(shapeType, state, true, self);\n    });\n  };\n\n  ItemBase.prototype.init = function () {\n    var shapeFactory = _shape.default.getFactory(this.get('type'));\n\n    this.set('shapeFactory', shapeFactory);\n  };\n  /**\n   * 获取属性\n   * @internal 仅内部类使用\n   * @param  {String} key 属性名\n   * @return {object | string | number} 属性值\n   */\n\n\n  ItemBase.prototype.get = function (key) {\n    return this._cfg[key];\n  };\n  /**\n   * 设置属性\n   * @internal 仅内部类使用\n   * @param {String|Object} key 属性名，也可以是对象\n   * @param {object | string | number} val 属性值\n   */\n\n\n  ItemBase.prototype.set = function (key, val) {\n    if ((0, _util.isPlainObject)(key)) {\n      this._cfg = (0, _tslib.__assign)((0, _tslib.__assign)({}, this._cfg), key);\n    } else {\n      this._cfg[key] = val;\n    }\n  };\n\n  ItemBase.prototype.getDefaultCfg = function () {\n    return {};\n  };\n  /**\n   * 更新/刷新等操作后，清除 cache\n   */\n\n\n  ItemBase.prototype.clearCache = function () {\n    this.set(CACHE_BBOX, null);\n    this.set(CACHE_CANVAS_BBOX, null);\n  };\n  /**\n   * 渲染前的逻辑，提供给子类复写\n   */\n\n\n  ItemBase.prototype.beforeDraw = function () {};\n  /**\n   * 渲染后的逻辑，提供给子类复写\n   */\n\n\n  ItemBase.prototype.afterDraw = function () {};\n  /**\n   * 更新后做一些工作\n   */\n\n\n  ItemBase.prototype.afterUpdate = function () {};\n  /**\n   * draw shape\n   */\n\n\n  ItemBase.prototype.draw = function () {\n    this.beforeDraw();\n    this.drawInner();\n    this.afterDraw();\n  };\n\n  ItemBase.prototype.getShapeStyleByName = function (name) {\n    var group = this.get('group');\n    var currentShape;\n\n    if (name) {\n      currentShape = group.find(function (element) {\n        return element.get('name') === name;\n      });\n    } else {\n      currentShape = this.getKeyShape();\n    }\n\n    if (currentShape) {\n      var styles_2 = {};\n      (0, _util.each)(currentShape.attr(), function (val, key) {\n        // 修改 img 通过 updateItem 实现\n        if (key !== 'img') {\n          styles_2[key] = val;\n        }\n      });\n      return styles_2;\n    }\n\n    return {};\n  };\n\n  ItemBase.prototype.getShapeCfg = function (model) {\n    var styles = this.get('styles');\n\n    if (styles) {\n      // merge graph的item样式与数据模型中的样式\n      var newModel = model;\n      newModel.style = (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), model.style);\n      return newModel;\n    }\n\n    return model;\n  };\n  /**\n   * 获取指定状态的样式，去除了全局样式\n   * @param state 状态名称\n   */\n\n\n  ItemBase.prototype.getStateStyle = function (state) {\n    var styles = this.get('styles');\n    var stateStyle = styles && styles[state];\n    return stateStyle;\n  };\n  /**\n   * get keyshape style\n   */\n\n\n  ItemBase.prototype.getOriginStyle = function () {\n    return this.get('originStyle');\n  };\n\n  ItemBase.prototype.getCurrentStatesStyle = function () {\n    var self = this;\n    var styles = {};\n    var states = self.getStates();\n\n    if (!states || !states.length) {\n      return this.getOriginStyle();\n    }\n\n    (0, _util.each)(self.getStates(), function (state) {\n      styles = Object.assign(styles, self.getStateStyle(state));\n    });\n    return styles;\n  };\n  /**\n   * 更改元素状态， visible 不属于这个范畴\n   * @internal 仅提供内部类 graph 使用\n   * @param {String} state 状态名\n   * @param {Boolean} value 节点状态值\n   */\n\n\n  ItemBase.prototype.setState = function (state, value) {\n    var states = this.get('states');\n    var shapeFactory = this.get('shapeFactory');\n    var stateName = state;\n    var filterStateName = state;\n\n    if ((0, _util.isString)(value)) {\n      stateName = state + \":\" + value;\n      filterStateName = state + \":\";\n    }\n\n    var newStates = states;\n\n    if ((0, _util.isBoolean)(value)) {\n      var index = states.indexOf(filterStateName);\n\n      if (value) {\n        if (index > -1) {\n          return;\n        }\n\n        states.push(stateName);\n      } else if (index > -1) {\n        states.splice(index, 1);\n      }\n    } else if ((0, _util.isString)(value)) {\n      // 过滤掉 states 中 filterStateName 相关的状态\n      var filterStates = states.filter(function (name) {\n        return name.includes(filterStateName);\n      });\n\n      if (filterStates.length > 0) {\n        this.clearStates(filterStates);\n      }\n\n      newStates = newStates.filter(function (name) {\n        return !name.includes(filterStateName);\n      });\n      newStates.push(stateName);\n      this.set('states', newStates);\n    }\n\n    if (shapeFactory) {\n      var model = this.get('model');\n      var type = model.type; // 调用 shape/shape.ts 中的 setState\n\n      shapeFactory.setState(type, state, value, this);\n    }\n  };\n  /**\n   * 清除指定的状态，如果参数为空，则不做任务处理\n   * @param states 状态名称\n   */\n\n\n  ItemBase.prototype.clearStates = function (states) {\n    var self = this;\n    var originStates = self.getStates();\n    var shapeFactory = self.get('shapeFactory');\n    var model = self.get('model');\n    var shape = model.type;\n\n    if (!states) {\n      states = originStates;\n    }\n\n    if ((0, _util.isString)(states)) {\n      states = [states];\n    }\n\n    var newStates = originStates.filter(function (state) {\n      return states.indexOf(state) === -1;\n    });\n    self.set('states', newStates);\n    states.forEach(function (state) {\n      shapeFactory.setState(shape, state, false, self);\n    });\n  };\n  /**\n   * 节点的图形容器\n   * @return {G.Group} 图形容器\n   */\n\n\n  ItemBase.prototype.getContainer = function () {\n    return this.get('group');\n  };\n  /**\n   * 节点的关键形状，用于计算节点大小，连线截距等\n   * @return {IShapeBase} 关键形状\n   */\n\n\n  ItemBase.prototype.getKeyShape = function () {\n    return this.get('keyShape');\n  };\n  /**\n   * 节点数据模型\n   * @return {Object} 数据模型\n   */\n\n\n  ItemBase.prototype.getModel = function () {\n    return this.get('model');\n  };\n  /**\n   * 节点类型\n   * @return {string} 节点的类型\n   */\n\n\n  ItemBase.prototype.getType = function () {\n    return this.get('type');\n  };\n  /**\n   * 获取 Item 的ID\n   */\n\n\n  ItemBase.prototype.getID = function () {\n    return this.get('id');\n  };\n  /**\n   * 是否是 Item 对象，悬空边情况下进行判定\n   */\n\n\n  ItemBase.prototype.isItem = function () {\n    return true;\n  };\n  /**\n   * 获取当前元素的所有状态\n   * @return {Array} 元素的所有状态\n   */\n\n\n  ItemBase.prototype.getStates = function () {\n    return this.get('states');\n  };\n  /**\n   * 当前元素是否处于某状态\n   * @param {String} state 状态名\n   * @return {Boolean} 是否处于某状态\n   */\n\n\n  ItemBase.prototype.hasState = function (state) {\n    var states = this.getStates();\n    return states.indexOf(state) >= 0;\n  };\n  /**\n   * 刷新一般用于处理几种情况\n   * 1. item model 在外部被改变\n   * 2. 边的节点位置发生改变，需要重新计算边\n   *\n   * 因为数据从外部被修改无法判断一些属性是否被修改，直接走位置和 shape 的更新\n   */\n\n\n  ItemBase.prototype.refresh = function () {\n    var model = this.get('model'); // 更新元素位置\n\n    this.updatePosition(model); // 更新元素内容，样式\n\n    this.updateShape(); // 做一些更新之后的操作\n\n    this.afterUpdate(); // 清除缓存\n\n    this.clearCache();\n  };\n\n  ItemBase.prototype.isOnlyMove = function (cfg) {\n    return false;\n  };\n  /**\n   * 将更新应用到 model 上，刷新属性\n   * @internal 仅提供给 Graph 使用，外部直接调用 graph.update 接口\n   * @param  {Object} cfg       配置项，可以是增量信息\n   */\n\n\n  ItemBase.prototype.update = function (cfg, onlyMove) {\n    if (onlyMove === void 0) {\n      onlyMove = false;\n    }\n\n    var model = this.get('model');\n    var oriVisible = model.visible;\n    var cfgVisible = cfg.visible;\n    if (oriVisible !== cfgVisible && cfgVisible !== undefined) this.changeVisibility(cfgVisible);\n    var originPosition = {\n      x: model.x,\n      y: model.y\n    };\n    cfg.x = isNaN(cfg.x) ? model.x : cfg.x;\n    cfg.y = isNaN(cfg.y) ? model.y : cfg.y;\n    var styles = this.get('styles');\n\n    if (cfg.stateStyles) {\n      // 更新 item 时更新 this.get('styles') 中的值\n      var stateStyles = cfg.stateStyles;\n      (0, _util.mix)(styles, stateStyles);\n      delete cfg.stateStyles;\n    } // 直接将更新合到原数据模型上，可以保证用户在外部修改源数据然后刷新时的样式符合期待。\n\n\n    Object.assign(model, cfg); // isOnlyMove 仅用于node\n    // const onlyMove = this.isOnlyMove(cfg);\n    // 仅仅移动位置时，既不更新，也不重绘\n\n    if (onlyMove) {\n      this.updatePosition(cfg);\n    } else {\n      // 如果 x,y 有变化，先重置位置\n      if (originPosition.x !== cfg.x || originPosition.y !== cfg.y) {\n        this.updatePosition(cfg);\n      }\n\n      this.updateShape();\n    }\n\n    this.afterUpdate();\n    this.clearCache();\n  };\n  /**\n   * 更新元素内容，样式\n   */\n\n\n  ItemBase.prototype.updateShape = function () {\n    var shapeFactory = this.get('shapeFactory');\n    var model = this.get('model');\n    var shape = model.type; // 判定是否允许更新\n    // 1. 注册的节点允许更新\n    // 2. 更新后的 shape 等于原先的 shape\n\n    if (shapeFactory.shouldUpdate(shape) && shape === this.get('currentShape')) {\n      var updateCfg = this.getShapeCfg(model);\n      shapeFactory.baseUpdate(shape, updateCfg, this); // 更新完以后重新设置原始样式\n\n      this.setOriginStyle();\n    } else {\n      // 如果不满足上面两种状态，重新绘制\n      this.draw();\n    } // 更新后重置节点状态\n\n\n    this.restoreStates(shapeFactory, shape);\n  };\n  /**\n   * 更新位置，避免整体重绘\n   * @param {object} cfg 待更新数据\n   */\n\n\n  ItemBase.prototype.updatePosition = function (cfg) {\n    var model = this.get('model');\n    var x = (0, _util.isNil)(cfg.x) ? model.x : cfg.x;\n    var y = (0, _util.isNil)(cfg.y) ? model.y : cfg.y;\n    var group = this.get('group');\n\n    if ((0, _util.isNil)(x) || (0, _util.isNil)(y)) {\n      return false;\n    }\n\n    model.x = x;\n    model.y = y;\n    var matrix = group.getMatrix();\n    if (matrix && matrix[6] === x && matrix[7] === y) return false;\n    group.resetMatrix(); // G 4.0 element 中移除了矩阵相关方法，详见https://www.yuque.com/antv/blog/kxzk9g#4rMMV\n\n    (0, _math.translate)(group, {\n      x: x,\n      y: y\n    });\n    this.clearCache(); // 位置更新后需要清除缓存\n\n    return true;\n  };\n  /**\n   * 获取 item 的包围盒，这个包围盒是相对于 item 自己，不会将 matrix 计算在内\n   * @return {Object} 包含 x,y,width,height, centerX, centerY\n   */\n\n\n  ItemBase.prototype.getBBox = function () {\n    // 计算 bbox 开销有些大，缓存\n    var bbox = this.get(CACHE_BBOX);\n\n    if (!bbox) {\n      bbox = this.calculateBBox();\n      this.set(CACHE_BBOX, bbox);\n    }\n\n    return bbox;\n  };\n  /**\n   * 获取 item 相对于画布的包围盒，会将从顶层到当前元素的 matrix 都计算在内\n   * @return {Object} 包含 x,y,width,height, centerX, centerY\n   */\n\n\n  ItemBase.prototype.getCanvasBBox = function () {\n    // 计算 bbox 开销有些大，缓存\n    var bbox = this.get(CACHE_CANVAS_BBOX);\n\n    if (!bbox) {\n      bbox = this.calculateCanvasBBox();\n      this.set(CACHE_CANVAS_BBOX, bbox);\n    }\n\n    return bbox;\n  };\n  /**\n   * 将元素放到最前面\n   */\n\n\n  ItemBase.prototype.toFront = function () {\n    var group = this.get('group');\n    group.toFront();\n  };\n  /**\n   * 将元素放到最后面\n   */\n\n\n  ItemBase.prototype.toBack = function () {\n    var group = this.get('group');\n    group.toBack();\n  };\n  /**\n   * 显示元素\n   */\n\n\n  ItemBase.prototype.show = function () {\n    this.changeVisibility(true);\n  };\n  /**\n   * 隐藏元素\n   */\n\n\n  ItemBase.prototype.hide = function () {\n    this.changeVisibility(false);\n  };\n  /**\n   * 更改是否显示\n   * @param  {Boolean} visible 是否显示\n   */\n\n\n  ItemBase.prototype.changeVisibility = function (visible) {\n    var group = this.get('group');\n\n    if (visible) {\n      group.show();\n    } else {\n      group.hide();\n    }\n\n    this.set('visible', visible);\n  };\n  /**\n   * 元素是否可见\n   * @return {Boolean} 返回该元素是否可见\n   */\n\n\n  ItemBase.prototype.isVisible = function () {\n    return this.get('visible');\n  };\n  /**\n   * 是否拾取及出发该元素的交互事件\n   * @param {Boolean} enable 标识位\n   */\n\n\n  ItemBase.prototype.enableCapture = function (enable) {\n    var group = this.get('group');\n\n    if (group) {\n      group.set('capture', enable);\n    }\n  };\n\n  ItemBase.prototype.destroy = function () {\n    if (!this.destroyed) {\n      var animate = this.get('animate');\n      var group = this.get('group');\n\n      if (animate) {\n        group.stopAnimate();\n      }\n\n      this.clearCache();\n      group.remove();\n      this._cfg = null;\n      this.destroyed = true;\n    }\n  };\n\n  return ItemBase;\n}();\n\nvar _default = ItemBase;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.ShapeFactoryBase = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _xml = require(\"./xml\");\n\nvar cache = {}; // ucfirst 开销过大，进行缓存\n// 首字母大写\n\nfunction ucfirst(str) {\n  if (!cache[str]) {\n    cache[str] = (0, _util.upperFirst)(str);\n  }\n\n  return cache[str];\n}\n/**\n * 工厂方法的基类\n * @type Shape.FactoryBase\n */\n\n\nvar ShapeFactoryBase = {\n  /**\n   * 默认的形状，当没有指定/匹配 shapeType 时，使用默认的\n   * @type {String}\n   */\n  defaultShapeType: 'defaultType',\n\n  /**\n   * 形状的 className，用于搜索\n   * @type {String}\n   */\n  className: null,\n\n  /**\n   * 获取绘制 Shape 的工具类，无状态\n   * @param  {String} type 类型\n   * @return {Shape} 工具类\n   */\n  getShape: function getShape(type) {\n    var self = this;\n    var shape = self[type] || self[self.defaultShapeType] || self['simple-circle'];\n    return shape;\n  },\n\n  /**\n   * 绘制图形\n   * @param  {String} type  类型\n   * @param  {Object} cfg 配置项\n   * @param  {G.Group} group 图形的分组\n   * @return {IShape} 图形对象\n   */\n  draw: function draw(type, cfg, group) {\n    var shape = this.getShape(type);\n    var rst = shape.draw(cfg, group);\n\n    if (shape.afterDraw) {\n      shape.afterDraw(cfg, group, rst);\n    }\n\n    return rst;\n  },\n\n  /**\n   * 更新\n   * @param  {String} type  类型\n   * @param  {Object} cfg 配置项\n   * @param  {G6.Item} item 节点、边、分组等\n   */\n  baseUpdate: function baseUpdate(type, cfg, item) {\n    var shape = this.getShape(type);\n\n    if (shape.update) {\n      // 防止没定义 update 函数\n      shape.update(cfg, item);\n    }\n\n    if (shape.afterUpdate) {\n      shape.afterUpdate(cfg, item);\n    }\n  },\n\n  /**\n   * 设置状态\n   * @param {String} type  类型\n   * @param {String} name  状态名\n   * @param {String | Boolean} value 状态值\n   * @param {G6.Item} item  节点、边、分组等\n   */\n  setState: function setState(type, name, value, item) {\n    var shape = this.getShape(type); // 调用 shape/shapeBase.ts 中的 setState 方法\n\n    shape.setState(name, value, item);\n  },\n\n  /**\n   * 是否允许更新，不重新绘制图形\n   * @param  {String} type 类型\n   * @return {Boolean} 是否允许使用更新\n   */\n  shouldUpdate: function shouldUpdate(type) {\n    var shape = this.getShape(type);\n    return !!shape.update;\n  },\n  getControlPoints: function getControlPoints(type, cfg) {\n    var shape = this.getShape(type);\n    return shape.getControlPoints(cfg);\n  },\n\n  /**\n   * 获取控制点\n   * @param {String} type 节点、边类型\n   * @param  {Object} cfg 节点、边的配置项\n   * @return {Array|null} 控制点的数组,如果为 null，则没有控制点\n   */\n  getAnchorPoints: function getAnchorPoints(type, cfg) {\n    var shape = this.getShape(type);\n    return shape.getAnchorPoints(cfg);\n  }\n};\n/**\n * 元素的框架\n */\n\nexports.ShapeFactoryBase = ShapeFactoryBase;\nvar ShapeFramework = {\n  // 默认样式及配置\n  options: {},\n\n  /**\n   * 绘制\n   */\n  draw: function draw(cfg, group) {\n    return this.drawShape(cfg, group);\n  },\n\n  /**\n   * 绘制\n   */\n  drawShape: function drawShape()\n  /* cfg, group */\n  {},\n\n  /**\n   * 绘制完成后的操作，便于用户继承现有的节点、边\n   */\n  afterDraw: function afterDraw()\n  /* cfg, group */\n  {},\n  // update(cfg, item) // 默认不定义\n  afterUpdate: function afterUpdate()\n  /* cfg, item */\n  {},\n\n  /**\n   * 设置节点、边状态\n   */\n  setState: function setState()\n  /* name, value, item */\n  {},\n\n  /**\n   * 获取控制点\n   * @param  {Object} cfg 节点、边的配置项\n   * @return {Array|null} 控制点的数组,如果为 null，则没有控制点\n   */\n  getControlPoints: function getControlPoints(cfg) {\n    return cfg.controlPoints;\n  },\n\n  /**\n   * 获取控制点\n   * @param  {Object} cfg 节点、边的配置项\n   * @return {Array|null} 控制点的数组,如果为 null，则没有控制点\n   */\n  getAnchorPoints: function getAnchorPoints(cfg) {\n    var defaultAnchorPoints = this.options.anchorPoints;\n    var anchorPoints = cfg.anchorPoints || defaultAnchorPoints;\n    return anchorPoints;\n  }\n  /* 如果没定义 update 方法，每次都调用 draw 方法\n  update(cfg, item) {\n     }\n  */\n\n};\n\nvar Shape =\n/** @class */\nfunction () {\n  function Shape() {}\n\n  Shape.registerFactory = function (factoryType, cfg) {\n    var className = ucfirst(factoryType);\n    var factoryBase = ShapeFactoryBase;\n    var shapeFactory = (0, _tslib.__assign)((0, _tslib.__assign)({}, factoryBase), cfg);\n    Shape[className] = shapeFactory;\n    shapeFactory.className = className;\n    return shapeFactory;\n  };\n\n  Shape.getFactory = function (factoryType) {\n    var className = ucfirst(factoryType);\n    return Shape[className];\n  };\n\n  Shape.registerNode = function (shapeType, nodeDefinition, extendShapeType) {\n    var shapeFactory = Shape.Node;\n    var shapeObj;\n\n    if (typeof nodeDefinition === 'string' || typeof nodeDefinition === 'function') {\n      var autoNodeDefinition = (0, _xml.createNodeFromXML)(nodeDefinition);\n      shapeObj = (0, _tslib.__assign)((0, _tslib.__assign)({}, shapeFactory.getShape('single-node')), autoNodeDefinition);\n    } else if (nodeDefinition.jsx) {\n      var jsx = nodeDefinition.jsx;\n      var autoNodeDefinition = (0, _xml.createNodeFromXML)(jsx);\n      shapeObj = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, shapeFactory.getShape('single-node')), autoNodeDefinition), nodeDefinition);\n    } else {\n      shapeFactory.getShape(extendShapeType);\n      var extendShape = extendShapeType ? shapeFactory.getShape(extendShapeType) : ShapeFramework;\n      shapeObj = (0, _tslib.__assign)((0, _tslib.__assign)({}, extendShape), nodeDefinition);\n    }\n\n    shapeObj.type = shapeType;\n    shapeObj.itemType = 'node';\n    shapeFactory[shapeType] = shapeObj;\n    return shapeObj;\n  };\n\n  Shape.registerEdge = function (shapeType, edgeDefinition, extendShapeType) {\n    var shapeFactory = Shape.Edge;\n    var extendShape = extendShapeType ? shapeFactory.getShape(extendShapeType) : ShapeFramework;\n    var shapeObj = (0, _tslib.__assign)((0, _tslib.__assign)({}, extendShape), edgeDefinition);\n    shapeObj.type = shapeType;\n    shapeObj.itemType = 'edge';\n    shapeFactory[shapeType] = shapeObj;\n    return shapeObj;\n  };\n\n  Shape.registerCombo = function (shapeType, comboDefinition, extendShapeType) {\n    var shapeFactory = Shape.Combo;\n    var extendShape = extendShapeType ? shapeFactory.getShape(extendShapeType) : ShapeFramework;\n    var shapeObj = (0, _tslib.__assign)((0, _tslib.__assign)({}, extendShape), comboDefinition);\n    shapeObj.type = shapeType;\n    shapeObj.itemType = 'combo';\n    shapeFactory[shapeType] = shapeObj;\n    return shapeObj;\n  };\n\n  return Shape;\n}();\n\nvar _default = Shape; // 注册 Node 的工厂方法\n\nexports.default = _default;\nShape.registerFactory('node', {\n  defaultShapeType: 'circle'\n}); // 注册 Edge 的工厂方法\n\nShape.registerFactory('edge', {\n  defaultShapeType: 'line'\n}); // 注册 Combo 的工厂方法\n\nShape.registerFactory('combo', {\n  defaultShapeType: 'circle'\n});","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseXML = parseXML;\nexports.getBBox = getBBox;\nexports.generateTarget = generateTarget;\nexports.compareTwoTarget = compareTwoTarget;\nexports.createNodeFromXML = createNodeFromXML;\nexports.xmlDataRenderer = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _graphic = require(\"../util/graphic\");\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * 一种更宽松的JSON 解析，如果遇到不符合规范的字段会直接转为字符串\n * @param text json 内容\n */\nfunction looseJSONParse(text) {\n  if (typeof text !== 'string') {\n    return text;\n  }\n\n  var safeParse = function safeParse(str) {\n    if (typeof str !== 'string') {\n      return str;\n    }\n\n    try {\n      return JSON.parse(str.trim());\n    } catch (e) {\n      return str.trim();\n    }\n  };\n\n  var firstAttempt = safeParse(text);\n\n  if (typeof firstAttempt !== 'string') {\n    return firstAttempt;\n  }\n\n  var tail = function tail(arr) {\n    return arr[arr.length - 1];\n  };\n\n  var str = text.trim();\n  var objectStack = [];\n  var syntaxStack = [];\n\n  var isLastPair = function isLastPair() {\n    var syntaxes = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      syntaxes[_i] = arguments[_i];\n    }\n\n    return syntaxes.some(function (syntax) {\n      return tail(syntaxStack) === syntax;\n    });\n  };\n\n  var getValueStore = function getValueStore() {\n    return tail(objectStack);\n  };\n\n  var rst = null;\n  var i = 0;\n  var temp = '';\n\n  while (i < str.length) {\n    var nowChar = str[i];\n    var isInString = isLastPair('\"', \"'\");\n\n    if (!isInString && !nowChar.trim()) {\n      i += 1;\n      continue;\n    }\n\n    var isLastTranslate = str[i - 1] === '\\\\';\n    var isInObject = isLastPair('}');\n    var isInArray = isLastPair(']');\n    var isWaitingValue = isLastPair(',');\n    var tempArr = getValueStore();\n\n    if (isInString) {\n      if (tail(syntaxStack) === nowChar && !isLastTranslate) {\n        syntaxStack.pop();\n        var value = safeParse(temp);\n        tempArr.push(value);\n        rst = value;\n        temp = '';\n      } else {\n        temp += nowChar;\n      }\n    } else if (isInArray && nowChar === ',') {\n      if (temp) {\n        tempArr.push(safeParse(temp));\n        temp = '';\n      }\n    } else if (isInObject && nowChar === ':') {\n      syntaxStack.push(',');\n\n      if (temp) {\n        tempArr.push(temp);\n        temp = '';\n      }\n    } else if (isWaitingValue && nowChar === ',') {\n      if (temp) {\n        tempArr.push(safeParse(temp));\n        temp = '';\n      }\n\n      syntaxStack.pop();\n    } else if (nowChar === '}' && (isInObject || isWaitingValue)) {\n      if (temp) {\n        tempArr.push(safeParse(temp));\n        temp = '';\n      }\n\n      if (isWaitingValue) {\n        syntaxStack.pop();\n      }\n\n      var obj = {};\n\n      for (var c = 1; c < tempArr.length; c += 2) {\n        obj[tempArr[c - 1]] = tempArr[c];\n      }\n\n      objectStack.pop();\n\n      if (objectStack.length) {\n        tail(objectStack).push(obj);\n      }\n\n      syntaxStack.pop();\n      rst = obj;\n    } else if (nowChar === ']' && isInArray) {\n      if (temp) {\n        tempArr.push(safeParse(temp));\n        temp = '';\n      }\n\n      objectStack.pop();\n\n      if (objectStack.length) {\n        tail(objectStack).push(tempArr);\n      }\n\n      syntaxStack.pop();\n      rst = tempArr;\n    } else if (nowChar === '{') {\n      objectStack.push([]);\n      syntaxStack.push('}');\n    } else if (nowChar === '[') {\n      objectStack.push([]);\n      syntaxStack.push(']');\n    } else if (nowChar === '\"') {\n      syntaxStack.push('\"');\n    } else if (nowChar === \"'\") {\n      syntaxStack.push(\"'\");\n    } else {\n      temp += nowChar;\n    }\n\n    i += 1;\n  }\n\n  return rst || temp;\n}\n\nvar keyConvert = function keyConvert(str) {\n  return str.split('-').reduce(function (a, b) {\n    return a + b.charAt(0).toUpperCase() + b.slice(1);\n  });\n};\n/**\n * 简单的一个{{}}模板渲染，不包含任何复杂语法\n * @param xml\n */\n\n\nvar xmlDataRenderer = function xmlDataRenderer(xml) {\n  return function (data) {\n    var len = xml.length;\n    var arr = [];\n    var i = 0;\n    var tmp = '';\n\n    while (i < len) {\n      if (xml[i] === '{' && xml[i + 1] === '{') {\n        arr.push(tmp);\n        tmp = '';\n        i += 2;\n      } else if (xml[i] === '}' && xml[i + 1] === '}') {\n        if (arr.length) {\n          var last = arr.pop();\n          tmp = (0, _util.get)(data, tmp, last.endsWith('=') ? \"\\\"{\" + tmp + \"}\\\"\" : tmp);\n          arr.push(last + tmp);\n        }\n\n        i += 2;\n        tmp = '';\n      } else {\n        tmp += xml[i];\n        i += 1;\n      }\n    }\n\n    arr.push(tmp);\n    return arr.map(function (e, index) {\n      return arr[index - 1] && arr[index - 1].endsWith('=') ? \"\\\"{\" + e + \"}\\\"\" : e;\n    }).join('');\n  };\n};\n/**\n * 解析XML，并转化为相应的JSON结构\n * @param xml xml解析后的节点\n */\n\n\nexports.xmlDataRenderer = xmlDataRenderer;\n\nfunction parseXML(xml, cfg) {\n  var attrs = {};\n  var keys = xml.getAttributeNames && xml.getAttributeNames() || [];\n  var children = xml.children && Array.from(xml.children).map(function (e) {\n    return parseXML(e, cfg);\n  });\n  var rst = {};\n  var tagName = xml.tagName ? xml.tagName.toLowerCase() : 'group';\n\n  if (tagName === 'text') {\n    attrs.text = xml.innerText;\n  }\n\n  rst.type = tagName;\n\n  if (tagName === 'img') {\n    rst.type = 'image';\n  }\n\n  Array.from(keys).forEach(function (k) {\n    var key = keyConvert(k);\n    var val = xml.getAttribute(k);\n\n    try {\n      if (key === 'style' || key === 'attrs') {\n        var style = looseJSONParse(val);\n        attrs = (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), style);\n      } else {\n        rst[key] = looseJSONParse(val);\n      }\n    } catch (e) {\n      if (key === 'style') {\n        throw e;\n      }\n\n      rst[key] = val;\n    }\n  });\n  rst.attrs = attrs;\n\n  if (cfg && cfg.style && rst.name && _typeof(cfg.style[rst.name]) === 'object') {\n    rst.attrs = (0, _tslib.__assign)((0, _tslib.__assign)({}, rst.attrs), cfg.style[rst.name]);\n  }\n\n  if (cfg && cfg.style && rst.keyshape) {\n    rst.attrs = (0, _tslib.__assign)((0, _tslib.__assign)({}, rst.attrs), cfg.style);\n  }\n\n  if (children.length) {\n    rst.children = children;\n  }\n\n  return rst;\n}\n/**\n * 根据偏移量和内部节点最终的bounding box来得出该shape最终的bbox\n */\n\n\nfunction getBBox(node, offset, chilrenBBox) {\n  var _a = node.attrs,\n      attrs = _a === void 0 ? {} : _a;\n  var bbox = {\n    x: offset.x || 0,\n    y: offset.y || 0,\n    width: chilrenBBox.width || 0,\n    height: chilrenBBox.height || 0\n  };\n  var shapeHeight, shapeWidth;\n\n  switch (node.type) {\n    case 'maker':\n    case 'circle':\n      if (attrs.r) {\n        shapeWidth = 2 * attrs.r;\n        shapeHeight = 2 * attrs.r;\n      }\n\n      break;\n\n    case 'text':\n      if (attrs.text) {\n        shapeWidth = (0, _graphic.getTextSize)(attrs.text, attrs.fontSize || 12)[0];\n        shapeHeight = 16;\n        bbox.y += shapeHeight;\n        bbox.height = shapeHeight;\n        bbox.width = shapeWidth;\n        node.attrs = (0, _tslib.__assign)({\n          fontSize: 12,\n          fill: '#000'\n        }, attrs);\n      }\n\n      break;\n\n    default:\n      if (attrs.width) {\n        shapeWidth = attrs.width;\n      }\n\n      if (attrs.height) {\n        shapeHeight = attrs.height;\n      }\n\n  }\n\n  if (shapeHeight >= 0) {\n    bbox.height = shapeHeight;\n  }\n\n  if (shapeWidth >= 0) {\n    bbox.width = shapeWidth;\n  }\n\n  if (attrs.marginTop) {\n    bbox.y += attrs.marginTop;\n  }\n\n  if (attrs.marginLeft) {\n    bbox.x += attrs.marginLeft;\n  }\n\n  return bbox;\n}\n/**\n * 把从xml计算出的结构填上位置信息，补全attrs\n * @param target\n * @param lastOffset\n */\n\n\nfunction generateTarget(target, lastOffset) {\n  var _a;\n\n  if (lastOffset === void 0) {\n    lastOffset = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var defaultBbox = (0, _tslib.__assign)({\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  }, lastOffset);\n\n  if ((_a = target.children) === null || _a === void 0 ? void 0 : _a.length) {\n    var _b = target.attrs,\n        attrs = _b === void 0 ? {} : _b;\n    var marginTop = attrs.marginTop;\n    var offset = (0, _tslib.__assign)({}, lastOffset);\n\n    if (marginTop) {\n      offset.y += marginTop;\n    }\n\n    for (var index = 0; index < target.children.length; index++) {\n      target.children[index].attrs.key = (attrs.key || 'root') + \" -\" + index + \" \";\n      var node = generateTarget(target.children[index], offset);\n\n      if (node.bbox) {\n        var bbox = node.bbox;\n\n        if (node.attrs.next === 'inline') {\n          offset.x += node.bbox.width;\n        } else {\n          offset.y += node.bbox.height;\n        }\n\n        if (bbox.width + bbox.x > defaultBbox.width) {\n          defaultBbox.width = bbox.width + bbox.x;\n        }\n\n        if (bbox.height + bbox.y > defaultBbox.height) {\n          defaultBbox.height = bbox.height + bbox.y;\n        }\n      }\n    }\n  }\n\n  target.bbox = getBBox(target, lastOffset, defaultBbox);\n  target.attrs = (0, _tslib.__assign)((0, _tslib.__assign)({}, target.attrs), target.bbox);\n  return target;\n}\n/**\n * 对比前后两个最终计算出来的node，并对比出最小改动,\n * 动作： 'add' 添加节点 ｜ ’delete‘ 删除节点 ｜ ’change‘ 改变节点attrs ｜ 'restructure' 重构节点\n * @param nowTarget\n * @param formerTarget\n */\n\n\nfunction compareTwoTarget(nowTarget, formerTarget) {\n  var _a, _b, _c, _d;\n\n  var type = (nowTarget || {}).type;\n  var key = ((formerTarget === null || formerTarget === void 0 ? void 0 : formerTarget.attrs) || {}).key;\n\n  if (key && nowTarget) {\n    nowTarget.attrs.key = key;\n  }\n\n  if (!nowTarget && formerTarget) {\n    return {\n      action: 'delete',\n      val: formerTarget,\n      type: type,\n      key: key\n    };\n  }\n\n  if (nowTarget && !formerTarget) {\n    return {\n      action: 'add',\n      val: nowTarget,\n      type: type\n    };\n  }\n\n  if (!nowTarget && !formerTarget) {\n    return {\n      action: 'same',\n      type: type\n    };\n  }\n\n  var children = [];\n\n  if (((_a = nowTarget.children) === null || _a === void 0 ? void 0 : _a.length) > 0 || ((_b = formerTarget.children) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n    var length_1 = Math.max((_c = nowTarget.children) === null || _c === void 0 ? void 0 : _c.length, (_d = formerTarget.children) === null || _d === void 0 ? void 0 : _d.length);\n    var formerChilren = formerTarget.children || [];\n    var nowChilren = nowTarget.children || [];\n\n    for (var index = 0; index < length_1; index += 1) {\n      children.push(compareTwoTarget(nowChilren[index], formerChilren[index]));\n    }\n  }\n\n  var formerKeys = Object.keys(formerTarget.attrs);\n  var nowKeys = Object.keys(nowTarget.attrs);\n\n  if (formerTarget.type !== nowTarget.type) {\n    return {\n      action: 'restructure',\n      nowTarget: nowTarget,\n      formerTarget: formerTarget,\n      key: key,\n      children: children\n    };\n  }\n\n  if (formerKeys.filter(function (e) {\n    return e !== 'children';\n  }).some(function (e) {\n    return nowTarget.attrs[e] !== formerTarget.attrs[e] || !nowKeys.includes(e);\n  })) {\n    return {\n      action: 'change',\n      val: nowTarget,\n      children: children,\n      type: type,\n      key: key\n    };\n  }\n\n  return {\n    action: 'same',\n    children: children,\n    type: type,\n    key: key\n  };\n}\n/**\n * 根据xml或者返回xml的函数构建自定义节点的结构\n * @param gen\n */\n\n\nfunction createNodeFromXML(gen) {\n  var structures = {};\n\n  var compileXML = function compileXML(cfg) {\n    var rawStr = typeof gen === 'function' ? gen(cfg) : gen;\n    var target = xmlDataRenderer(rawStr)(cfg);\n    var xmlParser = document.createElement('div');\n    xmlParser.innerHTML = target;\n    var xml = xmlParser.children[0];\n    var result = generateTarget(parseXML(xml, cfg));\n    xmlParser.remove();\n    return result;\n  };\n\n  return {\n    draw: function draw(cfg, group) {\n      var resultTarget = compileXML(cfg);\n      var keyshape = group;\n\n      var renderTarget = function renderTarget(target) {\n        var _a = target.attrs,\n            attrs = _a === void 0 ? {} : _a,\n            bbox = target.bbox,\n            type = target.type,\n            children = target.children,\n            rest = (0, _tslib.__rest)(target, [\"attrs\", \"bbox\", \"type\", \"children\"]);\n\n        if (target.type !== 'group') {\n          var shape = group.addShape(target.type, (0, _tslib.__assign)({\n            attrs: attrs,\n            origin: {\n              bbox: bbox,\n              type: type,\n              children: children\n            }\n          }, rest));\n\n          if (target.keyshape) {\n            keyshape = shape;\n          }\n        }\n\n        if (target.children) {\n          target.children.forEach(function (n) {\n            return renderTarget(n);\n          });\n        }\n      };\n\n      renderTarget(resultTarget);\n      structures[cfg.id] = [resultTarget];\n      return keyshape;\n    },\n    update: function update(cfg, node) {\n      if (!structures[cfg.id]) {\n        structures[cfg.id] = [];\n      }\n\n      var container = node.getContainer();\n      var children = container.get('children');\n      var newTarget = compileXML(cfg);\n      var lastTarget = structures[cfg.id].pop();\n      var diffResult = compareTwoTarget(newTarget, lastTarget);\n\n      var addShape = function addShape(shape) {\n        var _a;\n\n        if (shape.type !== 'group') {\n          container.addShape(shape.type, {\n            attrs: shape.attrs\n          });\n        }\n\n        if ((_a = shape.children) === null || _a === void 0 ? void 0 : _a.length) {\n          shape.children.map(function (e) {\n            return addShape(e);\n          });\n        }\n      };\n\n      var delShape = function delShape(shape) {\n        var _a;\n\n        var targetShape = children.find(function (e) {\n          return e.attrs.key === shape.attrs.key;\n        });\n\n        if (targetShape) {\n          container.removeChild(targetShape);\n        }\n\n        if ((_a = shape.children) === null || _a === void 0 ? void 0 : _a.length) {\n          shape.children.map(function (e) {\n            return delShape(e);\n          });\n        }\n      };\n\n      var updateTarget = function updateTarget(target) {\n        var key = target.key;\n\n        if (target.type !== 'group') {\n          var targetShape = children.find(function (e) {\n            return e.attrs.key === key;\n          });\n\n          switch (target.action) {\n            case 'change':\n              if (targetShape) {\n                var originAttr = target.val.keyshape ? node.getOriginStyle() : {};\n                targetShape.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, originAttr), target.val.attrs));\n              }\n\n              break;\n\n            case 'add':\n              addShape(target.val);\n              break;\n\n            case 'delete':\n              delShape(target.val);\n              break;\n\n            case 'restructure':\n              delShape(target.formerTarget);\n              addShape(target.nowTarget);\n              break;\n\n            default:\n              break;\n          }\n        }\n\n        if (target.children) {\n          target.children.forEach(function (n) {\n            return updateTarget(n);\n          });\n        }\n      };\n\n      updateTarget(diffResult);\n      structures[cfg.id].push(newTarget);\n    },\n    getAnchorPoints: function getAnchorPoints() {\n      return [[0, 0.5], [1, 0.5], [0.5, 1], [0.5, 0]];\n    }\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _math = require(\"../util/math\");\n\nvar _item = _interopRequireDefault(require(\"./item\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar CACHE_ANCHOR_POINTS = 'anchorPointsCache';\nvar CACHE_BBOX = 'bboxCache';\n\nvar Node =\n/** @class */\nfunction (_super) {\n  (0, _tslib.__extends)(Node, _super);\n\n  function Node() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Node.prototype.getNearestPoint = function (points, curPoint) {\n    var index = 0;\n    var nearestPoint = points[0];\n    var minDistance = (0, _math.distance)(points[0], curPoint);\n\n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      var dis = (0, _math.distance)(point, curPoint);\n\n      if (dis < minDistance) {\n        nearestPoint = point;\n        minDistance = dis;\n        index = i;\n      }\n    }\n\n    nearestPoint.anchorIndex = index;\n    return nearestPoint;\n  };\n\n  Node.prototype.getDefaultCfg = function () {\n    return {\n      type: 'node',\n      edges: []\n    };\n  };\n  /**\n   * 获取从节点关联的所有边\n   */\n\n\n  Node.prototype.getEdges = function () {\n    return this.get('edges');\n  };\n  /**\n   * 获取所有的入边\n   */\n\n\n  Node.prototype.getInEdges = function () {\n    var self = this;\n    return this.get('edges').filter(function (edge) {\n      return edge.get('target') === self;\n    });\n  };\n  /**\n   * 获取所有的出边\n   */\n\n\n  Node.prototype.getOutEdges = function () {\n    var self = this;\n    return this.get('edges').filter(function (edge) {\n      return edge.get('source') === self;\n    });\n  };\n  /**\n   * 获取节点的邻居节点\n   *\n   * @returns {INode[]}\n   * @memberof Node\n   */\n\n\n  Node.prototype.getNeighbors = function (type) {\n    var _this = this;\n\n    var edges = this.get('edges');\n\n    if (type === 'target') {\n      // 当前节点为 source，它所指向的目标节点\n      var neighhborsConverter_1 = function neighhborsConverter_1(edge) {\n        return edge.getSource() === _this;\n      };\n\n      return edges.filter(neighhborsConverter_1).map(function (edge) {\n        return edge.getTarget();\n      });\n    }\n\n    if (type === 'source') {\n      // 当前节点为 target，它所指向的源节点\n      var neighhborsConverter_2 = function neighhborsConverter_2(edge) {\n        return edge.getTarget() === _this;\n      };\n\n      return edges.filter(neighhborsConverter_2).map(function (edge) {\n        return edge.getSource();\n      });\n    } // 若未指定 type ，则返回所有邻居\n\n\n    var neighhborsConverter = function neighhborsConverter(edge) {\n      return edge.getSource() === _this ? edge.getTarget() : edge.getSource();\n    };\n\n    return edges.map(neighhborsConverter);\n  };\n  /**\n   * 根据锚点的索引获取连接点\n   * @param  {Number} index 索引\n   */\n\n\n  Node.prototype.getLinkPointByAnchor = function (index) {\n    var anchorPoints = this.getAnchorPoints();\n    return anchorPoints[index];\n  };\n  /**\n   * 获取连接点\n   * @param point\n   */\n\n\n  Node.prototype.getLinkPoint = function (point) {\n    var keyShape = this.get('keyShape');\n    var type = keyShape.get('type');\n    var itemType = this.get('type');\n    var centerX;\n    var centerY;\n    var bbox = this.getBBox();\n\n    if (itemType === 'combo') {\n      centerX = bbox.centerX || (bbox.maxX + bbox.minX) / 2;\n      centerY = bbox.centerY || (bbox.maxY + bbox.minY) / 2;\n    } else {\n      centerX = bbox.centerX;\n      centerY = bbox.centerY;\n    }\n\n    var anchorPoints = this.getAnchorPoints();\n    var intersectPoint;\n\n    switch (type) {\n      case 'circle':\n        intersectPoint = (0, _math.getCircleIntersectByPoint)({\n          x: centerX,\n          y: centerY,\n          r: bbox.width / 2\n        }, point);\n        break;\n\n      case 'ellipse':\n        intersectPoint = (0, _math.getEllipseIntersectByPoint)({\n          x: centerX,\n          y: centerY,\n          rx: bbox.width / 2,\n          ry: bbox.height / 2\n        }, point);\n        break;\n\n      default:\n        intersectPoint = (0, _math.getRectIntersectByPoint)(bbox, point);\n    }\n\n    var linkPoint = intersectPoint; // 如果存在锚点，则使用交点计算最近的锚点\n\n    if (anchorPoints.length) {\n      if (!linkPoint) {\n        // 如果计算不出交点\n        linkPoint = point;\n      }\n\n      linkPoint = this.getNearestPoint(anchorPoints, linkPoint);\n    }\n\n    if (!linkPoint) {\n      // 如果最终依然没法找到锚点和连接点，直接返回中心点\n      linkPoint = {\n        x: centerX,\n        y: centerY\n      };\n    }\n\n    return linkPoint;\n  };\n  /**\n   * 获取锚点的定义\n   * @return {array} anchorPoints\n   */\n\n\n  Node.prototype.getAnchorPoints = function () {\n    var anchorPoints = this.get(CACHE_ANCHOR_POINTS);\n\n    if (!anchorPoints) {\n      anchorPoints = [];\n      var shapeFactory = this.get('shapeFactory');\n      var bbox_1 = this.getBBox();\n      var model = this.get('model');\n      var shapeCfg = this.getShapeCfg(model);\n      var type = model.type;\n      var points = shapeFactory.getAnchorPoints(type, shapeCfg) || [];\n      (0, _util.each)(points, function (pointArr, index) {\n        var point = {\n          x: bbox_1.minX + pointArr[0] * bbox_1.width,\n          y: bbox_1.minY + pointArr[1] * bbox_1.height,\n          anchorIndex: index\n        };\n        anchorPoints.push(point);\n      });\n      this.set(CACHE_ANCHOR_POINTS, anchorPoints);\n    }\n\n    return anchorPoints;\n  };\n  /**\n   * add edge\n   * @param edge Edge instance\n   */\n\n\n  Node.prototype.addEdge = function (edge) {\n    this.get('edges').push(edge);\n  };\n  /**\n   * 锁定节点\n   */\n\n\n  Node.prototype.lock = function () {\n    this.set('locked', true);\n  };\n  /**\n   * 解锁锁定的节点\n   */\n\n\n  Node.prototype.unlock = function () {\n    this.set('locked', false);\n  };\n\n  Node.prototype.hasLocked = function () {\n    return this.get('locked');\n  };\n  /**\n   * 移除边\n   * @param {Edge} edge 边\n   */\n\n\n  Node.prototype.removeEdge = function (edge) {\n    var edges = this.getEdges();\n    var index = edges.indexOf(edge);\n\n    if (index > -1) {\n      edges.splice(index, 1);\n    }\n  };\n\n  Node.prototype.clearCache = function () {\n    this.set(CACHE_BBOX, null); // 清理缓存的 bbox\n\n    this.set(CACHE_ANCHOR_POINTS, null);\n  };\n  /**\n   * 是否仅仅移动节点，其他属性没变化\n   * @param cfg 节点数据模型\n   */\n\n\n  Node.prototype.isOnlyMove = function (cfg) {\n    if (!cfg) {\n      return false;\n    }\n\n    var existX = !(0, _util.isNil)(cfg.x);\n    var existY = !(0, _util.isNil)(cfg.y);\n    var keys = Object.keys(cfg); // 仅有一个字段，包含 x 或者 包含 y\n    // 两个字段，同时有 x，同时有 y\n\n    return keys.length === 1 && (existX || existY) || keys.length === 2 && existX && existY;\n  };\n\n  return Node;\n}(_item.default);\n\nvar _default = Node;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _node = _interopRequireDefault(require(\"./node\"));\n\nvar _global = _interopRequireDefault(require(\"../global\"));\n\nvar _graphic = require(\"../util/graphic\");\n\nvar _util = require(\"@antv/util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar CACHE_BBOX = 'bboxCache';\nvar CACHE_CANVAS_BBOX = 'bboxCanvasCache';\nvar CACHE_SIZE = 'sizeCache';\nvar CACHE_ANCHOR_POINTS = 'anchorPointsCache';\n\nvar Combo =\n/** @class */\nfunction (_super) {\n  (0, _tslib.__extends)(Combo, _super);\n\n  function Combo() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Combo.prototype.getDefaultCfg = function () {\n    return {\n      type: 'combo',\n      nodes: [],\n      edges: [],\n      combos: []\n    };\n  };\n\n  Combo.prototype.getShapeCfg = function (model) {\n    var styles = this.get('styles');\n    var bbox = this.get('bbox');\n\n    if (styles && bbox) {\n      // merge graph的item样式与数据模型中的样式\n      var newModel = model;\n      var size = {\n        r: Math.hypot(bbox.height, bbox.width) / 2 || _global.default.defaultCombo.size[0] / 2,\n        width: bbox.width || _global.default.defaultCombo.size[0],\n        height: bbox.height || _global.default.defaultCombo.size[1]\n      };\n      newModel.style = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), model.style), size);\n      var padding = model.padding || _global.default.defaultCombo.padding;\n\n      if ((0, _util.isNumber)(padding)) {\n        size.r += padding;\n        size.width += padding * 2;\n        size.height += padding * 2;\n      } else {\n        size.r += padding[0];\n        size.width += padding[1] + padding[3] || padding[1] * 2;\n        size.height += padding[0] + padding[2] || padding[0] * 2;\n      }\n\n      this.set(CACHE_SIZE, size);\n      return newModel;\n    }\n\n    return model;\n  };\n  /**\n   * 根据 keyshape 计算包围盒\n   */\n\n\n  Combo.prototype.calculateCanvasBBox = function () {\n    if (this.destroyed) return;\n    var keyShape = this.get('keyShape');\n    var group = this.get('group'); // 因为 group 可能会移动，所以必须通过父元素计算才能计算出正确的包围盒\n\n    var bbox = (0, _graphic.getBBox)(keyShape, group);\n    bbox.centerX = (bbox.minX + bbox.maxX) / 2;\n    bbox.centerY = (bbox.minY + bbox.maxY) / 2;\n    var cacheSize = this.get(CACHE_SIZE);\n    var cacheBBox = this.get(CACHE_BBOX) || {};\n    var oriX = cacheBBox.x;\n    var oriY = cacheBBox.x;\n\n    if (cacheSize) {\n      cacheSize.width = Math.max(cacheSize.width, bbox.width);\n      cacheSize.height = Math.max(cacheSize.height, bbox.height);\n      var type = keyShape.get('type');\n\n      if (type === 'circle') {\n        bbox.width = cacheSize.r * 2;\n        bbox.height = cacheSize.r * 2;\n      } else {\n        bbox.width = cacheSize.width;\n        bbox.height = cacheSize.height;\n      }\n\n      bbox.minX = bbox.centerX - bbox.width / 2;\n      bbox.minY = bbox.centerY - bbox.height / 2;\n      bbox.maxX = bbox.centerX + bbox.width / 2;\n      bbox.maxY = bbox.centerY + bbox.height / 2;\n    } else {\n      bbox.width = bbox.maxX - bbox.minX;\n      bbox.height = bbox.maxY - bbox.minY;\n      bbox.centerX = (bbox.minX + bbox.maxX) / 2;\n      bbox.centerY = (bbox.minY + bbox.maxY) / 2;\n    }\n\n    bbox.x = bbox.minX;\n    bbox.y = bbox.minY;\n    if (bbox.x !== oriX || bbox.y !== oriY) this.set(CACHE_ANCHOR_POINTS, null);\n    return bbox;\n  };\n  /**\n   * 获取 Combo 中所有的子元素，包括 Combo、Node 及 Edge\n   */\n\n\n  Combo.prototype.getChildren = function () {\n    var self = this;\n    return {\n      nodes: self.getNodes(),\n      combos: self.getCombos()\n    };\n  };\n  /**\n   * 获取 Combo 中所有子节点\n   */\n\n\n  Combo.prototype.getNodes = function () {\n    var self = this;\n    return self.get('nodes');\n  };\n  /**\n   * 获取 Combo 中所有子 combo\n   */\n\n\n  Combo.prototype.getCombos = function () {\n    var self = this;\n    return self.get('combos');\n  };\n  /**\n   * 向 Combo 中增加子 combo 或 node\n   * @param item Combo 或节点实例\n   * @return boolean 添加成功返回 true，否则返回 false\n   */\n\n\n  Combo.prototype.addChild = function (item) {\n    var self = this;\n    var itemType = item.getType();\n\n    switch (itemType) {\n      case 'node':\n        self.addNode(item);\n        break;\n\n      case 'combo':\n        self.addCombo(item);\n        break;\n\n      default:\n        console.warn('Only node or combo items are allowed to be added into a combo');\n        return false;\n    }\n\n    return true;\n  };\n  /**\n   * 向 Combo 中增加 combo\n   * @param combo Combo 实例\n   * @return boolean 添加成功返回 true，否则返回 false\n   */\n\n\n  Combo.prototype.addCombo = function (combo) {\n    var self = this;\n    self.get('combos').push(combo);\n    return true;\n  };\n  /**\n   * 向 Combo 中添加节点\n   * @param node 节点实例\n   * @return boolean 添加成功返回 true，否则返回 false\n   */\n\n\n  Combo.prototype.addNode = function (node) {\n    var self = this;\n    self.get('nodes').push(node);\n    return true;\n  };\n  /**\n   * 向 Combo 中增加子 combo 或 node\n   * @param item Combo 或节点实例\n   * @return boolean 添加成功返回 true，否则返回 false\n   */\n\n\n  Combo.prototype.removeChild = function (item) {\n    var self = this;\n    var itemType = item.getType();\n\n    switch (itemType) {\n      case 'node':\n        self.removeNode(item);\n        break;\n\n      case 'combo':\n        self.removeCombo(item);\n        break;\n\n      default:\n        console.warn('Only node or combo items are allowed to be added into a combo');\n        return false;\n    }\n\n    return true;\n  };\n  /**\n   * 从 Combo 中移除指定的 combo\n   * @param combo Combo 实例\n   * @return boolean 移除成功返回 true，否则返回 false\n   */\n\n\n  Combo.prototype.removeCombo = function (combo) {\n    if (!combo) return;\n    var combos = this.getCombos();\n    var index = combos.indexOf(combo);\n\n    if (index > -1) {\n      combos.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * 向 Combo 中移除指定的节点\n   * @param node 节点实例\n   * @return boolean 移除成功返回 true，否则返回 false\n   */\n\n\n  Combo.prototype.removeNode = function (node) {\n    if (!node) return;\n    var nodes = this.getNodes();\n    var index = nodes.indexOf(node);\n\n    if (index > -1) {\n      nodes.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  };\n\n  Combo.prototype.isOnlyMove = function (cfg) {\n    return false;\n  };\n  /**\n   * 获取 item 的包围盒，这个包围盒是相对于 item 自己，不会将 matrix 计算在内\n   * @return {Object} 包含 x,y,width,height, centerX, centerY\n   */\n\n\n  Combo.prototype.getBBox = function () {\n    this.set(CACHE_CANVAS_BBOX, null);\n    var bbox = this.calculateCanvasBBox();\n    return bbox;\n  };\n\n  Combo.prototype.clearCache = function () {\n    this.set(CACHE_BBOX, null); // 清理缓存的 bbox\n\n    this.set(CACHE_CANVAS_BBOX, null);\n    this.set(CACHE_ANCHOR_POINTS, null);\n  };\n\n  Combo.prototype.destroy = function () {\n    if (!this.destroyed) {\n      var animate = this.get('animate');\n      var group = this.get('group');\n\n      if (animate) {\n        group.stopAnimate();\n      }\n\n      this.clearCache();\n      this.set(CACHE_SIZE, null);\n      this.set('bbox', null);\n      group.remove();\n      this._cfg = null;\n      this.destroyed = true;\n    }\n  };\n\n  return Combo;\n}(_node.default);\n\nvar _default = Combo;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@antv/util\");\n\nvar timer = null;\n\nvar StateController =\n/** @class */\nfunction () {\n  function StateController(graph) {\n    this.graph = graph;\n    /**\n     * this.cachedStates = {\n     *    enabled: {\n     *        hover: [Node]\n     *    },\n     *     disabled: {}\n     *  }\n     */\n\n    this.cachedStates = {\n      enabled: {},\n      disabled: {}\n    };\n    this.destroyed = false;\n  }\n  /**\n   * 检查 cache 的可用性\n   *\n   * @private\n   * @param {Item} item\n   * @param {string} state\n   * @param {object} cache\n   * @returns\n   * @memberof State\n   */\n\n\n  StateController.checkCache = function (item, state, cache) {\n    if (!cache[state]) {\n      return;\n    }\n\n    var index = cache[state].indexOf(item);\n\n    if (index >= 0) {\n      cache[state].splice(index, 1);\n    }\n  };\n  /**\n   * 缓存 state\n   *\n   * @private\n   * @param {Item} item Item 实例\n   * @param {string} state 状态名称\n   * @param {object} states\n   * @memberof State\n   */\n\n\n  StateController.cacheState = function (item, state, states) {\n    if (!states[state]) {\n      states[state] = [];\n    }\n\n    states[state].push(item);\n  };\n  /**\n   * 更新 Item 的状态\n   *\n   * @param {Item} item Item实例\n   * @param {string} state 状态名称\n   * @param {boolean} enabled 状态是否可用\n   * @memberof State\n   */\n\n\n  StateController.prototype.updateState = function (item, state, enabled) {\n    var _this = this;\n\n    var checkCache = StateController.checkCache,\n        cacheState = StateController.cacheState;\n\n    if (item.destroyed) {\n      return;\n    }\n\n    var cachedStates = this.cachedStates;\n    var enabledStates = cachedStates.enabled;\n    var disabledStates = cachedStates.disabled;\n\n    if (enabled) {\n      checkCache(item, state, disabledStates);\n      cacheState(item, state, enabledStates);\n    } else {\n      checkCache(item, state, enabledStates);\n      cacheState(item, state, disabledStates);\n    }\n\n    if (timer) {\n      clearTimeout(timer);\n    }\n\n    timer = setTimeout(function () {\n      timer = null;\n\n      _this.updateGraphStates();\n    }, 16);\n  };\n  /**\n   * 批量更新 states，兼容 updateState，支持更新一个 state\n   *\n   * @param {Item} item\n   * @param {(string | string[])} states\n   * @param {boolean} enabled\n   * @memberof State\n   */\n\n\n  StateController.prototype.updateStates = function (item, states, enabled) {\n    var _this = this;\n\n    if ((0, _util.isString)(states)) {\n      this.updateState(item, states, enabled);\n    } else {\n      states.forEach(function (state) {\n        _this.updateState(item, state, enabled);\n      });\n    }\n  };\n  /**\n   * 更新 states\n   *\n   * @memberof State\n   */\n\n\n  StateController.prototype.updateGraphStates = function () {\n    var states = this.graph.get('states');\n    var cachedStates = this.cachedStates;\n    (0, _util.each)(cachedStates.disabled, function (val, key) {\n      if (states[key]) {\n        states[key] = states[key].filter(function (item) {\n          return val.indexOf(item) < 0 && !val.destroyed;\n        });\n      }\n    });\n    (0, _util.each)(cachedStates.enabled, function (val, key) {\n      if (!states[key]) {\n        states[key] = val;\n      } else {\n        var map_1 = {};\n        states[key].forEach(function (item) {\n          if (!item.destroyed) {\n            map_1[item.get('id')] = true;\n          }\n        });\n        val.forEach(function (item) {\n          if (!item.destroyed) {\n            var id = item.get('id');\n\n            if (!map_1[id]) {\n              map_1[id] = true;\n              states[key].push(item);\n            }\n          }\n        });\n      }\n    });\n    this.graph.emit('graphstatechange', {\n      states: states\n    });\n    this.cachedStates = {\n      enabled: {},\n      disabled: {}\n    };\n  };\n\n  StateController.prototype.destroy = function () {\n    this.graph = null;\n    this.cachedStates = null;\n\n    if (timer) {\n      clearTimeout(timer);\n    }\n\n    timer = null;\n    this.destroyed = true;\n  };\n\n  return StateController;\n}();\n\nvar _default = StateController;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _pathUtil = require(\"@antv/path-util\");\n\nvar _path = require(\"../util/path\");\n\nvar _math = require(\"../util/math\");\n\nvar _convexHull = require(\"../element/hull/convexHull\");\n\nvar _bubbleset = require(\"../element/hull/bubbleset\");\n\n/**\n * 用于包裹内部的成员的轮廓。\n * convex hull(凸包)：http://geomalgorithms.com/a10-_hull-1.html#Monotone%20Chain\n * bubble: 使用 bubbleset算法，refer: http://vialab.science.uoit.ca/wp-content/papercite-data/pdf/col2009c.pdf\n * 通过配置 padding 可以调节包裹轮廓对节点的松紧程度\n */\nvar Hull =\n/** @class */\nfunction () {\n  function Hull(graph, cfg) {\n    this.cfg = (0, _util.deepMix)(this.getDefaultCfg(), cfg);\n    this.graph = graph;\n    this.id = this.cfg.id;\n    this.group = this.cfg.group;\n    this.members = this.cfg.members.map(function (item) {\n      return (0, _util.isString)(item) ? graph.findById(item) : item;\n    });\n    this.nonMembers = this.cfg.nonMembers.map(function (item) {\n      return (0, _util.isString)(item) ? graph.findById(item) : item;\n    });\n    this.setPadding();\n    this.setType();\n    this.path = this.calcPath(this.members, this.nonMembers);\n    this.render();\n  }\n\n  Hull.prototype.getDefaultCfg = function () {\n    return {\n      id: 'g6-hull',\n      type: 'round-convex',\n      members: [],\n      nonMembers: [],\n      style: {\n        fill: 'lightblue',\n        stroke: 'blue',\n        opacity: 0.2\n      },\n      padding: 10\n    };\n  };\n\n  Hull.prototype.setPadding = function () {\n    var nodeSize = this.members.length && this.members[0].getKeyShape().getCanvasBBox().width / 2;\n    this.padding = this.cfg.padding > 0 ? this.cfg.padding + nodeSize : 10 + nodeSize;\n    this.cfg.bubbleCfg = {\n      nodeR0: this.padding - nodeSize,\n      nodeR1: this.padding - nodeSize,\n      morphBuffer: this.padding - nodeSize\n    };\n  };\n\n  Hull.prototype.setType = function () {\n    this.type = this.cfg.type;\n\n    if (this.members.length < 3) {\n      this.type = 'round-convex';\n    }\n\n    if (this.type !== 'round-convex' && this.type !== 'smooth-convex' && this.type !== 'bubble') {\n      console.warn('The hull type should be either round-convex, smooth-convex or bubble, round-convex is used by default.');\n      this.type = 'round-convex';\n    }\n  };\n\n  Hull.prototype.calcPath = function (members, nonMembers) {\n    var contour, path, hull;\n\n    switch (this.type) {\n      case 'round-convex':\n        contour = (0, _convexHull.genConvexHull)(members);\n        hull = (0, _path.roundedHull)(contour.map(function (p) {\n          return [p.x, p.y];\n        }), this.padding);\n        path = (0, _pathUtil.parsePathString)(hull);\n        break;\n\n      case 'smooth-convex':\n        contour = (0, _convexHull.genConvexHull)(members);\n\n        if (contour.length === 2) {\n          hull = (0, _path.roundedHull)(contour.map(function (p) {\n            return [p.x, p.y];\n          }), this.padding);\n          path = (0, _pathUtil.parsePathString)(hull);\n        } else if (contour.length > 2) {\n          hull = (0, _path.paddedHull)(contour.map(function (p) {\n            return [p.x, p.y];\n          }), this.padding);\n          path = (0, _path.getClosedSpline)(hull);\n        }\n\n        break;\n\n      case 'bubble':\n        contour = (0, _bubbleset.genBubbleSet)(members, nonMembers, this.cfg.bubbleCfg);\n        path = contour.length >= 2 && (0, _path.getClosedSpline)(contour);\n        break;\n\n      default:\n    }\n\n    return path;\n  };\n\n  Hull.prototype.render = function () {\n    this.group.addShape('path', {\n      attrs: (0, _tslib.__assign)({\n        path: this.path\n      }, this.cfg.style),\n      id: this.id,\n      name: this.cfg.id\n    });\n    this.group.toBack();\n  };\n  /**\n   * 增加hull的成员，同时如果该成员原先在nonMembers中，则从nonMembers中去掉\n   * @param item 节点实例\n   * @return boolean 添加成功返回 true，否则返回 false\n   */\n\n\n  Hull.prototype.addMember = function (item) {\n    if (!item) return;\n    if ((0, _util.isString)(item)) item = this.graph.findById(item);\n    this.members.push(item);\n    var index = this.nonMembers.indexOf(item);\n\n    if (index > -1) {\n      this.nonMembers.splice(index, 1);\n    }\n\n    this.updateData(this.members, this.nonMembers);\n    return true;\n  };\n  /**\n   * 增加hull需要排除的节点，同时如果该成员原先在members中，则从members中去掉\n   * @param item 节点实例\n   * @return boolean 添加成功返回 true，否则返回 false\n   */\n\n\n  Hull.prototype.addNonMember = function (item) {\n    if (!item) return;\n    if ((0, _util.isString)(item)) item = this.graph.findById(item);\n    this.nonMembers.push(item);\n    var index = this.members.indexOf(item);\n\n    if (index > -1) {\n      this.members.splice(index, 1);\n    }\n\n    this.updateData(this.members, this.nonMembers);\n    return true;\n  };\n  /**\n   * 移除hull中的成员\n   * @param node 节点实例\n   * @return boolean 移除成功返回 true，否则返回 false\n   */\n\n\n  Hull.prototype.removeMember = function (item) {\n    if (!item) return;\n    if ((0, _util.isString)(item)) item = this.graph.findById(item);\n    var index = this.members.indexOf(item);\n\n    if (index > -1) {\n      this.members.splice(index, 1);\n      this.updateData(this.members, this.nonMembers);\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * @param node 节点实例\n   * @return boolean 移除成功返回 true，否则返回 false\n   */\n\n\n  Hull.prototype.removeNonMember = function (item) {\n    if (!item) return;\n    if ((0, _util.isString)(item)) item = this.graph.findById(item);\n    var index = this.nonMembers.indexOf(item);\n\n    if (index > -1) {\n      this.nonMembers.splice(index, 1);\n      this.updateData(this.members, this.nonMembers);\n      return true;\n    }\n\n    return false;\n  };\n\n  Hull.prototype.updateData = function (members, nonMembers) {\n    var _this = this;\n\n    this.group.findById(this.id).remove();\n    if (members) this.members = members.map(function (item) {\n      return (0, _util.isString)(item) ? _this.graph.findById(item) : item;\n    });\n    if (nonMembers) this.nonMembers = nonMembers.map(function (item) {\n      return (0, _util.isString)(item) ? _this.graph.findById(item) : item;\n    });\n    this.path = this.calcPath(this.members, this.nonMembers);\n    this.render();\n  };\n\n  Hull.prototype.updateStyle = function (cfg) {\n    var path = this.group.findById(this.id);\n    path.attr((0, _tslib.__assign)({}, cfg));\n  };\n  /**\n   * 更新 hull\n   * @param cfg hull 配置项\n   */\n\n\n  Hull.prototype.updateCfg = function (cfg) {\n    var _this = this;\n\n    this.cfg = (0, _util.deepMix)(this.cfg, cfg);\n    this.id = this.cfg.id;\n    this.group = this.cfg.group;\n\n    if (cfg.members) {\n      this.members = this.cfg.members.map(function (item) {\n        return (0, _util.isString)(item) ? _this.graph.findById(item) : item;\n      });\n    }\n\n    if (cfg.nonMembers) {\n      this.nonMembers = this.cfg.nonMembers.map(function (item) {\n        return (0, _util.isString)(item) ? _this.graph.findById(item) : item;\n      });\n    } // TODO padding 设置太大，会影响到 contain 结果\n\n\n    this.setPadding();\n    this.setType();\n    this.path = this.calcPath(this.members, this.nonMembers);\n    this.render();\n  };\n  /**\n   * 判断是否在hull内部\n   * @param item\n   */\n\n\n  Hull.prototype.contain = function (item) {\n    var _this = this;\n\n    var nodeItem;\n\n    if ((0, _util.isString)(item)) {\n      nodeItem = this.graph.findById(item);\n    } else {\n      nodeItem = item;\n    }\n\n    var shapePoints;\n    var shape = nodeItem.getKeyShape();\n\n    if (nodeItem.get('type') === 'path') {\n      shapePoints = (0, _path.pathToPoints)(shape.attr('path'));\n    } else {\n      var shapeBBox = shape.getCanvasBBox();\n      shapePoints = [[shapeBBox.minX, shapeBBox.minY], [shapeBBox.maxX, shapeBBox.minY], [shapeBBox.maxX, shapeBBox.maxY], [shapeBBox.minX, shapeBBox.maxY]];\n    }\n\n    shapePoints = shapePoints.map(function (canvasPoint) {\n      var point = _this.graph.getPointByCanvas(canvasPoint[0], canvasPoint[1]);\n\n      return [point.x, point.y];\n    });\n    return (0, _math.isPolygonsIntersect)(shapePoints, (0, _path.pathToPoints)(this.path));\n  };\n\n  Hull.prototype.destroy = function () {\n    this.group.remove();\n    this.cfg = null;\n  };\n\n  return Hull;\n}();\n\nvar _default = Hull;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.roundedHull = roundedHull;\nexports.paddedHull = paddedHull;\nexports.getClosedSpline = exports.pathToPoints = exports.pointsToPolygon = exports.getControlPoint = exports.getSpline = void 0;\n\nvar _matrixUtil = require(\"@antv/matrix-util\");\n\nvar _pathUtil = require(\"@antv/path-util\");\n\n/**\n * 替换字符串中的字段\n * @param {String} str 模版字符串\n * @param {Object} o json data\n */\nvar substitute = function substitute(str, o) {\n  if (!str || !o) {\n    return str;\n  }\n\n  return str.replace(/\\\\?\\{([^{}]+)\\}/g, function (match, name) {\n    if (match.charAt(0) === '\\\\') {\n      return match.slice(1);\n    }\n\n    var res = o[name];\n    if (res === 0) res = '0';\n    return res || '';\n  });\n};\n/**\n * 给定坐标获取三次贝塞尔曲线的 M 及 C 值\n * @param points coordinate set\n */\n\n\nvar getSpline = function getSpline(points) {\n  var data = [];\n\n  if (points.length < 2) {\n    throw new Error(\"point length must largn than 2, now it's \" + points.length);\n  }\n\n  for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n    var point = points_1[_i];\n    var x = point.x,\n        y = point.y;\n    data.push(x);\n    data.push(y);\n  }\n\n  var spliePath = (0, _pathUtil.catmullRom2Bezier)(data);\n  spliePath.unshift(['M', points[0].x, points[0].y]);\n  return spliePath;\n};\n/**\n * 根据起始点、相对位置、偏移量计算控制点\n * @param  {IPoint} startPoint 起始点，包含 x,y\n * @param  {IPoint} endPoint  结束点, 包含 x,y\n * @param  {Number} percent   相对位置,范围 0-1\n * @param  {Number} offset    偏移量\n * @return {IPoint} 控制点，包含 x,y\n */\n\n\nexports.getSpline = getSpline;\n\nvar getControlPoint = function getControlPoint(startPoint, endPoint, percent, offset) {\n  if (percent === void 0) {\n    percent = 0;\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var point = {\n    x: (1 - percent) * startPoint.x + percent * endPoint.x,\n    y: (1 - percent) * startPoint.y + percent * endPoint.y\n  };\n  var tangent = [0, 0];\n\n  _matrixUtil.vec2.normalize(tangent, [endPoint.x - startPoint.x, endPoint.y - startPoint.y]);\n\n  if (!tangent || !tangent[0] && !tangent[1]) {\n    tangent = [0, 0];\n  }\n\n  var perpendicular = [-tangent[1] * offset, tangent[0] * offset]; // 垂直向量\n\n  point.x += perpendicular[0];\n  point.y += perpendicular[1];\n  return point;\n};\n/**\n * 点集转化为Path多边形\n * @param {Array} points 点集\n * @param {Boolen} z 是否封闭\n * @return {Array} Path\n */\n\n\nexports.getControlPoint = getControlPoint;\n\nvar pointsToPolygon = function pointsToPolygon(points, z) {\n  var length = points.length;\n\n  if (!length) {\n    return '';\n  }\n\n  var path = '';\n  var str = '';\n\n  for (var i = 0; i < length; i++) {\n    var item = points[i];\n\n    if (i === 0) {\n      str = 'M{x} {y}';\n    } else {\n      str = 'L{x} {y}';\n    }\n\n    path += substitute(str, item);\n  }\n\n  if (z) {\n    path += 'Z';\n  }\n\n  return path;\n};\n\nexports.pointsToPolygon = pointsToPolygon;\n\nvar pathToPoints = function pathToPoints(path) {\n  var points = [];\n  path.forEach(function (seg) {\n    var command = seg[0];\n\n    if (command !== 'A') {\n      for (var i = 1; i < seg.length; i = i + 2) {\n        points.push([seg[i], seg[i + 1]]);\n      }\n    } else {\n      var length_1 = seg.length;\n      points.push([seg[length_1 - 2], seg[length_1 - 1]]);\n    }\n  });\n  return points;\n};\n/**\n * 生成平滑的闭合曲线\n * @param points\n */\n\n\nexports.pathToPoints = pathToPoints;\n\nvar getClosedSpline = function getClosedSpline(points) {\n  if (points.length < 2) {\n    throw new Error(\"point length must largn than 2, now it's \" + points.length);\n  }\n\n  var first = points[0];\n  var second = points[1];\n  var last = points[points.length - 1];\n  var lastSecond = points[points.length - 2];\n  points.unshift(last);\n  points.unshift(lastSecond);\n  points.push(first);\n  points.push(second);\n  var closedPath = [];\n\n  for (var i = 1; i < points.length - 2; i += 1) {\n    var x0 = points[i - 1].x;\n    var y0 = points[i - 1].y;\n    var x1 = points[i].x;\n    var y1 = points[i].y;\n    var x2 = points[i + 1].x;\n    var y2 = points[i + 1].y;\n    var x3 = i !== points.length - 2 ? points[i + 2].x : x2;\n    var y3 = i !== points.length - 2 ? points[i + 2].y : y2;\n    var cp1x = x1 + (x2 - x0) / 6;\n    var cp1y = y1 + (y2 - y0) / 6;\n    var cp2x = x2 - (x3 - x1) / 6;\n    var cp2y = y2 - (y3 - y1) / 6;\n    closedPath.push(['C', cp1x, cp1y, cp2x, cp2y, x2, y2]);\n  }\n\n  closedPath.unshift(['M', last.x, last.y]);\n  return closedPath;\n};\n\nexports.getClosedSpline = getClosedSpline;\n\nvar vecScaleTo = function vecScaleTo(v, length) {\n  // Vector with direction of v with specified length\n  return _matrixUtil.vec2.scale([0, 0], _matrixUtil.vec2.normalize([0, 0], v), length);\n};\n\nvar unitNormal = function unitNormal(p0, p1) {\n  // Returns the unit normal to the line segment from p0 to p1.\n  var n = [p0[1] - p1[1], p1[0] - p0[0]];\n  var nLength = Math.sqrt(n[0] * n[0] + n[1] * n[1]);\n\n  if (nLength === 0) {\n    throw new Error('p0 should not be equal to p1');\n  }\n\n  return [n[0] / nLength, n[1] / nLength];\n};\n\nvar vecFrom = function vecFrom(p0, p1) {\n  // Vector from p0 to p1\n  return [p1[0] - p0[0], p1[1] - p0[1]];\n};\n/**\n * 传入的节点作为多边形顶点，生成有圆角的多边形\n * @param polyPoints 多边形顶点\n * @param padding 在原多边形基础上增加最终轮廓和原多边形的空白间隔\n */\n\n\nfunction roundedHull(polyPoints, padding) {\n  // The rounded hull path around a single point\n  var roundedHull1 = function roundedHull1(points) {\n    var p1 = [points[0][0], points[0][1] - padding];\n    var p2 = [points[0][0], points[0][1] + padding];\n    return \"M \" + p1 + \" A \" + padding + \",\" + padding + \",0,0,0,\" + p2 + \" A \" + padding + \",\" + padding + \",0,0,0,\" + p1;\n  }; // The rounded hull path around two points\n\n\n  var roundedHull2 = function roundedHull2(points) {\n    var offsetVector = _matrixUtil.vec2.scale([0, 0], unitNormal(points[0], points[1]), padding);\n\n    var invOffsetVector = _matrixUtil.vec2.scale([0, 0], offsetVector, -1);\n\n    var p0 = _matrixUtil.vec2.add([0, 0], points[0], offsetVector);\n\n    var p1 = _matrixUtil.vec2.add([0, 0], points[1], offsetVector);\n\n    var p2 = _matrixUtil.vec2.add([0, 0], points[1], invOffsetVector);\n\n    var p3 = _matrixUtil.vec2.add([0, 0], points[0], invOffsetVector);\n\n    return \"M \" + p0 + \" L \" + p1 + \" A \" + [padding, padding, '0,0,0', p2].join(',') + \" L \" + p3 + \" A \" + [padding, padding, '0,0,0', p0].join(',');\n  }; // 特殊情况处理：节点数小于等于2\n\n\n  if (!polyPoints || polyPoints.length < 1) return '';\n  if (polyPoints.length === 1) return roundedHull1(polyPoints);\n  if (polyPoints.length === 2) return roundedHull2(polyPoints);\n  var segments = new Array(polyPoints.length); // Calculate each offset (outwards) segment of the convex hull.\n\n  for (var segmentIndex = 0; segmentIndex < segments.length; ++segmentIndex) {\n    var p0 = segmentIndex === 0 ? polyPoints[polyPoints.length - 1] : polyPoints[segmentIndex - 1];\n    var p1 = polyPoints[segmentIndex]; // Compute the offset vector for the line segment, with length = padding.\n\n    var offset = _matrixUtil.vec2.scale([0, 0], unitNormal(p0, p1), padding);\n\n    segments[segmentIndex] = [_matrixUtil.vec2.add([0, 0], p0, offset), _matrixUtil.vec2.add([0, 0], p1, offset)];\n  }\n\n  var arcData = \"A \" + [padding, padding, '0,0,0,'].join(',');\n  segments = segments.map(function (segment, index) {\n    var pathFragment = '';\n\n    if (index === 0) {\n      pathFragment = \"M \" + segments[segments.length - 1][1] + \" \";\n    }\n\n    pathFragment += arcData + segment[0] + \" L \" + segment[1];\n    return pathFragment;\n  });\n  return segments.join(' ');\n}\n/**\n * 传入的节点作为多边形顶点，生成平滑的闭合多边形\n * @param polyPoints\n * @param padding\n */\n\n\nfunction paddedHull(polyPoints, padding) {\n  var pointCount = polyPoints.length;\n\n  var smoothHull1 = function smoothHull1(points) {\n    // Returns the path for a circular hull around a single point.\n    var p1 = [points[0][0], points[0][1] - padding];\n    var p2 = [points[0][0], points[0][1] + padding];\n    return \"M \" + p1 + \" A \" + [padding, padding, '0,0,0', p2].join(',') + \" A \" + [padding, padding, '0,0,0', p1].join(',');\n  }; // Returns the path for a rounded hull around two points.\n\n\n  var smoothHull2 = function smoothHull2(points) {\n    var v = vecFrom(points[0], points[1]);\n    var extensionVec = vecScaleTo(v, padding);\n\n    var extension0 = _matrixUtil.vec2.add([0, 0], points[0], _matrixUtil.vec2.scale([0, 0], extensionVec, -1));\n\n    var extension1 = _matrixUtil.vec2.add([0, 0], points[1], extensionVec);\n\n    var tangentHalfLength = 1.2 * padding;\n    var controlDelta = vecScaleTo(_matrixUtil.vec2.normalize([0, 0], v), tangentHalfLength);\n\n    var invControlDelta = _matrixUtil.vec2.scale([0, 0], controlDelta, -1);\n\n    var control0 = _matrixUtil.vec2.add([0, 0], extension0, invControlDelta);\n\n    var control1 = _matrixUtil.vec2.add([0, 0], extension1, invControlDelta);\n\n    var control3 = _matrixUtil.vec2.add([0, 0], extension0, controlDelta); // return [\n    //   ['M', extension0[0], extension0[1]],\n    //   ['C', control0, control1, extension1],\n    //   ['S', control3, extension0],\n    //   'Z',\n    // ];\n\n\n    return \"M \" + extension0 + \" C \" + [control0, control1, extension1].join(',') + \" S \" + [control3, extension0].join(',') + \" Z\";\n  }; // Handle special cases\n\n\n  if (!polyPoints || pointCount < 1) return '';\n  if (pointCount === 1) return smoothHull1(polyPoints);\n  if (pointCount === 2) return smoothHull2(polyPoints);\n  var hullPoints = polyPoints.map(function (point, index) {\n    var pNext = polyPoints[(index + 1) % pointCount];\n    return {\n      p: point,\n      v: _matrixUtil.vec2.normalize([0, 0], vecFrom(point, pNext))\n    };\n  }); // Compute the expanded hull points, and the nearest prior control point for each.\n\n  for (var i = 0; i < hullPoints.length; ++i) {\n    var priorIndex = i > 0 ? i - 1 : pointCount - 1;\n\n    var extensionVec = _matrixUtil.vec2.normalize([0, 0], _matrixUtil.vec2.add([0, 0], hullPoints[priorIndex].v, _matrixUtil.vec2.scale([0, 0], hullPoints[i].v, -1)));\n\n    hullPoints[i].p = _matrixUtil.vec2.add([0, 0], hullPoints[i].p, _matrixUtil.vec2.scale([0, 0], extensionVec, padding));\n  }\n\n  return hullPoints.map(function (obj) {\n    var point = obj.p;\n    return {\n      x: point[0],\n      y: point[1]\n    };\n  });\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.genConvexHull = exports.cross = void 0;\n\n/**\n * Use cross product to judge the direction of the turn.\n * Returns a positive value, if OAB makes a clockwise turn,\n * negative for counter-clockwise turn, and zero if the points are collinear.\n */\nvar cross = function cross(a, b, o) {\n  return (a.y - o.y) * (b.x - o.x) - (a.x - o.x) * (b.y - o.y);\n};\n/**\n * Generate a convex hull of given points. Andrew's monotone chain algorithm.\n * @param points An array of [x, y] representing the coordinates of points.\n * @return a list of vertices of the convex hull in counter-clockwise order,\n */\n\n\nexports.cross = cross;\n\nvar genConvexHull = function genConvexHull(items) {\n  var points = items.map(function (item) {\n    return {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n  });\n  points.sort(function (a, b) {\n    return a.x === b.x ? a.y - b.y : a.x - b.x;\n  });\n\n  if (points.length === 1) {\n    return points;\n  } // build the lower hull\n\n\n  var lower = [];\n\n  for (var i = 0; i < points.length; i++) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n      lower.pop();\n    }\n\n    lower.push(points[i]);\n  } // build the upper hull\n\n\n  var upper = [];\n\n  for (var i = points.length - 1; i >= 0; i--) {\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {\n      upper.pop();\n    }\n\n    upper.push(points[i]);\n  }\n\n  upper.pop();\n  lower.pop();\n  var strictHull = lower.concat(upper);\n  return strictHull;\n};\n\nexports.genConvexHull = genConvexHull;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.genBubbleSet = void 0;\n\nvar _math = require(\"../../util/math\");\n\nvar defaultOps = {\n  maxRoutingIterations: 100,\n  maxMarchingIterations: 100,\n  pixelGroupSize: 2,\n  edgeR0: 10,\n  edgeR1: 10,\n  nodeR0: 5,\n  nodeR1: 10,\n  morphBuffer: 5,\n  threshold: 0.001,\n  skip: 16,\n  nodeInfluenceFactor: 1,\n  edgeInfluenceFactor: 1,\n  negativeNodeInfluenceFactor: -0.5\n};\n/**\n * Marching square algorithm for traching the contour of a pixel group\n * https://www.emanueleferonato.com/2013/03/01/using-marching-squares-algorithm-to-trace-the-contour-of-an-image/\n * @param potentialArea\n * @param threshold\n */\n\nfunction MarchingSquares(contour, potentialArea, threshold) {\n  var marched = false;\n\n  var getVal = function getVal(x, y) {\n    return potentialArea.cells[x + y * potentialArea.width];\n  };\n\n  var getState = function getState(x, y) {\n    var squareVal = 0;\n\n    if (getVal(x - 1, y - 1) >= threshold) {\n      squareVal += 1;\n    }\n\n    if (getVal(x, y - 1) > threshold) {\n      squareVal += 2;\n    }\n\n    if (getVal(x - 1, y) > threshold) {\n      squareVal += 4;\n    }\n\n    if (getVal(x, y) > threshold) {\n      squareVal += 8;\n    }\n\n    return squareVal;\n  };\n\n  var doMarch = function doMarch(xPos, yPos) {\n    var x = xPos;\n    var y = yPos;\n    var prevX;\n    var prevY;\n\n    for (var i = 0; i < potentialArea.width * potentialArea.height; i++) {\n      prevX = x;\n      prevY = y;\n\n      if (contour.findIndex(function (item) {\n        return item.x === x && item.y === y;\n      }) > -1) {\n        if (contour[0].x !== x || contour[0].y !== y) {// encountered a loop but haven't returned to start: change direction using conditionals and continue back to start\n        } else {\n          return true;\n        }\n      } else {\n        contour.push({\n          x: x,\n          y: y\n        });\n      }\n\n      var state = getState(x, y); // assign the move direction according to state of the square\n\n      switch (state) {\n        case -1:\n          console.warn('Marched out of bounds');\n          return true;\n\n        case 0:\n        case 3:\n        case 2:\n        case 7:\n          x++; // go right\n\n          break;\n\n        case 12:\n        case 14:\n        case 4:\n          x--; // go left\n\n          break;\n\n        case 6:\n          // go left if come from up else go right\n          if (prevX === 0) {\n            if (prevY === -1) {\n              x -= 1;\n            } else {\n              x += 1;\n            }\n          }\n\n          break;\n\n        case 1:\n        case 13:\n        case 5:\n          y--; // go up\n\n          break;\n\n        case 9:\n          // go up if come from right else go down\n          if (prevX === 1) {\n            if (prevY === 0) {\n              y -= 1;\n            } else {\n              y += 1;\n            }\n          }\n\n          break;\n\n        case 10:\n        case 8:\n        case 11:\n          y++; // go down\n\n          break;\n\n        default:\n          console.warn(\"Marching squares invalid state: \" + state);\n          return true;\n      }\n    }\n  };\n\n  this.march = function () {\n    for (var x = 0; x < potentialArea.width && !marched; x += 1) {\n      for (var y = 0; y < potentialArea.height && !marched; y += 1) {\n        if (getVal(x, y) > threshold && getState(x, y) !== 15) {\n          marched = doMarch(x, y);\n        }\n      }\n    }\n\n    return marched;\n  };\n}\n/**\n * Space partition & assign value to each cell\n * @param points\n */\n\n\nvar initGridCells = function initGridCells(width, height, pixelGroupSize) {\n  var scaleWidth = Math.ceil(width / pixelGroupSize);\n  var scaleHeight = Math.ceil(height / pixelGroupSize);\n  var gridCells = new Float32Array(Math.max(0, scaleWidth * scaleHeight)).fill(0);\n  return {\n    cells: gridCells,\n    width: scaleWidth,\n    height: scaleHeight\n  };\n};\n/**\n * Find the optimal already visited member to item;\n   Optimal: minimize cost(j) = distance(i,j) ∗ countObstacles(i,j)\n * @param item\n * @param visited\n */\n\n\nvar pickBestNeighbor = function pickBestNeighbor(item, visited, nonMembers) {\n  var closestNeighbour = null;\n  var minCost = Number.POSITIVE_INFINITY;\n  visited.forEach(function (neighbourItem) {\n    var itemP = {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n    var neighbourItemP = {\n      x: neighbourItem.getModel().x,\n      y: neighbourItem.getModel().y\n    };\n    var dist = (0, _math.squareDist)(itemP, neighbourItemP);\n    var directLine = new _math.Line(itemP.x, itemP.y, neighbourItemP.x, neighbourItemP.y);\n    var numberObstacles = nonMembers.reduce(function (count, _item) {\n      if ((0, _math.fractionToLine)(_item, directLine) > 0) {\n        return count + 1;\n      }\n\n      return count;\n    }, 0);\n\n    if (dist * Math.pow(numberObstacles + 1, 2) < minCost) {\n      closestNeighbour = neighbourItem;\n      minCost = dist * Math.pow(numberObstacles + 1, 2);\n    }\n  });\n  return closestNeighbour;\n};\n/**\n * 返回和线相交的item中，离边的起点最近的item\n * @param items\n * @param line\n */\n\n\nvar getIntersectItem = function getIntersectItem(items, line) {\n  var minDistance = Number.POSITIVE_INFINITY;\n  var closestItem = null;\n  items.forEach(function (item) {\n    var distance = (0, _math.fractionToLine)(item, line); // find closest intersection\n\n    if (distance >= 0 && distance < minDistance) {\n      closestItem = item;\n      minDistance = distance;\n    }\n  });\n  return closestItem;\n};\n/**\n * Modify the directLine and Route virtual edges around obstacles\n */\n\n\nvar computeRoute = function computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer) {\n  var checkedLines = [];\n  var linesToCheck = [];\n  linesToCheck.push(directLine);\n  var hasIntersection = true;\n  var iterations = 0;\n\n  var pointExists = function pointExists(point, lines) {\n    var flag = false;\n    lines.forEach(function (line) {\n      if (flag) return;\n\n      if ((0, _math.isPointsOverlap)(point, {\n        x: line.x1,\n        y: line.y1\n      }) || (0, _math.isPointsOverlap)(point, {\n        x: line.x2,\n        y: line.y2\n      })) {\n        flag = true;\n      }\n    });\n    return flag;\n  };\n\n  var isPointInNonMembers = function isPointInNonMembers(point, _nonMembers) {\n    for (var _i = 0, _nonMembers_1 = _nonMembers; _i < _nonMembers_1.length; _i++) {\n      var item = _nonMembers_1[_i];\n      var bbox = item.getBBox();\n      var itemContour = [[bbox.x, bbox.y], [bbox.x + bbox.width, bbox.y], [bbox.x, bbox.y + bbox.height], [bbox.x + bbox.width, bbox.y + bbox.height]];\n\n      if ((0, _math.isPointInPolygon)(itemContour, point.x, point.y)) {\n        return true;\n      }\n    }\n\n    return false;\n  }; // outer loop end when no more intersections or out of iterations\n\n\n  while (hasIntersection && iterations < maxRoutingIterations) {\n    hasIntersection = false;\n\n    var _loop_1 = function _loop_1() {\n      var line = linesToCheck.pop();\n      var closestItem = getIntersectItem(nonMembers, line);\n\n      if (closestItem) {\n        var _a = (0, _math.itemIntersectByLine)(closestItem, line),\n            intersections_1 = _a[0],\n            countIntersections = _a[1]; // if line passes through item\n\n\n        if (countIntersections === 2) {\n          var testReroute = function testReroute(isFirst) {\n            var tempMorphBuffer = morphBuffer;\n            var virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst); // test the virtualNode already exists\n\n            var exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);\n            var pointInside = isPointInNonMembers(virtualNode, nonMembers);\n\n            while (!exist && pointInside && tempMorphBuffer >= 1) {\n              // try a smaller buffer\n              tempMorphBuffer /= 1.5;\n              virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst);\n              exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);\n              pointInside = isPointInNonMembers(virtualNode, nonMembers);\n            } // 第二次route时不要求pointInside\n\n\n            if (virtualNode && !exist && (!isFirst || !pointInside)) {\n              // add 2 rerouted lines to check\n              linesToCheck.push(new _math.Line(line.x1, line.y1, virtualNode.x, virtualNode.y));\n              linesToCheck.push(new _math.Line(virtualNode.x, virtualNode.y, line.x2, line.y2));\n              hasIntersection = true;\n            }\n          };\n\n          testReroute(true);\n\n          if (!hasIntersection) {\n            // if we didn't find a valid point around the first corner, try the second\n            testReroute(false);\n          }\n        }\n      } // no intersection found, mark this line as completed\n\n\n      if (!hasIntersection) {\n        checkedLines.push(line);\n      }\n\n      iterations += 1;\n    }; // inner loop end when out of lines or found an intersection\n\n\n    while (!hasIntersection && linesToCheck.length) {\n      _loop_1();\n    }\n  } // 加入剩余的线\n\n\n  while (linesToCheck.length) {\n    checkedLines.push(linesToCheck.pop());\n  }\n\n  return checkedLines;\n};\n/**\n *  Connect item with visited members using direct line or virtual edges\n */\n\n\nfunction getRoute(item, nonMembers, visited, maxRoutingIterations, morphBuffer) {\n  var optimalNeighbor = pickBestNeighbor(item, visited, nonMembers);\n\n  if (optimalNeighbor === null) {\n    return [];\n  } //  merge the consecutive lines\n\n\n  var mergeLines = function mergeLines(checkedLines) {\n    var finalRoute = [];\n\n    while (checkedLines.length > 0) {\n      var line1 = checkedLines.pop();\n\n      if (checkedLines.length === 0) {\n        finalRoute.push(line1);\n        break;\n      }\n\n      var line2 = checkedLines.pop();\n      var mergeLine = new _math.Line(line1.x1, line1.y1, line2.x2, line2.y2);\n      var closestItem = getIntersectItem(nonMembers, mergeLine); // merge most recent line and previous line\n\n      if (!closestItem) {\n        checkedLines.push(mergeLine);\n      } else {\n        finalRoute.push(line1);\n        checkedLines.push(line2);\n      }\n    }\n\n    return finalRoute;\n  };\n\n  var directLine = new _math.Line(item.getModel().x, item.getModel().y, optimalNeighbor.getModel().x, optimalNeighbor.getModel().y);\n  var checkedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);\n  var finalRoute = mergeLines(checkedLines);\n  return finalRoute;\n}\n/**\n * Calculate the countor that includes the  selected items and exclues the non-selected items\n * @param graph\n * @param members\n * @param nonMembers\n * @param options\n */\n\n\nvar genBubbleSet = function genBubbleSet(members, nonMembers, ops) {\n  // eslint-disable-next-line no-redeclare\n  var options = Object.assign(defaultOps, ops);\n  var centroid = (0, _math.getPointsCenter)(members.map(function (item) {\n    return {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n  })); // 按照到中心距离远近排序\n\n  members = members.sort(function (a, b) {\n    return (0, _math.squareDist)({\n      x: a.getModel().x,\n      y: a.getModel().y\n    }, centroid) - (0, _math.squareDist)({\n      x: b.getModel().x,\n      y: b.getModel().y\n    }, centroid);\n  });\n  var visited = [];\n  var virtualEdges = [];\n  members.forEach(function (item) {\n    var lines = getRoute(item, nonMembers, visited, options.maxRoutingIterations, options.morphBuffer);\n    lines.forEach(function (l) {\n      virtualEdges.push(l);\n    });\n    visited.push(item);\n  }); // 由于edge也可以作为member和nonMember传入，暂时不考虑把edges作为参数传入genBubbleSet\n  // edges && edges.forEach(e => {\n  //   virtualEdges.push(new Line(e.getSource().getModel().x, e.getSource().getModel().y, e.getTarget().getModel().x, e.getTarget().getModel().y));\n  // });\n\n  var activeRegion = getActiveRregion(members, virtualEdges, options.nodeR0);\n  var potentialArea = initGridCells(activeRegion.width, activeRegion.height, options.pixelGroupSize); // Use march squares to generate contour\n\n  var contour = [];\n  var hull = [];\n\n  for (var iterations = 0; iterations < options.maxMarchingIterations; iterations++) {\n    fillPotentialArea(members, nonMembers, virtualEdges, activeRegion, potentialArea, options);\n    contour = [];\n    hull = [];\n    if (!new MarchingSquares(contour, potentialArea, options.threshold).march()) continue;\n    var marchedPath = contour.map(function (point) {\n      return {\n        x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX),\n        y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY)\n      };\n    }); // const marchedPath = marchingSquares(potentialArea, options.threshold).map(point => ({ x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX), y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY) }))\n\n    if (marchedPath) {\n      var size = marchedPath.length;\n\n      if (options.skip > 1) {\n        size = Math.floor(marchedPath.length / options.skip); // if we reduced too much (fewer than three points in reduced surface) reduce skip and try again\n\n        while (size < 3 && options.skip > 1) {\n          options.skip -= 1;\n          size = Math.floor(marchedPath.length / options.skip);\n        }\n      } // copy hull values\n\n\n      for (var i = 0, j = 0; j < size; j += 1, i += options.skip) {\n        hull.push({\n          x: marchedPath[i].x,\n          y: marchedPath[i].y\n        });\n      }\n    }\n\n    var isContourValid = function isContourValid() {\n      for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {\n        var item = members_1[_i];\n        var hullPoints = hull.map(function (point) {\n          return [point.x, point.y];\n        });\n        if (!(0, _math.isPointInPolygon)(hullPoints, item.getBBox().centerX, item.getBBox().centerY)) return false;\n      } // 不强制要求所有nonMembers都没有包含在内\n      // for (const item of nonMembers) {\n      //   if (isPointInPolygon({ x: item.getBBox().centerX, y: item.getBBox().centerY }, contour)) return false\n      // }\n\n\n      return true;\n    };\n\n    if (hull && isContourValid()) {\n      return hull;\n    } // update parameters for next iteraction\n\n\n    options.threshold *= 0.9;\n\n    if (iterations <= options.maxMarchingIterations * 0.5) {\n      options.memberInfluenceFactor *= 1.2;\n      options.edgeInfluenceFactor *= 1.2;\n    } else if (options.nonMemberInfluenceFactor !== 0 && nonMembers.length > 0) {\n      // after half the iterations, start increasing positive energy and lowering the threshold\n      options.nonMemberInfluenceFactor *= 0.8;\n    } else {\n      break;\n    }\n  }\n\n  return hull;\n};\n/**\n * unionboundingbox\n * @param members\n * @param edges\n */\n\n\nexports.genBubbleSet = genBubbleSet;\n\nfunction getActiveRregion(members, edges, offset) {\n  var activeRegion = {\n    minX: Number.POSITIVE_INFINITY,\n    minY: Number.POSITIVE_INFINITY,\n    maxX: Number.NEGATIVE_INFINITY,\n    maxY: Number.NEGATIVE_INFINITY,\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0\n  };\n  var bboxes = [];\n  members.forEach(function (item) {\n    bboxes.push(item.getBBox());\n  });\n  edges.forEach(function (l) {\n    bboxes.push(l.getBBox());\n  });\n\n  for (var _i = 0, bboxes_1 = bboxes; _i < bboxes_1.length; _i++) {\n    var bbox = bboxes_1[_i];\n    activeRegion.minX = (bbox.minX < activeRegion.minX ? bbox.minX : activeRegion.minX) - offset;\n    activeRegion.minY = (bbox.minY < activeRegion.minY ? bbox.minY : activeRegion.minY) - offset;\n    activeRegion.maxX = (bbox.maxX > activeRegion.maxX ? bbox.maxX : activeRegion.maxX) + offset;\n    activeRegion.maxY = (bbox.maxY > activeRegion.maxY ? bbox.maxY : activeRegion.maxY) + offset;\n  }\n\n  activeRegion.width = activeRegion.maxX - activeRegion.minX;\n  activeRegion.height = activeRegion.maxY - activeRegion.minY;\n  activeRegion.x = activeRegion.minX;\n  activeRegion.y = activeRegion.minY;\n  return activeRegion;\n}\n\nfunction fillPotentialArea(members, nonMembers, edges, activeRegion, potentialArea, options) {\n  function pos2GridIx(x, offset) {\n    var gridIx = Math.floor((x - offset) / options.pixelGroupSize);\n    return gridIx < 0 ? 0 : gridIx;\n  }\n\n  function gridIx2Pos(x, offset) {\n    return x * options.pixelGroupSize + offset;\n  } // using inverse a for numerical stability\n\n\n  var nodeInfA = (options.nodeR0 - options.nodeR1) * (options.nodeR0 - options.nodeR1);\n  var edgeInfA = (options.edgeR0 - options.edgeR1) * (options.edgeR0 - options.edgeR1);\n\n  var getAffectedRegion = function getAffectedRegion(bbox, thresholdR) {\n    var startX = Math.min(pos2GridIx(bbox.minX, thresholdR + activeRegion.minX), potentialArea.width);\n    var startY = Math.min(pos2GridIx(bbox.minY, thresholdR + activeRegion.minY), potentialArea.height);\n    var endX = Math.min(pos2GridIx(bbox.maxX, -thresholdR + activeRegion.minX), potentialArea.width);\n    var endY = Math.min(pos2GridIx(bbox.maxY, -thresholdR + activeRegion.minY), potentialArea.height);\n    return [startX, startY, endX, endY];\n  };\n\n  var addItemInfluence = function addItemInfluence(item, influenceFactor) {\n    var bbox = item.getBBox();\n\n    var _a = getAffectedRegion(bbox, options.nodeR1),\n        startX = _a[0],\n        startY = _a[1],\n        endX = _a[2],\n        endY = _a[3]; // calculate item influence for each cell\n\n\n    for (var y = startY; y < endY; y += 1) {\n      for (var x = startX; x < endX; x += 1) {\n        if (influenceFactor < 0 && potentialArea[x + y * potentialArea.width] <= 0) {\n          continue;\n        }\n\n        var tempX = gridIx2Pos(x, activeRegion.minX);\n        var tempY = gridIx2Pos(y, activeRegion.minY);\n        var distanceSq = (0, _math.pointRectSquareDist)({\n          x: tempX,\n          y: tempY\n        }, {\n          x: bbox.minX,\n          y: bbox.minY,\n          width: bbox.width,\n          height: bbox.height\n        });\n\n        if (distanceSq < Math.pow(options.nodeR1, 2)) {\n          var dr = Math.sqrt(distanceSq) - options.nodeR1;\n          potentialArea.cells[x + y * potentialArea.width] += influenceFactor * dr * dr;\n        }\n      }\n    }\n  };\n\n  var addEdgeInfluence = function addEdgeInfluence(line, influenceFactor) {\n    var bbox = line.getBBox();\n\n    var _a = getAffectedRegion(bbox, options.edgeR1),\n        startX = _a[0],\n        startY = _a[1],\n        endX = _a[2],\n        endY = _a[3]; // for every point in active part of potentialArea, calculate distance to nearest point on line and add influence\n\n\n    for (var y = startY; y < endY; y += 1) {\n      for (var x = startX; x < endX; x += 1) {\n        if (influenceFactor < 0 && potentialArea.cells[x + y * potentialArea.width] <= 0) {\n          continue;\n        }\n\n        var tempX = gridIx2Pos(x, activeRegion.minX);\n        var tempY = gridIx2Pos(y, activeRegion.minY);\n        var minDistanceSq = (0, _math.pointLineSquareDist)({\n          x: tempX,\n          y: tempY\n        }, line); // only influence if less than r1\n\n        if (minDistanceSq < Math.pow(options.edgeR1, 2)) {\n          var mdr = Math.sqrt(minDistanceSq) - options.edgeR1;\n          potentialArea.cells[x + y * potentialArea.width] += influenceFactor * mdr * mdr;\n        }\n      }\n    }\n  };\n\n  if (options.nodeInfluenceFactor) {\n    members.forEach(function (item) {\n      addItemInfluence(item, options.nodeInfluenceFactor / nodeInfA);\n    });\n  }\n\n  if (options.edgeInfluenceFactor) {\n    edges.forEach(function (edge) {\n      addEdgeInfluence(edge, options.edgeInfluenceFactor / edgeInfA);\n    });\n  }\n\n  if (options.negativeNodeInfluenceFactor) {\n    nonMembers.forEach(function (item) {\n      addItemInfluence(item, options.negativeNodeInfluenceFactor / nodeInfA);\n    });\n  }\n}\n\nfunction rerouteLine(item, buffer, intersections, wrapNormal) {\n  var bbox = item.getBBox();\n  var topIntersect = intersections[0],\n      leftIntersect = intersections[1],\n      bottomIntersect = intersections[2],\n      rightIntersect = intersections[3];\n  var cornerPos = {\n    topLeft: {\n      x: bbox.minX - buffer,\n      y: bbox.minY - buffer\n    },\n    topRight: {\n      x: bbox.maxX + buffer,\n      y: bbox.minY - buffer\n    },\n    bottomLeft: {\n      x: bbox.minX - buffer,\n      y: bbox.maxY + buffer\n    },\n    bottomRight: {\n      x: bbox.maxX + buffer,\n      y: bbox.maxY + buffer\n    }\n  };\n  var totalArea = bbox.height * bbox.width;\n\n  function calcHalfArea(intersect1, intersect2) {\n    return bbox.width * ((intersect1.y - bbox.minY + (intersect2.y - bbox.minY)) * 0.5);\n  } // 根据线和boundingbox相交的情况，确定control point的位置\n\n\n  if (leftIntersect) {\n    // 相交区域有三角形\n    if (topIntersect) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n    if (bottomIntersect) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight; // 相交区域分成上下两个梯形，比较面积\n\n    var topArea = calcHalfArea(leftIntersect, rightIntersect);\n\n    if (topArea < totalArea * 0.5) {\n      if (leftIntersect.y > rightIntersect.y) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n      return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n    }\n\n    if (leftIntersect.y < rightIntersect.y) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\n    return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n  }\n\n  if (rightIntersect) {\n    if (topIntersect) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n    if (bottomIntersect) return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n  } // 相交区域分成左右两个梯形\n\n\n  var leftArea = calcHalfArea(topIntersect, bottomIntersect);\n\n  if (leftArea < totalArea * 0.5) {\n    if (topIntersect.x > bottomIntersect.x) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n    return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\n  }\n\n  if (topIntersect.x < bottomIntersect.x) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n  return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Arrow\", {\n  enumerable: true,\n  get: function get() {\n    return _arrow.default;\n  }\n});\nObject.defineProperty(exports, \"Marker\", {\n  enumerable: true,\n  get: function get() {\n    return _marker.default;\n  }\n});\nexports.default = void 0;\n\nvar _shape = _interopRequireDefault(require(\"./shape\"));\n\nrequire(\"./node\");\n\nrequire(\"./edge\");\n\nrequire(\"./combo\");\n\nrequire(\"./combos\");\n\nrequire(\"./nodes\");\n\nvar _arrow = _interopRequireDefault(require(\"./arrow\"));\n\nvar _marker = _interopRequireDefault(require(\"./marker\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _default = _shape.default;\nexports.default = _default;","\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _base = require(\"../util/base\");\n\nvar _global = _interopRequireDefault(require(\"../global\"));\n\nvar _shape = _interopRequireDefault(require(\"./shape\"));\n\nvar _shapeBase = require(\"./shapeBase\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar singleNode = {\n  itemType: 'node',\n  // 单个图形的类型\n  shapeType: 'single-node',\n\n  /**\n   * 文本相对图形的位置，默认以中心点\n   * 位置包括： top, bottom, left, right, center\n   * @type {String}\n   */\n  labelPosition: 'center',\n\n  /**\n   * 文本相对偏移，当 labelPosition 不为 center 时有效\n   * @type {Number}\n   */\n  offset: _global.default.nodeLabel.offset,\n\n  /**\n   * 获取节点宽高\n   * @internal 返回节点的大小，以 [width, height] 的方式维护\n   * @param  {Object} cfg 节点的配置项\n   * @return {Array} 宽高\n   */\n  getSize: function getSize(cfg) {\n    var size = cfg.size || this.getOptions({}).size || _global.default.defaultNode.size; // size 是数组，但长度为1，则补长度为2\n\n\n    if ((0, _util.isArray)(size) && size.length === 1) {\n      size = [size[0], size[0]];\n    } // size 为数字，则转换为数组\n\n\n    if (!(0, _util.isArray)(size)) {\n      size = [size, size];\n    }\n\n    return size;\n  },\n  // 私有方法，不希望扩展的节点复写这个方法\n  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg) {\n    var labelPosition = labelCfg.position || this.labelPosition; // 默认的位置（最可能的情形），所以放在最上面\n\n    if (labelPosition === 'center') {\n      return {\n        x: 0,\n        y: 0,\n        text: cfg.label\n      };\n    }\n\n    var offset = labelCfg.offset;\n\n    if ((0, _util.isNil)(offset)) {\n      // 考虑 offset = 0 的场景，不用用 labelCfg.offset || Global.nodeLabel.offset\n      offset = this.offset; // 不居中时的偏移量\n    }\n\n    var size = this.getSize(cfg);\n    var width = size[0];\n    var height = size[1];\n    var style;\n\n    switch (labelPosition) {\n      case 'top':\n        style = {\n          x: 0,\n          y: 0 - height / 2 - offset,\n          textBaseline: 'bottom' // 文本在图形的上面\n\n        };\n        break;\n\n      case 'bottom':\n        style = {\n          x: 0,\n          y: height / 2 + offset,\n          textBaseline: 'top'\n        };\n        break;\n\n      case 'left':\n        style = {\n          x: 0 - width / 2 - offset,\n          y: 0,\n          textAlign: 'right'\n        };\n        break;\n\n      default:\n        style = {\n          x: width / 2 + offset,\n          y: 0,\n          textAlign: 'left'\n        };\n        break;\n    }\n\n    style.text = cfg.label;\n    return style;\n  },\n  getLabelBgStyleByPosition: function getLabelBgStyleByPosition(label, cfg, labelCfg, group) {\n    if (!label) {\n      return {};\n    }\n\n    var bbox = label.getBBox();\n    var backgroundStyle = labelCfg.style && labelCfg.style.background;\n\n    if (!backgroundStyle) {\n      return {};\n    }\n\n    var padding = (0, _base.formatPadding)(backgroundStyle.padding);\n    var backgroundWidth = bbox.width + padding[1] + padding[3];\n    var backgroundHeight = bbox.height + padding[0] + padding[2];\n    var offset = labelCfg.offset;\n\n    if ((0, _util.isNil)(offset)) {\n      // 考虑 offset = 0 的场景，不用用 labelCfg.offset || Global.nodeLabel.offset\n      offset = this.offset; // 不居中时的偏移量\n    }\n\n    var style;\n    style = {\n      x: bbox.minX - padding[3],\n      y: bbox.minY - padding[0]\n    };\n    style = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, style), backgroundStyle), {\n      width: backgroundWidth,\n      height: backgroundHeight\n    });\n    return style;\n  },\n  drawShape: function drawShape(cfg, group) {\n    var shapeType = this.shapeType; // || this.type，都已经加了 shapeType\n\n    var style = this.getShapeStyle(cfg);\n    var shape = group.addShape(shapeType, {\n      attrs: style,\n      draggable: true,\n      name: 'node-shape'\n    });\n    return shape;\n  },\n\n  /**\n   * 更新linkPoints\n   * @param {Object} cfg 节点数据配置项\n   * @param {Group} group Item所在的group\n   */\n  updateLinkPoints: function updateLinkPoints(cfg, group) {\n    var defaultLinkPoints = this.getOptions(cfg).linkPoints;\n    var markLeft = group.find(function (element) {\n      return element.get('className') === 'link-point-left';\n    });\n    var markRight = group.find(function (element) {\n      return element.get('className') === 'link-point-right';\n    });\n    var markTop = group.find(function (element) {\n      return element.get('className') === 'link-point-top';\n    });\n    var markBottom = group.find(function (element) {\n      return element.get('className') === 'link-point-bottom';\n    });\n    var currentLinkPoints;\n\n    if (markLeft) {\n      currentLinkPoints = markLeft.attr();\n    }\n\n    if (markRight && !currentLinkPoints) {\n      currentLinkPoints = markRight.attr();\n    }\n\n    if (markTop && !currentLinkPoints) {\n      currentLinkPoints = markTop.attr();\n    }\n\n    if (markBottom && !currentLinkPoints) {\n      currentLinkPoints = markBottom.attr();\n    }\n\n    if (!currentLinkPoints) currentLinkPoints = defaultLinkPoints;\n    var linkPoints = (0, _util.mix)({}, currentLinkPoints, cfg.linkPoints);\n    var markFill = linkPoints.fill,\n        markStroke = linkPoints.stroke,\n        borderWidth = linkPoints.lineWidth;\n    var markSize = linkPoints.size / 2;\n    if (!markSize) markSize = linkPoints.r;\n\n    var _a = cfg.linkPoints ? cfg.linkPoints : {\n      left: undefined,\n      right: undefined,\n      top: undefined,\n      bottom: undefined\n    },\n        left = _a.left,\n        right = _a.right,\n        top = _a.top,\n        bottom = _a.bottom;\n\n    var size = this.getSize(cfg);\n    var width = size[0];\n    var height = size[1];\n    var styles = {\n      r: markSize,\n      fill: markFill,\n      stroke: markStroke,\n      lineWidth: borderWidth\n    };\n\n    if (markLeft) {\n      if (!left && left !== undefined) {\n        markLeft.remove();\n      } else {\n        markLeft.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n          x: -width / 2,\n          y: 0\n        }));\n      }\n    } else if (left) {\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n          x: -width / 2,\n          y: 0\n        }),\n        className: 'link-point-left',\n        name: 'link-point-left',\n        isAnchorPoint: true\n      });\n    }\n\n    if (markRight) {\n      if (!right && right !== undefined) {\n        markRight.remove();\n      }\n\n      markRight.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n        x: width / 2,\n        y: 0\n      }));\n    } else if (right) {\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n          x: width / 2,\n          y: 0\n        }),\n        className: 'link-point-right',\n        name: 'link-point-right',\n        isAnchorPoint: true\n      });\n    }\n\n    if (markTop) {\n      if (!top && top !== undefined) {\n        markTop.remove();\n      }\n\n      markTop.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n        x: 0,\n        y: -height / 2\n      }));\n    } else if (top) {\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n          x: 0,\n          y: -height / 2\n        }),\n        className: 'link-point-top',\n        name: 'link-point-top',\n        isAnchorPoint: true\n      });\n    }\n\n    if (markBottom) {\n      if (!bottom && bottom !== undefined) {\n        markBottom.remove();\n      } else {\n        markBottom.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n          x: 0,\n          y: height / 2\n        }));\n      }\n    } else if (bottom) {\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n          x: 0,\n          y: height / 2\n        }),\n        className: 'link-point-bottom',\n        name: 'link-point-bottom',\n        isAnchorPoint: true\n      });\n    }\n  },\n  updateShape: function updateShape(cfg, item, keyShapeStyle, hasIcon) {\n    var keyShape = item.get('keyShape');\n    keyShape.attr((0, _tslib.__assign)({}, keyShapeStyle));\n    this.updateLabel(cfg, item); // special for some types of nodes\n\n    if (hasIcon) {\n      this.updateIcon(cfg, item);\n    }\n  },\n  updateIcon: function updateIcon(cfg, item) {\n    var _this = this;\n\n    var group = item.getContainer();\n    var icon = this.getOptions(cfg).icon;\n    var show = (cfg.icon ? cfg.icon : {\n      show: undefined\n    }).show;\n    var iconShape = group.find(function (element) {\n      return element.get('className') === _this.type + \"-icon\";\n    });\n\n    if (iconShape) {\n      // 若原先存在 icon\n      if (show || show === undefined) {\n        // 若传入 show: true, 或没有设置，则更新原有的 icon 样式\n        var iconConfig = (0, _util.mix)({}, iconShape.attr(), icon);\n        var w = iconConfig.width,\n            h = iconConfig.height;\n        iconShape.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, iconConfig), {\n          x: -w / 2,\n          y: -h / 2\n        }));\n      } else {\n        // 若传入了 show: false 则删除原先的 icon\n        iconShape.remove();\n      }\n    } else if (show) {\n      // 如果原先不存在 icon，但传入了 show: true，则新增 icon\n      var w = icon.width,\n          h = icon.height;\n      group.addShape('image', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, icon), {\n          x: -w / 2,\n          y: -h / 2\n        }),\n        className: this.type + \"-icon\",\n        name: this.type + \"-icon\"\n      }); // to ensure the label is on the top of all the shapes\n\n      var labelShape = group.find(function (element) {\n        return element.get('className') === \"node-label\";\n      });\n\n      if (labelShape) {\n        labelShape.toFront();\n      }\n    }\n  }\n};\nvar singleNodeDef = (0, _tslib.__assign)((0, _tslib.__assign)({}, _shapeBase.shapeBase), singleNode);\n\n_shape.default.registerNode('single-node', singleNodeDef);","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shapeBase = exports.CLS_LABEL_BG_SUFFIX = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _global = _interopRequireDefault(require(\"../global\"));\n\nvar _matrixUtil = require(\"@antv/matrix-util\");\n\nvar _util = require(\"@antv/util\");\n\nvar _graphic = require(\"../util/graphic\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar transform = _matrixUtil.ext.transform;\nvar CLS_SHAPE_SUFFIX = '-shape';\nvar CLS_LABEL_SUFFIX = '-label';\nvar ARROWS = ['startArrow', 'endArrow'];\nvar SHAPE_DEFAULT_ATTRS = {\n  lineWidth: 1,\n  stroke: undefined,\n  fill: undefined,\n  lineAppendWidth: 1,\n  opacity: undefined,\n  strokeOpacity: undefined,\n  fillOpacity: undefined,\n  x: 0,\n  y: 0,\n  r: 10,\n  width: 20,\n  height: 20,\n  shadowColor: undefined,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0\n};\nvar PATH_SHAPE_DEFAULT_ATTRS = {\n  lineWidth: 1,\n  stroke: '#000',\n  lineDash: undefined,\n  startArrow: false,\n  endArrow: false,\n  opacity: undefined,\n  strokeOpacity: undefined,\n  fillOpacity: undefined,\n  shadowColor: undefined,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0\n};\nvar SHAPES_DEFAULT_ATTRS = {\n  edge: PATH_SHAPE_DEFAULT_ATTRS,\n  node: SHAPE_DEFAULT_ATTRS,\n  combo: SHAPE_DEFAULT_ATTRS\n};\nvar CLS_LABEL_BG_SUFFIX = '-label-bg'; // 单个 shape 带有一个 label，共用这段代码\n\nexports.CLS_LABEL_BG_SUFFIX = CLS_LABEL_BG_SUFFIX;\nvar shapeBase = {\n  // 默认样式及配置\n  options: {},\n  itemType: '',\n\n  /**\n   * 形状的类型，例如 circle，ellipse，polyline...\n   */\n  type: '',\n  getCustomConfig: function getCustomConfig(cfg) {\n    return {};\n  },\n  getOptions: function getOptions(cfg) {\n    return (0, _util.deepMix)({\n      // 解决局部渲染导致的文字移动残影问题\n      labelCfg: {\n        style: {\n          fontFamily: typeof window !== 'undefined' && window.getComputedStyle ? window.getComputedStyle(document.body, null).getPropertyValue('font-family') || 'Arial, sans-serif' : 'Arial, sans-serif'\n        }\n      },\n      descriptionCfg: {\n        style: {\n          fontFamily: typeof window !== 'undefined' && window.getComputedStyle ? window.getComputedStyle(document.body, null).getPropertyValue('font-family') || 'Arial, sans-serif' : 'Arial, sans-serif'\n        }\n      }\n    }, this.options, this.getCustomConfig(cfg) || {}, cfg);\n  },\n\n  /**\n   * 绘制节点/边，包含文本\n   * @override\n   * @param  {Object} cfg 节点的配置项\n   * @param  {G.Group} group 节点的容器\n   * @return {IShape} 绘制的图形\n   */\n  draw: function draw(cfg, group) {\n    var shape = this.drawShape(cfg, group);\n    shape.set('className', this.itemType + CLS_SHAPE_SUFFIX);\n\n    if (cfg.label) {\n      var label = this.drawLabel(cfg, group);\n      label.set('className', this.itemType + CLS_LABEL_SUFFIX);\n    }\n\n    return shape;\n  },\n\n  /**\n   * 绘制完成后的操作，便于用户继承现有的节点、边\n   * @param cfg\n   * @param group\n   * @param keyShape\n   */\n  afterDraw: function afterDraw(cfg, group, keyShape) {},\n  drawShape: function drawShape(cfg, group) {\n    return null;\n  },\n  drawLabel: function drawLabel(cfg, group) {\n    var defaultLabelCfg = this.getOptions(cfg).labelCfg; // image的情况下有可能为null\n\n    var labelCfg = defaultLabelCfg || {};\n    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);\n    var rotate = labelStyle.rotate;\n    delete labelStyle.rotate;\n    var label = group.addShape('text', {\n      attrs: labelStyle,\n      draggable: true,\n      className: 'text-shape',\n      name: 'text-shape'\n    });\n\n    if (rotate) {\n      var labelBBox = label.getBBox();\n      var labelMatrix = label.getMatrix();\n\n      if (!labelMatrix) {\n        labelMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      }\n\n      if (labelStyle.rotateCenter) {\n        switch (labelStyle.rotateCenter) {\n          case 'center':\n            labelMatrix = transform(labelMatrix, [['t', -labelBBox.width / 2, -labelBBox.height / 2], ['r', rotate], ['t', labelBBox.width / 2, labelBBox.height / 2]]);\n            break;\n\n          case 'lefttop':\n            labelMatrix = transform(labelMatrix, [['t', -labelStyle.x, -labelStyle.y], ['r', rotate], ['t', labelStyle.x, labelStyle.y]]);\n            break;\n\n          case 'leftcenter':\n            labelMatrix = transform(labelMatrix, [['t', -labelStyle.x, -labelStyle.y - labelBBox.height / 2], ['r', rotate], ['t', labelStyle.x, labelStyle.y + labelBBox.height / 2]]);\n            break;\n\n          default:\n            labelMatrix = transform(labelMatrix, [['t', -labelBBox.width / 2, -labelBBox.height / 2], ['r', rotate], ['t', labelBBox.width / 2, labelBBox.height / 2]]);\n            break;\n        }\n      } else {\n        labelMatrix = transform(labelMatrix, [['t', -labelStyle.x, -labelStyle.y - labelBBox.height / 2], ['r', rotate], ['t', labelStyle.x, labelStyle.y + labelBBox.height / 2]]);\n      }\n\n      label.setMatrix(labelMatrix);\n    }\n\n    if (labelStyle.background) {\n      var rect = this.drawLabelBg(cfg, group, label);\n      var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;\n      rect.set('classname', labelBgClassname);\n      label.toFront();\n    }\n\n    return label;\n  },\n  drawLabelBg: function drawLabelBg(cfg, group, label) {\n    var defaultLabelCfg = this.options.labelCfg;\n    var labelCfg = (0, _util.mix)({}, defaultLabelCfg, cfg.labelCfg);\n    var style = this.getLabelBgStyleByPosition(label, cfg, labelCfg, group);\n    var rect = group.addShape('rect', {\n      name: 'text-bg-shape',\n      attrs: style\n    });\n    return rect;\n  },\n  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg, group) {\n    return {\n      text: cfg.label\n    };\n  },\n  getLabelBgStyleByPosition: function getLabelBgStyleByPosition(label, cfg, labelCfg, group) {\n    return {};\n  },\n\n  /**\n   * 获取文本的配置项\n   * @param cfg 节点的配置项\n   * @param labelCfg 文本的配置项\n   * @param group 父容器，label 的定位可能与图形相关\n   */\n  getLabelStyle: function getLabelStyle(cfg, labelCfg, group) {\n    var calculateStyle = this.getLabelStyleByPosition(cfg, labelCfg, group);\n    var attrName = this.itemType + \"Label\"; // 取 nodeLabel，edgeLabel 的配置项\n\n    var defaultStyle = _global.default[attrName] ? _global.default[attrName].style : null;\n    var labelStyle = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, defaultStyle), calculateStyle), labelCfg.style);\n    return labelStyle;\n  },\n\n  /**\n   * 获取图形的配置项\n   * @param cfg\n   */\n  getShapeStyle: function getShapeStyle(cfg) {\n    return cfg.style;\n  },\n\n  /**\n   * 更新节点，包含文本\n   * @override\n   * @param  {Object} cfg 节点/边的配置项\n   * @param  {G6.Item} item 节点/边\n   */\n  update: function update(cfg, item) {\n    this.updateShapeStyle(cfg, item);\n    this.updateLabel(cfg, item);\n  },\n  updateShapeStyle: function updateShapeStyle(cfg, item) {\n    var group = item.getContainer();\n    var shape = item.getKeyShape();\n    var shapeStyle = (0, _util.mix)({}, shape.attr(), cfg.style);\n\n    var _loop_1 = function _loop_1(key) {\n      var _a;\n\n      var style = shapeStyle[key];\n\n      if ((0, _util.isPlainObject)(style)) {\n        // 更新图元素样式，支持更新子元素\n        var subShape = group.find(function (element) {\n          return element.get('name') === key;\n        });\n\n        if (subShape) {\n          subShape.attr(style);\n        }\n      } else {\n        shape.attr((_a = {}, _a[key] = style, _a));\n      }\n    };\n\n    for (var key in shapeStyle) {\n      _loop_1(key);\n    }\n  },\n  updateLabel: function updateLabel(cfg, item) {\n    var group = item.getContainer();\n    var defaultLabelCfg = this.getOptions({}).labelCfg;\n    var labelClassName = this.itemType + CLS_LABEL_SUFFIX;\n    var label = group.find(function (element) {\n      return element.get('className') === labelClassName;\n    });\n    var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;\n    var labelBg = group.find(function (element) {\n      return element.get('classname') === labelBgClassname;\n    }); // 防止 cfg.label = \"\" 的情况\n\n    if (cfg.label || cfg.label === '') {\n      // 若传入的新配置中有 label，（用户没传入但原先有 label，label 也会有值）\n      if (!label) {\n        // 若原先不存在 label，则绘制一个新的 label\n        var newLabel = this.drawLabel(cfg, group);\n        newLabel.set('className', labelClassName);\n      } else {\n        // 若原先存在 label，则更新样式。与 getLabelStyle 不同在于这里需要融合当前 label 的样式\n        // 用于融合 style 以外的属性：position, offset, ...\n        var currentLabelCfg = {};\n\n        if (item.getModel) {\n          currentLabelCfg = item.getModel().labelCfg;\n        } // 这里不能去掉\n\n\n        var labelCfg = (0, _util.deepMix)({}, defaultLabelCfg, currentLabelCfg, cfg.labelCfg); // 获取位置信息\n\n        var calculateStyle = this.getLabelStyleByPosition(cfg, labelCfg, group); // 取 nodeLabel，edgeLabel 的配置项\n\n        var cfgStyle = cfg.labelCfg ? cfg.labelCfg.style : undefined;\n        var cfgBgStyle = labelCfg.style && labelCfg.style.background; // 需要融合当前\b label 的样式 label.attr()。不再需要全局/默认样式，因为已经应用在当前的 label 上\n\n        var labelStyle = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, label.attr()), calculateStyle), cfgStyle);\n        var rotate = labelStyle.rotate;\n        delete labelStyle.rotate; // 计算 label 的旋转矩阵\n\n        if (rotate) {\n          // if G 4.x define the rotateAtStart, use it directly instead of using the following codes\n          var rotateMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          rotateMatrix = transform(rotateMatrix, [['t', -labelStyle.x, -labelStyle.y], ['r', rotate], ['t', labelStyle.x, labelStyle.y]]);\n          label.resetMatrix();\n          label.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, labelStyle), {\n            matrix: rotateMatrix\n          }));\n        } else {\n          label.resetMatrix();\n          label.attr(labelStyle);\n        }\n\n        if (!labelBg) {\n          if (labelStyle.background) {\n            labelBg = this.drawLabelBg(cfg, group, label);\n            labelBg.set('classname', labelBgClassname);\n            label.toFront();\n          }\n        } else if (labelStyle.background) {\n          var calculateBgStyle = this.getLabelBgStyleByPosition(label, cfg, labelCfg, group);\n          var labelBgStyle = (0, _tslib.__assign)((0, _tslib.__assign)({}, calculateBgStyle), cfgBgStyle);\n          labelBg.resetMatrix();\n\n          if (rotate) {\n            var bgRotateMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n            bgRotateMatrix = transform(bgRotateMatrix, [['t', -labelBgStyle.x, -labelBgStyle.y], ['r', rotate], ['t', labelBgStyle.x, labelBgStyle.y]]);\n            labelBgStyle.matrix = bgRotateMatrix;\n          }\n\n          labelBg.attr(labelBgStyle);\n        } else {\n          group.removeChild(labelBg);\n        }\n      }\n    }\n  },\n  // update(cfg, item) // 默认不定义\n  afterUpdate: function afterUpdate(cfg, item) {},\n\n  /**\n   * 设置节点的状态，主要是交互状态，业务状态请在 draw 方法中实现\n   * 单图形的节点仅考虑 selected、active 状态，有其他状态需求的用户自己复写这个方法\n   * @override\n   * @param  {String} name 状态名称\n   * @param  {String | Boolean} value 状态值\n   * @param  {G6.Item} item 节点\n   */\n  setState: function setState(name, value, item) {\n    var _a, _b;\n\n    var shape = item.get('keyShape');\n    if (!shape || shape.destroyed) return;\n    var type = item.getType();\n    var stateName = (0, _util.isBoolean)(value) ? name : name + \":\" + value;\n    var shapeStateStyle = this.getStateStyle(stateName, item);\n    var itemStateStyle = item.getStateStyle(stateName); // const originStyle = item.getOriginStyle();\n    // 不允许设置一个不存在的状态\n\n    if (!itemStateStyle && !shapeStateStyle) {\n      return;\n    } // 要设置或取消的状态的样式\n    // 当没有 state 状态时，默认使用 model.stateStyles 中的样式\n\n\n    var styles = (0, _util.mix)({}, itemStateStyle || shapeStateStyle);\n    var group = item.getContainer(); // 从图元素现有的样式中删除本次要取消的 states 中存在的属性值。使用对象检索更快\n\n    var keptAttrs = {\n      x: 1,\n      y: 1,\n      cx: 1,\n      cy: 1\n    };\n\n    if (type === 'combo') {\n      keptAttrs.r = 1;\n      keptAttrs.width = 1;\n      keptAttrs.height = 1;\n    }\n\n    if (value) {\n      var _loop_2 = function _loop_2(key) {\n        var _c;\n\n        var style = styles[key];\n\n        if ((0, _util.isPlainObject)(style) && !ARROWS.includes(key)) {\n          var subShape = group.find(function (element) {\n            return element.get('name') === key;\n          });\n\n          if (subShape) {\n            subShape.attr(style);\n          }\n        } else {\n          // 非纯对象，则认为是设置到 keyShape 上面的\n          shape.attr((_c = {}, _c[key] = style, _c));\n        }\n      }; // style 为要设置的状态的样式\n\n\n      for (var key in styles) {\n        _loop_2(key);\n      }\n    } else {\n      // 所有生效的 state 的样式\n      var enableStatesStyle = (0, _graphic.cloneBesidesImg)(item.getCurrentStatesStyle());\n      var model = item.getModel(); // 原始样式\n\n      var originStyle_1 = (0, _util.mix)({}, model.style, (0, _graphic.cloneBesidesImg)(item.getOriginStyle()));\n      var keyShapeName_1 = shape.get('name'); // cloning  shape.attr(), keys.forEach to avoid cloning the img attr, which leads to maximum clone heap #2383\n      // const keyShapeStyles = clone(shape.attr())\n\n      var shapeAttrs_1 = shape.attr();\n      var keyShapeStyles_1 = {};\n      Object.keys(shapeAttrs_1).forEach(function (key) {\n        if (key === 'img') return;\n        var attr = shapeAttrs_1[key];\n\n        if (attr && _typeof(attr) === 'object') {\n          keyShapeStyles_1[key] = (0, _util.clone)(attr);\n        } else {\n          keyShapeStyles_1[key] = attr;\n        }\n      }); // 已有样式 - 要取消的状态的样式\n\n      var filtetDisableStatesStyle = {};\n\n      var _loop_3 = function _loop_3(p) {\n        var style = styles[p];\n\n        if ((0, _util.isPlainObject)(style) && !ARROWS.includes(p)) {\n          var subShape_1 = group.find(function (element) {\n            return element.get('name') === p;\n          });\n\n          if (subShape_1) {\n            var subShapeStyles_1 = (0, _util.clone)(subShape_1.attr());\n            (0, _util.each)(style, function (v, key) {\n              if (p === keyShapeName_1 && keyShapeStyles_1[key] && !keptAttrs[key]) {\n                delete keyShapeStyles_1[key];\n                var value_1 = originStyle_1[p][key] || SHAPES_DEFAULT_ATTRS[type][key];\n                shape.attr(key, value_1);\n              } else if (subShapeStyles_1[key] || subShapeStyles_1[key] === 0) {\n                delete subShapeStyles_1[key];\n                var value_2 = originStyle_1[p][key] || SHAPES_DEFAULT_ATTRS[type][key];\n                subShape_1.attr(key, value_2);\n              }\n            });\n            filtetDisableStatesStyle[p] = subShapeStyles_1;\n          }\n        } else {\n          if (keyShapeStyles_1[p] && !keptAttrs[p]) {\n            delete keyShapeStyles_1[p];\n            var value_3 = originStyle_1[p] || (originStyle_1[keyShapeName_1] ? originStyle_1[keyShapeName_1][p] : undefined) || SHAPES_DEFAULT_ATTRS[type][p];\n            shape.attr(p, value_3);\n          }\n        }\n      }; // styles 为要取消的状态的样式\n\n\n      for (var p in styles) {\n        _loop_3(p);\n      } // 从图元素现有的样式中删除本次要取消的 states 中存在的属性值后，\n      // 如果 keyShape 有 name 属性，则 filtetDisableStatesStyle 的格式为 { keyShapeName: {} }\n      // 否则为普通对象\n\n\n      if (!keyShapeName_1) {\n        (0, _util.mix)(filtetDisableStatesStyle, keyShapeStyles_1);\n      } else {\n        filtetDisableStatesStyle[keyShapeName_1] = keyShapeStyles_1;\n      }\n\n      for (var key in enableStatesStyle) {\n        if (keptAttrs[key]) continue;\n        var enableStyle = enableStatesStyle[key];\n\n        if (!(0, _util.isPlainObject)(enableStyle) || ARROWS.includes(key)) {\n          // 把样式属性merge到keyShape中\n          if (!keyShapeName_1) {\n            (0, _util.mix)(originStyle_1, (_a = {}, _a[key] = enableStyle, _a));\n          } else {\n            (0, _util.mix)(originStyle_1[keyShapeName_1], (_b = {}, _b[key] = enableStyle, _b));\n            delete originStyle_1[key];\n          }\n\n          delete enableStatesStyle[key];\n        }\n      }\n\n      var originstyles = {};\n      (0, _util.deepMix)(originstyles, originStyle_1, filtetDisableStatesStyle, enableStatesStyle);\n      var keyShapeSetted = false;\n\n      var _loop_4 = function _loop_4(originKey) {\n        var _d, _e;\n\n        var style = originstyles[originKey];\n\n        if ((0, _util.isPlainObject)(style) && !ARROWS.includes(originKey)) {\n          var subShape = group.find(function (element) {\n            return element.get('name') === originKey;\n          });\n\n          if (subShape) {\n            if (originKey === keyShapeName_1) {\n              if (type === 'combo') {\n                delete style.r;\n                delete style.width;\n                delete style.height;\n              }\n\n              keyShapeSetted = true;\n            }\n\n            subShape.attr(style);\n          }\n        } else if (!keyShapeSetted) {\n          var value_4 = style || SHAPES_DEFAULT_ATTRS[type][originKey]; // 当更新 combo 状态时，当不存在 keyShapeName 时候，则认为是设置到 keyShape 上面的\n\n          if (type === 'combo') {\n            if (!keyShapeName_1) {\n              shape.attr((_d = {}, _d[originKey] = value_4, _d));\n            }\n          } else {\n            shape.attr((_e = {}, _e[originKey] = value_4, _e));\n          }\n        }\n      };\n\n      for (var originKey in originstyles) {\n        _loop_4(originKey);\n      }\n    }\n  },\n\n  /**\n   * 获取不同状态下的样式\n   *\n   * @param {string} name 状态名称\n   * @param {Item} item Node或Edge的实例\n   * @return {object} 样式\n   */\n  getStateStyle: function getStateStyle(name, item) {\n    var model = item.getModel();\n    var type = item.getType();\n\n    var _a = this.getOptions(model),\n        stateStyles = _a.stateStyles,\n        _b = _a.style,\n        style = _b === void 0 ? {} : _b;\n\n    var modelStateStyle = model.stateStyles ? model.stateStyles[name] : stateStyles && stateStyles[name];\n\n    if (type === 'combo') {\n      return (0, _util.clone)(modelStateStyle);\n    }\n\n    return (0, _util.mix)({}, style, modelStateStyle);\n  },\n\n  /**\n   * 获取控制点\n   * @param  {Object} cfg 节点、边的配置项\n   * @return {Array|null} 控制点的数组,如果为 null，则没有控制点\n   */\n  getControlPoints: function getControlPoints(cfg) {\n    return cfg.controlPoints;\n  },\n\n  /**\n   * 获取控制点\n   * @param  {Object} cfg 节点、边的配置项\n   * @return {Array|null} 锚点的数组,如果为 null，则没有锚点\n   */\n  getAnchorPoints: function getAnchorPoints(cfg) {\n    var anchorPoints = this.getOptions(cfg).anchorPoints;\n    return anchorPoints;\n  }\n};\nexports.shapeBase = shapeBase;","\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _graphic = require(\"../util/graphic\");\n\nvar _math = require(\"../util/math\");\n\nvar _path = require(\"../util/path\");\n\nvar _global = _interopRequireDefault(require(\"../global\"));\n\nvar _shape = _interopRequireDefault(require(\"./shape\"));\n\nvar _shapeBase = require(\"./shapeBase\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @fileOverview 自定义边\n * @description 自定义边中有大量逻辑同自定义节点重复，虽然可以提取成为 mixin ，但是考虑到代码的可读性，还是单独实现。\n */\nvar CLS_SHAPE = 'edge-shape'; // start,end 倒置，center 不变\n\nfunction revertAlign(labelPosition) {\n  var textAlign = labelPosition;\n\n  if (labelPosition === 'start') {\n    textAlign = 'end';\n  } else if (labelPosition === 'end') {\n    textAlign = 'start';\n  }\n\n  return textAlign;\n}\n\nvar singleEdge = {\n  itemType: 'edge',\n\n  /**\n   * 文本的位置\n   * @type {String}\n   */\n  labelPosition: 'center',\n\n  /**\n   * 文本的 x 偏移\n   * @type {Number}\n   */\n  refX: 0,\n\n  /**\n   * 文本的 y 偏移\n   * @type {Number}\n   */\n  refY: 0,\n\n  /**\n   * 文本是否跟着线自动旋转，默认 false\n   * @type {Boolean}\n   */\n  labelAutoRotate: false,\n  // 自定义边时的配置\n  options: {\n    size: _global.default.defaultEdge.size,\n    style: {\n      x: 0,\n      y: 0,\n      stroke: _global.default.defaultEdge.style.stroke,\n      lineAppendWidth: _global.default.defaultEdge.style.lineAppendWidth\n    },\n    labelCfg: {\n      style: {\n        fill: _global.default.edgeLabel.style.fill,\n        fontSize: _global.default.edgeLabel.style.fontSize\n      }\n    },\n    stateStyles: (0, _tslib.__assign)({}, _global.default.edgeStateStyles)\n  },\n\n  /**\n   * 获取边的 path\n   * @internal 供扩展的边覆盖\n   * @param  {Array} points 构成边的点的集合\n   * @return {Array} 构成 path 的数组\n   */\n  getPath: function getPath(points) {\n    var path = [];\n    (0, _util.each)(points, function (point, index) {\n      if (index === 0) {\n        path.push(['M', point.x, point.y]);\n      } else {\n        path.push(['L', point.x, point.y]);\n      }\n    });\n    return path;\n  },\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.options.style;\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = (0, _util.mix)({}, defaultStyle, strokeStyle, cfg.style);\n    var size = cfg.size || _global.default.defaultEdge.size;\n    cfg = this.getPathPoints(cfg);\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var controlPoints = this.getControlPoints(cfg);\n    var points = [startPoint]; // 添加起始点\n    // 添加控制点\n\n    if (controlPoints) {\n      points = points.concat(controlPoints);\n    } // 添加结束点\n\n\n    points.push(endPoint);\n    var path = this.getPath(points);\n    var styles = (0, _util.mix)({}, _global.default.defaultEdge.style, {\n      stroke: _global.default.defaultEdge.color,\n      lineWidth: size,\n      path: path\n    }, style);\n    return styles;\n  },\n  updateShapeStyle: function updateShapeStyle(cfg, item) {\n    var group = item.getContainer();\n    var strokeStyle = {\n      stroke: cfg.color\n    };\n    var shape = group.find(function (element) {\n      return element.get('className') === 'edge-shape';\n    }) || item.getKeyShape();\n    var size = cfg.size;\n    cfg = this.getPathPoints(cfg);\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var controlPoints = this.getControlPoints(cfg); // || cfg.controlPoints;\n\n    var points = [startPoint]; // 添加起始点\n    // 添加控制点\n\n    if (controlPoints) {\n      points = points.concat(controlPoints);\n    } // 添加结束点\n\n\n    points.push(endPoint);\n    var currentAttr = shape.attr();\n    var previousStyle = (0, _util.mix)({}, strokeStyle, currentAttr, cfg.style);\n    var source = cfg.sourceNode;\n    var target = cfg.targetNode;\n    var routeCfg = {\n      radius: previousStyle.radius\n    };\n\n    if (!controlPoints) {\n      routeCfg = {\n        source: source,\n        target: target,\n        offset: previousStyle.offset,\n        radius: previousStyle.radius\n      };\n    }\n\n    if (currentAttr.endArrow && previousStyle.endArrow === false) {\n      cfg.style.endArrow = {\n        path: ''\n      };\n    }\n\n    if (currentAttr.startArrow && previousStyle.startArrow === false) {\n      cfg.style.startArrow = {\n        path: ''\n      };\n    }\n\n    var path = this.getPath(points, routeCfg);\n    var style = (0, _util.mix)(strokeStyle, shape.attr(), {\n      lineWidth: size,\n      path: path\n    }, cfg.style);\n\n    if (shape) {\n      shape.attr(style);\n    }\n  },\n  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg, group) {\n    var labelPosition = labelCfg.position || this.labelPosition; // 文本的位置用户可以传入\n\n    var style = {};\n    var pathShape = group && group.find(function (element) {\n      return element.get('className') === CLS_SHAPE;\n    }); // 不对 pathShape 进行判空，如果线不存在，说明有问题了\n\n    var pointPercent;\n\n    if (labelPosition === 'start') {\n      pointPercent = 0;\n    } else if (labelPosition === 'end') {\n      pointPercent = 1;\n    } else {\n      pointPercent = 0.5;\n    } // 偏移量\n\n\n    var offsetX = labelCfg.refX || this.refX;\n    var offsetY = labelCfg.refY || this.refY; // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移\n\n    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {\n      style.x = cfg.startPoint.x + offsetX;\n      style.y = cfg.startPoint.y + offsetY;\n      style.text = cfg.label;\n      return style;\n    }\n\n    var autoRotate;\n    if ((0, _util.isNil)(labelCfg.autoRotate)) autoRotate = this.labelAutoRotate;else autoRotate = labelCfg.autoRotate;\n    var offsetStyle = (0, _graphic.getLabelPosition)(pathShape, pointPercent, offsetX, offsetY, autoRotate);\n    style.x = offsetStyle.x;\n    style.y = offsetStyle.y;\n    style.rotate = offsetStyle.rotate;\n    style.textAlign = this._getTextAlign(labelPosition, offsetStyle.angle);\n    style.text = cfg.label;\n    return style;\n  },\n  getLabelBgStyleByPosition: function getLabelBgStyleByPosition(label, cfg, labelCfg, group) {\n    if (!label) {\n      return {};\n    }\n\n    var bbox = label.getBBox();\n    var backgroundStyle = labelCfg.style && labelCfg.style.background;\n\n    if (!backgroundStyle) {\n      return {};\n    }\n\n    var padding = backgroundStyle.padding;\n    var backgroundWidth = bbox.width + padding[1] + padding[3];\n    var backgroundHeight = bbox.height + padding[0] + padding[2];\n    var labelPosition = labelCfg.position || this.labelPosition;\n    var style = (0, _tslib.__assign)((0, _tslib.__assign)({}, backgroundStyle), {\n      width: backgroundWidth,\n      height: backgroundHeight,\n      x: bbox.minX - padding[2],\n      y: bbox.minY - padding[0],\n      rotate: 0\n    });\n    var autoRotate;\n    if ((0, _util.isNil)(labelCfg.autoRotate)) autoRotate = this.labelAutoRotate;else autoRotate = labelCfg.autoRotate;\n    var pathShape = group && group.find(function (element) {\n      return element.get('className') === CLS_SHAPE;\n    }); // 不对 pathShape 进行判空，如果线不存在，说明有问题了\n\n    var pointPercent;\n\n    if (labelPosition === 'start') {\n      pointPercent = 0;\n    } else if (labelPosition === 'end') {\n      pointPercent = 1;\n    } else {\n      pointPercent = 0.5;\n    } // 偏移量\n\n\n    var offsetX = labelCfg.refX || this.refX;\n    var offsetY = labelCfg.refY || this.refY; // // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移\n\n    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {\n      style.x = cfg.startPoint.x + offsetX - backgroundWidth / 2;\n      style.y = cfg.startPoint.y + offsetY - backgroundHeight / 2;\n      return style;\n    }\n\n    var offsetStyle = (0, _graphic.getLabelPosition)(pathShape, pointPercent, offsetX - backgroundWidth / 2, offsetY + backgroundHeight / 2, autoRotate);\n    var rad = offsetStyle.angle;\n\n    if (rad > 1 / 2 * Math.PI && rad < 3 * 1 / 2 * Math.PI) {\n      offsetStyle = (0, _graphic.getLabelPosition)(pathShape, pointPercent, offsetX + backgroundWidth / 2, offsetY + backgroundHeight / 2, autoRotate);\n    }\n\n    if (autoRotate) {\n      style.x = offsetStyle.x;\n      style.y = offsetStyle.y;\n    }\n\n    style.rotate = offsetStyle.rotate;\n    return style;\n  },\n  // 获取文本对齐方式\n  _getTextAlign: function _getTextAlign(labelPosition, angle) {\n    var textAlign = 'center';\n\n    if (!angle) {\n      return labelPosition;\n    }\n\n    angle = angle % (Math.PI * 2); // 取模\n\n    if (labelPosition !== 'center') {\n      if (angle >= 0 && angle <= Math.PI / 2 || angle >= 3 / 2 * Math.PI && angle < 2 * Math.PI) {\n        textAlign = labelPosition;\n      } else {\n        textAlign = revertAlign(labelPosition);\n      }\n    }\n\n    return textAlign;\n  },\n\n  /**\n   * @internal 获取边的控制点\n   * @param  {Object} cfg 边的配置项\n   * @return {Array} 控制点的数组\n   */\n  getControlPoints: function getControlPoints(cfg) {\n    return cfg.controlPoints;\n  },\n\n  /**\n   * @internal 处理需要重计算点和边的情况\n   * @param {Object} cfg 边的配置项\n   * @return {Object} 边的配置项\n   */\n  getPathPoints: function getPathPoints(cfg) {\n    return cfg;\n  },\n\n  /**\n   * 绘制边\n   * @override\n   * @param  {Object} cfg   边的配置项\n   * @param  {G.Group} group 边的容器\n   * @return {IShape} 图形\n   */\n  drawShape: function drawShape(cfg, group) {\n    var shapeStyle = this.getShapeStyle(cfg);\n    var shape = group.addShape('path', {\n      className: CLS_SHAPE,\n      name: CLS_SHAPE,\n      attrs: shapeStyle\n    });\n    return shape;\n  },\n  drawLabel: function drawLabel(cfg, group) {\n    var defaultLabelCfg = this.options.labelCfg;\n    var defaultFontFamily;\n    if (typeof window !== 'undefined' && typeof window.getComputedStyle !== 'undefined') defaultFontFamily = window.getComputedStyle(document.body, null).getPropertyValue('font-family') || 'Arial, sans-serif';else defaultFontFamily = 'Arial, sans-serif';\n    var labelCfg = (0, _util.deepMix)({\n      fontFamily: defaultFontFamily\n    }, defaultLabelCfg, cfg.labelCfg);\n    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);\n    var rotate = labelStyle.rotate;\n    delete labelStyle.rotate;\n    var label = group.addShape('text', {\n      attrs: labelStyle,\n      name: 'text-shape'\n    });\n\n    if (rotate) {\n      label.rotateAtStart(rotate);\n    }\n\n    if (labelStyle.background) {\n      var rect = this.drawLabelBg(cfg, group, label);\n      var labelBgClassname = this.itemType + _shapeBase.CLS_LABEL_BG_SUFFIX;\n      rect.set('classname', labelBgClassname);\n      label.toFront();\n    }\n\n    return label;\n  },\n  drawLabelBg: function drawLabelBg(cfg, group, label) {\n    var defaultLabelCfg = this.options.labelCfg;\n    var labelCfg = (0, _util.deepMix)({}, defaultLabelCfg, cfg.labelCfg);\n    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);\n    var rotate = labelStyle.rotate;\n    var style = this.getLabelBgStyleByPosition(label, cfg, labelCfg, group);\n    delete style.rotate;\n    var rect = group.addShape('rect', {\n      name: 'text-bg-shape',\n      attrs: style\n    });\n    if (rotate) rect.rotateAtStart(rotate);\n    return rect;\n  }\n};\nvar singleEdgeDef = (0, _tslib.__assign)((0, _tslib.__assign)({}, _shapeBase.shapeBase), singleEdge);\n\n_shape.default.registerEdge('single-edge', singleEdgeDef); // 直线, 不支持控制点\n\n\n_shape.default.registerEdge('line', {\n  // 控制点不生效\n  getControlPoints: function getControlPoints() {\n    return undefined;\n  }\n}, 'single-edge'); // 直线\n\n\n_shape.default.registerEdge('spline', {\n  getPath: function getPath(points) {\n    var path = (0, _path.getSpline)(points);\n    return path;\n  }\n}, 'single-edge');\n\n_shape.default.registerEdge('arc', {\n  curveOffset: 20,\n  clockwise: 1,\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var midPoint = {\n      x: (startPoint.x + endPoint.x) / 2,\n      y: (startPoint.y + endPoint.y) / 2\n    };\n    var center;\n    var arcPoint; // 根据给定点计算圆弧\n\n    if (cfg.controlPoints !== undefined) {\n      arcPoint = cfg.controlPoints[0];\n      center = (0, _math.getCircleCenterByPoints)(startPoint, arcPoint, endPoint); // 根据控制点和直线关系决定 clockwise值\n\n      if (startPoint.x <= endPoint.x && startPoint.y > endPoint.y) {\n        this.clockwise = center.x > arcPoint.x ? 0 : 1;\n      } else if (startPoint.x <= endPoint.x && startPoint.y < endPoint.y) {\n        this.clockwise = center.x > arcPoint.x ? 1 : 0;\n      } else if (startPoint.x > endPoint.x && startPoint.y <= endPoint.y) {\n        this.clockwise = center.y < arcPoint.y ? 0 : 1;\n      } else {\n        this.clockwise = center.y < arcPoint.y ? 1 : 0;\n      } // 若给定点和两端点共线，无法生成圆弧，绘制直线\n\n\n      if ((arcPoint.x - startPoint.x) / (arcPoint.y - startPoint.y) === (endPoint.x - startPoint.x) / (endPoint.y - startPoint.y)) {\n        return [];\n      }\n    } else {\n      // 根据直线连线中点的的偏移计算圆弧\n      // 若用户给定偏移量则根据其计算，否则按照默认偏移值计算\n      if (cfg.curveOffset === undefined) {\n        cfg.curveOffset = this.curveOffset;\n      }\n\n      if ((0, _util.isArray)(cfg.curveOffset)) {\n        cfg.curveOffset = cfg.curveOffset[0];\n      }\n\n      if (cfg.curveOffset < 0) {\n        this.clockwise = 0;\n      } else {\n        this.clockwise = 1;\n      }\n\n      var vec = {\n        x: endPoint.x - startPoint.x,\n        y: endPoint.y - startPoint.y\n      };\n      var edgeAngle = Math.atan2(vec.y, vec.x);\n      arcPoint = {\n        x: cfg.curveOffset * Math.cos(-Math.PI / 2 + edgeAngle) + midPoint.x,\n        y: cfg.curveOffset * Math.sin(-Math.PI / 2 + edgeAngle) + midPoint.y\n      };\n      center = (0, _math.getCircleCenterByPoints)(startPoint, arcPoint, endPoint);\n    }\n\n    var radius = (0, _math.distance)(startPoint, center);\n    var controlPoints = [{\n      x: radius,\n      y: radius\n    }];\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]); // 控制点与端点共线\n\n    if (points.length === 2) {\n      path.push(['L', points[1].x, points[1].y]);\n    } else {\n      path.push(['A', points[1].x, points[1].y, 0, 0, this.clockwise, points[2].x, points[2].y]);\n    }\n\n    return path;\n  }\n}, 'single-edge');\n\n_shape.default.registerEdge('quadratic', {\n  curvePosition: 0.5,\n  curveOffset: -20,\n  getControlPoints: function getControlPoints(cfg) {\n    var controlPoints = cfg.controlPoints; // 指定controlPoints\n\n    if (!controlPoints || !controlPoints.length) {\n      var startPoint = cfg.startPoint,\n          endPoint = cfg.endPoint;\n      if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n      if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n      if ((0, _util.isArray)(this.curveOffset)) cfg.curveOffset = cfg.curveOffset[0];\n      if ((0, _util.isArray)(this.curvePosition)) cfg.curvePosition = cfg.curveOffset[0];\n      var innerPoint = (0, _path.getControlPoint)(startPoint, endPoint, cfg.curvePosition, cfg.curveOffset);\n      controlPoints = [innerPoint];\n    }\n\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]);\n    path.push(['Q', points[1].x, points[1].y, points[2].x, points[2].y]);\n    return path;\n  }\n}, 'single-edge');\n\n_shape.default.registerEdge('cubic', {\n  curvePosition: [1 / 2, 1 / 2],\n  curveOffset: [-20, 20],\n  getControlPoints: function getControlPoints(cfg) {\n    var controlPoints = cfg.controlPoints; // 指定 controlPoints\n\n    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n    if ((0, _util.isNumber)(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];\n    if ((0, _util.isNumber)(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];\n\n    if (!controlPoints || !controlPoints.length || controlPoints.length < 2) {\n      var startPoint = cfg.startPoint,\n          endPoint = cfg.endPoint;\n      var innerPoint1 = (0, _path.getControlPoint)(startPoint, endPoint, cfg.curvePosition[0], cfg.curveOffset[0]);\n      var innerPoint2 = (0, _path.getControlPoint)(startPoint, endPoint, cfg.curvePosition[1], cfg.curveOffset[1]);\n      controlPoints = [innerPoint1, innerPoint2];\n    }\n\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]);\n    path.push(['C', points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);\n    return path;\n  }\n}, 'single-edge'); // 垂直方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点\n\n\n_shape.default.registerEdge('cubic-vertical', {\n  curvePosition: [1 / 2, 1 / 2],\n  minCurveOffset: [0, 0],\n  curveOffset: undefined,\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n    if (cfg.minCurveOffset === undefined) cfg.minCurveOffset = this.minCurveOffset;\n    if ((0, _util.isNumber)(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];\n    if ((0, _util.isNumber)(cfg.minCurveOffset)) cfg.minCurveOffset = [cfg.minCurveOffset, -cfg.minCurveOffset];\n    if ((0, _util.isNumber)(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];\n    var yDist = endPoint.y - startPoint.y;\n    var curveOffset = [0, 0];\n\n    if (cfg.curveOffset) {\n      curveOffset = cfg.curveOffset;\n    } else if (Math.abs(yDist) < Math.abs(cfg.minCurveOffset[0])) {\n      curveOffset = cfg.minCurveOffset;\n    }\n\n    var innerPoint1 = {\n      x: startPoint.x,\n      y: startPoint.y + yDist * this.curvePosition[0] + curveOffset[0]\n    };\n    var innerPoint2 = {\n      x: endPoint.x,\n      y: endPoint.y - yDist * this.curvePosition[1] + curveOffset[1]\n    };\n    return [innerPoint1, innerPoint2];\n  }\n}, 'cubic'); // 水平方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点\n\n\n_shape.default.registerEdge('cubic-horizontal', {\n  curvePosition: [1 / 2, 1 / 2],\n  minCurveOffset: [0, 0],\n  curveOffset: undefined,\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n    if (cfg.minCurveOffset === undefined) cfg.minCurveOffset = this.minCurveOffset;\n    if ((0, _util.isNumber)(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];\n    if ((0, _util.isNumber)(cfg.minCurveOffset)) cfg.minCurveOffset = [cfg.minCurveOffset, -cfg.minCurveOffset];\n    if ((0, _util.isNumber)(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];\n    var xDist = endPoint.x - startPoint.x;\n    var curveOffset = [0, 0];\n\n    if (cfg.curveOffset) {\n      curveOffset = cfg.curveOffset;\n    } else if (Math.abs(xDist) < Math.abs(cfg.minCurveOffset[0])) {\n      curveOffset = cfg.minCurveOffset;\n    }\n\n    var innerPoint1 = {\n      x: startPoint.x + xDist * this.curvePosition[0] + curveOffset[0],\n      y: startPoint.y\n    };\n    var innerPoint2 = {\n      x: endPoint.x - xDist * this.curvePosition[1] + curveOffset[1],\n      y: endPoint.y\n    };\n    var controlPoints = [innerPoint1, innerPoint2];\n    return controlPoints;\n  }\n}, 'cubic');\n\n_shape.default.registerEdge('loop', {\n  getPathPoints: function getPathPoints(cfg) {\n    return (0, _graphic.getLoopCfgs)(cfg);\n  },\n  getControlPoints: function getControlPoints(cfg) {\n    return cfg.controlPoints;\n  },\n  afterDraw: function afterDraw(cfg) {\n    cfg.controlPoints = undefined;\n  },\n  afterUpdate: function afterUpdate(cfg) {\n    cfg.controlPoints = undefined;\n  }\n}, 'cubic');","\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _global = _interopRequireDefault(require(\"../global\"));\n\nvar _shape = _interopRequireDefault(require(\"./shape\"));\n\nvar _shapeBase = require(\"./shapeBase\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar singleCombo = {\n  itemType: 'combo',\n  // 单个图形的类型\n  shapeType: 'single-combo',\n\n  /**\n   * Combo 标题文本相对图形的位置，默认为 top\n   * 位置包括： top, bottom, left, right, center\n   * @type {String}\n   */\n  labelPosition: 'top',\n\n  /**\n   * 标题文本相对偏移，当 labelPosition 不为 center 时有效\n   * @type {Number}\n   */\n  refX: _global.default.comboLabel.refX,\n  refY: _global.default.comboLabel.refY,\n  options: {\n    style: {\n      stroke: _global.default.defaultCombo.style.stroke,\n      fill: _global.default.defaultCombo.style.fill,\n      lineWidth: _global.default.defaultCombo.style.lineWidth\n    },\n    labelCfg: {\n      style: {\n        fill: _global.default.comboLabel.style.fill,\n        fontSize: _global.default.comboLabel.style.fontSize\n      }\n    },\n    stateStyles: (0, _tslib.__assign)({}, _global.default.comboStateStyles)\n  },\n\n  /**\n   * 获取 Combo 宽高\n   * @internal 返回 Combo 的大小，以 [width, height] 的方式维护\n   * @param  {Object} cfg Combo 的配置项\n   * @return {Array} 宽高\n   */\n  getSize: function getSize(cfg) {\n    var size = (0, _util.clone)(cfg.size || this.options.size || _global.default.defaultCombo.size); // size 是数组，若长度为 1，则补长度为 2\n\n    if ((0, _util.isArray)(size) && size.length === 1) {\n      size = [size[0], size[0]];\n    } // size 为数字，则转换为数组\n\n\n    if (!(0, _util.isArray)(size)) {\n      size = [size, size];\n    }\n\n    return size;\n  },\n  // 私有方法，不希望扩展的 Combo 复写这个方法\n  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg) {\n    var labelPosition = labelCfg.position || this.labelPosition;\n    var cfgStyle = cfg.style;\n    var padding = cfg.padding || this.options.padding;\n    if ((0, _util.isArray)(padding)) padding = padding[0];\n    var refX = labelCfg.refX,\n        refY = labelCfg.refY; // 考虑 refX 和 refY = 0 的场景，不用用 labelCfg.refX || Global.nodeLabel.refX\n\n    if ((0, _util.isNil)(refX)) {\n      refX = this.refX; // 不居中时的偏移量\n    }\n\n    if ((0, _util.isNil)(refY)) {\n      refY = this.refY; // 不居中时的偏移量\n    }\n\n    var size = this.getSize(cfg);\n    var r = Math.max(cfgStyle.r, size[0] / 2) || size[0] / 2;\n    var dis = r + padding;\n    var style;\n\n    switch (labelPosition) {\n      case 'top':\n        style = {\n          x: 0,\n          y: -dis - refY,\n          textBaseline: 'bottom',\n          textAlign: 'center'\n        };\n        break;\n\n      case 'bottom':\n        style = {\n          x: 0,\n          y: dis + refY,\n          textBaseline: 'bottom',\n          textAlign: 'center'\n        };\n        break;\n\n      case 'left':\n        style = {\n          x: -dis + refX,\n          y: 0,\n          textAlign: 'left'\n        };\n        break;\n\n      case 'center':\n        style = {\n          x: 0,\n          y: 0,\n          text: cfg.label,\n          textAlign: 'center'\n        };\n        break;\n\n      default:\n        style = {\n          x: dis + refX,\n          y: 0,\n          textAlign: 'right'\n        };\n        break;\n    }\n\n    style.text = cfg.label;\n    return style;\n  },\n  drawShape: function drawShape(cfg, group) {\n    var shapeType = this.shapeType; // || this.type，都已经加了 shapeType\n\n    var style = this.getShapeStyle(cfg);\n    var shape = group.addShape(shapeType, {\n      attrs: style,\n      draggable: true,\n      name: 'combo-shape'\n    });\n    return shape;\n  },\n  updateShape: function updateShape(cfg, item, keyShapeStyle) {\n    var keyShape = item.get('keyShape');\n    var animate = cfg.animate === undefined ? this.options.animate : cfg.animate;\n\n    if (animate && keyShape.animate) {\n      keyShape.animate(keyShapeStyle, {\n        duration: 200,\n        easing: 'easeLinear'\n      });\n    } else {\n      keyShape.attr((0, _tslib.__assign)({}, keyShapeStyle));\n    }\n\n    this.updateLabel(cfg, item); // special for some types of nodes\n  }\n};\nvar singleComboDef = (0, _tslib.__assign)((0, _tslib.__assign)({}, _shapeBase.shapeBase), singleCombo);\n\n_shape.default.registerCombo('single-combo', singleComboDef);","\n\nrequire(\"./circle\");\n\nrequire(\"./rect\");","\n\nvar _tslib = require(\"tslib\");\n\nvar _global = _interopRequireDefault(require(\"../../global\"));\n\nvar _shape = _interopRequireDefault(require(\"../shape\"));\n\nvar _util = require(\"@antv/util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// 圆形 Combo\n_shape.default.registerCombo('circle', {\n  // 自定义节点时的配置\n  options: {\n    size: [_global.default.defaultCombo.size[0], _global.default.defaultCombo.size[0]],\n    padding: _global.default.defaultCombo.padding[0],\n    animate: true,\n    style: {\n      stroke: _global.default.defaultCombo.style.stroke,\n      fill: _global.default.defaultCombo.style.fill,\n      lineWidth: _global.default.defaultCombo.style.lineWidth\n    },\n    labelCfg: {\n      style: {\n        fill: _global.default.comboLabel.style.fill,\n        fontSize: _global.default.comboLabel.style.fontSize\n      },\n      refX: 0,\n      refY: 0\n    },\n    stateStyles: (0, _tslib.__assign)({}, _global.default.comboStateStyles)\n  },\n  shapeType: 'circle',\n  // 文本位置\n  labelPosition: 'top',\n  drawShape: function drawShape(cfg, group) {\n    var style = this.getShapeStyle(cfg);\n    delete style.height;\n    delete style.width;\n    var keyShape = group.addShape('circle', {\n      attrs: style,\n      className: 'circle-combo',\n      name: 'circle-combo',\n      draggable: true\n    });\n    return keyShape;\n  },\n\n  /**\n   * 获取 Combo 的样式，供基于该 Combo 自定义时使用\n   * @param {Object} cfg Combo 数据模型\n   * @return {Object} Combo 的样式\n   */\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.options.style;\n    var padding = cfg.padding || this.options.padding;\n    if ((0, _util.isArray)(padding)) padding = padding[0];\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = (0, _util.mix)({}, defaultStyle, strokeStyle, cfg.style);\n    var r;\n\n    if (cfg.fixSize) {\n      r = (0, _util.isNumber)(cfg.fixSize) ? cfg.fixSize : cfg.fixSize[0];\n    } else {\n      var size = this.getSize(cfg);\n      if (!(0, _util.isNumber)(style.r) || isNaN(style.r)) r = size[0] / 2 || _global.default.defaultCombo.style.r;else r = Math.max(style.r, size[0] / 2) || size[0] / 2;\n    }\n\n    style.r = r + padding;\n    var styles = (0, _tslib.__assign)({\n      x: 0,\n      y: 0\n    }, style);\n    if (cfg.style) cfg.style.r = r;else {\n      cfg.style = {\n        r: r\n      };\n    }\n    return styles;\n  },\n  update: function update(cfg, item) {\n    var size = this.getSize(cfg);\n    var padding = cfg.padding || this.options.padding;\n    if ((0, _util.isArray)(padding)) padding = padding[0];\n    var cfgStyle = (0, _util.clone)(cfg.style);\n    var r;\n\n    if (cfg.fixSize) {\n      r = (0, _util.isNumber)(cfg.fixSize) ? cfg.fixSize : cfg.fixSize[0];\n    } else {\n      r = Math.max(cfgStyle.r, size[0] / 2) || size[0] / 2;\n    }\n\n    cfgStyle.r = r + padding;\n    var itemCacheSize = item.get('sizeCache');\n\n    if (itemCacheSize) {\n      itemCacheSize.r = cfgStyle.r;\n    } // 下面这些属性需要覆盖默认样式与目前样式，但若在 cfg 中有指定则应该被 cfg 的相应配置覆盖。\n\n\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 与 getShapeStyle 不同在于，update 时需要获取到当前的 style 进行融合。即新传入的配置项中没有涉及的属性，保留当前的配置。\n\n    var keyShape = item.get('keyShape');\n    var style = (0, _util.mix)({}, keyShape.attr(), strokeStyle, cfgStyle);\n    if (cfg.style) cfg.style.r = r;else {\n      cfg.style = {\n        r: r\n      };\n    }\n    this.updateShape(cfg, item, style, true);\n  }\n}, 'single-combo');","\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _global = _interopRequireDefault(require(\"../../global\"));\n\nvar _shape = _interopRequireDefault(require(\"../shape\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_shape.default.registerCombo('rect', {\n  // 自定义 Combo 时的配置\n  options: {\n    size: [40, 5],\n    padding: [25, 20, 15, 20],\n    animate: true,\n    style: {\n      radius: 0,\n      stroke: _global.default.defaultCombo.style.stroke,\n      fill: _global.default.defaultCombo.style.fill,\n      lineWidth: _global.default.defaultCombo.style.lineWidth\n    },\n    // 文本样式配置\n    labelCfg: {\n      style: {\n        fill: _global.default.comboLabel.style.fill,\n        fontSize: _global.default.comboLabel.style.fontSize\n      }\n    },\n    // 连接点，默认为左右\n    anchorPoints: [[0, 0.5], [1, 0.5]],\n    stateStyles: (0, _tslib.__assign)({}, _global.default.comboStateStyles)\n  },\n  shapeType: 'rect',\n  labelPosition: 'top',\n  drawShape: function drawShape(cfg, group) {\n    var style = this.getShapeStyle(cfg);\n    var keyShape = group.addShape('rect', {\n      attrs: style,\n      className: 'rect-combo',\n      name: 'rect-combo',\n      draggable: true\n    });\n    return keyShape;\n  },\n  // 私有方法，不希望扩展的 Combo 复写这个方法\n  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg) {\n    var labelPosition = labelCfg.position || this.labelPosition;\n    var cfgStyle = cfg.style;\n    var padding = cfg.padding || this.options.padding;\n    if ((0, _util.isNumber)(padding)) padding = [padding, padding, padding, padding];\n    var refX = labelCfg.refX,\n        refY = labelCfg.refY; // 考虑 refX 和 refY = 0 的场景，不用用 labelCfg.refX || Global.nodeLabel.refY\n\n    if ((0, _util.isNil)(refX)) {\n      refX = this.refX; // 不居中时的偏移量\n    }\n\n    if ((0, _util.isNil)(refY)) {\n      refY = this.refY; // 不居中时的偏移量\n    }\n\n    var leftDis = cfgStyle.width / 2 + padding[3];\n    var topDis = cfgStyle.height / 2 + padding[0];\n    var style;\n\n    switch (labelPosition) {\n      case 'top':\n        style = {\n          x: 0 - leftDis + refX,\n          y: 0 - topDis + refY,\n          textBaseline: 'top',\n          textAlign: 'left'\n        };\n        break;\n\n      case 'bottom':\n        style = {\n          x: 0,\n          y: topDis + refY,\n          textBaseline: 'bottom',\n          textAlign: 'center'\n        };\n        break;\n\n      case 'left':\n        style = {\n          x: 0 - leftDis + refY,\n          y: 0,\n          textAlign: 'left'\n        };\n        break;\n\n      case 'center':\n        style = {\n          x: 0,\n          y: 0,\n          text: cfg.label,\n          textAlign: 'center'\n        };\n        break;\n\n      default:\n        style = {\n          x: leftDis + refX,\n          y: 0,\n          textAlign: 'right'\n        };\n        break;\n    }\n\n    style.text = cfg.label;\n    return style;\n  },\n\n  /**\n   * 获取节点的样式，供基于该节点自定义时使用\n   * @param {Object} cfg 节点数据模型\n   * @return {Object} 节点的样式\n   */\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.options.style;\n    var padding = cfg.padding || this.options.padding;\n    if ((0, _util.isNumber)(padding)) padding = [padding, padding, padding, padding];\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = (0, _util.mix)({}, defaultStyle, strokeStyle, cfg.style);\n    var size = this.getSize(cfg);\n    var width;\n    var height;\n    var fixSize = cfg.collapsed && cfg.fixCollapseSize ? cfg.fixCollapseSize : cfg.fixSize;\n\n    if (fixSize) {\n      if ((0, _util.isNumber)(fixSize)) {\n        width = fixSize;\n        height = fixSize;\n      } else {\n        width = fixSize[0];\n        height = fixSize[1];\n      }\n    } else {\n      if (!(0, _util.isNumber)(style.width) || isNaN(style.width)) width = size[0] || _global.default.defaultCombo.style.width;else width = Math.max(style.width, size[0]) || size[0];\n      if (!(0, _util.isNumber)(style.height) || isNaN(style.height)) height = size[1] || _global.default.defaultCombo.style.height;else height = Math.max(style.height, size[1]) || size[1];\n    }\n\n    var x = -width / 2 - padding[3];\n    var y = -height / 2 - padding[0];\n    style.width = width + padding[1] + padding[3];\n    style.height = height + padding[0] + padding[2];\n    var styles = (0, _tslib.__assign)({\n      x: x,\n      y: y\n    }, style);\n\n    if (!cfg.style) {\n      cfg.style = {\n        width: width,\n        height: height\n      };\n    } else {\n      cfg.style.width = width;\n      cfg.style.height = height;\n    }\n\n    return styles;\n  },\n  update: function update(cfg, item) {\n    var size = this.getSize(cfg);\n    var padding = cfg.padding || this.options.padding;\n    if ((0, _util.isNumber)(padding)) padding = [padding, padding, padding, padding];\n    var cfgStyle = (0, _util.clone)(cfg.style);\n    var width, height;\n    var fixSize = cfg.collapsed && cfg.fixCollapseSize ? cfg.fixCollapseSize : cfg.fixSize;\n\n    if (fixSize) {\n      if ((0, _util.isNumber)(fixSize)) {\n        width = fixSize;\n        height = fixSize;\n      } else {\n        width = fixSize[0];\n        height = fixSize[1];\n      }\n    } else {\n      width = Math.max(cfgStyle.width, size[0]) || size[0];\n      height = Math.max(cfgStyle.height, size[1]) || size[1];\n    }\n\n    cfgStyle.width = width + padding[1] + padding[3];\n    cfgStyle.height = height + padding[0] + padding[2];\n    var itemCacheSize = item.get('sizeCache');\n\n    if (itemCacheSize) {\n      itemCacheSize.width = cfgStyle.width;\n      itemCacheSize.height = cfgStyle.height;\n    }\n\n    cfgStyle.x = -width / 2 - padding[3];\n    cfgStyle.y = -height / 2 - padding[0]; // 下面这些属性需要覆盖默认样式与目前样式，但若在 cfg 中有指定则应该被 cfg 的相应配置覆盖。\n\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 与 getShapeStyle 不同在于，update 时需要获取到当前的 style 进行融合。即新传入的配置项中没有涉及的属性，保留当前的配置。\n\n    var keyShape = item.get('keyShape');\n    var style = (0, _util.mix)({}, keyShape.attr(), strokeStyle, cfgStyle);\n\n    if (cfg.style) {\n      cfg.style.width = width;\n      cfg.style.height = height;\n    } else {\n      cfg.style = {\n        width: width,\n        height: height\n      };\n    }\n\n    this.updateShape(cfg, item, style, false);\n  },\n  updateShape: function updateShape(cfg, item, keyShapeStyle) {\n    var keyShape = item.get('keyShape');\n    var animate = cfg.animate === undefined ? this.options.animate : cfg.animate;\n\n    if (animate && keyShape.animate) {\n      keyShape.animate(keyShapeStyle, {\n        duration: 200,\n        easing: 'easeLinear'\n      });\n    } else {\n      keyShape.attr((0, _tslib.__assign)({}, keyShapeStyle));\n    }\n\n    this.updateLabel(cfg, item);\n  }\n}, 'single-combo');","\n\nrequire(\"./simple-circle\");\n\nrequire(\"./simple-rect\");\n\nrequire(\"./image\");","\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _global = _interopRequireDefault(require(\"../../global\"));\n\nvar _shape = _interopRequireDefault(require(\"../shape\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// 带有图标的圆，可用于拓扑图中\n_shape.default.registerNode('simple-circle', {\n  // 自定义节点时的配置\n  options: {\n    size: _global.default.defaultNode.size,\n    style: {\n      x: 0,\n      y: 0,\n      stroke: _global.default.defaultNode.style.stroke,\n      fill: _global.default.defaultNode.style.fill,\n      lineWidth: _global.default.defaultNode.style.lineWidth\n    },\n    labelCfg: {\n      style: {\n        fill: _global.default.nodeLabel.style.fill,\n        fontSize: _global.default.nodeLabel.style.fontSize\n      }\n    },\n    stateStyles: (0, _tslib.__assign)({}, _global.default.nodeStateStyles)\n  },\n  shapeType: 'simple-circle',\n  // 文本位置\n  labelPosition: 'center',\n  drawShape: function drawShape(cfg, group) {\n    var style = this.getShapeStyle(cfg);\n    var keyShape = group.addShape('circle', {\n      attrs: style,\n      className: this.type + \"-keyShape\",\n      draggable: true\n    });\n    return keyShape;\n  },\n\n  /**\n   * 获取节点的样式，供基于该节点自定义时使用\n   * @param {Object} cfg 节点数据模型\n   * @return {Object} 节点的样式\n   */\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.getOptions(cfg).style;\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = (0, _util.deepMix)({}, defaultStyle, strokeStyle);\n    var size = this.getSize(cfg);\n    var r = size[0] / 2;\n    var styles = (0, _tslib.__assign)({\n      x: 0,\n      y: 0,\n      r: r\n    }, style);\n    return styles;\n  },\n  update: function update(cfg, item) {\n    var size = this.getSize(cfg); // 下面这些属性需要覆盖默认样式与目前样式，但若在 cfg 中有指定则应该被 cfg 的相应配置覆盖。\n\n    var strokeStyle = {\n      stroke: cfg.color,\n      r: size[0] / 2\n    }; // 与 getShapeStyle 不同在于，update 时需要获取到当前的 style 进行融合。即新传入的配置项中没有涉及的属性，保留当前的配置。\n\n    var keyShape = item.get('keyShape');\n    var style = (0, _util.deepMix)({}, keyShape.attr(), strokeStyle, cfg.style);\n    this.updateShape(cfg, item, style, true);\n  }\n}, 'single-node');","\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _global = _interopRequireDefault(require(\"../../global\"));\n\nvar _shape = _interopRequireDefault(require(\"../shape\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_shape.default.registerNode('simple-rect', {\n  // 自定义节点时的配置\n  options: {\n    size: [100, 30],\n    style: {\n      radius: 0,\n      stroke: _global.default.defaultNode.style.stroke,\n      fill: _global.default.defaultNode.style.fill,\n      lineWidth: _global.default.defaultNode.style.lineWidth\n    },\n    // 文本样式配置\n    labelCfg: {\n      style: {\n        fill: _global.default.nodeLabel.style.fill,\n        fontSize: _global.default.nodeLabel.style.fontSize\n      }\n    },\n    // 连接点，默认为左右\n    // anchorPoints: [{ x: 0, y: 0.5 }, { x: 1, y: 0.5 }]\n    anchorPoints: [[0, 0.5], [1, 0.5]],\n    stateStyles: (0, _tslib.__assign)({}, _global.default.nodeStateStyles)\n  },\n  shapeType: 'simple-rect',\n  labelPosition: 'center',\n  drawShape: function drawShape(cfg, group) {\n    var style = this.getShapeStyle(cfg);\n    var keyShape = group.addShape('rect', {\n      attrs: style,\n      className: this.type + \"-keyShape\",\n      name: this.type + \"-keyShape\",\n      draggable: true\n    });\n    return keyShape;\n  },\n\n  /**\n   * 获取节点的样式，供基于该节点自定义时使用\n   * @param {Object} cfg 节点数据模型\n   * @return {Object} 节点的样式\n   */\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.getOptions(cfg).style;\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = (0, _util.mix)({}, defaultStyle, strokeStyle);\n    var size = this.getSize(cfg);\n    var width = style.width || size[0];\n    var height = style.height || size[1];\n    var styles = (0, _tslib.__assign)({\n      x: -width / 2,\n      y: -height / 2,\n      width: width,\n      height: height\n    }, style);\n    return styles;\n  },\n  update: function update(cfg, item) {\n    var group = item.getContainer(); // 这里不传 cfg 参数是因为 cfg.style 需要最后覆盖样式\n\n    var defaultStyle = this.getOptions({}).style;\n    var size = this.getSize(cfg);\n    var keyShape = item.get('keyShape');\n\n    if (!cfg.size) {\n      size[0] = keyShape.attr('width') || defaultStyle.width;\n      size[1] = keyShape.attr('height') || defaultStyle.height;\n    } // 下面这些属性需要覆盖默认样式与目前样式，但若在 cfg 中有指定则应该被 cfg 的相应配置覆盖。\n\n\n    var strokeStyle = {\n      stroke: cfg.color,\n      x: -size[0] / 2,\n      y: -size[1] / 2,\n      width: size[0],\n      height: size[1]\n    }; // 与 getShapeStyle 不同在于，update 时需要获取到当前的 style 进行融合。即新传入的配置项中没有涉及的属性，保留当前的配置。\n\n    var style = (0, _util.mix)({}, defaultStyle, keyShape.attr(), strokeStyle);\n    style = (0, _util.mix)(style, cfg.style);\n    this.updateShape(cfg, item, style, false);\n  }\n}, 'single-node');","\n\nvar _tslib = require(\"tslib\");\n\nvar _shape = _interopRequireDefault(require(\"../shape\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * 基本的图片，可以添加文本，默认文本在图片的下面\n */\n_shape.default.registerNode('image', {\n  options: {\n    img: 'https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*eD7nT6tmYgAAAAAAAAAAAABkARQnAQ',\n    size: 200,\n    clipCfg: {\n      show: false,\n      type: 'circle',\n      // circle\n      r: 50,\n      // ellipse\n      rx: 50,\n      ry: 35,\n      // rect\n      width: 50,\n      height: 35,\n      // polygon\n      points: [[30, 12], [12, 30], [30, 48], [48, 30]],\n      // path\n      path: [['M', 25, 25], ['L', 50, 25], ['A', 12.5, 12.5, 0, 1, 1, 50, 50], ['A', 12.5, 12.5, 0, 1, 0, 50, 50], ['L', 25, 75], ['Z']],\n      // 坐标\n      x: 0,\n      y: 0 // clip 的属性样式\n      // style: {\n      //   lineWidth: 1\n      // },\n\n    }\n  },\n  shapeType: 'image',\n  labelPosition: 'bottom',\n  drawShape: function drawShape(cfg, group) {\n    var shapeType = this.shapeType; // || this.type，都已经加了 shapeType\n\n    var style = this.getShapeStyle(cfg);\n    delete style.fill;\n    var shape = group.addShape(shapeType, {\n      attrs: style,\n      className: this.type + \"-keyShape\",\n      name: this.type + \"-keyShape\",\n      draggable: true\n    });\n    this.drawClip(cfg, shape);\n    return shape;\n  },\n  drawClip: function drawClip(cfg, shape) {\n    var clip = this.getOptions(cfg).clipCfg;\n\n    if (!clip.show) {\n      return;\n    } // 支持 circle、rect、ellipse、Polygon 及自定义 path clip\n\n\n    var type = clip.type,\n        x = clip.x,\n        y = clip.y,\n        style = clip.style;\n\n    if (type === 'circle') {\n      var r = clip.r;\n      shape.setClip({\n        type: 'circle',\n        attrs: (0, _tslib.__assign)({\n          r: r,\n          x: x,\n          y: y\n        }, style)\n      });\n    } else if (type === 'rect') {\n      var width = clip.width,\n          height = clip.height;\n      var rectX = x - width / 2;\n      var rectY = y - height / 2;\n      shape.setClip({\n        type: 'rect',\n        attrs: (0, _tslib.__assign)({\n          x: rectX,\n          y: rectY,\n          width: width,\n          height: height\n        }, style)\n      });\n    } else if (type === 'ellipse') {\n      var rx = clip.rx,\n          ry = clip.ry;\n      shape.setClip({\n        type: 'ellipse',\n        attrs: (0, _tslib.__assign)({\n          x: x,\n          y: y,\n          rx: rx,\n          ry: ry\n        }, style)\n      });\n    } else if (type === 'polygon') {\n      var points = clip.points;\n      shape.setClip({\n        type: 'polygon',\n        attrs: (0, _tslib.__assign)({\n          points: points\n        }, style)\n      });\n    } else if (type === 'path') {\n      var path = clip.path;\n      shape.setClip({\n        type: 'path',\n        attrs: (0, _tslib.__assign)({\n          path: path\n        }, style)\n      });\n    }\n  },\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.getOptions(cfg).style;\n    var size = this.getSize(cfg);\n    var img = this.getOptions(cfg).img;\n    var width = size[0];\n    var height = size[1];\n\n    if (defaultStyle) {\n      width = defaultStyle.width || size[0];\n      height = defaultStyle.height || size[1];\n    }\n\n    var style = (0, _tslib.__assign)({\n      x: -width / 2,\n      y: -height / 2,\n      width: width,\n      height: height,\n      img: img\n    }, defaultStyle);\n    return style;\n  },\n  updateShapeStyle: function updateShapeStyle(cfg, item) {\n    var group = item.getContainer();\n    var shapeClassName = this.itemType + \"-shape\";\n    var shape = group.find(function (element) {\n      return element.get('className') === shapeClassName;\n    }) || item.getKeyShape();\n    var shapeStyle = this.getShapeStyle(cfg);\n\n    if (shape) {\n      shape.attr(shapeStyle);\n    }\n  }\n}, 'single-node');","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = {\n  triangle: function triangle(width, length, d) {\n    if (width === void 0) {\n      width = 10;\n    }\n\n    if (length === void 0) {\n      length = 15;\n    }\n\n    if (d === void 0) {\n      d = 0;\n    }\n\n    var begin = d * 2;\n    var path = \"M \" + begin + \",0 L \" + (begin + length) + \",-\" + width / 2 + \" L \" + (begin + length) + \",\" + width / 2 + \" Z\";\n    return path;\n  },\n  vee: function vee(width, length, d) {\n    if (width === void 0) {\n      width = 15;\n    }\n\n    if (length === void 0) {\n      length = 20;\n    }\n\n    if (d === void 0) {\n      d = 0;\n    }\n\n    var begin = d * 2;\n    var path = \"M \" + begin + \",0 L \" + (begin + length) + \",-\" + width / 2 + \"\\n        L \" + (begin + 2 * length / 3) + \",0 L \" + (begin + length) + \",\" + width / 2 + \" Z\";\n    return path;\n  },\n  circle: function circle(r, d) {\n    if (r === void 0) {\n      r = 5;\n    }\n\n    if (d === void 0) {\n      d = 0;\n    }\n\n    var begin = d * 2;\n    var path = \"M \" + begin + \", 0\\n            a \" + r + \",\" + r + \" 0 1,0 \" + r * 2 + \",0\\n            a \" + r + \",\" + r + \" 0 1,0 \" + -r * 2 + \",0\";\n    return path;\n  },\n  rect: function rect(width, length, d) {\n    if (width === void 0) {\n      width = 10;\n    }\n\n    if (length === void 0) {\n      length = 10;\n    }\n\n    if (d === void 0) {\n      d = 0;\n    }\n\n    var begin = d * 2;\n    var path = \"M \" + begin + \",\" + -width / 2 + \" \\n        L \" + (begin + length) + \",\" + -width / 2 + \" \\n        L \" + (begin + length) + \",\" + width / 2 + \" \\n        L \" + begin + \",\" + width / 2 + \" Z\";\n    return path;\n  },\n  diamond: function diamond(width, length, d) {\n    if (width === void 0) {\n      width = 15;\n    }\n\n    if (length === void 0) {\n      length = 15;\n    }\n\n    if (d === void 0) {\n      d = 0;\n    }\n\n    var begin = d * 2;\n    var path = \"M \" + begin + \",0 \\n        L \" + (begin + length / 2) + \",\" + -width / 2 + \" \\n        L \" + (begin + length) + \",0 \\n        L \" + (begin + length / 2) + \",\" + width / 2 + \" Z\";\n    return path;\n  },\n  triangleRect: function triangleRect(tWidth, tLength, rWidth, rLength, gap, d) {\n    if (tWidth === void 0) {\n      tWidth = 15;\n    }\n\n    if (tLength === void 0) {\n      tLength = 15;\n    }\n\n    if (rWidth === void 0) {\n      rWidth = 15;\n    }\n\n    if (rLength === void 0) {\n      rLength = 3;\n    }\n\n    if (gap === void 0) {\n      gap = 5;\n    }\n\n    if (d === void 0) {\n      d = 0;\n    }\n\n    var begin = d * 2;\n    var rectBegin = begin + tLength + gap;\n    var path = \"M \" + begin + \",0 L \" + (begin + tLength) + \",-\" + tWidth / 2 + \" L \" + (begin + tLength) + \",\" + tWidth / 2 + \" Z\\n            M \" + rectBegin + \", -\" + rWidth / 2 + \"\\n            L \" + (rectBegin + rLength) + \" -\" + rWidth / 2 + \"\\n            L \" + (rectBegin + rLength) + \" \" + rWidth / 2 + \"\\n            L \" + rectBegin + \" \" + rWidth / 2 + \"\\n            Z\";\n    return path;\n  }\n};\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = {\n  collapse: function collapse(x, y, r) {\n    return [['M', x - r, y], ['a', r, r, 0, 1, 0, r * 2, 0], ['a', r, r, 0, 1, 0, -r * 2, 0], ['M', x - r + 4, y], ['L', x + r - 4, y]];\n  },\n  expand: function expand(x, y, r) {\n    return [['M', x - r, y], ['a', r, r, 0, 1, 0, r * 2, 0], ['a', r, r, 0, 1, 0, -r * 2, 0], ['M', x - r + 4, y], ['L', x - r + 2 * r - 4, y], ['M', x - r + r, y - r + 4], ['L', x, y + r - 4]];\n  },\n  upTriangle: function upTriangle(x, y, r) {\n    var l1 = r * Math.cos(Math.PI / 6);\n    var l2 = r * Math.sin(Math.PI / 6);\n    return [['M', x - l1, y + l2], ['L', x + l1, y + l2], ['L', x, y - r], ['Z']];\n  },\n  downTriangle: function downTriangle(x, y, r) {\n    var l1 = r * Math.cos(Math.PI / 6);\n    var l2 = r * Math.sin(Math.PI / 6);\n    return [['M', x - l1, y - l2], ['L', x + l1, y - l2], ['L', x, y + r], ['Z']];\n  }\n};\nexports.default = _default;","\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar MathUtil = _interopRequireWildcard(require(\"./math\"));\n\nvar GraphicUtil = _interopRequireWildcard(require(\"./graphic\"));\n\nvar PathUtil = _interopRequireWildcard(require(\"./path\"));\n\nvar BaseUtil = _interopRequireWildcard(require(\"./base\"));\n\nvar ColorUtil = _interopRequireWildcard(require(\"./color\"));\n\nvar _matrixUtil = require(\"@antv/matrix-util\");\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar transform = _matrixUtil.ext.transform;\nvar Util = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, BaseUtil), GraphicUtil), PathUtil), MathUtil), ColorUtil), {\n  transform: transform,\n  mat3: _matrixUtil.mat3\n});\nvar _default = Util;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultSubjectColors = void 0;\nvar defaultSubjectColors = ['#5F95FF', '#61DDAA', '#65789B', '#F6BD16', '#7262FD', '#78D3F8', '#9661BC', '#F6903D', '#008685', '#F08BB4'];\nexports.defaultSubjectColors = defaultSubjectColors;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _base = require(\"../../util/base\");\n\nvar LayoutController =\n/** @class */\nfunction () {\n  function LayoutController(graph) {\n    this.graph = graph;\n    this.layoutCfg = graph.get('layout') || {};\n    this.layoutType = this.getLayoutType();\n    this.layoutMethods = [];\n    this.initLayout();\n  } // eslint-disable-next-line class-methods-use-this\n\n\n  LayoutController.prototype.initLayout = function () {// no data before rendering\n  };\n\n  LayoutController.prototype.getLayoutType = function () {\n    return this.getLayoutCfgType(this.layoutCfg);\n  };\n\n  LayoutController.prototype.getLayoutCfgType = function (layoutCfg) {\n    var type = layoutCfg.type; // type should be top priority\n\n    if (type) {\n      return type;\n    }\n\n    var pipes = layoutCfg.pipes;\n\n    if (Array.isArray(pipes)) {\n      return pipes.map(function (pipe) {\n        return (pipe === null || pipe === void 0 ? void 0 : pipe.type) || '';\n      });\n    }\n\n    return null;\n  };\n\n  LayoutController.prototype.isLayoutTypeSame = function (cfg) {\n    var current = this.getLayoutCfgType(cfg); // already has pipes\n\n    if (Array.isArray(this.layoutType)) {\n      return this.layoutType.every(function (type, index) {\n        return type === current[index];\n      });\n    }\n\n    return (cfg === null || cfg === void 0 ? void 0 : cfg.type) === this.layoutType;\n  }; // 绘制\n\n\n  LayoutController.prototype.refreshLayout = function () {\n    var graph = this.graph;\n    if (!graph) return;\n\n    if (graph.get('animate')) {\n      graph.positionsAnimate();\n    } else {\n      graph.refreshPositions();\n    }\n  }; // 更换布局\n\n\n  LayoutController.prototype.changeLayout = function (cfg) {\n    this.layoutCfg = cfg;\n    this.destoryLayoutMethods();\n    this.layout();\n  }; // 更换数据\n\n\n  LayoutController.prototype.changeData = function () {\n    this.destoryLayoutMethods();\n    this.layout();\n  };\n\n  LayoutController.prototype.destoryLayoutMethods = function () {\n    var layoutMethods = this.layoutMethods;\n    layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.forEach(function (layoutMethod) {\n      layoutMethod.destroy();\n    });\n    this.layoutMethods = [];\n  }; // 销毁布局，不能使用 this.destroy，因为 controller 还需要被使用，只是把布局算法销毁\n\n\n  LayoutController.prototype.destroyLayout = function () {\n    var graph = this.graph;\n    this.destoryLayoutMethods();\n    graph.set('layout', undefined);\n    this.layoutCfg = undefined;\n    this.layoutType = undefined;\n    this.layoutMethods = undefined;\n  }; // 从 this.graph 获取数据\n\n\n  LayoutController.prototype.setDataFromGraph = function () {\n    var nodes = [];\n    var hiddenNodes = [];\n    var edges = [];\n    var hiddenEdges = [];\n    var comboEdges = [];\n    var combos = [];\n    var hiddenCombos = [];\n    var nodeItems = this.graph.getNodes();\n    var edgeItems = this.graph.getEdges();\n    var comboItems = this.graph.getCombos();\n    var nodeLength = nodeItems.length;\n\n    for (var i = 0; i < nodeLength; i++) {\n      var nodeItem = nodeItems[i];\n      if (!nodeItem || nodeItem.destroyed) continue;\n      var model = nodeItem.getModel();\n\n      if (!nodeItem.isVisible()) {\n        hiddenNodes.push(model);\n        continue;\n      }\n\n      nodes.push(model);\n    }\n\n    var edgeLength = edgeItems.length;\n\n    for (var i = 0; i < edgeLength; i++) {\n      var edgeItem = edgeItems[i];\n      if (!edgeItem || edgeItem.destroyed) continue;\n      var model = edgeItem.getModel();\n\n      if (!edgeItem.isVisible()) {\n        hiddenEdges.push(model);\n        continue;\n      }\n\n      if (!model.isComboEdge) edges.push(model);else comboEdges.push(model);\n    }\n\n    var comboLength = comboItems.length;\n\n    for (var i = 0; i < comboLength; i++) {\n      var comboItem = comboItems[i];\n      if (comboItem.destroyed) continue;\n      var model = comboItem.getModel();\n\n      if (!comboItem.isVisible()) {\n        hiddenEdges.push(model);\n        continue;\n      }\n\n      combos.push(model);\n    }\n\n    return {\n      nodes: nodes,\n      hiddenNodes: hiddenNodes,\n      edges: edges,\n      hiddenEdges: hiddenEdges,\n      combos: combos,\n      hiddenCombos: hiddenCombos,\n      comboEdges: comboEdges\n    };\n  };\n\n  LayoutController.prototype.reLayoutMethod = function (layoutMethod, layoutCfg) {\n    var _this = this;\n\n    return new Promise(function (reslove, reject) {\n      var graph = _this.graph;\n      var layoutType = layoutCfg === null || layoutCfg === void 0 ? void 0 : layoutCfg.type; // 每个布局方法都需要注册\n\n      layoutCfg.onLayoutEnd = function () {\n        graph.emit('aftersublayout', {\n          type: layoutType\n        });\n        reslove();\n      };\n\n      layoutMethod.init(_this.data);\n\n      if (layoutType === 'force') {\n        layoutMethod.ticking = false;\n        layoutMethod.forceSimulation.stop();\n      }\n\n      graph.emit('beforesublayout', {\n        type: layoutType\n      });\n      layoutMethod.execute();\n      if (layoutMethod.isCustomLayout && layoutCfg.onLayoutEnd) layoutCfg.onLayoutEnd();\n    });\n  }; // 重新布局\n\n\n  LayoutController.prototype.relayout = function (reloadData) {\n    var _this = this;\n\n    var _a = this,\n        graph = _a.graph,\n        layoutMethods = _a.layoutMethods,\n        layoutCfg = _a.layoutCfg;\n\n    if (reloadData) {\n      this.data = this.setDataFromGraph();\n      var nodes = this.data.nodes;\n\n      if (!nodes) {\n        return false;\n      }\n\n      this.initPositions(layoutCfg.center, nodes);\n    }\n\n    graph.emit('beforelayout');\n    var start = Promise.resolve();\n    layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.forEach(function (layoutMethod, index) {\n      var currentCfg = layoutCfg[index];\n      start = start.then(function () {\n        return _this.reLayoutMethod(layoutMethod, currentCfg);\n      });\n    });\n    start.then(function () {\n      if (layoutCfg.onAllLayoutEnd) layoutCfg.onAllLayoutEnd();\n    }).catch(function (error) {\n      console.warn('relayout failed', error);\n    });\n  }; // 筛选参与布局的nodes和edges\n\n\n  LayoutController.prototype.filterLayoutData = function (data, cfg) {\n    var nodes = data.nodes,\n        edges = data.edges,\n        rest = (0, _tslib.__rest)(data, [\"nodes\", \"edges\"]);\n\n    if (!nodes) {\n      return data;\n    }\n\n    var nodesFilter;\n    var edegsFilter;\n\n    if ((0, _util.isFunction)(cfg === null || cfg === void 0 ? void 0 : cfg.nodesFilter)) {\n      nodesFilter = cfg.nodesFilter;\n    } else {\n      nodesFilter = function nodesFilter() {\n        return true;\n      };\n    }\n\n    if ((0, _util.isFunction)(cfg === null || cfg === void 0 ? void 0 : cfg.edgesFilter)) {\n      edegsFilter = cfg.edgesFilter;\n    } else {\n      var nodesMap_1 = nodes.reduce(function (acc, cur) {\n        acc[cur.id] = true;\n        return acc;\n      }, {});\n\n      edegsFilter = function edegsFilter(edge) {\n        return nodesMap_1[edge.source] && nodesMap_1[edge.target];\n      };\n    }\n\n    return (0, _tslib.__assign)({\n      nodes: nodes.filter(nodesFilter),\n      edges: edges.filter(edegsFilter)\n    }, rest);\n  };\n\n  LayoutController.prototype.getLayoutBBox = function (nodes) {\n    var graph = this.graph;\n    var graphGroupNodes = (0, _util.groupBy)(graph.getNodes(), function (n) {\n      return n.getModel().layoutOrder;\n    });\n    var layoutNodes = Object.values(graphGroupNodes).map(function (value) {\n      var bbox = (0, _base.calculationItemsBBox)(value);\n      bbox.size = [bbox.width, bbox.height];\n      return bbox;\n    });\n    var groupNodes = Object.values((0, _util.groupBy)(nodes, 'layoutOrder'));\n    return {\n      groupNodes: groupNodes,\n      layoutNodes: layoutNodes\n    };\n  }; // 控制布局动画\n  // eslint-disable-next-line class-methods-use-this\n\n\n  LayoutController.prototype.layoutAnimate = function () {}; // 将当前节点的平均中心移动到原点\n\n\n  LayoutController.prototype.moveToZero = function () {\n    var graph = this.graph;\n    var data = graph.get('data');\n    var nodes = data.nodes;\n\n    if (nodes[0].x === undefined || nodes[0].x === null || (0, _base.isNaN)(nodes[0].x)) {\n      return;\n    }\n\n    var meanCenter = [0, 0];\n    var nodeLength = nodes.length;\n\n    for (var i = 0; i < nodeLength; i++) {\n      var node = nodes[i];\n      meanCenter[0] += node.x;\n      meanCenter[1] += node.y;\n    }\n\n    meanCenter[0] /= nodes.length;\n    meanCenter[1] /= nodes.length;\n\n    for (var i = 0; i < nodeLength; i++) {\n      var node = nodes[i];\n      node.x -= meanCenter[0];\n      node.y -= meanCenter[1];\n    }\n  }; // 初始化节点到 center 附近\n\n\n  LayoutController.prototype.initPositions = function (center, nodes) {\n    var graph = this.graph;\n\n    if (!nodes) {\n      return false;\n    }\n\n    var nodeLength = nodes ? nodes.length : 0;\n    if (!nodeLength) return;\n    var width = graph.get('width') * 0.85;\n    var height = graph.get('height') * 0.85;\n    var horiNum = Math.ceil(Math.sqrt(nodeLength) * (width / height));\n    var vertiNum = Math.ceil(nodeLength / horiNum);\n    var horiGap = width / (horiNum - 1);\n    var vertiGap = height / (vertiNum - 1);\n    if (!isFinite(horiGap) || !horiGap) horiGap = 0;\n    if (!isFinite(vertiGap) || !horiGap) vertiGap = 0;\n    var beginX = center[0] - width / 2;\n    var beginY = center[1] - height / 2;\n    var allHavePos = true;\n\n    for (var i = 0; i < nodeLength; i++) {\n      var node = nodes[i];\n\n      if ((0, _base.isNaN)(node.x)) {\n        allHavePos = false;\n        node.x = i % horiNum * horiGap + beginX;\n      }\n\n      if ((0, _base.isNaN)(node.y)) {\n        allHavePos = false;\n        node.y = Math.floor(i / horiNum) * vertiGap + beginY;\n      }\n    }\n\n    return allHavePos;\n  };\n\n  LayoutController.prototype.destroy = function () {\n    this.graph = null;\n    this.destoryLayoutMethods();\n    this.destroyed = true;\n  };\n\n  return LayoutController;\n}();\n\nvar _default = LayoutController;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar EventController =\n/** @class */\nfunction () {\n  function EventController(graph) {\n    this.graph = graph;\n    this.destroyed = false;\n    this.initEvents();\n  }\n\n  return EventController;\n}();\n\nvar _default = EventController;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  G6Event: true\n};\nexports.G6Event = void 0;\n\nvar _interface = require(\"../interface\");\n\nObject.keys(_interface).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _interface[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _interface[key];\n    }\n  });\n});\n// Behavior type file\nvar G6Event;\nexports.G6Event = G6Event;\n\n(function (G6Event) {\n  // common events\n  G6Event[\"CLICK\"] = \"click\";\n  G6Event[\"DBLCLICK\"] = \"dblclick\";\n  G6Event[\"MOUSEDOWN\"] = \"mousedown\";\n  G6Event[\"MOUDEUP\"] = \"mouseup\";\n  G6Event[\"CONTEXTMENU\"] = \"contextmenu\";\n  G6Event[\"MOUSEENTER\"] = \"mouseenter\";\n  G6Event[\"MOUSEOUT\"] = \"mouseout\";\n  G6Event[\"MOUSEOVER\"] = \"mouseover\";\n  G6Event[\"MOUSEMOVE\"] = \"mousemove\";\n  G6Event[\"MOUSELEAVE\"] = \"mouseleave\";\n  G6Event[\"DRAGSTART\"] = \"dragstart\";\n  G6Event[\"DRAGEND\"] = \"dragend\";\n  G6Event[\"DRAG\"] = \"drag\";\n  G6Event[\"DRAGENTER\"] = \"dragenter\";\n  G6Event[\"DRAGLEAVE\"] = \"dragleave\";\n  G6Event[\"DRAGOVER\"] = \"dragover\";\n  G6Event[\"DRAGOUT\"] = \"dragout\";\n  G6Event[\"DDROP\"] = \"drop\";\n  G6Event[\"KEYUP\"] = \"keyup\";\n  G6Event[\"KEYDOWN\"] = \"keydown\";\n  G6Event[\"WHEEL\"] = \"wheel\";\n  G6Event[\"FOCUS\"] = \"focus\";\n  G6Event[\"BLUR\"] = \"blur\"; // touch events\n\n  G6Event[\"TOUCHSTART\"] = \"touchstart\";\n  G6Event[\"TOUCHMOVE\"] = \"touchmove\";\n  G6Event[\"TOUCHEND\"] = \"touchend\";\n  G6Event[\"CANVAS_TOUCHSTART\"] = \"canvas:touchstart\";\n  G6Event[\"CANVAS_TOUCHMOVE\"] = \"canvas:touchmove\";\n  G6Event[\"CANVAS_TOUCHEND\"] = \"canvas:touchend\";\n  G6Event[\"NODE_TOUCHSTART\"] = \"node:touchstart\";\n  G6Event[\"NODE_TOUCHMOVE\"] = \"node:touchmove\";\n  G6Event[\"NODE_TOUCHEND\"] = \"node:touchend\";\n  G6Event[\"COMBO_TOUCHSTART\"] = \"combo:touchstart\";\n  G6Event[\"COMBO_TOUCHMOVE\"] = \"combo:touchmove\";\n  G6Event[\"COMBO_TOUCHEND\"] = \"combo:touchend\";\n  G6Event[\"EDGE_TOUCHSTART\"] = \"edge:touchstart\";\n  G6Event[\"EDGE_TOUCHMOVE\"] = \"edge:touchmove\";\n  G6Event[\"EDGE_TOUCHEND\"] = \"edge:touchend\"; // node events\n\n  G6Event[\"NODE_CONTEXTMENU\"] = \"node:contextmenu\";\n  G6Event[\"NODE_CLICK\"] = \"node:click\";\n  G6Event[\"NODE_DBLCLICK\"] = \"node:dblclick\";\n  G6Event[\"NODE_MOUSEDOWN\"] = \"node:mousedown\";\n  G6Event[\"NODE_MOUSEUP\"] = \"node:mouseup\";\n  G6Event[\"NODE_MOUSEENTER\"] = \"node:mouseenter\";\n  G6Event[\"NODE_MOUSELEAVE\"] = \"node:mouseleave\";\n  G6Event[\"NODE_MOUSEMOVE\"] = \"node:mousemove\";\n  G6Event[\"NODE_MOUSEOUT\"] = \"node:mouseout\";\n  G6Event[\"NODE_MOUSEOVER\"] = \"node:mouseover\";\n  G6Event[\"NODE_DROP\"] = \"node:drop\";\n  G6Event[\"NODE_DRAGOVER\"] = \"node:dragover\";\n  G6Event[\"NODE_DRAGENTER\"] = \"node:dragenter\";\n  G6Event[\"NODE_DRAGLEAVE\"] = \"node:dragleave\";\n  G6Event[\"NODE_DRAGSTART\"] = \"node:dragstart\";\n  G6Event[\"NODE_DRAG\"] = \"node:drag\";\n  G6Event[\"NODE_DRAGEND\"] = \"node:dragend\";\n  G6Event[\"NODE_TAP\"] = \"node:tap\";\n  G6Event[\"NODE_PANSTART\"] = \"node:panstart\";\n  G6Event[\"NODE_PANMOVE\"] = \"node:panmove\";\n  G6Event[\"NODE_PANEND\"] = \"node:panend\"; // combo, extends from nodes\n\n  G6Event[\"COMBO_CONTEXTMENU\"] = \"combo:contextmenu\";\n  G6Event[\"COMBO_CLICK\"] = \"combo:click\";\n  G6Event[\"COMBO_DBLCLICK\"] = \"combo:dblclick\";\n  G6Event[\"COMBO_MOUSEDOWN\"] = \"combo:mousedown\";\n  G6Event[\"COMBO_MOUSEUP\"] = \"combo:mouseup\";\n  G6Event[\"COMBO_MOUSEENTER\"] = \"combo:mouseenter\";\n  G6Event[\"COMBO_MOUSELEAVE\"] = \"combo:mouseleave\";\n  G6Event[\"COMBO_MOUSEMOVE\"] = \"combo:mousemove\";\n  G6Event[\"COMBO_MOUSEOUT\"] = \"combo:mouseout\";\n  G6Event[\"COMBO_MOUSEOVER\"] = \"combo:mouseover\";\n  G6Event[\"COMBO_DROP\"] = \"combo:drop\";\n  G6Event[\"COMBO_DRAGOVER\"] = \"combo:dragover\";\n  G6Event[\"COMBO_DRAGENTER\"] = \"combo:dragenter\";\n  G6Event[\"COMBO_DRAGLEAVE\"] = \"combo:dragleave\";\n  G6Event[\"COMBO_DRAGSTART\"] = \"combo:dragstart\";\n  G6Event[\"COMBO_DRAG\"] = \"combo:drag\";\n  G6Event[\"COMBO_DRAGEND\"] = \"combo:dragend\";\n  G6Event[\"COMBO_TAP\"] = \"combo:tap\";\n  G6Event[\"COMBO_PANSTART\"] = \"combo:panstart\";\n  G6Event[\"COMBO_PANMOVE\"] = \"combo:panmove\";\n  G6Event[\"COMBO_PANEND\"] = \"combo:panend\"; // edge events\n\n  G6Event[\"EDGE_CONTEXTMENU\"] = \"edge:contextmenu\";\n  G6Event[\"EDGE_CLICK\"] = \"edge:click\";\n  G6Event[\"EDGE_DBLCLICK\"] = \"edge:dblclick\";\n  G6Event[\"EDGE_MOUSEDOWN\"] = \"edge:mousedown\";\n  G6Event[\"EDGE_MOUSEUP\"] = \"edge:mouseup\";\n  G6Event[\"EDGE_MOUSEENTER\"] = \"edge:mouseenter\";\n  G6Event[\"EDGE_MOUSELEAVE\"] = \"edge:mouseleave\";\n  G6Event[\"EDGE_MOUSEMOVE\"] = \"edge:mousemove\";\n  G6Event[\"EDGE_MOUSEOUT\"] = \"edge:mouseout\";\n  G6Event[\"EDGE_MOUSEOVER\"] = \"edge:mouseover\";\n  G6Event[\"EDGE_DROP\"] = \"edge:drop\";\n  G6Event[\"EDGE_DRAGOVER\"] = \"edge:dragover\";\n  G6Event[\"EDGE_DRAGENTER\"] = \"edge:dragenter\";\n  G6Event[\"EDGE_DRAGLEAVE\"] = \"edge:dragleave\"; // canvas events\n\n  G6Event[\"CANVAS_CONTEXTMENU\"] = \"canvas:contextmenu\";\n  G6Event[\"CANVAS_CLICK\"] = \"canvas:click\";\n  G6Event[\"CANVAS_DBLCLICK\"] = \"canvas:dblclick\";\n  G6Event[\"CANVAS_MOUSEDOWN\"] = \"canvas:mousedown\";\n  G6Event[\"CANVAS_MOUSEUP\"] = \"canvas:mouseup\";\n  G6Event[\"CANVAS_MOUSEENTER\"] = \"canvas:mouseenter\";\n  G6Event[\"CANVAS_MOUSELEAVE\"] = \"canvas:mouseleave\";\n  G6Event[\"CANVAS_MOUSEMOVE\"] = \"canvas:mousemove\";\n  G6Event[\"CANVAS_MOUSEOUT\"] = \"canvas:mouseout\";\n  G6Event[\"CANVAS_MOUSEOVER\"] = \"canvas:mouseover\";\n  G6Event[\"CANVAS_DROP\"] = \"canvas:drop\";\n  G6Event[\"CANVAS_DRAGENTER\"] = \"canvas:dragenter\";\n  G6Event[\"CANVAS_DRAGLEAVE\"] = \"canvas:dragleave\";\n  G6Event[\"CANVAS_DRAGSTART\"] = \"canvas:dragstart\";\n  G6Event[\"CANVAS_DRAG\"] = \"canvas:drag\";\n  G6Event[\"CANVAS_DRAGEND\"] = \"canvas:dragend\";\n  G6Event[\"CANVAS_TAP\"] = \"canvas:tap\";\n  G6Event[\"CANVAS_PANSTART\"] = \"canvas:panstart\";\n  G6Event[\"CANVAS_PANMOVE\"] = \"canvas:panmove\";\n  G6Event[\"CANVAS_PANEND\"] = \"canvas:panend\"; // timing events\n\n  G6Event[\"BEFORERENDER\"] = \"beforerender\";\n  G6Event[\"AFTERRENDER\"] = \"afterrender\";\n  G6Event[\"BEFOREADDITEM\"] = \"beforeadditem\";\n  G6Event[\"AFTERADDITEM\"] = \"afteradditem\";\n  G6Event[\"BEFOREREMOVEITEM\"] = \"beforeremoveitem\";\n  G6Event[\"AFTERREMOVEITEM\"] = \"afterremoveitem\";\n  G6Event[\"BEFOREUPDATEITEM\"] = \"beforeupdateitem\";\n  G6Event[\"AFTERUPDATEITEM\"] = \"afterupdateitem\";\n  G6Event[\"BEFOREITEMVISIBILITYCHANGE\"] = \"beforeitemvisibilitychange\";\n  G6Event[\"AFTERITEMVISIBILITYCHANGE\"] = \"afteritemvisibilitychange\";\n  G6Event[\"BEFOREITEMSTATECHANGE\"] = \"beforeitemstatechange\";\n  G6Event[\"AFTERITEMSTATECHANGE\"] = \"afteritemstatechange\";\n  G6Event[\"BEFOREITEMREFRESH\"] = \"beforeitemrefresh\";\n  G6Event[\"AFTERITEMREFRESH\"] = \"afteritemrefresh\";\n  G6Event[\"BEFOREITEMSTATESCLEAR\"] = \"beforeitemstatesclear\";\n  G6Event[\"AFTERITEMSTATESCLEAR\"] = \"afteritemstatesclear\";\n  G6Event[\"BEFOREMODECHANGE\"] = \"beforemodechange\";\n  G6Event[\"AFTERMODECHANGE\"] = \"aftermodechange\";\n  G6Event[\"BEFORELAYOUT\"] = \"beforelayout\";\n  G6Event[\"AFTERLAYOUT\"] = \"afterlayout\";\n  G6Event[\"BEFORECREATEEDGE\"] = \"beforecreateedge\";\n  G6Event[\"AFTERCREATEEDGE\"] = \"aftercreateedge\";\n  G6Event[\"BEFOREGRAPHREFRESHPOSITION\"] = \"beforegraphrefreshposition\";\n  G6Event[\"AFTERGRAPHREFRESHPOSITION\"] = \"aftergraphrefreshposition\";\n  G6Event[\"BEFOREGRAPHREFRESH\"] = \"beforegraphrefresh\";\n  G6Event[\"AFTERGRAPHREFRESH\"] = \"aftergraphrefresh\";\n  G6Event[\"BEFOREANIMATE\"] = \"beforeanimate\";\n  G6Event[\"AFTERANIMATE\"] = \"afteranimate\";\n  G6Event[\"BEFOREPAINT\"] = \"beforepaint\";\n  G6Event[\"AFTERPAINT\"] = \"afterpaint\";\n  G6Event[\"BEFORECOLLAPSEEXPANDCOMBO\"] = \"beforecollapseexpandcombo\";\n  G6Event[\"AFTERCOLLAPSEEXPANDCOMBO\"] = \"aftercollapseexpandcombo\";\n  G6Event[\"GRAPHSTATECHANGE\"] = \"graphstatechange\";\n  G6Event[\"AFTERACTIVATERELATIONS\"] = \"afteractivaterelations\";\n  G6Event[\"NODESELECTCHANGE\"] = \"nodeselectchange\";\n  G6Event[\"TOOLTIPCHANGE\"] = \"tooltipchange\";\n  G6Event[\"WHEELZOOM\"] = \"wheelzoom\";\n  G6Event[\"VIEWPORTCHANGE\"] = \"viewportchange\";\n  G6Event[\"DRAGNODEEND\"] = \"dragnodeend\";\n  G6Event[\"STACKCHANGE\"] = \"stackchange\"; // Mobile event support\n\n  G6Event[\"TAP\"] = \"tap\";\n  G6Event[\"PINCHSTART\"] = \"pinchstart\";\n  G6Event[\"PINCHMOVE\"] = \"pinchmove\";\n  G6Event[\"PANSTART\"] = \"panstart\";\n  G6Event[\"PANMOVE\"] = \"panmove\";\n  G6Event[\"PANEND\"] = \"panend\";\n})(G6Event || (exports.G6Event = G6Event = {}));","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _graph = require(\"./graph\");\n\nObject.keys(_graph).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _graph[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _graph[key];\n    }\n  });\n});\n\nvar _behavior = require(\"./behavior\");\n\nObject.keys(_behavior).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _behavior[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _behavior[key];\n    }\n  });\n});\n\nvar _item = require(\"./item\");\n\nObject.keys(_item).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _item[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _item[key];\n    }\n  });\n});\n\nvar _shape = require(\"./shape\");\n\nObject.keys(_shape).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _shape[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _shape[key];\n    }\n  });\n});","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});"]}