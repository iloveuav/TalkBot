{"version":3,"sources":["index.js","behavior/index.js","behavior/behavior.js","behavior/behaviorOption.js","graph/graph.js","util/math.js","util/validation.js","util/graphic.js","global.js","util/letterAspectRatio.js","graph/controller/index.js","graph/controller/mode.js","graph/controller/view.js","util/base.js","interface/behavior.js","graph/controller/item.js","item/edge.js","item/item.js","element/shape.js","element/xml.js","item/node.js","item/combo.js","graph/controller/state.js","item/hull.js","util/path.js","element/hull/convexHull.js","element/hull/bubbleset.js","element/index.js","element/node.js","element/shapeBase.js","element/edge.js","element/combo.js","element/combos/index.js","element/combos/circle.js","element/combos/rect.js","element/nodes/index.js","element/nodes/simple-circle.js","element/nodes/simple-rect.js","element/nodes/image.js","element/arrow.js","element/marker.js","util/index.js","util/color.js","graph/controller/layout.js","graph/controller/event.js","types/index.js","interface/index.js","interface/graph.js","interface/item.js","interface/shape.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,AGTA,AJYA;AELA,ACHA,AFMA,AGTA,AJYA;AELA,ACHA,AFMA,AGTA,AJYA;AELA,ACHA,AFMA,AGTA,AJYA,AKfA;AHUA,ACHA,ACHA,AJYA,AKfA;AHUA,ACHA,ACHA,AJYA,AKfA;AHUA,ACHA,ACHA,AJYA,AKfA,ACHA;AJaA,ACHA,ACHA,AJYA,AKfA,ACHA;AJaA,ACHA,ACHA,AJYA,AKfA,ACHA;AJaA,ACHA,ACHA,AJYA,AOrBA,AFMA,ACHA;AJaA,ACHA,ACHA,AJYA,AOrBA,AFMA,ACHA;AJaA,ACHA,ACHA,AJYA,AOrBA,AFMA,ACHA;AJaA,ACHA,AKfA,AJYA,AJYA,AOrBA,AFMA,ACHA;AJaA,ACHA,AKfA,AJYA,AJYA,AOrBA,AFMA,ACHA;AJaA,ACHA,AKfA,AJYA,AJYA,AOrBA,AFMA,ACHA;AJaA,ACHA,AKfA,AJYA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AJYA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AJYA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ANkBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ANkBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ANkBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,APqBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,APqBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,APqBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,AOrBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,AavCA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,AavCA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,AavCA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,Ac1CA,ADGA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,Ac1CA,ADGA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,ACHA,ACHA,ARwBA,AJYA,Ac1CA,ADGA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,ADGA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,ADGA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,ADGA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,AHSA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,AHSA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,AHSA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,AKfA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,AV8BA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,AV8BA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,AV8BA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AJYA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AENA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,ACHA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AENA,AKfA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,ACHA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,ACHA;AJaA,ACHA,Ae7CA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,Ac1CA,AOrBA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,Ae7CA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,Ae7CA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AsBlEA,APqBA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AsBlEA,APqBA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AsBlEA,APqBA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,APqBA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,APqBA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,APqBA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,AT2BA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,AT2BA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,AT2BA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,ACHA,AV8BA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,ACHA,AV8BA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,ACHA,AV8BA,ACHA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AHUA,AuBrEA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AwBvEA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AwBvEA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AwBvEA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,ADGA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,ADGA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,ADGA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,ACHA,AFMA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,ACHA,AFMA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,ACHA,AFMA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ADGA,AFMA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ADGA,AFMA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,AHSA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AV8BA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AOrBA,AjBmDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AOrBA,AjBmDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AOrBA,AjBmDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AOrBA,ACHA,AlBsDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AOrBA,ACHA,AlBsDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AOrBA,ACHA,AlBsDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AOrBA,ACHA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AQxBA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AQxBA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AyB1EA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AiClGA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AiClGA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AiClGA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,AENA,ACHA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AiClGA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AiClGA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AiClGA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AENA,AJYA,AmBzDA,AlBsDA;AiClGA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AkCtGA,AhCgGA,AJYA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AkCtGA,AhCgGA,AJYA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AkCtGA,AhCgGA,AJYA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,A6BvFA,AnCyGA,AkCtGA,AhCgGA,AJYA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,A6BvFA,AnCyGA,AkCtGA,AhCgGA,AJYA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,AJYA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,A6BvFA,AnCyGA,AkCtGA,AhCgGA,AJYA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,A6BvFA,AnCyGA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,A6BvFA,AnCyGA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,A6BvFA,AnCyGA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,A6BvFA,AnCyGA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,A6BvFA,AnCyGA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,APqBA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,AqB/DA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A+C7IA,ADGA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,ADGA,Ae7CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A+C7IA,ADGA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,Ac1CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A+C7IA,ADGA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,Ac1CA,AZoCA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A+C7IA,ADGA,AENA,A3BiFA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A+C7IA,ADGA,AENA,A3BiFA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AENA,A3BiFA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AENA,ACHA,A5BoFA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AENA,ACHA,A5BoFA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AGTA,A5BoFA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AGTA,A5BoFA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AGTA,A5BoFA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AoC5GA,A7BuFA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AkCtGA,ApC4GA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AJYA,A8C1IA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,AFMA,ACHA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,A0C9HA,AzB2EA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ADGA,AnByDA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AENA,ACHA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;Ae5CA,ARwBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AOpBA,AGTA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,AWjCA,AV8BA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AXiCA,AOrBA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AU9BA,ApB4DA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AhCgGA,ACHA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AhCgGA,ANkBA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,A/B6FA,ARwBA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,AV8BA,AWjCA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AyB3EA,AtCkHA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AU7BA,AJYA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,ALeA,AOrBA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AGTA,AbuCA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AiBnDA,AENA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AmBzDA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AmBzDA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AmBzDA,ANkBA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA,AmBzDA;AMjBA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AENA,ACHA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,A4BpFA,AvCqHA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AGTA,AV8BA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,APqBA,AJYA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AyB1EA,AJYA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AV8BA,AFMA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AqB9DA,AXiCA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;AU7BA,AXiCA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,AavCA,AZoCA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\n\r\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nvar _exportNames = {\r\n  registerNode: true,\r\n  registerCombo: true,\r\n  registerEdge: true,\r\n  registerBehavior: true,\r\n  BaseGlobal: true,\r\n  AbstractGraph: true,\r\n  Shape: true,\r\n  Arrow: true,\r\n  Marker: true,\r\n  Util: true,\r\n  AbstractLayout: true,\r\n  AbstractEvent: true,\r\n  Node: true,\r\n  Edge: true,\r\n  Hull: true,\r\n  Combo: true\r\n};\r\nObject.defineProperty(exports, \"AbstractGraph\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _graph.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"Shape\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _element.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"Arrow\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _element.Arrow;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"Marker\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _element.Marker;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"Util\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _util.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"AbstractLayout\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _layout.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"AbstractEvent\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _event.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"Node\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _node.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"Edge\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _edge.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"Hull\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _hull.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"Combo\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _combo.default;\r\n  }\r\n});\r\nexports.default = exports.BaseGlobal = exports.registerBehavior = exports.registerEdge = exports.registerCombo = exports.registerNode = void 0;\r\n\r\nvar _behavior = _interopRequireDefault(require(\"./behavior\"));\r\n\r\nvar _graph = _interopRequireDefault(require(\"./graph/graph\"));\r\n\r\nvar _element = _interopRequireWildcard(require(\"./element\"));\r\n\r\nvar _global = _interopRequireDefault(require(\"./global\"));\r\n\r\nvar _util = _interopRequireDefault(require(\"./util\"));\r\n\r\nvar _layout = _interopRequireDefault(require(\"./graph/controller/layout\"));\r\n\r\nvar _event = _interopRequireDefault(require(\"./graph/controller/event\"));\r\n\r\nvar _node = _interopRequireDefault(require(\"./item/node\"));\r\n\r\nvar _edge = _interopRequireDefault(require(\"./item/edge\"));\r\n\r\nvar _hull = _interopRequireDefault(require(\"./item/hull\"));\r\n\r\nvar _combo = _interopRequireDefault(require(\"./item/combo\"));\r\n\r\nvar _types = require(\"./types\");\r\n\r\nObject.keys(_types).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\r\n  if (key in exports && exports[key] === _types[key]) return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function get() {\r\n      return _types[key];\r\n    }\r\n  });\r\n});\r\n\r\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\r\n\r\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n// 用于 PC 和 Mobile 端分别实现 layout 和 updateLayoutCfg 方法\r\nvar registerNode = _element.default.registerNode;\r\nexports.registerNode = registerNode;\r\nvar registerEdge = _element.default.registerEdge;\r\nexports.registerEdge = registerEdge;\r\nvar registerCombo = _element.default.registerCombo;\r\nexports.registerCombo = registerCombo;\r\nvar registerBehavior = _behavior.default.registerBehavior;\r\nexports.registerBehavior = registerBehavior;\r\nvar BaseGlobal = _global.default;\r\nexports.BaseGlobal = BaseGlobal;\r\nvar _default = {\r\n  version: _global.default.version,\r\n  AbstractGraph: _graph.default,\r\n  BaseGlobal: BaseGlobal,\r\n  Util: _util.default,\r\n  Shape: _element.default,\r\n  Node: _node.default,\r\n  Edge: _edge.default,\r\n  Combo: _combo.default,\r\n  Hull: _hull.default,\r\n  registerNode: _element.default.registerNode,\r\n  registerEdge: _element.default.registerEdge,\r\n  registerCombo: _element.default.registerCombo,\r\n  registerBehavior: _behavior.default.registerBehavior,\r\n  Arrow: _element.Arrow,\r\n  Marker: _element.Marker,\r\n  AbstractLayout: _layout.default,\r\n  AbstractEvent: _event.default\r\n};\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _behavior = _interopRequireDefault(require(\"./behavior\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar _default = _behavior.default;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _behaviorOption = _interopRequireDefault(require(\"./behaviorOption\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar Behavior =\r\n/** @class */\r\nfunction () {\r\n  function Behavior() {}\r\n  /**\r\n   * 自定义 Behavior\r\n   * @param type Behavior 名称\r\n   * @param behavior Behavior 定义的方法集合\r\n   */\r\n\r\n\r\n  Behavior.registerBehavior = function (type, behavior) {\r\n    if (!behavior) {\r\n      throw new Error(\"please specify handler for this behavior: \" + type);\r\n    }\r\n\r\n    var prototype = (0, _util.clone)(_behaviorOption.default);\r\n    Object.assign(prototype, behavior); // eslint-disable-next-line func-names\r\n\r\n    var base = function base(cfg) {\r\n      var _this = this;\r\n\r\n      Object.assign(this, this.getDefaultCfg(), cfg);\r\n      var events = this.getEvents();\r\n      this.events = null;\r\n      var eventsToBind = {};\r\n\r\n      if (events) {\r\n        (0, _util.each)(events, function (handle, event) {\r\n          eventsToBind[event] = (0, _util.wrapBehavior)(_this, handle);\r\n        });\r\n        this.events = eventsToBind;\r\n      }\r\n    };\r\n\r\n    base.prototype = prototype;\r\n    Behavior.types[type] = base;\r\n  };\r\n\r\n  Behavior.hasBehavior = function (type) {\r\n    return !!Behavior.types[type];\r\n  };\r\n\r\n  Behavior.getBehavior = function (type) {\r\n    return Behavior.types[type];\r\n  }; // 所有自定义的 Behavior 的实例\r\n\r\n\r\n  Behavior.types = {};\r\n  return Behavior;\r\n}();\r\n\r\nvar _default = Behavior;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\n// 自定义 Behavior 时候共有的方法\r\nvar _default = {\r\n  getDefaultCfg: function getDefaultCfg() {\r\n    return {};\r\n  },\r\n\r\n  /**\r\n   * register event handler, behavior will auto bind events\r\n   * for example:\r\n   * return {\r\n   *  click: 'onClick'\r\n   * }\r\n   */\r\n  getEvents: function getEvents() {\r\n    return {};\r\n  },\r\n  updateCfg: function updateCfg(cfg) {\r\n    Object.assign(this, cfg);\r\n    return true;\r\n  },\r\n  shouldBegin: function shouldBegin() {\r\n    return true;\r\n  },\r\n  shouldUpdate: function shouldUpdate() {\r\n    return true;\r\n  },\r\n  shouldEnd: function shouldEnd() {\r\n    return true;\r\n  },\r\n\r\n  /**\r\n   * auto bind events when register behavior\r\n   * @param graph Graph instance\r\n   */\r\n  bind: function bind(graph) {\r\n    var _this = this;\r\n\r\n    var events = this.events;\r\n    this.graph = graph;\r\n\r\n    if (this.type === 'drag-canvas' || this.type === 'brush-select' || this.type === 'lasso-select') {\r\n      graph.get('canvas').set('draggable', true);\r\n    }\r\n\r\n    (0, _util.each)(events, function (handler, event) {\r\n      graph.on(event, handler);\r\n    }); // To avoid the tabs switching makes the keydown related behaviors disable\r\n\r\n    document.addEventListener('visibilitychange', function () {\r\n      _this.keydown = false;\r\n    });\r\n  },\r\n  unbind: function unbind(graph) {\r\n    var events = this.events;\r\n\r\n    if (this.type === 'drag-canvas' || this.type === 'brush-select' || this.type === 'lasso-select') {\r\n      graph.get('canvas').set('draggable', false);\r\n    }\r\n\r\n    (0, _util.each)(events, function (handler, event) {\r\n      graph.off(event, handler);\r\n    });\r\n  },\r\n  get: function get(val) {\r\n    return this[val];\r\n  },\r\n  set: function set(key, val) {\r\n    this[key] = val;\r\n    return this;\r\n  }\r\n};\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _eventEmitter = _interopRequireDefault(require(\"@antv/event-emitter\"));\r\n\r\nvar _matrixUtil = require(\"@antv/matrix-util\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _algorithm = require(\"@antv/algorithm\");\r\n\r\nvar _math = require(\"../util/math\");\r\n\r\nvar _validation = require(\"../util/validation\");\r\n\r\nvar _global = _interopRequireDefault(require(\"../global\"));\r\n\r\nvar _controller = require(\"./controller\");\r\n\r\nvar _graphic = require(\"../util/graphic\");\r\n\r\nvar _hull = _interopRequireDefault(require(\"../item/hull\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar transform = _matrixUtil.ext.transform;\r\nvar NODE = 'node';\r\n\r\nvar AbstractGraph =\r\n/** @class */\r\nfunction (_super) {\r\n  (0, _tslib.__extends)(AbstractGraph, _super);\r\n\r\n  function AbstractGraph(cfg) {\r\n    var _this = _super.call(this) || this;\r\n\r\n    _this.cfg = (0, _util.deepMix)(_this.getDefaultCfg(), cfg);\r\n\r\n    _this.init();\r\n\r\n    _this.animating = false;\r\n    _this.destroyed = false; // 启用 stack 后，实例化 undoStack 和 redoStack\r\n\r\n    if (_this.cfg.enabledStack) {\r\n      // 实例化 undo 和 redo 栈\r\n      _this.undoStack = new _algorithm.Stack(_this.cfg.maxStep);\r\n      _this.redoStack = new _algorithm.Stack(_this.cfg.maxStep);\r\n    }\r\n\r\n    return _this;\r\n  }\r\n\r\n  AbstractGraph.prototype.init = function () {\r\n    this.initCanvas(); // instance controller\r\n\r\n    var viewController = new _controller.ViewController(this);\r\n    var modeController = new _controller.ModeController(this);\r\n    var itemController = new _controller.ItemController(this);\r\n    var stateController = new _controller.StateController(this);\r\n    this.set({\r\n      viewController: viewController,\r\n      modeController: modeController,\r\n      itemController: itemController,\r\n      stateController: stateController\r\n    }); // 初始化布局机制\r\n\r\n    this.initLayoutController(); // 初始化事件机制\r\n\r\n    this.initEventController();\r\n    this.initGroups();\r\n    /** 初始化插件 */\r\n\r\n    this.initPlugins();\r\n  }; // 初始化所有 Group\r\n\r\n\r\n  AbstractGraph.prototype.initGroups = function () {\r\n    var canvas = this.get('canvas');\r\n    var el = this.get('canvas').get('el');\r\n    var id = el.id;\r\n    var group = canvas.addGroup({\r\n      id: id + \"-root\",\r\n      className: _global.default.rootContainerClassName\r\n    });\r\n\r\n    if (this.get('groupByTypes')) {\r\n      var edgeGroup = group.addGroup({\r\n        id: id + \"-edge\",\r\n        className: _global.default.edgeContainerClassName\r\n      });\r\n      var nodeGroup = group.addGroup({\r\n        id: id + \"-node\",\r\n        className: _global.default.nodeContainerClassName\r\n      });\r\n      var comboGroup = group.addGroup({\r\n        id: id + \"-combo\",\r\n        className: _global.default.comboContainerClassName\r\n      }); // 用于存储自定义的群组\r\n\r\n      comboGroup.toBack();\r\n      this.set({\r\n        nodeGroup: nodeGroup,\r\n        edgeGroup: edgeGroup,\r\n        comboGroup: comboGroup\r\n      });\r\n    }\r\n\r\n    var delegateGroup = group.addGroup({\r\n      id: id + \"-delegate\",\r\n      className: _global.default.delegateContainerClassName\r\n    });\r\n    this.set({\r\n      delegateGroup: delegateGroup\r\n    });\r\n    this.set('group', group);\r\n  }; // eslint-disable-next-line class-methods-use-this\r\n\r\n\r\n  AbstractGraph.prototype.getDefaultCfg = function () {\r\n    return {\r\n      /**\r\n       * Container could be dom object or dom id\r\n       */\r\n      container: undefined,\r\n\r\n      /**\r\n       * Canvas width\r\n       * unit pixel if undefined force fit width\r\n       */\r\n      width: undefined,\r\n\r\n      /**\r\n       * Canvas height\r\n       * unit pixel if undefined force fit height\r\n       */\r\n      height: undefined,\r\n\r\n      /**\r\n       * renderer canvas or svg\r\n       * @type {string}\r\n       */\r\n      renderer: 'canvas',\r\n\r\n      /**\r\n       * control graph behaviors\r\n       */\r\n      modes: {},\r\n\r\n      /**\r\n       * 注册插件\r\n       */\r\n      plugins: [],\r\n\r\n      /**\r\n       * source data\r\n       */\r\n      data: {},\r\n\r\n      /**\r\n       * Fit view padding (client scale)\r\n       */\r\n      fitViewPadding: 10,\r\n\r\n      /**\r\n       * Minimum scale size\r\n       */\r\n      minZoom: 0.2,\r\n\r\n      /**\r\n       * Maxmum scale size\r\n       */\r\n      maxZoom: 10,\r\n\r\n      /**\r\n       *  capture events\r\n       */\r\n      event: true,\r\n\r\n      /**\r\n       * group node & edges into different graphic groups\r\n       */\r\n      groupByTypes: true,\r\n\r\n      /**\r\n       * determine if it's a directed graph\r\n       */\r\n      directed: false,\r\n\r\n      /**\r\n       * when data or shape changed, should canvas draw automatically\r\n       */\r\n      autoPaint: true,\r\n\r\n      /**\r\n       * store all the node instances\r\n       */\r\n      nodes: [],\r\n\r\n      /**\r\n       * store all the edge instances\r\n       */\r\n      edges: [],\r\n\r\n      /**\r\n       * store all the combo instances\r\n       */\r\n      combos: [],\r\n\r\n      /**\r\n       * store all the edge instances which are virtual edges related to collapsed combo\r\n       */\r\n      vedges: [],\r\n\r\n      /**\r\n       * all the instances indexed by id\r\n       */\r\n      itemMap: {},\r\n\r\n      /**\r\n       * 边直接连接到节点的中心，不再考虑锚点\r\n       */\r\n      linkCenter: false,\r\n\r\n      /**\r\n       * 默认的节点配置，data 上定义的配置会覆盖这些配置。例如：\r\n       * defaultNode: {\r\n       *  type: 'rect',\r\n       *  size: [60, 40],\r\n       *  style: {\r\n       *    //... 样式配置项\r\n       *  }\r\n       * }\r\n       * 若数据项为 { id: 'node', x: 100, y: 100 }\r\n       * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'rect', size: [60, 40] }\r\n       * 若数据项为 { id: 'node', x: 100, y: 100, type: 'circle' }\r\n       * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'circle', size: [60, 40] }\r\n       */\r\n      defaultNode: {},\r\n\r\n      /**\r\n       * 默认边配置，data 上定义的配置会覆盖这些配置。用法同 defaultNode\r\n       */\r\n      defaultEdge: {},\r\n\r\n      /**\r\n       * 节点默认样式，也可以添加状态样式\r\n       * 例如：\r\n       * const graph = new G6.Graph({\r\n       *  nodeStateStyles: {\r\n       *    selected: { fill: '#ccc', stroke: '#666' },\r\n       *    active: { lineWidth: 2 }\r\n       *  },\r\n       *  ...\r\n       * });\r\n       *\r\n       */\r\n      nodeStateStyles: {},\r\n\r\n      /**\r\n       * 边默认样式，用法同nodeStateStyle\r\n       */\r\n      edgeStateStyles: {},\r\n\r\n      /**\r\n       * graph 状态\r\n       */\r\n      states: {},\r\n\r\n      /**\r\n       * 是否启用全局动画\r\n       */\r\n      animate: false,\r\n\r\n      /**\r\n       * 动画设置,仅在 animate 为 true 时有效\r\n       */\r\n      animateCfg: {\r\n        /**\r\n         * 帧回调函数，用于自定义节点运动路径，为空时线性运动\r\n         */\r\n        onFrame: undefined,\r\n\r\n        /**\r\n         * 动画时长(ms)\r\n         */\r\n        duration: 500,\r\n\r\n        /**\r\n         * 指定动画动效\r\n         */\r\n        easing: 'easeLinear'\r\n      },\r\n      callback: undefined,\r\n      // 默认不启用 undo & redo 功能\r\n      enabledStack: false,\r\n      // 只有当 enabledStack 为 true 时才起作用\r\n      maxStep: 10,\r\n      // 存储图上的 tooltip dom，方便销毁\r\n      tooltips: []\r\n    };\r\n  };\r\n  /**\r\n   * 将值设置到 this.cfg 变量上面\r\n   * @param key 键 或 对象值\r\n   * @param val 值\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.set = function (key, val) {\r\n    if ((0, _util.isPlainObject)(key)) {\r\n      this.cfg = (0, _tslib.__assign)((0, _tslib.__assign)({}, this.cfg), key);\r\n    } else {\r\n      this.cfg[key] = val;\r\n    }\r\n\r\n    return this;\r\n  };\r\n  /**\r\n   * 获取 this.cfg 中的值\r\n   * @param key 键\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.get = function (key) {\r\n    return this.cfg[key];\r\n  };\r\n  /**\r\n   * 获取 graph 的根图形分组\r\n   * @return 根 group\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getGroup = function () {\r\n    return this.get('group');\r\n  };\r\n  /**\r\n   * 获取 graph 的 DOM 容器\r\n   * @return DOM 容器\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getContainer = function () {\r\n    return this.get('container');\r\n  };\r\n  /**\r\n   * 获取 graph 的最小缩放比例\r\n   * @return minZoom\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getMinZoom = function () {\r\n    return this.get('minZoom');\r\n  };\r\n  /**\r\n   * 设置 graph 的最小缩放比例\r\n   * @return minZoom\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.setMinZoom = function (ratio) {\r\n    return this.set('minZoom', ratio);\r\n  };\r\n  /**\r\n   * 获取 graph 的最大缩放比例\r\n   * @param maxZoom\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getMaxZoom = function () {\r\n    return this.get('maxZoom');\r\n  };\r\n  /**\r\n   * 设置 graph 的最大缩放比例\r\n   * @param maxZoom\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.setMaxZoom = function (ratio) {\r\n    return this.set('maxZoom', ratio);\r\n  };\r\n  /**\r\n   * 获取 graph 的宽度\r\n   * @return width\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getWidth = function () {\r\n    return this.get('width');\r\n  };\r\n  /**\r\n   * 获取 graph 的高度\r\n   * @return width\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getHeight = function () {\r\n    return this.get('height');\r\n  };\r\n  /**\r\n   * 清理元素多个状态\r\n   * @param {string|Item} item 元素id或元素实例\r\n   * @param {string[]} states 状态\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.clearItemStates = function (item, states) {\r\n    if ((0, _util.isString)(item)) {\r\n      item = this.findById(item);\r\n    }\r\n\r\n    var itemController = this.get('itemController');\r\n\r\n    if (!states) {\r\n      states = item.get('states');\r\n    }\r\n\r\n    itemController.clearItemStates(item, states);\r\n    var stateController = this.get('stateController');\r\n    stateController.updateStates(item, states, false);\r\n  };\r\n  /**\r\n   * 设置各个节点样式，以及在各种状态下节点 keyShape 的样式。\r\n   * 若是自定义节点切在各种状态下\r\n   * graph.node(node => {\r\n   *  return {\r\n   *    type: 'rect',\r\n   *    label: node.id,\r\n   *    style: { fill: '#666' },\r\n   *    stateStyles: {\r\n   *       selected: { fill: 'blue' },\r\n   *       custom: { fill: 'green' }\r\n   *     }\r\n   *   }\r\n   * });\r\n   * @param {function} nodeFn 指定每个节点样式\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.node = function (nodeFn) {\r\n    if (typeof nodeFn === 'function') {\r\n      this.set('nodeMapper', nodeFn);\r\n    }\r\n  };\r\n  /**\r\n   * 设置各个边样式\r\n   * @param {function} edgeFn 指定每个边的样式,用法同 node\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.edge = function (edgeFn) {\r\n    if (typeof edgeFn === 'function') {\r\n      this.set('edgeMapper', edgeFn);\r\n    }\r\n  };\r\n  /**\r\n   * 设置各个 combo 的配置\r\n   * @param comboFn\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.combo = function (comboFn) {\r\n    if (typeof comboFn === 'function') {\r\n      this.set('comboMapper', comboFn);\r\n    }\r\n  };\r\n  /**\r\n   * 根据 ID 查询图元素实例\r\n   * @param id 图元素 ID\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.findById = function (id) {\r\n    return this.get('itemMap')[id];\r\n  };\r\n  /**\r\n   * 根据对应规则查找单个元素\r\n   * @param {ITEM_TYPE} type 元素类型(node | edge | group)\r\n   * @param {(item: T, index: number) => T} fn 指定规则\r\n   * @return {T} 元素实例\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.find = function (type, fn) {\r\n    var result;\r\n    var items = this.get(type + \"s\"); // eslint-disable-next-line consistent-return\r\n\r\n    (0, _util.each)(items, function (item, i) {\r\n      if (fn(item, i)) {\r\n        result = item;\r\n        return result;\r\n      }\r\n    });\r\n    return result;\r\n  };\r\n  /**\r\n   * 查找所有满足规则的元素\r\n   * @param {string} type 元素类型(node|edge)\r\n   * @param {string} fn 指定规则\r\n   * @return {array} 元素实例\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.findAll = function (type, fn) {\r\n    var result = [];\r\n    (0, _util.each)(this.get(type + \"s\"), function (item, i) {\r\n      if (fn(item, i)) {\r\n        result.push(item);\r\n      }\r\n    });\r\n    return result;\r\n  };\r\n  /**\r\n   * 查找所有处于指定状态的元素\r\n   * @param {string} type 元素类型(node|edge)\r\n   * @param {string} state 状态\r\n   * @return {object} 元素实例\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.findAllByState = function (type, state) {\r\n    return this.findAll(type, function (item) {\r\n      return item.hasState(state);\r\n    });\r\n  };\r\n  /**\r\n   * 平移画布\r\n   * @param dx 水平方向位移\r\n   * @param dy 垂直方向位移\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.translate = function (dx, dy) {\r\n    var group = this.get('group');\r\n    var matrix = (0, _util.clone)(group.getMatrix());\r\n\r\n    if (!matrix) {\r\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n    }\r\n\r\n    matrix = transform(matrix, [['t', dx, dy]]);\r\n    group.setMatrix(matrix);\r\n    this.emit('viewportchange', {\r\n      action: 'translate',\r\n      matrix: group.getMatrix()\r\n    });\r\n    this.autoPaint();\r\n  };\r\n  /**\r\n   * 平移画布到某点\r\n   * @param {number} x 水平坐标\r\n   * @param {number} y 垂直坐标\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.moveTo = function (x, y) {\r\n    var group = this.get('group');\r\n    (0, _math.move)(group, {\r\n      x: x,\r\n      y: y\r\n    });\r\n    this.emit('viewportchange', {\r\n      action: 'move',\r\n      matrix: group.getMatrix()\r\n    });\r\n  };\r\n  /**\r\n   * 调整视口适应视图\r\n   * @param {object} padding 四周围边距\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.fitView = function (padding) {\r\n    if (padding) {\r\n      this.set('fitViewPadding', padding);\r\n    }\r\n\r\n    var viewController = this.get('viewController');\r\n    viewController.fitView();\r\n    this.autoPaint();\r\n  };\r\n  /**\r\n   * 调整视口适应视图，不缩放，仅将图 bbox 中心对齐到画布中心\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.fitCenter = function () {\r\n    var viewController = this.get('viewController');\r\n    viewController.fitCenter();\r\n    this.autoPaint();\r\n  };\r\n  /**\r\n   * 新增行为\r\n   * @param {string | ModeOption | ModeType[]} behaviors 添加的行为\r\n   * @param {string | string[]} modes 添加到对应的模式\r\n   * @return {Graph} Graph\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.addBehaviors = function (behaviors, modes) {\r\n    var modeController = this.get('modeController');\r\n    modeController.manipulateBehaviors(behaviors, modes, true);\r\n    return this;\r\n  };\r\n  /**\r\n   * 移除行为\r\n   * @param {string | ModeOption | ModeType[]} behaviors 移除的行为\r\n   * @param {string | string[]} modes 从指定的模式中移除\r\n   * @return {Graph} Graph\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.removeBehaviors = function (behaviors, modes) {\r\n    var modeController = this.get('modeController');\r\n    modeController.manipulateBehaviors(behaviors, modes, false);\r\n    return this;\r\n  };\r\n  /**\r\n   * 更新行为参数\r\n   * @param {string | ModeOption | ModeType} behavior 需要更新的行为\r\n   * @param {string | string[]} modes 指定的模式中的行为，不指定则为 default\r\n   * @return {Graph} Graph\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.updateBehavior = function (behavior, newCfg, mode) {\r\n    var modeController = this.get('modeController');\r\n    modeController.updateBehavior(behavior, newCfg, mode);\r\n    return this;\r\n  };\r\n  /**\r\n   * 伸缩窗口\r\n   * @param ratio 伸缩比例\r\n   * @param center 以center的x, y坐标为中心缩放\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.zoom = function (ratio, center) {\r\n    var group = this.get('group');\r\n    var matrix = (0, _util.clone)(group.getMatrix());\r\n    var minZoom = this.get('minZoom');\r\n    var maxZoom = this.get('maxZoom');\r\n\r\n    if (!matrix) {\r\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n    }\r\n\r\n    if (center) {\r\n      matrix = transform(matrix, [['t', -center.x, -center.y], ['s', ratio, ratio], ['t', center.x, center.y]]);\r\n    } else {\r\n      matrix = transform(matrix, [['s', ratio, ratio]]);\r\n    }\r\n\r\n    if (minZoom && matrix[0] < minZoom || maxZoom && matrix[0] > maxZoom) {\r\n      return;\r\n    } // matrix = [2, 0, 0, 0, 2, 0, -125, -125, 1];\r\n\r\n\r\n    group.setMatrix(matrix);\r\n    this.emit('viewportchange', {\r\n      action: 'zoom',\r\n      matrix: matrix\r\n    });\r\n    this.autoPaint();\r\n  };\r\n  /**\r\n   * 伸缩视口到一固定比例\r\n   * @param {number} toRatio 伸缩比例\r\n   * @param {Point} center 以center的x, y坐标为中心缩放\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.zoomTo = function (toRatio, center) {\r\n    var ratio = toRatio / this.getZoom();\r\n    this.zoom(ratio, center);\r\n  };\r\n  /**\r\n   * 将元素移动到视口中心\r\n   * @param {Item} item 指定元素\r\n   * @param {boolean} animate 是否带有动画地移动\r\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.focusItem = function (item, animate, animateCfg) {\r\n    var viewController = this.get('viewController');\r\n    var isAnimate = false;\r\n    if (animate) isAnimate = true;else if (animate === undefined) isAnimate = this.get('animate');\r\n    var curAniamteCfg = {};\r\n    if (animateCfg) curAniamteCfg = animateCfg;else if (animateCfg === undefined) curAniamteCfg = this.get('animateCfg');\r\n    viewController.focus(item, isAnimate, curAniamteCfg);\r\n    this.autoPaint();\r\n  };\r\n  /**\r\n   * 自动重绘\r\n   * @internal 仅供内部更新机制调用，外部根据需求调用 render 或 paint 接口\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.autoPaint = function () {\r\n    if (this.get('autoPaint')) {\r\n      this.paint();\r\n    }\r\n  };\r\n  /**\r\n   * 仅画布重新绘制\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.paint = function () {\r\n    this.emit('beforepaint');\r\n    this.get('canvas').draw();\r\n    this.emit('afterpaint');\r\n  };\r\n  /**\r\n   * 将屏幕坐标转换为视口坐标\r\n   * @param {number} clientX 屏幕x坐标\r\n   * @param {number} clientY 屏幕y坐标\r\n   * @return {Point} 视口坐标\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getPointByClient = function (clientX, clientY) {\r\n    var viewController = this.get('viewController');\r\n    return viewController.getPointByClient(clientX, clientY);\r\n  };\r\n  /**\r\n   * 将绘制坐标转换为屏幕坐标\r\n   * @param {number} x 绘制坐标 x\r\n   * @param {number} y 绘制坐标 y\r\n   * @return {Point} 绘制坐标\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getClientByPoint = function (x, y) {\r\n    var viewController = this.get('viewController');\r\n    return viewController.getClientByPoint(x, y);\r\n  };\r\n  /**\r\n   * 将画布坐标转换为绘制坐标\r\n   * @param {number} canvasX 画布 x 坐标\r\n   * @param {number} canvasY 画布 y 坐标\r\n   * @return {object} 绘制坐标\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getPointByCanvas = function (canvasX, canvasY) {\r\n    var viewController = this.get('viewController');\r\n    return viewController.getPointByCanvas(canvasX, canvasY);\r\n  };\r\n  /**\r\n   * 将绘制坐标转换为画布坐标\r\n   * @param {number} x 绘制坐标 x\r\n   * @param {number} y 绘制坐标 y\r\n   * @return {object} 画布坐标\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getCanvasByPoint = function (x, y) {\r\n    var viewController = this.get('viewController');\r\n    return viewController.getCanvasByPoint(x, y);\r\n  };\r\n  /**\r\n   * 获取图内容的中心绘制坐标\r\n   * @return {object} 中心绘制坐标\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getGraphCenterPoint = function () {\r\n    var bbox = this.get('group').getCanvasBBox();\r\n    return {\r\n      x: (bbox.minX + bbox.maxX) / 2,\r\n      y: (bbox.minY + bbox.maxY) / 2\r\n    };\r\n  };\r\n  /**\r\n   * 获取视口中心绘制坐标\r\n   * @return {object} 视口中心绘制坐标\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getViewPortCenterPoint = function () {\r\n    return this.getPointByCanvas(this.get('width') / 2, this.get('height') / 2);\r\n  };\r\n  /**\r\n   * 显示元素\r\n   * @param {Item} item 指定元素\r\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.showItem = function (item, stack) {\r\n    if (stack === void 0) {\r\n      stack = true;\r\n    }\r\n\r\n    var itemController = this.get('itemController');\r\n    var object = itemController.changeItemVisibility(item, true);\r\n\r\n    if (stack && this.get('enabledStack')) {\r\n      var id = object.getID();\r\n      var type = object.getType();\r\n      var before = {};\r\n      var after = {};\r\n\r\n      switch (type) {\r\n        case 'node':\r\n          before.nodes = [{\r\n            id: id,\r\n            visible: false\r\n          }];\r\n          after.nodes = [{\r\n            id: id,\r\n            visible: true\r\n          }];\r\n          break;\r\n\r\n        case 'edge':\r\n          before.nodes = [{\r\n            id: id,\r\n            visible: false\r\n          }];\r\n          after.edges = [{\r\n            id: id,\r\n            visible: true\r\n          }];\r\n          break;\r\n\r\n        case 'combo':\r\n          before.nodes = [{\r\n            id: id,\r\n            visible: false\r\n          }];\r\n          after.combos = [{\r\n            id: id,\r\n            visible: true\r\n          }];\r\n          break;\r\n\r\n        default:\r\n          break;\r\n      }\r\n\r\n      this.pushStack('visible', {\r\n        before: before,\r\n        after: after\r\n      });\r\n    }\r\n  };\r\n  /**\r\n   * 隐藏元素\r\n   * @param {Item} item 指定元素\r\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.hideItem = function (item, stack) {\r\n    if (stack === void 0) {\r\n      stack = true;\r\n    }\r\n\r\n    var itemController = this.get('itemController');\r\n    var object = itemController.changeItemVisibility(item, false);\r\n\r\n    if (stack && this.get('enabledStack')) {\r\n      var id = object.getID();\r\n      var type = object.getType();\r\n      var before = {};\r\n      var after = {};\r\n\r\n      switch (type) {\r\n        case 'node':\r\n          before.nodes = [{\r\n            id: id,\r\n            visible: true\r\n          }];\r\n          after.nodes = [{\r\n            id: id,\r\n            visible: false\r\n          }];\r\n          break;\r\n\r\n        case 'edge':\r\n          before.nodes = [{\r\n            id: id,\r\n            visible: true\r\n          }];\r\n          after.edges = [{\r\n            id: id,\r\n            visible: false\r\n          }];\r\n          break;\r\n\r\n        case 'combo':\r\n          before.nodes = [{\r\n            id: id,\r\n            visible: true\r\n          }];\r\n          after.combos = [{\r\n            id: id,\r\n            visible: false\r\n          }];\r\n          break;\r\n\r\n        default:\r\n          break;\r\n      }\r\n\r\n      this.pushStack('visible', {\r\n        before: before,\r\n        after: after\r\n      });\r\n    }\r\n  };\r\n  /**\r\n   * 刷新元素\r\n   * @param {string|object} item 元素id或元素实例\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.refreshItem = function (item) {\r\n    var itemController = this.get('itemController');\r\n    itemController.refreshItem(item);\r\n  };\r\n  /**\r\n   * 设置是否在更新/刷新后自动重绘\r\n   * @param {boolean} auto 自动重绘\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.setAutoPaint = function (auto) {\r\n    var self = this;\r\n    self.set('autoPaint', auto);\r\n    var canvas = self.get('canvas');\r\n    canvas.set('autoDraw', auto);\r\n  };\r\n  /**\r\n   * 删除元素\r\n   * @param {Item} item 元素id或元素实例\r\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.remove = function (item, stack) {\r\n    if (stack === void 0) {\r\n      stack = true;\r\n    }\r\n\r\n    this.removeItem(item, stack);\r\n  };\r\n  /**\r\n   * 删除元素\r\n   * @param {Item} item 元素id或元素实例\r\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.removeItem = function (item, stack) {\r\n    if (stack === void 0) {\r\n      stack = true;\r\n    }\r\n\r\n    var nodeItem = item;\r\n    if ((0, _util.isString)(item)) nodeItem = this.findById(item);\r\n\r\n    if (!nodeItem && (0, _util.isString)(item)) {\r\n      console.warn('The item to be removed does not exist!');\r\n    } else if (nodeItem) {\r\n      var type = '';\r\n      if (nodeItem.getType) type = nodeItem.getType(); // 将删除的元素入栈\r\n\r\n      if (stack && this.get('enabledStack')) {\r\n        var deletedModel = (0, _tslib.__assign)((0, _tslib.__assign)({}, nodeItem.getModel()), {\r\n          itemType: type\r\n        });\r\n        var before = {};\r\n\r\n        switch (type) {\r\n          case 'node':\r\n            {\r\n              before.nodes = [deletedModel];\r\n              before.edges = [];\r\n              var edges = nodeItem.getEdges();\r\n\r\n              for (var i = edges.length - 1; i >= 0; i--) {\r\n                before.edges.push((0, _tslib.__assign)((0, _tslib.__assign)({}, edges[i].getModel()), {\r\n                  itemType: 'edge'\r\n                }));\r\n              }\r\n\r\n              break;\r\n            }\r\n\r\n          case 'edge':\r\n            before.edges = [deletedModel];\r\n            break;\r\n\r\n          case 'combo':\r\n            before.combos = [deletedModel];\r\n            break;\r\n\r\n          default:\r\n            break;\r\n        }\r\n\r\n        this.pushStack('delete', {\r\n          before: before,\r\n          after: {}\r\n        });\r\n      }\r\n\r\n      if (type === 'node') {\r\n        var model = nodeItem.getModel(); // 如果删除的是节点，且该节点存在于某个 Combo 中，则需要先将 node 从 combo 中移除，否则删除节点后，操作 combo 会出错\r\n\r\n        if (model.comboId) {\r\n          this.updateComboTree(nodeItem);\r\n        }\r\n      }\r\n\r\n      var itemController = this.get('itemController');\r\n      itemController.removeItem(nodeItem);\r\n\r\n      if (type === 'combo') {\r\n        var newComboTrees = (0, _graphic.reconstructTree)(this.get('comboTrees'));\r\n        this.set('comboTrees', newComboTrees);\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * 新增元素\r\n   * @param {ITEM_TYPE} type 元素类型(node | edge)\r\n   * @param {ModelConfig} model 元素数据模型\r\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n   * @param {boolean} sortCombo 本次操作是否需要更新 combo 层级顺序，内部参数，用户在外部使用 addItem 时始终时需要更新\r\n   * @return {Item} 元素实例\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.addItem = function (type, model, stack, sortCombo) {\r\n    if (stack === void 0) {\r\n      stack = true;\r\n    }\r\n\r\n    if (sortCombo === void 0) {\r\n      sortCombo = true;\r\n    }\r\n\r\n    var currentComboSorted = this.get('comboSorted');\r\n    this.set('comboSorted', currentComboSorted && !sortCombo);\r\n    var itemController = this.get('itemController'); // 添加节点、边或combo之前，先验证数据是否符合规范\r\n\r\n    if (!(0, _validation.singleDataValidation)(type, model)) {\r\n      return false;\r\n    }\r\n\r\n    if (model.id && this.findById(model.id)) {\r\n      console.warn(\"This item exists already. Be sure the id %c\" + model.id + \"%c is unique.\", 'font-size: 20px; color: red;', '');\r\n      return;\r\n    }\r\n\r\n    var item;\r\n    var comboTrees = this.get('comboTrees');\r\n    if (!comboTrees) comboTrees = [];\r\n\r\n    if (type === 'combo') {\r\n      var itemMap_1 = this.get('itemMap');\r\n      var foundParent_1 = false;\r\n      comboTrees.forEach(function (ctree) {\r\n        if (foundParent_1) return; // terminate the forEach after the tree containing the item is done\r\n\r\n        (0, _graphic.traverseTreeUp)(ctree, function (child) {\r\n          // find the parent\r\n          if (model.parentId === child.id) {\r\n            foundParent_1 = true;\r\n            var newCombo = (0, _tslib.__assign)({\r\n              id: model.id,\r\n              depth: child.depth + 2\r\n            }, model);\r\n            if (child.children) child.children.push(newCombo);else child.children = [newCombo];\r\n            model.depth = newCombo.depth;\r\n            item = itemController.addItem(type, model);\r\n          }\r\n\r\n          var childItem = itemMap_1[child.id]; // after the parent is found, update all the ancestors\r\n\r\n          if (foundParent_1 && childItem && childItem.getType && childItem.getType() === 'combo') {\r\n            itemController.updateCombo(childItem, child.children);\r\n          }\r\n\r\n          return true;\r\n        });\r\n      }); // if the parent is not found, add it to the root\r\n\r\n      if (!foundParent_1) {\r\n        var newCombo = (0, _tslib.__assign)({\r\n          id: model.id,\r\n          depth: 0\r\n        }, model);\r\n        model.depth = newCombo.depth;\r\n        comboTrees.push(newCombo);\r\n        item = itemController.addItem(type, model);\r\n      }\r\n\r\n      this.set('comboTrees', comboTrees);\r\n    } else if (type === 'node' && (0, _util.isString)(model.comboId) && comboTrees) {\r\n      var parentCombo = this.findById(model.comboId);\r\n\r\n      if (parentCombo && parentCombo.getType && parentCombo.getType() !== 'combo') {\r\n        console.warn(\"'\" + model.comboId + \"' is not a id of a combo in the graph, the node will be added without combo.\");\r\n      }\r\n\r\n      item = itemController.addItem(type, model);\r\n      var itemMap_2 = this.get('itemMap');\r\n      var foundParent_2 = false,\r\n          foundNode_1 = false;\r\n      (comboTrees || []).forEach(function (ctree) {\r\n        if (foundNode_1 || foundParent_2) return; // terminate the forEach\r\n\r\n        (0, _graphic.traverseTreeUp)(ctree, function (child) {\r\n          if (child.id === model.id) {\r\n            // if the item exists in the tree already, terminate\r\n            foundNode_1 = true;\r\n            return false;\r\n          }\r\n\r\n          if (model.comboId === child.id && !foundNode_1) {\r\n            // found the parent, add the item to the children of its parent in the tree\r\n            foundParent_2 = true;\r\n            var cloneNode = (0, _util.clone)(model);\r\n            cloneNode.itemType = 'node';\r\n            if (child.children) child.children.push(cloneNode);else child.children = [cloneNode];\r\n            cloneNode.depth = child.depth + 1;\r\n          } // update the size of all the ancestors\r\n\r\n\r\n          if (foundParent_2 && itemMap_2[child.id].getType && itemMap_2[child.id].getType() === 'combo') {\r\n            itemController.updateCombo(itemMap_2[child.id], child.children);\r\n          }\r\n\r\n          return true;\r\n        });\r\n      });\r\n    } else {\r\n      item = itemController.addItem(type, model);\r\n    }\r\n\r\n    if (type === 'node' && model.comboId || type === 'combo' && model.parentId) {\r\n      // add the combo to the parent's children array\r\n      var parentCombo = this.findById(model.comboId || model.parentId);\r\n      if (parentCombo && parentCombo.getType && parentCombo.getType() === 'combo') parentCombo.addChild(item);\r\n    }\r\n\r\n    var combos = this.get('combos');\r\n\r\n    if (combos && combos.length > 0) {\r\n      this.sortCombos();\r\n    }\r\n\r\n    this.autoPaint();\r\n\r\n    if (stack && this.get('enabledStack')) {\r\n      var addedModel = (0, _tslib.__assign)((0, _tslib.__assign)({}, item.getModel()), {\r\n        itemType: type\r\n      });\r\n      var after = {};\r\n\r\n      switch (type) {\r\n        case 'node':\r\n          after.nodes = [addedModel];\r\n          break;\r\n\r\n        case 'edge':\r\n          after.edges = [addedModel];\r\n          break;\r\n\r\n        case 'combo':\r\n          after.combos = [addedModel];\r\n          break;\r\n\r\n        default:\r\n          break;\r\n      }\r\n\r\n      this.pushStack('add', {\r\n        before: {},\r\n        after: after\r\n      });\r\n    }\r\n\r\n    return item;\r\n  };\r\n  /**\r\n   * 新增元素\r\n   * @param {ITEM_TYPE} type 元素类型(node | edge)\r\n   * @param {ModelConfig} model 元素数据模型\r\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n   * @return {Item} 元素实例\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.add = function (type, model, stack, sortCombo) {\r\n    if (stack === void 0) {\r\n      stack = true;\r\n    }\r\n\r\n    if (sortCombo === void 0) {\r\n      sortCombo = true;\r\n    }\r\n\r\n    return this.addItem(type, model, stack, sortCombo);\r\n  };\r\n  /**\r\n   * 更新元素\r\n   * @param {Item} item 元素id或元素实例\r\n   * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.updateItem = function (item, cfg, stack) {\r\n    var _this = this;\r\n\r\n    if (stack === void 0) {\r\n      stack = true;\r\n    }\r\n\r\n    var itemController = this.get('itemController');\r\n    var currentItem;\r\n\r\n    if ((0, _util.isString)(item)) {\r\n      currentItem = this.findById(item);\r\n    } else {\r\n      currentItem = item;\r\n    }\r\n\r\n    var UnupdateModel = (0, _util.clone)(currentItem.getModel());\r\n    var type = '';\r\n    if (currentItem.getType) type = currentItem.getType();\r\n    var states = (0, _tslib.__spreadArray)([], currentItem.getStates());\r\n\r\n    if (type === 'combo') {\r\n      (0, _util.each)(states, function (state) {\r\n        return _this.setItemState(currentItem, state, false);\r\n      });\r\n    }\r\n\r\n    itemController.updateItem(currentItem, cfg);\r\n\r\n    if (type === 'combo') {\r\n      (0, _util.each)(states, function (state) {\r\n        return _this.setItemState(currentItem, state, true);\r\n      });\r\n    }\r\n\r\n    if (stack && this.get('enabledStack')) {\r\n      var before = {\r\n        nodes: [],\r\n        edges: [],\r\n        combos: []\r\n      };\r\n      var after = {\r\n        nodes: [],\r\n        edges: [],\r\n        combos: []\r\n      };\r\n      var afterModel = (0, _tslib.__assign)({\r\n        id: UnupdateModel.id\r\n      }, cfg);\r\n\r\n      switch (type) {\r\n        case 'node':\r\n          before.nodes.push(UnupdateModel);\r\n          after.nodes.push(afterModel);\r\n          break;\r\n\r\n        case 'edge':\r\n          before.edges.push(UnupdateModel);\r\n          after.edges.push(afterModel);\r\n          break;\r\n\r\n        case 'combo':\r\n          before.combos.push(UnupdateModel);\r\n          after.combos.push(afterModel);\r\n          break;\r\n\r\n        default:\r\n          break;\r\n      }\r\n\r\n      if (type === 'node') {\r\n        before.nodes.push(UnupdateModel);\r\n      }\r\n\r\n      this.pushStack('update', {\r\n        before: before,\r\n        after: after\r\n      });\r\n    }\r\n  };\r\n  /**\r\n   * 更新元素\r\n   * @param {Item} item 元素id或元素实例\r\n   * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\r\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.update = function (item, cfg, stack) {\r\n    if (stack === void 0) {\r\n      stack = true;\r\n    }\r\n\r\n    this.updateItem(item, cfg, stack);\r\n  };\r\n  /**\r\n   * 设置元素状态\r\n   * @param {Item} item 元素id或元素实例\r\n   * @param {string} state 状态名称\r\n   * @param {string | boolean} value 是否启用状态 或 状态值\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.setItemState = function (item, state, value) {\r\n    if ((0, _util.isString)(item)) {\r\n      item = this.findById(item);\r\n    }\r\n\r\n    var itemController = this.get('itemController');\r\n    itemController.setItemState(item, state, value);\r\n    var stateController = this.get('stateController');\r\n\r\n    if ((0, _util.isString)(value)) {\r\n      stateController.updateState(item, state + \":\" + value, true);\r\n    } else {\r\n      stateController.updateState(item, state, value);\r\n    }\r\n  };\r\n  /**\r\n   * 将指定状态的优先级提升为最高优先级\r\n   * @param {Item} item 元素id或元素实例\r\n   * @param state 状态名称\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.priorityState = function (item, state) {\r\n    var itemController = this.get('itemController');\r\n    itemController.priorityState(item, state);\r\n  };\r\n  /**\r\n   * 设置视图初始化数据\r\n   * @param {GraphData} data 初始化数据\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.data = function (data) {\r\n    (0, _validation.dataValidation)(data);\r\n    this.set('data', data);\r\n  };\r\n  /**\r\n   * 根据data接口的数据渲染视图\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.render = function () {\r\n    var self = this;\r\n    this.set('comboSorted', false);\r\n    var data = this.get('data');\r\n\r\n    if (this.get('enabledStack')) {\r\n      // render 之前清空 redo 和 undo 栈\r\n      this.clearStack();\r\n    }\r\n\r\n    if (!data) {\r\n      throw new Error('data must be defined first');\r\n    }\r\n\r\n    var _a = data.nodes,\r\n        nodes = _a === void 0 ? [] : _a,\r\n        _b = data.edges,\r\n        edges = _b === void 0 ? [] : _b,\r\n        _c = data.combos,\r\n        combos = _c === void 0 ? [] : _c;\r\n    this.clear(true);\r\n    this.emit('beforerender');\r\n    (0, _util.each)(nodes, function (node) {\r\n      self.add('node', node, false, false);\r\n    }); // process the data to tree structure\r\n\r\n    if (combos && combos.length !== 0) {\r\n      var comboTrees = (0, _graphic.plainCombosToTrees)(combos, nodes);\r\n      this.set('comboTrees', comboTrees); // add combos\r\n\r\n      self.addCombos(combos);\r\n    }\r\n\r\n    (0, _util.each)(edges, function (edge) {\r\n      self.add('edge', edge, false, false);\r\n    });\r\n    var animate = self.get('animate');\r\n\r\n    if (self.get('fitView') || self.get('fitCenter')) {\r\n      self.set('animate', false);\r\n    } // layout\r\n\r\n\r\n    var layoutController = self.get('layoutController');\r\n\r\n    if (layoutController) {\r\n      layoutController.layout(success);\r\n      if (this.destroyed) return;\r\n    } else {\r\n      if (self.get('fitView')) {\r\n        self.fitView();\r\n      }\r\n\r\n      if (self.get('fitCenter')) {\r\n        self.fitCenter();\r\n      }\r\n\r\n      self.emit('afterrender');\r\n      self.set('animate', animate);\r\n    } // 将在 onLayoutEnd 中被调用\r\n\r\n\r\n    function success() {\r\n      // fitView 与 fitCenter 共存时，fitView 优先，fitCenter 不再执行\r\n      if (self.get('fitView')) {\r\n        self.fitView();\r\n      } else if (self.get('fitCenter')) {\r\n        self.fitCenter();\r\n      }\r\n\r\n      self.autoPaint();\r\n      self.emit('afterrender');\r\n\r\n      if (self.get('fitView') || self.get('fitCenter')) {\r\n        self.set('animate', animate);\r\n      }\r\n    }\r\n\r\n    if (!this.get('groupByTypes')) {\r\n      if (combos && combos.length !== 0) {\r\n        this.sortCombos();\r\n      } else {\r\n        // 为提升性能，选择数量少的进行操作\r\n        if (data.nodes && data.edges && data.nodes.length < data.edges.length) {\r\n          var nodesArr = this.getNodes(); // 遍历节点实例，将所有节点提前。\r\n\r\n          nodesArr.forEach(function (node) {\r\n            node.toFront();\r\n          });\r\n        } else {\r\n          var edgesArr = this.getEdges(); // 遍历节点实例，将所有节点提前。\r\n\r\n          edgesArr.forEach(function (edge) {\r\n            edge.toBack();\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.get('enabledStack')) {\r\n      this.pushStack('render');\r\n    }\r\n  };\r\n  /**\r\n   * 接收数据进行渲染\r\n   * @Param {Object} data 初始化数据\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.read = function (data) {\r\n    this.data(data);\r\n    this.render();\r\n  }; // 比较item\r\n\r\n\r\n  AbstractGraph.prototype.diffItems = function (type, items, models) {\r\n    var self = this;\r\n    var item;\r\n    var itemMap = this.get('itemMap');\r\n    (0, _util.each)(models, function (model) {\r\n      item = itemMap[model.id];\r\n\r\n      if (item) {\r\n        if (self.get('animate') && type === NODE) {\r\n          var containerMatrix = item.getContainer().getMatrix();\r\n          if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n          item.set('originAttrs', {\r\n            x: containerMatrix[6],\r\n            y: containerMatrix[7]\r\n          });\r\n        }\r\n\r\n        self.updateItem(item, model, false);\r\n      } else {\r\n        item = self.addItem(type, model, false);\r\n      }\r\n\r\n      if (item) items[type + \"s\"].push(item);\r\n    });\r\n  };\r\n  /**\r\n   * 更改源数据，根据新数据重新渲染视图\r\n   * @param {GraphData | TreeGraphData} data 源数据\r\n   * @param {boolean} 是否入栈，默认为true\r\n   * @return {object} this\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.changeData = function (data, stack) {\r\n    if (stack === void 0) {\r\n      stack = true;\r\n    }\r\n\r\n    var self = this;\r\n\r\n    if (!(0, _validation.dataValidation)(data)) {\r\n      return this;\r\n    }\r\n\r\n    if (stack && this.get('enabledStack')) {\r\n      this.pushStack('changedata', {\r\n        before: self.save(),\r\n        after: data\r\n      });\r\n    }\r\n\r\n    this.set('comboSorted', false); // 删除 hulls\r\n\r\n    this.removeHulls(); // 更改数据源后，取消所有状态\r\n\r\n    this.getNodes().map(function (node) {\r\n      return self.clearItemStates(node);\r\n    });\r\n    this.getEdges().map(function (edge) {\r\n      return self.clearItemStates(edge);\r\n    });\r\n    var canvas = this.get('canvas');\r\n    var localRefresh = canvas.get('localRefresh');\r\n    canvas.set('localRefresh', false);\r\n\r\n    if (!self.get('data')) {\r\n      self.data(data);\r\n      self.render();\r\n    }\r\n\r\n    var itemMap = this.get('itemMap');\r\n    var items = {\r\n      nodes: [],\r\n      edges: []\r\n    };\r\n    var combosData = data.combos;\r\n\r\n    if (combosData) {\r\n      var comboTrees = (0, _graphic.plainCombosToTrees)(combosData, data.nodes);\r\n      this.set('comboTrees', comboTrees);\r\n    }\r\n\r\n    this.diffItems('node', items, data.nodes);\r\n    (0, _util.each)(itemMap, function (item, id) {\r\n      itemMap[id].getModel().depth = 0;\r\n      if (item.getType && item.getType() === 'edge') return;\r\n\r\n      if (item.getType && item.getType() === 'combo') {\r\n        delete itemMap[id];\r\n        item.destroy();\r\n      } else if (items.nodes.indexOf(item) < 0) {\r\n        delete itemMap[id];\r\n        self.remove(item, false);\r\n      }\r\n    }); // clear the destroyed combos here to avoid removing sub nodes before removing the parent combo\r\n\r\n    var comboItems = this.getCombos();\r\n    var combosLength = comboItems.length;\r\n\r\n    for (var i = combosLength - 1; i >= 0; i--) {\r\n      if (comboItems[i].destroyed) {\r\n        comboItems.splice(i, 1);\r\n      }\r\n    } // process the data to tree structure\r\n\r\n\r\n    if (combosData) {\r\n      // add combos\r\n      self.addCombos(combosData);\r\n\r\n      if (!this.get('groupByTypes')) {\r\n        this.sortCombos();\r\n      }\r\n    }\r\n\r\n    this.diffItems('edge', items, data.edges);\r\n    (0, _util.each)(itemMap, function (item, id) {\r\n      if (item.getType && (item.getType() === 'node' || item.getType() === 'combo')) return;\r\n\r\n      if (items.edges.indexOf(item) < 0) {\r\n        delete itemMap[id];\r\n        self.remove(item, false);\r\n      }\r\n    });\r\n    this.set({\r\n      nodes: items.nodes,\r\n      edges: items.edges\r\n    });\r\n    var layoutController = this.get('layoutController');\r\n\r\n    if (layoutController) {\r\n      layoutController.changeData();\r\n\r\n      if (self.get('animate') && !layoutController.getLayoutType()) {\r\n        // 如果没有指定布局\r\n        self.positionsAnimate();\r\n      } else {\r\n        self.autoPaint();\r\n      }\r\n    }\r\n\r\n    setTimeout(function () {\r\n      canvas.set('localRefresh', localRefresh);\r\n    }, 16);\r\n    return this;\r\n  };\r\n  /**\r\n   * 私有方法，在 render 和 changeData 的时候批量添加数据中所有平铺的 combos\r\n   * @param {ComboConfig[]} combos 平铺的 combos 数据\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.addCombos = function (combos) {\r\n    var self = this;\r\n    var comboTrees = self.get('comboTrees');\r\n    var itemController = this.get('itemController');\r\n    itemController.addCombos(comboTrees, combos);\r\n  };\r\n  /**\r\n   * 根据已经存在的节点或 combo 创建新的 combo\r\n   * @param combo combo ID 或 Combo 配置\r\n   * @param children 添加到 Combo 中的元素，包括节点和 combo\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.createCombo = function (combo, children) {\r\n    var _this = this;\r\n\r\n    this.set('comboSorted', false); // step 1: 创建新的 Combo\r\n\r\n    var comboId = '';\r\n    var comboConfig;\r\n    if (!combo) return;\r\n\r\n    if ((0, _util.isString)(combo)) {\r\n      comboId = combo;\r\n      comboConfig = {\r\n        id: combo\r\n      };\r\n    } else {\r\n      comboId = combo.id;\r\n\r\n      if (!comboId) {\r\n        console.warn('Create combo failed. Please assign a unique string id for the adding combo.');\r\n        return;\r\n      }\r\n\r\n      comboConfig = combo;\r\n    } // step2: 更新 children，根据类型添加 comboId 或 parentId\r\n\r\n\r\n    var trees = children.map(function (elementId) {\r\n      var item = _this.findById(elementId);\r\n\r\n      var model = item.getModel();\r\n      var type = '';\r\n      if (item.getType) type = item.getType();\r\n      var cItem = {\r\n        id: item.getID(),\r\n        itemType: type\r\n      };\r\n\r\n      if (type === 'combo') {\r\n        cItem.parentId = comboId;\r\n        model.parentId = comboId;\r\n      } else if (type === 'node') {\r\n        cItem.comboId = comboId;\r\n        model.comboId = comboId;\r\n      }\r\n\r\n      return cItem;\r\n    });\r\n    comboConfig.children = trees; // step 3: 添加 Combo，addItem 时会将子将元素添加到 Combo 中\r\n\r\n    this.addItem('combo', comboConfig, false);\r\n    this.set('comboSorted', false); // step4: 更新 comboTrees 结构\r\n\r\n    var comboTrees = this.get('comboTrees');\r\n    (comboTrees || []).forEach(function (ctree) {\r\n      (0, _graphic.traverseTreeUp)(ctree, function (child) {\r\n        if (child.id === comboId) {\r\n          child.itemType = 'combo';\r\n          child.children = trees;\r\n          return false;\r\n        }\r\n\r\n        return true;\r\n      });\r\n    });\r\n\r\n    if (comboTrees) {\r\n      this.sortCombos();\r\n    }\r\n  };\r\n  /**\r\n   * 解散 combo\r\n   * @param {String | INode | ICombo} combo 需要被解散的 Combo item 或 id\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.uncombo = function (combo) {\r\n    var _this = this;\r\n\r\n    var self = this;\r\n    var comboItem = combo;\r\n\r\n    if ((0, _util.isString)(combo)) {\r\n      comboItem = this.findById(combo);\r\n    }\r\n\r\n    if (!comboItem || comboItem.getType && comboItem.getType() !== 'combo') {\r\n      console.warn('The item is not a combo!');\r\n      return;\r\n    }\r\n\r\n    var parentId = comboItem.getModel().parentId;\r\n    var comboTrees = self.get('comboTrees');\r\n    if (!comboTrees) comboTrees = [];\r\n    var itemMap = this.get('itemMap');\r\n    var comboId = comboItem.get('id');\r\n    var treeToBeUncombo;\r\n    var brothers = [];\r\n    var comboItems = this.get('combos');\r\n    var parentItem = this.findById(parentId);\r\n    comboTrees.forEach(function (ctree) {\r\n      if (treeToBeUncombo) return; // terminate the forEach\r\n\r\n      (0, _graphic.traverseTreeUp)(ctree, function (subtree) {\r\n        // find the combo to be uncomboed, delete the combo from map and cache\r\n        if (subtree.id === comboId) {\r\n          treeToBeUncombo = subtree; // delete the related edges\r\n\r\n          var edges = comboItem.getEdges();\r\n          edges.forEach(function (edge) {\r\n            _this.removeItem(edge, false);\r\n          });\r\n          var index = comboItems.indexOf(combo);\r\n          comboItems.splice(index, 1);\r\n          delete itemMap[comboId];\r\n          comboItem.destroy();\r\n        } // find the parent to remove the combo from the combo's brothers array and add the combo's children to the combo's brothers array in the tree\r\n\r\n\r\n        if (parentId && treeToBeUncombo && subtree.id === parentId) {\r\n          parentItem.removeCombo(comboItem);\r\n          brothers = subtree.children; // the combo's brothers\r\n          // remove the combo from its brothers array\r\n\r\n          var index = brothers.indexOf(treeToBeUncombo);\r\n\r\n          if (index !== -1) {\r\n            brothers.splice(index, 1);\r\n          } // append the combo's children to the combo's brothers array\r\n\r\n\r\n          treeToBeUncombo.children.forEach(function (child) {\r\n            var item = _this.findById(child.id);\r\n\r\n            var childModel = item.getModel();\r\n\r\n            if (item.getType && item.getType() === 'combo') {\r\n              child.parentId = parentId;\r\n              delete child.comboId;\r\n              childModel.parentId = parentId; // update the parentId of the model\r\n\r\n              delete childModel.comboId;\r\n            } else if (item.getType && item.getType() === 'node') {\r\n              child.comboId = parentId;\r\n              childModel.comboId = parentId; // update the parentId of the model\r\n            }\r\n\r\n            parentItem.addChild(item);\r\n            brothers.push(child);\r\n          });\r\n          return false;\r\n        }\r\n\r\n        return true;\r\n      });\r\n    }); // if the parentId is not found, remove the combo from the roots\r\n\r\n    if (!parentId && treeToBeUncombo) {\r\n      var index = comboTrees.indexOf(treeToBeUncombo);\r\n      comboTrees.splice(index, 1); // modify the parentId of the children\r\n\r\n      treeToBeUncombo.children.forEach(function (child) {\r\n        child.parentId = undefined;\r\n\r\n        var childModel = _this.findById(child.id).getModel();\r\n\r\n        delete childModel.parentId; // update the parentId of the model\r\n\r\n        delete childModel.comboId; // update the comboId of the model\r\n\r\n        if (child.itemType !== 'node') comboTrees.push(child);\r\n      });\r\n    }\r\n  };\r\n  /**\r\n   * 根据节点的 bbox 更新所有 combos 的绘制，包括 combos 的位置和范围\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.updateCombos = function () {\r\n    var _this = this;\r\n\r\n    var self = this;\r\n    var comboTrees = this.get('comboTrees');\r\n    var itemController = self.get('itemController');\r\n    var itemMap = self.get('itemMap');\r\n    (comboTrees || []).forEach(function (ctree) {\r\n      (0, _graphic.traverseTreeUp)(ctree, function (child) {\r\n        if (!child) {\r\n          return true;\r\n        }\r\n\r\n        var childItem = itemMap[child.id];\r\n\r\n        if (childItem && childItem.getType && childItem.getType() === 'combo') {\r\n          // 更新具体的 Combo 之前先清除所有的已有状态，以免将 state 中的样式更新为 Combo 的样式\r\n          var states = (0, _tslib.__spreadArray)([], childItem.getStates());\r\n          (0, _util.each)(states, function (state) {\r\n            return _this.setItemState(childItem, state, false);\r\n          }); // 更新具体的 Combo\r\n\r\n          itemController.updateCombo(childItem, child.children); // 更新 Combo 后，还原已有的状态\r\n\r\n          (0, _util.each)(states, function (state) {\r\n            return _this.setItemState(childItem, state, true);\r\n          });\r\n        }\r\n\r\n        return true;\r\n      });\r\n    });\r\n    self.sortCombos();\r\n  };\r\n  /**\r\n   * 根据节点的 bbox 更新 combo 及其祖先 combos 的绘制，包括 combos 的位置和范围\r\n   * @param {String | ICombo} combo 需要被更新的 Combo 或 id，若指定，则该 Combo 及所有祖先 Combod 都会被更新\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.updateCombo = function (combo) {\r\n    var _this = this;\r\n\r\n    var self = this;\r\n    var comboItem = combo;\r\n    var comboId;\r\n\r\n    if ((0, _util.isString)(combo)) {\r\n      comboItem = this.findById(combo);\r\n    }\r\n\r\n    if (!comboItem || comboItem.getType && comboItem.getType() !== 'combo') {\r\n      console.warn('The item to be updated is not a combo!');\r\n      return;\r\n    }\r\n\r\n    comboId = comboItem.get('id');\r\n    var comboTrees = this.get('comboTrees');\r\n    var itemController = self.get('itemController');\r\n    var itemMap = self.get('itemMap');\r\n    (comboTrees || []).forEach(function (ctree) {\r\n      (0, _graphic.traverseTreeUp)(ctree, function (child) {\r\n        if (!child) {\r\n          return true;\r\n        }\r\n\r\n        var childItem = itemMap[child.id];\r\n\r\n        if (comboId === child.id && childItem && childItem.getType && childItem.getType() === 'combo') {\r\n          // 更新具体的 Combo 之前先清除所有的已有状态，以免将 state 中的样式更新为 Combo 的样式\r\n          var states = (0, _tslib.__spreadArray)([], childItem.getStates()); // || !item.getStateStyle(stateName)\r\n\r\n          (0, _util.each)(states, function (state) {\r\n            if (childItem.getStateStyle(state)) {\r\n              _this.setItemState(childItem, state, false);\r\n            }\r\n          }); // 更新具体的 Combo\r\n\r\n          itemController.updateCombo(childItem, child.children); // 更新 Combo 后，还原已有的状态\r\n\r\n          (0, _util.each)(states, function (state) {\r\n            if (childItem.getStateStyle(state)) {\r\n              _this.setItemState(childItem, state, true);\r\n            }\r\n          });\r\n          if (comboId) comboId = child.parentId;\r\n        }\r\n\r\n        return true;\r\n      });\r\n    });\r\n  };\r\n  /**\r\n   * 更新树结构，例如移动子树等\r\n   * @param {String | INode | ICombo} item 需要被更新的 Combo 或 节点 id\r\n   * @param {string | undefined} parentId 新的父 combo id，undefined 代表没有父 combo\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.updateComboTree = function (item, parentId, stack) {\r\n    if (stack === void 0) {\r\n      stack = true;\r\n    }\r\n\r\n    var self = this;\r\n    this.set('comboSorted', false);\r\n    var uItem;\r\n\r\n    if ((0, _util.isString)(item)) {\r\n      uItem = self.findById(item);\r\n    } else {\r\n      uItem = item;\r\n    }\r\n\r\n    var model = uItem.getModel();\r\n    var oldParentId = model.comboId || model.parentId;\r\n    var type = '';\r\n    if (uItem.getType) type = uItem.getType(); // 若 item 是 Combo，且 parentId 是其子孙 combo 的 id，则警告并终止\r\n\r\n    if (parentId && type === 'combo') {\r\n      var comboTrees = this.get('comboTrees');\r\n      var valid_1 = true;\r\n      var itemSubTree_1;\r\n      (comboTrees || []).forEach(function (ctree) {\r\n        if (itemSubTree_1) return;\r\n        (0, _graphic.traverseTree)(ctree, function (subTree) {\r\n          if (itemSubTree_1) return; // 找到从 item 开始的子树\r\n\r\n          if (subTree.id === uItem.getID()) {\r\n            itemSubTree_1 = subTree;\r\n          }\r\n\r\n          return true;\r\n        });\r\n      }); // 在以 item 为根的子树中寻找与 parentId 相同的后继元素\r\n\r\n      (0, _graphic.traverseTree)(itemSubTree_1, function (subTree) {\r\n        if (subTree.id === parentId) {\r\n          valid_1 = false;\r\n          return false;\r\n        }\r\n\r\n        return true;\r\n      }); // parentId 是 item 的一个后继元素，不能进行更新\r\n\r\n      if (!valid_1) {\r\n        console.warn('Failed to update the combo tree! The parentId points to a descendant of the combo!');\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (stack && this.get('enabledStack')) {\r\n      var beforeData = {},\r\n          afterData = {};\r\n\r\n      if (type === 'combo') {\r\n        beforeData.combos = [{\r\n          id: model.id,\r\n          parentId: model.parentId\r\n        }];\r\n        afterData.combos = [{\r\n          id: model.id,\r\n          parentId: parentId\r\n        }];\r\n      } else if (type === 'node') {\r\n        beforeData.nodes = [{\r\n          id: model.id,\r\n          parentId: model.comboId\r\n        }];\r\n        afterData.nodes = [{\r\n          id: model.id,\r\n          parentId: parentId\r\n        }];\r\n      }\r\n\r\n      this.pushStack('updateComboTree', {\r\n        before: beforeData,\r\n        after: afterData\r\n      });\r\n    } // 当 combo 存在 parentId 或 comboId 时，才将其移除\r\n\r\n\r\n    if (model.parentId || model.comboId) {\r\n      var combo = this.findById(model.parentId || model.comboId);\r\n\r\n      if (combo) {\r\n        combo.removeChild(uItem);\r\n      }\r\n    }\r\n\r\n    if (type === 'combo') {\r\n      model.parentId = parentId;\r\n    } else if (type === 'node') {\r\n      model.comboId = parentId;\r\n    } // 只有当移入到指定 combo 时才添加\r\n\r\n\r\n    if (parentId) {\r\n      var parentCombo = this.findById(parentId);\r\n\r\n      if (parentCombo) {\r\n        // 将元素添加到 parentCombo 中\r\n        parentCombo.addChild(uItem);\r\n      }\r\n    } // 如果原先有父亲 combo，则从原父 combo 的子元素数组中删除\r\n\r\n\r\n    if (oldParentId) {\r\n      var parentCombo = this.findById(oldParentId);\r\n\r\n      if (parentCombo) {\r\n        // 将元素从 parentCombo 中移除\r\n        parentCombo.removeChild(uItem);\r\n      }\r\n    }\r\n\r\n    var newComboTrees = (0, _graphic.reconstructTree)(this.get('comboTrees'), model.id, parentId);\r\n    this.set('comboTrees', newComboTrees);\r\n    this.updateCombos();\r\n  };\r\n  /**\r\n   * 导出图数据\r\n   * @return {object} data\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.save = function () {\r\n    var nodes = [];\r\n    var edges = [];\r\n    var combos = [];\r\n    (0, _util.each)(this.get('nodes'), function (node) {\r\n      nodes.push(node.getModel());\r\n    });\r\n    (0, _util.each)(this.get('edges'), function (edge) {\r\n      edges.push(edge.getModel());\r\n    });\r\n    (0, _util.each)(this.get('combos'), function (combo) {\r\n      combos.push(combo.getModel());\r\n    });\r\n    return {\r\n      nodes: nodes,\r\n      edges: edges,\r\n      combos: combos\r\n    };\r\n  };\r\n  /**\r\n   * 改变画布大小\r\n   * @param  {number} width  画布宽度\r\n   * @param  {number} height 画布高度\r\n   * @return {object} this\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.changeSize = function (width, height) {\r\n    var viewController = this.get('viewController');\r\n    viewController.changeSize(width, height);\r\n    return this;\r\n  };\r\n  /**\r\n   * 当源数据在外部发生变更时，根据新数据刷新视图。但是不刷新节点位置\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.refresh = function () {\r\n    var self = this;\r\n    self.emit('beforegraphrefresh');\r\n\r\n    if (self.get('animate')) {\r\n      self.positionsAnimate();\r\n    } else {\r\n      var nodes = self.get('nodes');\r\n      var edges = self.get('edges');\r\n      var vedges = self.get('edges');\r\n      (0, _util.each)(nodes, function (node) {\r\n        node.refresh();\r\n      });\r\n      (0, _util.each)(edges, function (edge) {\r\n        edge.refresh();\r\n      });\r\n      (0, _util.each)(vedges, function (vedge) {\r\n        vedge.refresh();\r\n      });\r\n    }\r\n\r\n    self.emit('aftergraphrefresh');\r\n    self.autoPaint();\r\n  };\r\n  /**\r\n   * 获取当前图中所有节点的item实例\r\n   * @return {INode} item数组\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getNodes = function () {\r\n    return this.get('nodes');\r\n  };\r\n  /**\r\n   * 获取当前图中所有边的item实例\r\n   * @return {IEdge} item数组\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getEdges = function () {\r\n    return this.get('edges');\r\n  };\r\n  /**\r\n   * 获取图中所有的 combo 实例\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getCombos = function () {\r\n    return this.get('combos');\r\n  };\r\n  /**\r\n   * 获取指定 Combo 中所有的节点\r\n   * @param comboId combo ID\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getComboChildren = function (combo) {\r\n    if ((0, _util.isString)(combo)) {\r\n      combo = this.findById(combo);\r\n    }\r\n\r\n    if (!combo || combo.getType && combo.getType() !== 'combo') {\r\n      console.warn('The combo does not exist!');\r\n      return;\r\n    }\r\n\r\n    return combo.getChildren();\r\n  };\r\n  /**\r\n   * 根据 graph 上的 animateCfg 进行视图中节点位置动画接口\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.positionsAnimate = function () {\r\n    var self = this;\r\n    self.emit('beforeanimate');\r\n    var animateCfg = self.get('animateCfg');\r\n    var onFrame = animateCfg.onFrame;\r\n    var nodes = self.getNodes();\r\n    var toNodes = nodes.map(function (node) {\r\n      var model = node.getModel();\r\n      return {\r\n        id: model.id,\r\n        x: model.x,\r\n        y: model.y\r\n      };\r\n    });\r\n\r\n    if (self.isAnimating()) {\r\n      self.stopAnimate();\r\n    }\r\n\r\n    var canvas = self.get('canvas');\r\n    canvas.animate(function (ratio) {\r\n      (0, _util.each)(toNodes, function (data) {\r\n        var node = self.findById(data.id);\r\n\r\n        if (!node || node.destroyed) {\r\n          return;\r\n        }\r\n\r\n        var originAttrs = node.get('originAttrs');\r\n        var model = node.get('model');\r\n\r\n        if (!originAttrs) {\r\n          var containerMatrix = node.getContainer().getMatrix();\r\n          if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n          originAttrs = {\r\n            x: containerMatrix[6],\r\n            y: containerMatrix[7]\r\n          };\r\n          node.set('originAttrs', originAttrs);\r\n        }\r\n\r\n        if (onFrame) {\r\n          var attrs = onFrame(node, ratio, data, originAttrs);\r\n          node.set('model', Object.assign(model, attrs));\r\n        } else {\r\n          model.x = originAttrs.x + (data.x - originAttrs.x) * ratio;\r\n          model.y = originAttrs.y + (data.y - originAttrs.y) * ratio;\r\n        }\r\n      });\r\n      self.refreshPositions();\r\n    }, {\r\n      duration: animateCfg.duration,\r\n      easing: animateCfg.easing,\r\n      callback: function callback() {\r\n        (0, _util.each)(nodes, function (node) {\r\n          node.set('originAttrs', null);\r\n        });\r\n\r\n        if (animateCfg.callback) {\r\n          animateCfg.callback();\r\n        }\r\n\r\n        self.emit('afteranimate');\r\n        self.animating = false;\r\n      }\r\n    });\r\n  };\r\n  /**\r\n   * 当节点位置在外部发生改变时，刷新所有节点位置，重计算边\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.refreshPositions = function () {\r\n    var self = this;\r\n    self.emit('beforegraphrefreshposition');\r\n    var nodes = self.get('nodes');\r\n    var edges = self.get('edges');\r\n    var vedges = self.get('vedges');\r\n    var combos = self.get('combos');\r\n    var model;\r\n    var updatedNodes = {};\r\n    (0, _util.each)(nodes, function (node) {\r\n      model = node.getModel();\r\n      var originAttrs = node.get('originAttrs');\r\n\r\n      if (originAttrs && model.x === originAttrs.x && model.y === originAttrs.y) {\r\n        return;\r\n      }\r\n\r\n      var changed = node.updatePosition({\r\n        x: model.x,\r\n        y: model.y\r\n      });\r\n      updatedNodes[model.id] = changed;\r\n      if (model.comboId) updatedNodes[model.comboId] = updatedNodes[model.comboId] || changed;\r\n    });\r\n\r\n    if (combos && combos.length !== 0) {\r\n      self.updateCombos();\r\n    }\r\n\r\n    (0, _util.each)(edges, function (edge) {\r\n      var sourceModel = edge.getSource().getModel();\r\n      var target = edge.getTarget(); // 避免 target 是纯对象的情况下调用 getModel 方法\r\n      // 拖动生成边的时候 target 会是纯对象\r\n\r\n      if (!(0, _util.isPlainObject)(target)) {\r\n        var targetModel = target.getModel();\r\n\r\n        if (updatedNodes[sourceModel.id] || updatedNodes[targetModel.id] || edge.getModel().isComboEdge) {\r\n          edge.refresh();\r\n        }\r\n      }\r\n    });\r\n    (0, _util.each)(vedges, function (vedge) {\r\n      vedge.refresh();\r\n    });\r\n    self.emit('aftergraphrefreshposition');\r\n    self.autoPaint();\r\n  };\r\n\r\n  AbstractGraph.prototype.stopAnimate = function () {\r\n    this.get('canvas').stopAnimate();\r\n  };\r\n\r\n  AbstractGraph.prototype.isAnimating = function () {\r\n    return this.animating;\r\n  };\r\n  /**\r\n   * 获取当前视口伸缩比例\r\n   * @return {number} 比例\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getZoom = function () {\r\n    var matrix = this.get('group').getMatrix();\r\n    return matrix ? matrix[0] : 1;\r\n  };\r\n  /**\r\n   * 获取当前的行为模式\r\n   * @return {string} 当前行为模式\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getCurrentMode = function () {\r\n    var modeController = this.get('modeController');\r\n    return modeController.getMode();\r\n  };\r\n  /**\r\n   * 切换行为模式\r\n   * @param {string} mode 指定模式\r\n   * @return {object} this\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.setMode = function (mode) {\r\n    var modeController = this.get('modeController');\r\n    modeController.setMode(mode);\r\n    return this;\r\n  };\r\n  /**\r\n   * 清除画布元素\r\n   * @return {object} this\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.clear = function (avoidEmit) {\r\n    if (avoidEmit === void 0) {\r\n      avoidEmit = false;\r\n    }\r\n\r\n    var canvas = this.get('canvas');\r\n    canvas.clear();\r\n    this.initGroups(); // 清空画布时同时清除数据\r\n\r\n    this.set({\r\n      itemMap: {},\r\n      nodes: [],\r\n      edges: [],\r\n      groups: [],\r\n      combos: [],\r\n      comboTrees: []\r\n    });\r\n    if (!avoidEmit) this.emit('afterrender');\r\n    return this;\r\n  };\r\n  /**\r\n   * 更换布局配置项\r\n   * @param {object} cfg 新布局配置项\r\n   * 若 cfg 含有 type 字段或为 String 类型，且与现有布局方法不同，则更换布局\r\n   * 若 cfg 不包括 type ，则保持原有布局方法，仅更新布局配置项\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.updateLayout = function (cfg) {\r\n    var layoutController = this.get('layoutController');\r\n\r\n    if ((0, _util.isString)(cfg)) {\r\n      cfg = {\r\n        type: cfg\r\n      };\r\n    }\r\n\r\n    var oriLayoutCfg = this.get('layout');\r\n    var layoutCfg = {};\r\n    Object.assign(layoutCfg, oriLayoutCfg, cfg);\r\n    this.set('layout', layoutCfg);\r\n\r\n    if (layoutController.isLayoutTypeSame(layoutCfg) && layoutCfg.gpuEnabled === oriLayoutCfg.gpuEnabled) {\r\n      // no type or same type, or switch the gpu and cpu, update layout\r\n      layoutController.updateLayoutCfg(layoutCfg);\r\n    } else {\r\n      // has different type, change layout\r\n      layoutController.changeLayout(layoutCfg);\r\n    }\r\n  };\r\n  /**\r\n   * 销毁布局，changeData 时不会再使用原来的布局方法对新数据进行布局\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.destroyLayout = function () {\r\n    var layoutController = this.get('layoutController');\r\n    layoutController.destroyLayout();\r\n  };\r\n  /**\r\n   * 重新以当前示例中配置的属性进行一次布局\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.layout = function () {\r\n    var layoutController = this.get('layoutController');\r\n    var layoutCfg = this.get('layout');\r\n    if (!layoutCfg || !layoutController) return;\r\n\r\n    if (layoutCfg.workerEnabled) {\r\n      // 如果使用web worker布局\r\n      layoutController.layout();\r\n      return;\r\n    }\r\n\r\n    if (layoutController.layoutMethod) {\r\n      layoutController.relayout(true);\r\n    } else {\r\n      layoutController.layout();\r\n    }\r\n  };\r\n  /**\r\n   * 收起指定的 combo\r\n   * @param {string | ICombo} combo combo ID 或 combo item\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.collapseCombo = function (combo) {\r\n    var _this = this;\r\n\r\n    if ((0, _util.isString)(combo)) {\r\n      combo = this.findById(combo);\r\n    }\r\n\r\n    if (!combo) {\r\n      console.warn('The combo to be collapsed does not exist!');\r\n      return;\r\n    }\r\n\r\n    this.emit('beforecollapseexpandcombo', {\r\n      action: 'expand',\r\n      item: combo\r\n    });\r\n    var comboModel = combo.getModel();\r\n    var itemController = this.get('itemController');\r\n    itemController.collapseCombo(combo);\r\n    comboModel.collapsed = true; // add virtual edges\r\n\r\n    var edges = this.getEdges().concat(this.get('vedges')); // find all the descendant nodes and combos\r\n\r\n    var cnodes = [];\r\n    var ccombos = [];\r\n    var comboTrees = this.get('comboTrees');\r\n    var found = false;\r\n    (comboTrees || []).forEach(function (ctree) {\r\n      if (found) return; // if the combo is found, terminate the forEach\r\n\r\n      (0, _graphic.traverseTree)(ctree, function (subTree) {\r\n        // if the combo is found and it is traversing the other branches, terminate\r\n        if (found && subTree.depth <= comboModel.depth) return false; // if the combo is found\r\n\r\n        if (comboModel.id === subTree.id) found = true;\r\n\r\n        if (found) {\r\n          // if the combo is found, concat the descendant nodes and combos\r\n          var item = _this.findById(subTree.id);\r\n\r\n          if (item && item.getType && item.getType() === 'combo') {\r\n            cnodes = cnodes.concat(item.getNodes());\r\n            ccombos = ccombos.concat(item.getCombos());\r\n          }\r\n        }\r\n\r\n        return true;\r\n      });\r\n    });\r\n    var edgeWeightMap = {};\r\n    var addedVEdges = [];\r\n    edges.forEach(function (edge) {\r\n      if (edge.isVisible() && !edge.getModel().isVEdge) return;\r\n      var source = edge.getSource();\r\n      var target = edge.getTarget();\r\n\r\n      if ((cnodes.includes(source) || ccombos.includes(source)) && !cnodes.includes(target) && !ccombos.includes(target) || source.getModel().id === comboModel.id) {\r\n        var edgeModel = edge.getModel();\r\n\r\n        if (edgeModel.isVEdge) {\r\n          _this.removeItem(edge, false);\r\n\r\n          return;\r\n        }\r\n\r\n        var targetModel = target.getModel();\r\n\r\n        while (!target.isVisible()) {\r\n          target = _this.findById(targetModel.parentId || targetModel.comboId);\r\n          if (!target || !targetModel.parentId && !targetModel.comboId) return; // all the ancestors are hidden, then ignore the edge\r\n\r\n          targetModel = target.getModel();\r\n        }\r\n\r\n        var targetId = targetModel.id;\r\n\r\n        if (edgeWeightMap[comboModel.id + \"-\" + targetId]) {\r\n          edgeWeightMap[comboModel.id + \"-\" + targetId] += edgeModel.size || 1;\r\n          return;\r\n        } // the source is in the combo, the target is not\r\n\r\n\r\n        var vedge = _this.addItem('vedge', {\r\n          source: comboModel.id,\r\n          target: targetId,\r\n          isVEdge: true\r\n        }, false);\r\n\r\n        edgeWeightMap[comboModel.id + \"-\" + targetId] = edgeModel.size || 1;\r\n        addedVEdges.push(vedge);\r\n      } else if (!cnodes.includes(source) && !ccombos.includes(source) && (cnodes.includes(target) || ccombos.includes(target)) || target.getModel().id === comboModel.id) {\r\n        var edgeModel = edge.getModel();\r\n\r\n        if (edgeModel.isVEdge) {\r\n          _this.removeItem(edge, false);\r\n\r\n          return;\r\n        }\r\n\r\n        var sourceModel = source.getModel();\r\n\r\n        while (!source.isVisible()) {\r\n          source = _this.findById(sourceModel.parentId || sourceModel.comboId);\r\n          if (!source || !sourceModel.parentId && !sourceModel.comboId) return; // all the ancestors are hidden, then ignore the edge\r\n\r\n          sourceModel = source.getModel();\r\n        }\r\n\r\n        var sourceId = sourceModel.id;\r\n\r\n        if (edgeWeightMap[sourceId + \"-\" + comboModel.id]) {\r\n          edgeWeightMap[sourceId + \"-\" + comboModel.id] += edgeModel.size || 1;\r\n          return;\r\n        } // the target is in the combo, the source is not\r\n\r\n\r\n        var vedge = _this.addItem('vedge', {\r\n          target: comboModel.id,\r\n          source: sourceId,\r\n          isVEdge: true\r\n        }, false);\r\n\r\n        edgeWeightMap[sourceId + \"-\" + comboModel.id] = edgeModel.size || 1;\r\n        addedVEdges.push(vedge);\r\n      }\r\n    }); // update the width of the virtual edges, which is the sum of merged actual edges\r\n    // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\r\n\r\n    addedVEdges.forEach(function (vedge) {\r\n      var vedgeModel = vedge.getModel();\r\n\r\n      _this.updateItem(vedge, {\r\n        size: edgeWeightMap[vedgeModel.source + \"-\" + vedgeModel.target]\r\n      }, false);\r\n    });\r\n    this.emit('aftercollapseexpandcombo', {\r\n      action: 'collapse',\r\n      item: combo\r\n    });\r\n  };\r\n  /**\r\n   * 展开指定的 combo\r\n   * @param {string | ICombo} combo combo ID 或 combo item\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.expandCombo = function (combo) {\r\n    var _this = this;\r\n\r\n    if ((0, _util.isString)(combo)) {\r\n      combo = this.findById(combo);\r\n    }\r\n\r\n    if (!combo || combo.getType && combo.getType() !== 'combo') {\r\n      console.warn('The combo to be collapsed does not exist!');\r\n      return;\r\n    }\r\n\r\n    this.emit('beforecollapseexpandcombo', {\r\n      action: 'expand',\r\n      item: combo\r\n    });\r\n    var comboModel = combo.getModel();\r\n    var itemController = this.get('itemController');\r\n    itemController.expandCombo(combo);\r\n    comboModel.collapsed = false; // add virtual edges\r\n\r\n    var edges = this.getEdges().concat(this.get('vedges')); // find all the descendant nodes and combos\r\n\r\n    var cnodes = [];\r\n    var ccombos = [];\r\n    var comboTrees = this.get('comboTrees');\r\n    var found = false;\r\n    (comboTrees || []).forEach(function (ctree) {\r\n      if (found) return; // if the combo is found, terminate\r\n\r\n      (0, _graphic.traverseTree)(ctree, function (subTree) {\r\n        // if the combo is found and it is traversing the other branches, terminate\r\n        if (found && subTree.depth <= comboModel.depth) return false;\r\n        if (comboModel.id === subTree.id) found = true;\r\n\r\n        if (found) {\r\n          var item = _this.findById(subTree.id);\r\n\r\n          if (item && item.getType && item.getType() === 'combo') {\r\n            cnodes = cnodes.concat(item.getNodes());\r\n            ccombos = ccombos.concat(item.getCombos());\r\n          }\r\n        }\r\n\r\n        return true;\r\n      });\r\n    });\r\n    var edgeWeightMap = {};\r\n    var addedVEdges = {};\r\n    edges.forEach(function (edge) {\r\n      if (edge.isVisible() && !edge.getModel().isVEdge) return;\r\n      var source = edge.getSource();\r\n      var target = edge.getTarget();\r\n      var sourceId = source.get('id');\r\n      var targetId = target.get('id');\r\n\r\n      if ((cnodes.includes(source) || ccombos.includes(source)) && !cnodes.includes(target) && !ccombos.includes(target) || sourceId === comboModel.id) {\r\n        // the source is in the combo, the target is not\r\n        // ignore the virtual edges\r\n        if (edge.getModel().isVEdge) {\r\n          _this.removeItem(edge, false);\r\n\r\n          return;\r\n        }\r\n\r\n        var targetModel = target.getModel(); // find the nearest visible ancestor\r\n\r\n        while (!target.isVisible()) {\r\n          target = _this.findById(targetModel.comboId || targetModel.parentId);\r\n\r\n          if (!target || !targetModel.parentId && !targetModel.comboId) {\r\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\r\n          }\r\n\r\n          targetModel = target.getModel();\r\n        }\r\n\r\n        targetId = targetModel.id;\r\n        var sourceModel = source.getModel(); // find the nearest visible ancestor\r\n\r\n        while (!source.isVisible()) {\r\n          source = _this.findById(sourceModel.comboId || sourceModel.parentId);\r\n\r\n          if (!source || !sourceModel.parentId && !sourceModel.comboId) {\r\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\r\n          }\r\n\r\n          if (sourceModel.comboId === comboModel.id || sourceModel.parentId === comboModel.id) {\r\n            break; // if the next ancestor is the combo, break the while\r\n          }\r\n\r\n          sourceModel = source.getModel();\r\n        }\r\n\r\n        sourceId = sourceModel.id;\r\n\r\n        if (targetId) {\r\n          var vedgeId = sourceId + \"-\" + targetId; // update the width of the virtual edges, which is the sum of merged actual edges\r\n          // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\r\n\r\n          if (edgeWeightMap[vedgeId]) {\r\n            edgeWeightMap[vedgeId] += edge.getModel().size || 1;\r\n\r\n            _this.updateItem(addedVEdges[vedgeId], {\r\n              size: edgeWeightMap[vedgeId]\r\n            }, false);\r\n\r\n            return;\r\n          }\r\n\r\n          var vedge = _this.addItem('vedge', {\r\n            source: sourceId,\r\n            target: targetId,\r\n            isVEdge: true\r\n          }, false);\r\n\r\n          edgeWeightMap[vedgeId] = edge.getModel().size || 1;\r\n          addedVEdges[vedgeId] = vedge;\r\n        }\r\n      } else if (!cnodes.includes(source) && !ccombos.includes(source) && (cnodes.includes(target) || ccombos.includes(target)) || targetId === comboModel.id) {\r\n        // the target is in the combo, the source is not\r\n        // ignore the virtual edges\r\n        if (edge.getModel().isVEdge) {\r\n          _this.removeItem(edge, false);\r\n\r\n          return;\r\n        }\r\n\r\n        var sourceModel = source.getModel(); // find the nearest visible ancestor\r\n\r\n        while (!source.isVisible()) {\r\n          source = _this.findById(sourceModel.comboId || sourceModel.parentId);\r\n\r\n          if (!source || !sourceModel.parentId && !sourceModel.comboId) {\r\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\r\n          }\r\n\r\n          sourceModel = source.getModel();\r\n        }\r\n\r\n        sourceId = sourceModel.id;\r\n        var targetModel = target.getModel(); // find the nearest visible ancestor\r\n\r\n        while (!target.isVisible()) {\r\n          target = _this.findById(targetModel.comboId || targetModel.parentId);\r\n\r\n          if (!target || !targetModel.parentId && !targetModel.comboId) {\r\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\r\n          }\r\n\r\n          if (targetModel.comboId === comboModel.id || targetModel.parentId === comboModel.id) {\r\n            break; // if the next ancestor is the combo, break the while\r\n          }\r\n\r\n          targetModel = target.getModel();\r\n        }\r\n\r\n        targetId = targetModel.id;\r\n\r\n        if (sourceId) {\r\n          var vedgeId = sourceId + \"-\" + targetId; // update the width of the virtual edges, which is the sum of merged actual edges\r\n          // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\r\n\r\n          if (edgeWeightMap[vedgeId]) {\r\n            edgeWeightMap[vedgeId] += edge.getModel().size || 1;\r\n\r\n            _this.updateItem(addedVEdges[vedgeId], {\r\n              size: edgeWeightMap[vedgeId]\r\n            }, false);\r\n\r\n            return;\r\n          }\r\n\r\n          var vedge = _this.addItem('vedge', {\r\n            target: targetId,\r\n            source: sourceId,\r\n            isVEdge: true\r\n          }, false);\r\n\r\n          edgeWeightMap[vedgeId] = edge.getModel().size || 1;\r\n          addedVEdges[vedgeId] = vedge;\r\n        }\r\n      } else if ((cnodes.includes(source) || ccombos.includes(source)) && (cnodes.includes(target) || ccombos.includes(target))) {\r\n        // both source and target are in the combo, if the target and source are both visible, show the edge\r\n        if (source.isVisible() && target.isVisible()) {\r\n          edge.show();\r\n        }\r\n      }\r\n    });\r\n    this.emit('aftercollapseexpandcombo', {\r\n      action: 'expand',\r\n      item: combo\r\n    });\r\n  };\r\n\r\n  AbstractGraph.prototype.collapseExpandCombo = function (combo) {\r\n    if ((0, _util.isString)(combo)) {\r\n      combo = this.findById(combo);\r\n    }\r\n\r\n    if (!combo || combo.getType && combo.getType() !== 'combo') return;\r\n    var comboModel = combo.getModel(); // if one ancestor combo of the combo is collapsed, it should not be collapsed or expanded\r\n\r\n    var parentItem = this.findById(comboModel.parentId);\r\n\r\n    while (parentItem) {\r\n      var parentModel = parentItem.getModel();\r\n\r\n      if (parentModel.collapsed) {\r\n        console.warn(\"Fail to expand the combo since it's ancestor combo is collapsed.\");\r\n        parentItem = undefined;\r\n        return;\r\n      }\r\n\r\n      parentItem = this.findById(parentModel.parentId);\r\n    }\r\n\r\n    var collapsed = comboModel.collapsed; // 该群组已经处于收起状态，需要展开\r\n\r\n    if (collapsed) {\r\n      this.expandCombo(combo);\r\n    } else {\r\n      this.collapseCombo(combo);\r\n    }\r\n\r\n    this.updateCombo(combo);\r\n  };\r\n  /**\r\n   * 根据 comboTree 结构整理 Combo 相关的图形绘制层级，包括 Combo 本身、节点、边\r\n   * @param {GraphData} data 数据\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.sortCombos = function () {\r\n    var _this = this;\r\n\r\n    var comboSorted = this.get('comboSorted');\r\n    if (comboSorted) return;\r\n    this.set('comboSorted', true);\r\n    var depthMap = [];\r\n    var dataDepthMap = {};\r\n    var comboTrees = this.get('comboTrees');\r\n    (comboTrees || []).forEach(function (cTree) {\r\n      (0, _graphic.traverseTree)(cTree, function (child) {\r\n        if (depthMap[child.depth]) depthMap[child.depth].push(child.id);else depthMap[child.depth] = [child.id];\r\n        dataDepthMap[child.id] = child.depth;\r\n        return true;\r\n      });\r\n    });\r\n    var edges = this.getEdges().concat(this.get('vedges'));\r\n    (edges || []).forEach(function (edgeItem) {\r\n      var edge = edgeItem.getModel();\r\n      var sourceDepth = dataDepthMap[edge.source] || 0;\r\n      var targetDepth = dataDepthMap[edge.target] || 0;\r\n      var depth = Math.max(sourceDepth, targetDepth);\r\n      if (depthMap[depth]) depthMap[depth].push(edge.id);else depthMap[depth] = [edge.id];\r\n    });\r\n    depthMap.forEach(function (array) {\r\n      if (!array || !array.length) return;\r\n\r\n      for (var i = array.length - 1; i >= 0; i--) {\r\n        var item = _this.findById(array[i]);\r\n\r\n        if (item) item.toFront();\r\n      }\r\n    });\r\n  };\r\n  /**\r\n   * 获取节点所有的邻居节点\r\n   *\r\n   * @param {(string | INode)} node 节点 ID 或实例\r\n   * @returns {INode[]}\r\n   * @memberof IAbstractGraph\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getNeighbors = function (node, type) {\r\n    var item = node;\r\n\r\n    if ((0, _util.isString)(node)) {\r\n      item = this.findById(node);\r\n    }\r\n\r\n    return item.getNeighbors(type);\r\n  };\r\n  /**\r\n   * 获取 node 的度数\r\n   *\r\n   * @param {(string | INode)} node 节点 ID 或实例\r\n   * @param {('in' | 'out' | 'total' | 'all' | undefined)} 度数类型，in 入度，out 出度，total 总度数，all 返回三种类型度数的对象\r\n   * @returns {Number | Object} 该节点的度数\r\n   * @memberof IAbstractGraph\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getNodeDegree = function (node, type, refresh) {\r\n    if (type === void 0) {\r\n      type = undefined;\r\n    }\r\n\r\n    if (refresh === void 0) {\r\n      refresh = false;\r\n    }\r\n\r\n    var item = node;\r\n\r\n    if ((0, _util.isString)(node)) {\r\n      item = this.findById(node);\r\n    }\r\n\r\n    var degrees = this.get('degrees');\r\n\r\n    if (!degrees || refresh) {\r\n      degrees = (0, _algorithm.getDegree)(this.save());\r\n      this.set('degrees', degrees);\r\n    }\r\n\r\n    var nodeDegrees = degrees[item.getID()];\r\n    var res = 0; // 如果是通过 addItem 后面新增加的节点，此时它的所有度数都为 0\r\n\r\n    if (!nodeDegrees) {\r\n      return 0;\r\n    }\r\n\r\n    switch (type) {\r\n      case 'in':\r\n        res = nodeDegrees.inDegree;\r\n        break;\r\n\r\n      case 'out':\r\n        res = nodeDegrees.outDegree;\r\n        break;\r\n\r\n      case 'all':\r\n        res = nodeDegrees;\r\n        break;\r\n\r\n      default:\r\n        res = nodeDegrees.degree;\r\n        break;\r\n    }\r\n\r\n    return res;\r\n  };\r\n\r\n  AbstractGraph.prototype.getUndoStack = function () {\r\n    return this.undoStack;\r\n  };\r\n\r\n  AbstractGraph.prototype.getRedoStack = function () {\r\n    return this.redoStack;\r\n  };\r\n  /**\r\n   * 获取 undo 和 redo 栈的数据\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getStackData = function () {\r\n    if (!this.get('enabledStack')) {\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      undoStack: this.undoStack.toArray(),\r\n      redoStack: this.redoStack.toArray()\r\n    };\r\n  };\r\n  /**\r\n   * 清空 undo stack & redo stack\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.clearStack = function () {\r\n    if (this.get('enabledStack')) {\r\n      this.undoStack.clear();\r\n      this.redoStack.clear();\r\n    }\r\n  };\r\n  /**\r\n   * 将操作类型和操作数据入栈\r\n   * @param action 操作类型\r\n   * @param data 入栈的数据\r\n   * @param stackType 栈的类型\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.pushStack = function (action, data, stackType) {\r\n    if (action === void 0) {\r\n      action = 'update';\r\n    }\r\n\r\n    if (stackType === void 0) {\r\n      stackType = 'undo';\r\n    }\r\n\r\n    if (!this.get('enabledStack')) {\r\n      console.warn('请先启用 undo & redo 功能，在实例化 Graph 时候配置 enabledStack: true !');\r\n      return;\r\n    }\r\n\r\n    var stackData = data ? (0, _util.clone)(data) : {\r\n      before: {},\r\n      after: (0, _util.clone)(this.save())\r\n    };\r\n\r\n    if (stackType === 'redo') {\r\n      this.redoStack.push({\r\n        action: action,\r\n        data: stackData\r\n      });\r\n    } else {\r\n      this.undoStack.push({\r\n        action: action,\r\n        data: stackData\r\n      });\r\n    }\r\n\r\n    this.emit('stackchange', {\r\n      undoStack: this.undoStack,\r\n      redoStack: this.redoStack\r\n    });\r\n  };\r\n  /**\r\n   * 获取邻接矩阵\r\n   *\r\n   * @param {boolean} cache 是否使用缓存的\r\n   * @param {boolean} directed 是否是有向图，默认取 graph.directed\r\n   * @returns {Matrix} 邻接矩阵\r\n   * @memberof IAbstractGraph\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getAdjMatrix = function (cache, directed) {\r\n    if (cache === void 0) {\r\n      cache = true;\r\n    }\r\n\r\n    if (directed === undefined) directed = this.get('directed');\r\n    var currentAdjMatrix = this.get('adjMatrix');\r\n\r\n    if (!currentAdjMatrix || !cache) {\r\n      currentAdjMatrix = (0, _algorithm.getAdjMatrix)(this.save(), directed);\r\n      this.set('adjMatrix', currentAdjMatrix);\r\n    }\r\n\r\n    return currentAdjMatrix;\r\n  };\r\n  /**\r\n   * 获取最短路径矩阵\r\n   *\r\n   * @param {boolean} cache 是否使用缓存的\r\n   * @param {boolean} directed 是否是有向图，默认取 graph.directed\r\n   * @returns {Matrix} 最短路径矩阵\r\n   * @memberof IAbstractGraph\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getShortestPathMatrix = function (cache, directed) {\r\n    if (cache === void 0) {\r\n      cache = true;\r\n    }\r\n\r\n    if (directed === undefined) directed = this.get('directed');\r\n    var currentAdjMatrix = this.get('adjMatrix');\r\n    var currentShourtestPathMatrix = this.get('shortestPathMatrix');\r\n\r\n    if (!currentAdjMatrix || !cache) {\r\n      currentAdjMatrix = (0, _algorithm.getAdjMatrix)(this.save(), directed);\r\n      this.set('adjMatrix', currentAdjMatrix);\r\n    }\r\n\r\n    if (!currentShourtestPathMatrix || !cache) {\r\n      currentShourtestPathMatrix = (0, _algorithm.floydWarshall)(this.save(), directed);\r\n      this.set('shortestPathMatrix', currentShourtestPathMatrix);\r\n    }\r\n\r\n    return currentShourtestPathMatrix;\r\n  };\r\n  /**\r\n   * 重新定义监听函数，复写参数类型\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.on = function (eventName, callback, once) {\r\n    return _super.prototype.on.call(this, eventName, callback, once);\r\n  };\r\n  /**\r\n   * 销毁画布\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.destroy = function () {\r\n    this.clear(); // 清空栈数据\r\n\r\n    this.clearStack();\r\n    this.get('itemController').destroy();\r\n    this.get('modeController').destroy();\r\n    this.get('viewController').destroy();\r\n    this.get('stateController').destroy();\r\n    this.get('canvas').destroy();\r\n    this.cfg = null;\r\n    this.destroyed = true;\r\n    this.redoStack = null;\r\n    this.undoStack = null;\r\n  };\r\n  /**\r\n   * 创建凸包或凹包轮廓\r\n   * @param cfg HullCfg 轮廓配置项\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.createHull = function (cfg) {\r\n    if (!cfg.members || cfg.members.length < 1) {\r\n      console.warn('Create hull failed! The members is empty.');\r\n      return;\r\n    }\r\n\r\n    var parent = this.get('hullGroup');\r\n    var hullMap = this.get('hullMap');\r\n\r\n    if (!hullMap) {\r\n      hullMap = {};\r\n      this.set('hullMap', hullMap);\r\n    }\r\n\r\n    if (!parent || parent.get('destroyed')) {\r\n      parent = this.get('group').addGroup({\r\n        id: 'hullGroup'\r\n      });\r\n      parent.toBack();\r\n      this.set('hullGroup', parent);\r\n    }\r\n\r\n    if (hullMap[cfg.id]) {\r\n      console.warn('Existed hull id.');\r\n      return hullMap[cfg.id];\r\n    }\r\n\r\n    var group = parent.addGroup({\r\n      id: cfg.id + \"-container\"\r\n    });\r\n    var hull = new _hull.default(this, (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {\r\n      group: group\r\n    }));\r\n    var hullId = hull.id;\r\n    hullMap[hullId] = hull;\r\n    return hull;\r\n  };\r\n  /**\r\n   * 获取当前 graph 中存在的包裹轮廓\r\n   * @return {[key: string]: Hull} Hull 的 map，hullId 对应的 hull 实例\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getHulls = function () {\r\n    return this.get('hullMap');\r\n  };\r\n  /**\r\n   * 根据 hullId 获取对应的 hull\r\n   * @return Hull\r\n   */\r\n\r\n\r\n  AbstractGraph.prototype.getHullById = function (hullId) {\r\n    return this.get('hullMap')[hullId];\r\n  };\r\n\r\n  AbstractGraph.prototype.removeHull = function (hull) {\r\n    var hullInstance;\r\n\r\n    if ((0, _util.isString)(hull)) {\r\n      hullInstance = this.getHullById(hull);\r\n    } else {\r\n      hullInstance = hull;\r\n    }\r\n\r\n    var hullMap = this.get('hullMap');\r\n    delete hullMap[hullInstance.id];\r\n    hullInstance.destroy();\r\n  };\r\n\r\n  AbstractGraph.prototype.removeHulls = function () {\r\n    var hulls = this.getHulls();\r\n    if (!hulls || !Object.keys(hulls).length) return;\r\n    Object.keys(hulls).forEach(function (key) {\r\n      var hull = hulls[key];\r\n      hull.destroy();\r\n    });\r\n    this.set('hullMap', {});\r\n  };\r\n\r\n  return AbstractGraph;\r\n}(_eventEmitter.default);\r\n\r\nvar _default = AbstractGraph;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.pointLineDistance = exports.pointRectSquareDist = exports.isPointsOverlap = exports.pointLineSquareDist = exports.squareDist = exports.getPointsCenter = exports.fractionToLine = exports.itemIntersectByLine = exports.getBBoxBoundLine = exports.Line = exports.isPolygonsIntersect = exports.intersectBBox = exports.isPointInPolygon = exports.getDegree = exports.rotate = exports.scale = exports.move = exports.translate = exports.getAdjMatrix = exports.floydWarshall = exports.scaleMatrix = exports.distance = exports.getCircleCenterByPoints = exports.invertMatrix = exports.applyMatrix = exports.getEllipseIntersectByPoint = exports.getCircleIntersectByPoint = exports.getRectIntersectByPoint = exports.getLineIntersect = exports.compare = void 0;\r\n\r\nvar _matrixUtil = require(\"@antv/matrix-util\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar transform = _matrixUtil.ext.transform;\r\n/**\r\n * 对比对象，用于对象数组排序\r\n * @param   {string}       attributeName  排序依据的字段名称\r\n * @param   {number}       min    最小值\r\n * @param   {number}       max    最大值\r\n * @return  {boolean}      bool   布尔\r\n */\r\n\r\nvar compare = function compare(attributeName) {\r\n  return function (m, n) {\r\n    return m[attributeName] - n[attributeName];\r\n  };\r\n};\r\n/**\r\n * 是否在区间内\r\n * @param   {number}       value  值\r\n * @param   {number}       min    最小值\r\n * @param   {number}       max    最大值\r\n * @return  {boolean}      bool   布尔\r\n */\r\n\r\n\r\nexports.compare = compare;\r\n\r\nvar isBetween = function isBetween(value, min, max) {\r\n  return value >= min && value <= max;\r\n};\r\n/**\r\n * 获取两条线段的交点\r\n * @param  {Point}  p0 第一条线段起点\r\n * @param  {Point}  p1 第一条线段终点\r\n * @param  {Point}  p2 第二条线段起点\r\n * @param  {Point}  p3 第二条线段终点\r\n * @return {Point}  交点\r\n */\r\n\r\n\r\nvar getLineIntersect = function getLineIntersect(p0, p1, p2, p3) {\r\n  var tolerance = 0.0001;\r\n  var E = {\r\n    x: p2.x - p0.x,\r\n    y: p2.y - p0.y\r\n  };\r\n  var D0 = {\r\n    x: p1.x - p0.x,\r\n    y: p1.y - p0.y\r\n  };\r\n  var D1 = {\r\n    x: p3.x - p2.x,\r\n    y: p3.y - p2.y\r\n  };\r\n  var kross = D0.x * D1.y - D0.y * D1.x;\r\n  var sqrKross = kross * kross;\r\n  var invertKross = 1 / kross;\r\n  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;\r\n  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;\r\n\r\n  if (sqrKross > tolerance * sqrLen0 * sqrLen1) {\r\n    var s = (E.x * D1.y - E.y * D1.x) * invertKross;\r\n    var t = (E.x * D0.y - E.y * D0.x) * invertKross;\r\n    if (!isBetween(s, 0, 1) || !isBetween(t, 0, 1)) return null;\r\n    return {\r\n      x: p0.x + s * D0.x,\r\n      y: p0.y + s * D0.y\r\n    };\r\n  }\r\n\r\n  return null;\r\n};\r\n/**\r\n * point and rectangular intersection point\r\n * @param  {IRect} rect  rect\r\n * @param  {Point} point point\r\n * @return {PointPoint} rst;\r\n */\r\n\r\n\r\nexports.getLineIntersect = getLineIntersect;\r\n\r\nvar getRectIntersectByPoint = function getRectIntersectByPoint(rect, point) {\r\n  var x = rect.x,\r\n      y = rect.y,\r\n      width = rect.width,\r\n      height = rect.height;\r\n  var cx = x + width / 2;\r\n  var cy = y + height / 2;\r\n  var points = [];\r\n  var center = {\r\n    x: cx,\r\n    y: cy\r\n  };\r\n  points.push({\r\n    x: x,\r\n    y: y\r\n  });\r\n  points.push({\r\n    x: x + width,\r\n    y: y\r\n  });\r\n  points.push({\r\n    x: x + width,\r\n    y: y + height\r\n  });\r\n  points.push({\r\n    x: x,\r\n    y: y + height\r\n  });\r\n  points.push({\r\n    x: x,\r\n    y: y\r\n  });\r\n  var rst = null;\r\n\r\n  for (var i = 1; i < points.length; i++) {\r\n    rst = getLineIntersect(points[i - 1], points[i], center, point);\r\n\r\n    if (rst) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return rst;\r\n};\r\n/**\r\n * get point and circle inIntersect\r\n * @param {ICircle} circle 圆点，x,y,r\r\n * @param {Point} point 点 x,y\r\n * @return {Point} applied point\r\n */\r\n\r\n\r\nexports.getRectIntersectByPoint = getRectIntersectByPoint;\r\n\r\nvar getCircleIntersectByPoint = function getCircleIntersectByPoint(circle, point) {\r\n  var cx = circle.x,\r\n      cy = circle.y,\r\n      r = circle.r;\r\n  var x = point.x,\r\n      y = point.y;\r\n  var dx = x - cx;\r\n  var dy = y - cy;\r\n  var d = Math.sqrt(dx * dx + dy * dy);\r\n\r\n  if (d < r) {\r\n    return null;\r\n  }\r\n\r\n  var signX = Math.sign(dx);\r\n  var signY = Math.sign(dy);\r\n  var angle = Math.atan(dy / dx);\r\n  return {\r\n    x: cx + Math.abs(r * Math.cos(angle)) * signX,\r\n    y: cy + Math.abs(r * Math.sin(angle)) * signY\r\n  };\r\n};\r\n/**\r\n * get point and ellipse inIntersect\r\n * @param {Object} ellipse 椭圆 x,y,rx,ry\r\n * @param {Object} point 点 x,y\r\n * @return {object} applied point\r\n */\r\n\r\n\r\nexports.getCircleIntersectByPoint = getCircleIntersectByPoint;\r\n\r\nvar getEllipseIntersectByPoint = function getEllipseIntersectByPoint(ellipse, point) {\r\n  var a = ellipse.rx;\r\n  var b = ellipse.ry;\r\n  var cx = ellipse.x;\r\n  var cy = ellipse.y;\r\n  var dx = point.x - cx;\r\n  var dy = point.y - cy; // 直接通过 x,y 求夹角，求出来的范围是 -PI, PI\r\n\r\n  var angle = Math.atan2(dy / b, dx / a);\r\n\r\n  if (angle < 0) {\r\n    angle += 2 * Math.PI; // 转换到 0，2PI\r\n  }\r\n\r\n  return {\r\n    x: cx + a * Math.cos(angle),\r\n    y: cy + b * Math.sin(angle)\r\n  };\r\n};\r\n/**\r\n * coordinate matrix transformation\r\n * @param  {number} point   coordinate\r\n * @param  {Matrix} matrix  matrix\r\n * @param  {number} tag     could be 0 or 1\r\n * @return {Point} transformed point\r\n */\r\n\r\n\r\nexports.getEllipseIntersectByPoint = getEllipseIntersectByPoint;\r\n\r\nvar applyMatrix = function applyMatrix(point, matrix, tag) {\r\n  if (tag === void 0) {\r\n    tag = 1;\r\n  }\r\n\r\n  var vector = [point.x, point.y, tag];\r\n\r\n  if (!matrix || isNaN(matrix[0])) {\r\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n  }\r\n\r\n  _matrixUtil.vec3.transformMat3(vector, vector, matrix);\r\n\r\n  return {\r\n    x: vector[0],\r\n    y: vector[1]\r\n  };\r\n};\r\n/**\r\n * coordinate matrix invert transformation\r\n * @param  {number} point   coordinate\r\n * @param  {number} matrix  matrix\r\n * @param  {number} tag     could be 0 or 1\r\n * @return {object} transformed point\r\n */\r\n\r\n\r\nexports.applyMatrix = applyMatrix;\r\n\r\nvar invertMatrix = function invertMatrix(point, matrix, tag) {\r\n  if (tag === void 0) {\r\n    tag = 1;\r\n  }\r\n\r\n  if (!matrix || isNaN(matrix[0])) {\r\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n  }\r\n\r\n  var inversedMatrix = _matrixUtil.mat3.invert([1, 0, 0, 0, 1, 0, 0, 0, 1], matrix);\r\n\r\n  if (!inversedMatrix) {\r\n    inversedMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n  }\r\n\r\n  var vector = [point.x, point.y, tag];\r\n\r\n  _matrixUtil.vec3.transformMat3(vector, vector, inversedMatrix);\r\n\r\n  return {\r\n    x: vector[0],\r\n    y: vector[1]\r\n  };\r\n};\r\n/**\r\n *\r\n * @param p1 First coordinate\r\n * @param p2 second coordinate\r\n * @param p3 three coordinate\r\n */\r\n\r\n\r\nexports.invertMatrix = invertMatrix;\r\n\r\nvar getCircleCenterByPoints = function getCircleCenterByPoints(p1, p2, p3) {\r\n  var a = p1.x - p2.x;\r\n  var b = p1.y - p2.y;\r\n  var c = p1.x - p3.x;\r\n  var d = p1.y - p3.y;\r\n  var e = (p1.x * p1.x - p2.x * p2.x - p2.y * p2.y + p1.y * p1.y) / 2;\r\n  var f = (p1.x * p1.x - p3.x * p3.x - p3.y * p3.y + p1.y * p1.y) / 2;\r\n  var denominator = b * c - a * d;\r\n  return {\r\n    x: -(d * e - b * f) / denominator,\r\n    y: -(a * f - c * e) / denominator\r\n  };\r\n};\r\n/**\r\n * get distance by two points\r\n * @param p1 first point\r\n * @param p2 second point\r\n */\r\n\r\n\r\nexports.getCircleCenterByPoints = getCircleCenterByPoints;\r\n\r\nvar distance = function distance(p1, p2) {\r\n  var vx = p1.x - p2.x;\r\n  var vy = p1.y - p2.y;\r\n  return Math.sqrt(vx * vx + vy * vy);\r\n};\r\n/**\r\n * scale matrix\r\n * @param matrix [ [], [], [] ]\r\n * @param ratio\r\n */\r\n\r\n\r\nexports.distance = distance;\r\n\r\nvar scaleMatrix = function scaleMatrix(matrix, ratio) {\r\n  var result = [];\r\n  matrix.forEach(function (row) {\r\n    var newRow = [];\r\n    row.forEach(function (v) {\r\n      newRow.push(v * ratio);\r\n    });\r\n    result.push(newRow);\r\n  });\r\n  return result;\r\n};\r\n/**\r\n * Floyd Warshall algorithm for shortest path distances matrix\r\n * @param  {array} adjMatrix   adjacency matrix\r\n * @return {array} distances   shortest path distances matrix\r\n */\r\n\r\n\r\nexports.scaleMatrix = scaleMatrix;\r\n\r\nvar floydWarshall = function floydWarshall(adjMatrix) {\r\n  // initialize\r\n  var dist = [];\r\n  var size = adjMatrix.length;\r\n\r\n  for (var i = 0; i < size; i += 1) {\r\n    dist[i] = [];\r\n\r\n    for (var j = 0; j < size; j += 1) {\r\n      if (i === j) {\r\n        dist[i][j] = 0;\r\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\r\n        dist[i][j] = Infinity;\r\n      } else {\r\n        dist[i][j] = adjMatrix[i][j];\r\n      }\r\n    }\r\n  } // floyd\r\n\r\n\r\n  for (var k = 0; k < size; k += 1) {\r\n    for (var i = 0; i < size; i += 1) {\r\n      for (var j = 0; j < size; j += 1) {\r\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\r\n          dist[i][j] = dist[i][k] + dist[k][j];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return dist;\r\n};\r\n/**\r\n * get adjacency matrix\r\n * @param data graph data\r\n * @param directed whether it's a directed graph\r\n */\r\n\r\n\r\nexports.floydWarshall = floydWarshall;\r\n\r\nvar getAdjMatrix = function getAdjMatrix(data, directed) {\r\n  var nodes = data.nodes,\r\n      edges = data.edges;\r\n  var matrix = []; // map node with index in data.nodes\r\n\r\n  var nodeMap = {};\r\n\r\n  if (!nodes) {\r\n    throw new Error('invalid nodes data!');\r\n  }\r\n\r\n  if (nodes) {\r\n    nodes.forEach(function (node, i) {\r\n      nodeMap[node.id] = i;\r\n      var row = [];\r\n      matrix.push(row);\r\n    });\r\n  }\r\n\r\n  if (edges) {\r\n    edges.forEach(function (e) {\r\n      var source = e.source,\r\n          target = e.target;\r\n      var sIndex = nodeMap[source];\r\n      var tIndex = nodeMap[target];\r\n      matrix[sIndex][tIndex] = 1;\r\n\r\n      if (!directed) {\r\n        matrix[tIndex][sIndex] = 1;\r\n      }\r\n    });\r\n  }\r\n\r\n  return matrix;\r\n};\r\n/**\r\n * 平移group\r\n * @param group Group 实例\r\n * @param vec 移动向量\r\n */\r\n\r\n\r\nexports.getAdjMatrix = getAdjMatrix;\r\n\r\nvar translate = function translate(group, vec) {\r\n  group.translate(vec.x, vec.y);\r\n};\r\n/**\r\n * 移动到指定坐标点\r\n * @param group Group 实例\r\n * @param point 移动到的坐标点\r\n */\r\n\r\n\r\nexports.translate = translate;\r\n\r\nvar move = function move(group, point) {\r\n  var matrix = group.getMatrix();\r\n\r\n  if (!matrix) {\r\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n  }\r\n\r\n  var bbox = group.getCanvasBBox();\r\n  var vx = point.x - bbox.minX;\r\n  var vy = point.y - bbox.minY;\r\n  var movedMatrix = transform(matrix, [['t', vx, vy]]);\r\n  group.setMatrix(movedMatrix);\r\n};\r\n/**\r\n * 缩放 group\r\n * @param group Group 实例\r\n * @param point 在x 和 y 方向上的缩放比例\r\n */\r\n\r\n\r\nexports.move = move;\r\n\r\nvar scale = function scale(group, ratio) {\r\n  var matrix = group.getMatrix();\r\n\r\n  if (!matrix) {\r\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n  }\r\n\r\n  var scaleXY = ratio;\r\n\r\n  if (!(0, _util.isArray)(ratio)) {\r\n    scaleXY = [ratio, ratio];\r\n  }\r\n\r\n  if ((0, _util.isArray)(ratio) && ratio.length === 1) {\r\n    scaleXY = [ratio[0], ratio[0]];\r\n  }\r\n\r\n  matrix = transform(matrix, [['s', scaleXY[0], scaleXY[1]]]);\r\n  group.setMatrix(matrix);\r\n};\r\n/**\r\n *\r\n * @param group Group 实例\r\n * @param ratio 选择角度\r\n */\r\n\r\n\r\nexports.scale = scale;\r\n\r\nvar rotate = function rotate(group, angle) {\r\n  var matrix = group.getMatrix();\r\n\r\n  if (!matrix) {\r\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n  }\r\n\r\n  matrix = transform(matrix, [['r', angle]]);\r\n  group.setMatrix(matrix);\r\n};\r\n\r\nexports.rotate = rotate;\r\n\r\nvar getDegree = function getDegree(n, nodeIdxMap, edges) {\r\n  var degrees = [];\r\n\r\n  for (var i = 0; i < n; i++) {\r\n    degrees[i] = 0;\r\n  }\r\n\r\n  edges.forEach(function (e) {\r\n    if (e.source) {\r\n      degrees[nodeIdxMap[e.source]] += 1;\r\n    }\r\n\r\n    if (e.target) {\r\n      degrees[nodeIdxMap[e.target]] += 1;\r\n    }\r\n  });\r\n  return degrees;\r\n}; // 判断点Q是否在p1和p2的线段上\r\n\r\n\r\nexports.getDegree = getDegree;\r\n\r\nfunction onSegment(p1, p2, q) {\r\n  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n/**\r\n * 判断点P在多边形内-射线法. Borrow from https://github.com/antvis/util/blob/master/packages/path-util/src/point-in-polygon.ts\r\n * @param points\r\n * @param x\r\n * @param y\r\n */\r\n\r\n\r\nvar isPointInPolygon = function isPointInPolygon(points, x, y) {\r\n  var isHit = false;\r\n  var n = points.length; // 判断两个double在eps精度下的大小关系\r\n\r\n  var tolerance = 1e-6;\r\n\r\n  function dcmp(xValue) {\r\n    if (Math.abs(xValue) < tolerance) {\r\n      return 0;\r\n    }\r\n\r\n    return xValue < 0 ? -1 : 1;\r\n  }\r\n\r\n  if (n <= 2) {\r\n    // svg 中点小于 3 个时，不显示，也无法被拾取\r\n    return false;\r\n  }\r\n\r\n  for (var i = 0; i < n; i++) {\r\n    var p1 = points[i];\r\n    var p2 = points[(i + 1) % n];\r\n\r\n    if (onSegment(p1, p2, [x, y])) {\r\n      // 点在多边形一条边上\r\n      return true;\r\n    } // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\r\n    // 后一个判断被测点 在 射线与边交点 的左边\r\n\r\n\r\n    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {\r\n      isHit = !isHit;\r\n    }\r\n  }\r\n\r\n  return isHit;\r\n}; // 判断两个BBox是否相交\r\n\r\n\r\nexports.isPointInPolygon = isPointInPolygon;\r\n\r\nvar intersectBBox = function intersectBBox(box1, box2) {\r\n  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\r\n};\r\n\r\nexports.intersectBBox = intersectBBox;\r\n\r\nvar lineIntersectPolygon = function lineIntersectPolygon(lines, line) {\r\n  var isIntersect = false;\r\n  (0, _util.each)(lines, function (l) {\r\n    if (getLineIntersect(l.from, l.to, line.from, line.to)) {\r\n      isIntersect = true;\r\n      return false;\r\n    }\r\n  });\r\n  return isIntersect;\r\n};\r\n/**\r\n * 判断两个polygon是否相交。\r\n * borrow from @antv/path-util\r\n * @param points1 polygon1的顶点数组\r\n * @param points2 polygon2的顶点数组\r\n */\r\n\r\n\r\nvar isPolygonsIntersect = function isPolygonsIntersect(points1, points2) {\r\n  var getBBox = function getBBox(points) {\r\n    var xArr = points.map(function (p) {\r\n      return p[0];\r\n    });\r\n    var yArr = points.map(function (p) {\r\n      return p[1];\r\n    });\r\n    return {\r\n      minX: Math.min.apply(null, xArr),\r\n      maxX: Math.max.apply(null, xArr),\r\n      minY: Math.min.apply(null, yArr),\r\n      maxY: Math.max.apply(null, yArr)\r\n    };\r\n  };\r\n\r\n  var parseToLines = function parseToLines(points) {\r\n    var lines = [];\r\n    var count = points.length;\r\n\r\n    for (var i = 0; i < count - 1; i++) {\r\n      var point = points[i];\r\n      var next = points[i + 1];\r\n      lines.push({\r\n        from: {\r\n          x: point[0],\r\n          y: point[1]\r\n        },\r\n        to: {\r\n          x: next[0],\r\n          y: next[1]\r\n        }\r\n      });\r\n    }\r\n\r\n    if (lines.length > 1) {\r\n      var first = points[0];\r\n      var last = points[count - 1];\r\n      lines.push({\r\n        from: {\r\n          x: last[0],\r\n          y: last[1]\r\n        },\r\n        to: {\r\n          x: first[0],\r\n          y: first[1]\r\n        }\r\n      });\r\n    }\r\n\r\n    return lines;\r\n  }; // 空数组，或者一个点返回 false\r\n\r\n\r\n  if (points1.length < 2 || points2.length < 2) {\r\n    return false;\r\n  }\r\n\r\n  var bbox1 = getBBox(points1);\r\n  var bbox2 = getBBox(points2); // 判定包围盒是否相交，比判定点是否在多边形内要快的多，可以筛选掉大多数情况\r\n\r\n  if (!intersectBBox(bbox1, bbox2)) {\r\n    return false;\r\n  }\r\n\r\n  var isIn = false; // 判定点是否在多边形内部，一旦有一个点在另一个多边形内，则返回\r\n\r\n  (0, _util.each)(points2, function (point) {\r\n    if (isPointInPolygon(points1, point[0], point[1])) {\r\n      isIn = true;\r\n      return false;\r\n    }\r\n  });\r\n\r\n  if (isIn) {\r\n    return true;\r\n  }\r\n\r\n  (0, _util.each)(points1, function (point) {\r\n    if (isPointInPolygon(points2, point[0], point[1])) {\r\n      isIn = true;\r\n      return false;\r\n    }\r\n  });\r\n\r\n  if (isIn) {\r\n    return true;\r\n  }\r\n\r\n  var lines1 = parseToLines(points1);\r\n  var lines2 = parseToLines(points2);\r\n  var isIntersect = false;\r\n  (0, _util.each)(lines2, function (line) {\r\n    if (lineIntersectPolygon(lines1, line)) {\r\n      isIntersect = true;\r\n      return false;\r\n    }\r\n  });\r\n  return isIntersect;\r\n};\r\n\r\nexports.isPolygonsIntersect = isPolygonsIntersect;\r\n\r\nvar Line =\r\n/** @class */\r\nfunction () {\r\n  function Line(x1, y1, x2, y2) {\r\n    this.x1 = x1;\r\n    this.y1 = y1;\r\n    this.x2 = x2;\r\n    this.y2 = y2;\r\n  }\r\n\r\n  Line.prototype.getBBox = function () {\r\n    var minX = Math.min(this.x1, this.x2);\r\n    var minY = Math.min(this.y1, this.y2);\r\n    var maxX = Math.max(this.x1, this.x2);\r\n    var maxY = Math.max(this.y1, this.y2);\r\n    var res = {\r\n      x: minX,\r\n      y: minY,\r\n      minX: minX,\r\n      minY: minY,\r\n      maxX: maxX,\r\n      maxY: maxY,\r\n      width: maxX - minX,\r\n      height: maxY - minY\r\n    };\r\n    return res;\r\n  };\r\n\r\n  return Line;\r\n}();\r\n\r\nexports.Line = Line;\r\n\r\nvar getBBoxBoundLine = function getBBoxBoundLine(bbox, direction) {\r\n  var bounds = {\r\n    top: [bbox.minX, bbox.minY, bbox.maxX, bbox.minY],\r\n    left: [bbox.minX, bbox.minY, bbox.minX, bbox.maxY],\r\n    bottom: [bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY],\r\n    right: [bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY]\r\n  };\r\n  return bounds[direction];\r\n};\r\n/**\r\n * 计算两条线段相交时，相交点对第一条线段上的分割比例\r\n */\r\n\r\n\r\nexports.getBBoxBoundLine = getBBoxBoundLine;\r\n\r\nvar fractionAlongLineA = function fractionAlongLineA(la, lb) {\r\n  var uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);\r\n  var ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);\r\n  var uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);\r\n\r\n  if (uB) {\r\n    var ua = uaT / uB;\r\n    var ub = ubT / uB;\r\n\r\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\r\n      return ua;\r\n    }\r\n  }\r\n\r\n  return Number.POSITIVE_INFINITY;\r\n};\r\n\r\nvar itemIntersectByLine = function itemIntersectByLine(item, line) {\r\n  var directions = ['top', 'left', 'bottom', 'right'];\r\n  var bbox = item.getBBox();\r\n  var countIntersections = 0;\r\n  var intersections = [];\r\n\r\n  for (var i = 0; i < 4; i++) {\r\n    var _a = getBBoxBoundLine(bbox, directions[i]),\r\n        x1 = _a[0],\r\n        y1 = _a[1],\r\n        x2 = _a[2],\r\n        y2 = _a[3];\r\n\r\n    intersections[i] = getLineIntersect({\r\n      x: line.x1,\r\n      y: line.y1\r\n    }, {\r\n      x: line.x2,\r\n      y: line.y2\r\n    }, {\r\n      x: x1,\r\n      y: y1\r\n    }, {\r\n      x: x2,\r\n      y: y2\r\n    });\r\n\r\n    if (intersections[i]) {\r\n      countIntersections += 1;\r\n    }\r\n  }\r\n\r\n  return [intersections, countIntersections];\r\n};\r\n\r\nexports.itemIntersectByLine = itemIntersectByLine;\r\n\r\nvar fractionToLine = function fractionToLine(item, line) {\r\n  var directions = ['top', 'left', 'bottom', 'right'];\r\n  var bbox = item.getBBox();\r\n  var minDistance = Number.POSITIVE_INFINITY;\r\n  var countIntersections = 0;\r\n\r\n  for (var i = 0; i < 4; i++) {\r\n    var _a = getBBoxBoundLine(bbox, directions[i]),\r\n        x1 = _a[0],\r\n        y1 = _a[1],\r\n        x2 = _a[2],\r\n        y2 = _a[3];\r\n\r\n    var testDistance = fractionAlongLineA(line, new Line(x1, y1, x2, y2));\r\n    testDistance = Math.abs(testDistance - 0.5);\r\n\r\n    if (testDistance >= 0 && testDistance <= 1) {\r\n      countIntersections += 1;\r\n      minDistance = testDistance < minDistance ? testDistance : minDistance;\r\n    }\r\n  }\r\n\r\n  if (countIntersections === 0) return -1;\r\n  return minDistance;\r\n};\r\n\r\nexports.fractionToLine = fractionToLine;\r\n\r\nvar getPointsCenter = function getPointsCenter(points) {\r\n  var centerX = 0;\r\n  var centerY = 0;\r\n\r\n  if (points.length > 0) {\r\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\r\n      var point = points_1[_i];\r\n      centerX += point.x;\r\n      centerY += point.y;\r\n    }\r\n\r\n    centerX /= points.length;\r\n    centerY /= points.length;\r\n  }\r\n\r\n  return {\r\n    x: centerX,\r\n    y: centerY\r\n  };\r\n};\r\n\r\nexports.getPointsCenter = getPointsCenter;\r\n\r\nvar squareDist = function squareDist(a, b) {\r\n  return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);\r\n};\r\n\r\nexports.squareDist = squareDist;\r\n\r\nvar pointLineSquareDist = function pointLineSquareDist(point, line) {\r\n  var x1 = line.x1;\r\n  var y1 = line.y1;\r\n  var x2 = line.x2 - x1;\r\n  var y2 = line.y2 - y1;\r\n  var px = point.x - x1;\r\n  var py = point.y - y1;\r\n  var dotprod = px * x2 + py * y2;\r\n  var projlenSq;\r\n\r\n  if (dotprod <= 0) {\r\n    projlenSq = 0;\r\n  } else {\r\n    px = x2 - px;\r\n    py = y2 - py;\r\n    dotprod = px * x2 + py * y2;\r\n\r\n    if (dotprod <= 0) {\r\n      projlenSq = 0;\r\n    } else {\r\n      projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\r\n    }\r\n  }\r\n\r\n  var lenSq = px * px + py * py - projlenSq;\r\n\r\n  if (lenSq < 0) {\r\n    lenSq = 0;\r\n  }\r\n\r\n  return lenSq;\r\n};\r\n\r\nexports.pointLineSquareDist = pointLineSquareDist;\r\n\r\nvar isPointsOverlap = function isPointsOverlap(p1, p2, e) {\r\n  if (e === void 0) {\r\n    e = 1e-3;\r\n  }\r\n\r\n  return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) < Math.pow(e, 2);\r\n};\r\n/**\r\n * 点到矩形的距离的平方：矩形内部点视作距离为0，外部的点若投影落在矩形边上则为点到矩形边的最近的垂直距离，否则为点到矩形顶点的距离，\r\n * @param point IPoint\r\n * @param rect IRect\r\n */\r\n\r\n\r\nexports.isPointsOverlap = isPointsOverlap;\r\n\r\nvar pointRectSquareDist = function pointRectSquareDist(point, rect) {\r\n  var isLeft = point.x < rect.x;\r\n  var isRight = point.x > rect.x + rect.width;\r\n  var isTop = point.y > rect.y + rect.height;\r\n  var isBottom = point.y < rect.y;\r\n  var isPointOutside = isLeft || isRight || isTop || isBottom;\r\n\r\n  if (!isPointOutside) {\r\n    return 0;\r\n  }\r\n\r\n  if (isTop && !isLeft && !isRight) {\r\n    return Math.pow(rect.y + rect.height - point.y, 2);\r\n  }\r\n\r\n  if (isBottom && !isLeft && !isRight) {\r\n    return Math.pow(point.y - rect.y, 2);\r\n  }\r\n\r\n  if (isLeft && !isTop && !isBottom) {\r\n    return Math.pow(rect.x - point.x, 2);\r\n  }\r\n\r\n  if (isRight && !isTop && !isBottom) {\r\n    return Math.pow(rect.x + rect.width - point.x, 2);\r\n  }\r\n\r\n  var dx = Math.min(Math.abs(rect.x - point.x), Math.abs(rect.x + rect.width - point.x));\r\n  var dy = Math.min(Math.abs(rect.y - point.y), Math.abs(rect.y + rect.height - point.y));\r\n  return dx * dx + dy * dy;\r\n};\r\n/**\r\n * point to line distance\r\n * @param  {array} line 线的四个顶点 [x1, y1, x2, y2]\r\n * @param  {object} point 坐标点 {x, y}\r\n * @return {Number|NaN} distance\r\n */\r\n\r\n\r\nexports.pointRectSquareDist = pointRectSquareDist;\r\n\r\nvar pointLineDistance = function pointLineDistance(line, point) {\r\n  var x1 = line[0],\r\n      y1 = line[1],\r\n      x2 = line[2],\r\n      y2 = line[3];\r\n  var x = point.x,\r\n      y = point.y;\r\n  var d = [x2 - x1, y2 - y1];\r\n\r\n  if (_matrixUtil.vec2.exactEquals(d, [0, 0])) {\r\n    return NaN;\r\n  }\r\n\r\n  var u = [-d[1], d[0]]; // @ts-ignore\r\n\r\n  _matrixUtil.vec2.normalize(u, u);\r\n\r\n  var a = [x - x1, y - y1]; // @ts-ignore\r\n\r\n  return Math.abs(_matrixUtil.vec2.dot(a, u));\r\n};\r\n\r\nexports.pointLineDistance = pointLineDistance;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.singleDataValidation = exports.dataValidation = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _graphic = require(\"./graphic\");\r\n\r\n/**\r\n * 验证关系图或树图数据的合法性，必须符合以下规则才会渲染图：\r\n * 1. 必须传入数据\r\n * 2. 节点的 ID 必须为字符串，暂不支持数字类型，如果支持数字类型，会出现类似 123 与 '123' 是否相等的问题\r\n * 3. 边的 source 和 target 值必须在节点 ID 中存在\r\n * @param data 关系图或树图数据\r\n * @return boolean 全部验证通过返回 true，否则返回 false\r\n */\r\nvar dataValidation = function dataValidation(data) {\r\n  // 1. 必须传入数据\r\n  if (!data) {\r\n    console.error('G6 Error Tips: the data must be defined');\r\n    return false;\r\n  } // 2. 节点的 ID 必须为字符串或数字类型\r\n\r\n\r\n  var nodes = data.nodes,\r\n      edges = data.edges,\r\n      _a = data.combos,\r\n      combos = _a === void 0 ? [] : _a;\r\n\r\n  if (!nodes && !edges) {\r\n    var validated_1 = true; // 不存在 nodes 和 edges，则说明是 TreeGraphData，按 TreeGraphData 规则验证\r\n\r\n    (0, _graphic.traverseTree)(data, function (param) {\r\n      if (!(0, _util.isString)(param.id)) {\r\n        validated_1 = false;\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    });\r\n    return validated_1;\r\n  }\r\n\r\n  var nonNode = (nodes || []).find(function (node) {\r\n    return !(0, _util.isString)(node.id);\r\n  });\r\n\r\n  if (nonNode) {\r\n    console.warn(\"G6 Warning Tips: missing 'id' property, or %c\" + nonNode.id + \"%c is not a string.\", 'font-size: 20px; color: red;', '');\r\n    return false;\r\n  } // 3. 边的 source 和 target 必须存在于节点 或 Combo中\r\n\r\n\r\n  var nodeIds = (nodes || []).map(function (node) {\r\n    return node.id;\r\n  });\r\n  var comboIds = combos.map(function (combo) {\r\n    return combo.id;\r\n  });\r\n  var ids = (0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], nodeIds), comboIds);\r\n  var nonEdges = (edges || []).find(function (edge) {\r\n    return !ids.includes(edge.source) || !ids.includes(edge.target);\r\n  });\r\n\r\n  if (nonEdges) {\r\n    console.warn(\"G6 Warning Tips: The source %c\" + nonEdges.source + \"%c or the target %c\" + nonEdges.target + \"%c of the edge do not exist in the nodes or combos.\", 'font-size: 20px; color: red;', '', 'font-size: 20px; color: red;', '');\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n/**\r\n * 验证添加节点、边或从combo时的数据\r\n * @param type 节点、边或从combo\r\n * @param data 添加的单条数据\r\n * @return boolean 全部验证通过返回 true，否则返回 false\r\n */\r\n\r\n\r\nexports.dataValidation = dataValidation;\r\n\r\nvar singleDataValidation = function singleDataValidation(type, data) {\r\n  if (type === 'node' || type === 'combo') {\r\n    // 必须有 id 字段，且id必须为字符串类型\r\n    if (data.id && !(0, _util.isString)(data.id)) {\r\n      console.warn(\"G6 Warning Tips: missing 'id' property, or the 'id' %c\" + data.id + \"%c is not a string.\", 'font-size: 20px; color: red;', '');\r\n      return false;\r\n    }\r\n  } else if (type === 'edge') {\r\n    // 必须有 source 和 target 字段\r\n    if (!data.source || !data.target) {\r\n      console.warn(\"G6 Warning Tips: missing 'source' or 'target' for the edge.\");\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nexports.singleDataValidation = singleDataValidation;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.cloneBesidesImg = exports.shouldRefreshEdge = exports.getComboBBox = exports.reconstructTree = exports.plainCombosToTrees = exports.getTextSize = exports.getLetterWidth = exports.traverseTreeUp = exports.traverseTree = exports.getLabelPosition = exports.getLoopCfgs = exports.getBBox = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _matrixUtil = require(\"@antv/matrix-util\");\r\n\r\nvar _global = _interopRequireDefault(require(\"../global\"));\r\n\r\nvar _math = require(\"./math\");\r\n\r\nvar _letterAspectRatio = _interopRequireDefault(require(\"./letterAspectRatio\"));\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar PI = Math.PI,\r\n    sin = Math.sin,\r\n    cos = Math.cos; // 一共支持8个方向的自环，每个环占的角度是45度，在计算时再二分，为22.5度\r\n\r\nvar SELF_LINK_SIN = sin(PI / 8);\r\nvar SELF_LINK_COS = cos(PI / 8);\r\n\r\nvar getBBox = function getBBox(element, group) {\r\n  var bbox = element.getBBox();\r\n  var leftTop = {\r\n    x: bbox.minX,\r\n    y: bbox.minY\r\n  };\r\n  var rightBottom = {\r\n    x: bbox.maxX,\r\n    y: bbox.maxY\r\n  }; // 根据父元素变换矩阵\r\n\r\n  if (group) {\r\n    var matrix = group.getMatrix();\r\n\r\n    if (!matrix) {\r\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n    }\r\n\r\n    leftTop = (0, _math.applyMatrix)(leftTop, matrix);\r\n    rightBottom = (0, _math.applyMatrix)(rightBottom, matrix);\r\n  }\r\n\r\n  var lx = leftTop.x,\r\n      ly = leftTop.y;\r\n  var rx = rightBottom.x,\r\n      ry = rightBottom.y;\r\n  return {\r\n    x: lx,\r\n    y: ly,\r\n    minX: lx,\r\n    minY: ly,\r\n    maxX: rx,\r\n    maxY: ry,\r\n    width: rx - lx,\r\n    height: ry - ly\r\n  };\r\n};\r\n/**\r\n * get loop edge config\r\n * @param cfg edge config\r\n */\r\n\r\n\r\nexports.getBBox = getBBox;\r\n\r\nvar getLoopCfgs = function getLoopCfgs(cfg) {\r\n  var item = cfg.sourceNode || cfg.targetNode;\r\n  var container = item.get('group');\r\n  var containerMatrix = container.getMatrix();\r\n  if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n  var keyShape = item.getKeyShape();\r\n  var bbox = keyShape.getBBox();\r\n  var loopCfg = cfg.loopCfg || {}; // 距离keyShape边的最高距离\r\n\r\n  var dist = loopCfg.dist || Math.max(bbox.width, bbox.height) * 2; // 自环边与keyShape的相对位置关系\r\n\r\n  var position = loopCfg.position || _global.default.defaultLoopPosition; // 中心取group上真实位置\r\n\r\n  var center = [containerMatrix[6], containerMatrix[7]];\r\n  var startPoint = [cfg.startPoint.x, cfg.startPoint.y];\r\n  var endPoint = [cfg.endPoint.x, cfg.endPoint.y];\r\n  var rstart = bbox.height / 2;\r\n  var rend = bbox.height / 2;\r\n  var sinDeltaStart = rstart * SELF_LINK_SIN;\r\n  var cosDeltaStart = rstart * SELF_LINK_COS;\r\n  var sinDeltaEnd = rend * SELF_LINK_SIN;\r\n  var cosDeltaEnd = rend * SELF_LINK_COS; // 如果定义了锚点的，直接用锚点坐标，否则，根据自环的 cfg 计算\r\n\r\n  if (startPoint[0] === endPoint[0] && startPoint[1] === endPoint[1]) {\r\n    switch (position) {\r\n      case 'top':\r\n        startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];\r\n        endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];\r\n        break;\r\n\r\n      case 'top-right':\r\n        rstart = bbox.height / 2;\r\n        rend = bbox.width / 2;\r\n        sinDeltaStart = rstart * SELF_LINK_SIN;\r\n        cosDeltaStart = rstart * SELF_LINK_COS;\r\n        sinDeltaEnd = rend * SELF_LINK_SIN;\r\n        cosDeltaEnd = rend * SELF_LINK_COS;\r\n        startPoint = [center[0] + sinDeltaStart, center[1] - cosDeltaStart];\r\n        endPoint = [center[0] + cosDeltaEnd, center[1] - sinDeltaEnd];\r\n        break;\r\n\r\n      case 'right':\r\n        rstart = bbox.width / 2;\r\n        rend = bbox.width / 2;\r\n        sinDeltaStart = rstart * SELF_LINK_SIN;\r\n        cosDeltaStart = rstart * SELF_LINK_COS;\r\n        sinDeltaEnd = rend * SELF_LINK_SIN;\r\n        cosDeltaEnd = rend * SELF_LINK_COS;\r\n        startPoint = [center[0] + cosDeltaStart, center[1] - sinDeltaStart];\r\n        endPoint = [center[0] + cosDeltaEnd, center[1] + sinDeltaEnd];\r\n        break;\r\n\r\n      case 'bottom-right':\r\n        rstart = bbox.width / 2;\r\n        rend = bbox.height / 2;\r\n        sinDeltaStart = rstart * SELF_LINK_SIN;\r\n        cosDeltaStart = rstart * SELF_LINK_COS;\r\n        sinDeltaEnd = rend * SELF_LINK_SIN;\r\n        cosDeltaEnd = rend * SELF_LINK_COS;\r\n        startPoint = [center[0] + cosDeltaStart, center[1] + sinDeltaStart];\r\n        endPoint = [center[0] + sinDeltaEnd, center[1] + cosDeltaEnd];\r\n        break;\r\n\r\n      case 'bottom':\r\n        rstart = bbox.height / 2;\r\n        rend = bbox.height / 2;\r\n        sinDeltaStart = rstart * SELF_LINK_SIN;\r\n        cosDeltaStart = rstart * SELF_LINK_COS;\r\n        sinDeltaEnd = rend * SELF_LINK_SIN;\r\n        cosDeltaEnd = rend * SELF_LINK_COS;\r\n        startPoint = [center[0] + sinDeltaStart, center[1] + cosDeltaStart];\r\n        endPoint = [center[0] - sinDeltaEnd, center[1] + cosDeltaEnd];\r\n        break;\r\n\r\n      case 'bottom-left':\r\n        rstart = bbox.height / 2;\r\n        rend = bbox.width / 2;\r\n        sinDeltaStart = rstart * SELF_LINK_SIN;\r\n        cosDeltaStart = rstart * SELF_LINK_COS;\r\n        sinDeltaEnd = rend * SELF_LINK_SIN;\r\n        cosDeltaEnd = rend * SELF_LINK_COS;\r\n        startPoint = [center[0] - sinDeltaStart, center[1] + cosDeltaStart];\r\n        endPoint = [center[0] - cosDeltaEnd, center[1] + sinDeltaEnd];\r\n        break;\r\n\r\n      case 'left':\r\n        rstart = bbox.width / 2;\r\n        rend = bbox.width / 2;\r\n        sinDeltaStart = rstart * SELF_LINK_SIN;\r\n        cosDeltaStart = rstart * SELF_LINK_COS;\r\n        sinDeltaEnd = rend * SELF_LINK_SIN;\r\n        cosDeltaEnd = rend * SELF_LINK_COS;\r\n        startPoint = [center[0] - cosDeltaStart, center[1] + sinDeltaStart];\r\n        endPoint = [center[0] - cosDeltaEnd, center[1] - sinDeltaEnd];\r\n        break;\r\n\r\n      case 'top-left':\r\n        rstart = bbox.width / 2;\r\n        rend = bbox.height / 2;\r\n        sinDeltaStart = rstart * SELF_LINK_SIN;\r\n        cosDeltaStart = rstart * SELF_LINK_COS;\r\n        sinDeltaEnd = rend * SELF_LINK_SIN;\r\n        cosDeltaEnd = rend * SELF_LINK_COS;\r\n        startPoint = [center[0] - cosDeltaStart, center[1] - sinDeltaStart];\r\n        endPoint = [center[0] - sinDeltaEnd, center[1] - cosDeltaEnd];\r\n        break;\r\n\r\n      default:\r\n        rstart = bbox.width / 2;\r\n        rend = bbox.width / 2;\r\n        sinDeltaStart = rstart * SELF_LINK_SIN;\r\n        cosDeltaStart = rstart * SELF_LINK_COS;\r\n        sinDeltaEnd = rend * SELF_LINK_SIN;\r\n        cosDeltaEnd = rend * SELF_LINK_COS;\r\n        startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];\r\n        endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];\r\n    } // 如果逆时针画，交换起点和终点\r\n\r\n\r\n    if (loopCfg.clockwise === false) {\r\n      var swap = [startPoint[0], startPoint[1]];\r\n      startPoint = [endPoint[0], endPoint[1]];\r\n      endPoint = [swap[0], swap[1]];\r\n    }\r\n  }\r\n\r\n  var startVec = [startPoint[0] - center[0], startPoint[1] - center[1]];\r\n  var scaleRateStart = (rstart + dist) / rstart;\r\n  var scaleRateEnd = (rend + dist) / rend;\r\n\r\n  if (loopCfg.clockwise === false) {\r\n    scaleRateStart = (rend + dist) / rend;\r\n    scaleRateEnd = (rstart + dist) / rstart;\r\n  }\r\n\r\n  var startExtendVec = _matrixUtil.vec2.scale([0, 0], startVec, scaleRateStart);\r\n\r\n  var controlPoint1 = [center[0] + startExtendVec[0], center[1] + startExtendVec[1]];\r\n  var endVec = [endPoint[0] - center[0], endPoint[1] - center[1]];\r\n\r\n  var endExtendVec = _matrixUtil.vec2.scale([0, 0], endVec, scaleRateEnd);\r\n\r\n  var controlPoint2 = [center[0] + endExtendVec[0], center[1] + endExtendVec[1]];\r\n  cfg.startPoint = {\r\n    x: startPoint[0],\r\n    y: startPoint[1]\r\n  };\r\n  cfg.endPoint = {\r\n    x: endPoint[0],\r\n    y: endPoint[1]\r\n  };\r\n  cfg.controlPoints = [{\r\n    x: controlPoint1[0],\r\n    y: controlPoint1[1]\r\n  }, {\r\n    x: controlPoint2[0],\r\n    y: controlPoint2[1]\r\n  }];\r\n  return cfg;\r\n};\r\n/**\r\n * 根据 label 所在线条的位置百分比，计算 label 坐标\r\n * @param {object}  pathShape  G 的 path 实例，一般是 Edge 实例的 keyShape\r\n * @param {number}  percent    范围 0 - 1 的线条百分比\r\n * @param {number}  refX     x 轴正方向为基准的 label 偏移\r\n * @param {number}  refY     y 轴正方向为基准的 label 偏移\r\n * @param {boolean} rotate     是否根据线条斜率旋转文本\r\n * @return {object} 文本的 x, y, 文本的旋转角度\r\n */\r\n\r\n\r\nexports.getLoopCfgs = getLoopCfgs;\r\n\r\nvar getLabelPosition = function getLabelPosition(pathShape, percent, refX, refY, rotate) {\r\n  var TAN_OFFSET = 0.0001;\r\n  var vector = [];\r\n  var point = pathShape.getPoint(percent);\r\n\r\n  if (point === null) {\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n      angle: 0\r\n    };\r\n  } // 头尾最可能，放在最前面，使用 g path 上封装的方法\r\n\r\n\r\n  if (percent < TAN_OFFSET) {\r\n    vector = pathShape.getStartTangent().reverse();\r\n  } else if (percent > 1 - TAN_OFFSET) {\r\n    vector = pathShape.getEndTangent();\r\n  } else {\r\n    // 否则取指定位置的点,与少量偏移的点，做微分向量\r\n    var offsetPoint = pathShape.getPoint(percent + TAN_OFFSET);\r\n    vector.push([point.x, point.y]);\r\n    vector.push([offsetPoint.x, offsetPoint.y]);\r\n  }\r\n\r\n  var rad = Math.atan2(vector[1][1] - vector[0][1], vector[1][0] - vector[0][0]);\r\n\r\n  if (rad < 0) {\r\n    rad += PI * 2;\r\n  }\r\n\r\n  if (refX) {\r\n    point.x += cos(rad) * refX;\r\n    point.y += sin(rad) * refX;\r\n  }\r\n\r\n  if (refY) {\r\n    // 默认方向是 x 轴正方向，法线是 求出角度 - 90°\r\n    var normal = rad - PI / 2; // 若法线角度在 y 轴负方向，切到正方向，保证 refY 相对于 y 轴正方向\r\n\r\n    if (rad > 1 / 2 * PI && rad < 3 * 1 / 2 * PI) {\r\n      normal -= PI;\r\n    }\r\n\r\n    point.x += cos(normal) * refY;\r\n    point.y += sin(normal) * refY;\r\n  }\r\n\r\n  var result = {\r\n    x: point.x,\r\n    y: point.y,\r\n    angle: rad\r\n  };\r\n\r\n  if (rotate) {\r\n    if (rad > 1 / 2 * PI && rad < 3 * 1 / 2 * PI) {\r\n      rad -= PI;\r\n    }\r\n\r\n    return (0, _tslib.__assign)({\r\n      rotate: rad\r\n    }, result);\r\n  }\r\n\r\n  return result;\r\n};\r\n/**\r\n * depth first traverse, from root to leaves, children in inverse order\r\n *  if the fn returns false, terminate the traverse\r\n */\r\n\r\n\r\nexports.getLabelPosition = getLabelPosition;\r\n\r\nvar traverse = function traverse(data, fn) {\r\n  if (fn(data) === false) {\r\n    return false;\r\n  }\r\n\r\n  if (data && data.children) {\r\n    for (var i = data.children.length - 1; i >= 0; i--) {\r\n      if (!traverse(data.children[i], fn)) return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n/**\r\n * depth first traverse, from leaves to root, children in inverse order\r\n *  if the fn returns false, terminate the traverse\r\n */\r\n\r\n\r\nvar traverseUp = function traverseUp(data, fn) {\r\n  if (data && data.children) {\r\n    for (var i = data.children.length - 1; i >= 0; i--) {\r\n      if (!traverseUp(data.children[i], fn)) return;\r\n    }\r\n  }\r\n\r\n  if (fn(data) === false) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n/**\r\n * depth first traverse, from root to leaves, children in inverse order\r\n *  if the fn returns false, terminate the traverse\r\n */\r\n\r\n\r\nvar traverseTree = function traverseTree(data, fn) {\r\n  if (typeof fn !== 'function') {\r\n    return;\r\n  }\r\n\r\n  traverse(data, fn);\r\n};\r\n/**\r\n * depth first traverse, from leaves to root, children in inverse order\r\n * if the fn returns false, terminate the traverse\r\n */\r\n\r\n\r\nexports.traverseTree = traverseTree;\r\n\r\nvar traverseTreeUp = function traverseTreeUp(data, fn) {\r\n  if (typeof fn !== 'function') {\r\n    return;\r\n  }\r\n\r\n  traverseUp(data, fn);\r\n};\r\n/**\r\n *\r\n * @param letter the letter\r\n * @param fontSize\r\n * @return the letter's width\r\n */\r\n\r\n\r\nexports.traverseTreeUp = traverseTreeUp;\r\n\r\nvar getLetterWidth = function getLetterWidth(letter, fontSize) {\r\n  return fontSize * (_letterAspectRatio.default[letter] || 1);\r\n};\r\n/**\r\n *\r\n * @param text the text\r\n * @param fontSize\r\n * @return the text's size\r\n */\r\n\r\n\r\nexports.getLetterWidth = getLetterWidth;\r\n\r\nvar getTextSize = function getTextSize(text, fontSize) {\r\n  var width = 0;\r\n  var pattern = new RegExp(\"[\\u4E00-\\u9FA5]+\");\r\n  text.split('').forEach(function (letter) {\r\n    if (pattern.test(letter)) {\r\n      // 中文字符\r\n      width += fontSize;\r\n    } else {\r\n      width += getLetterWidth(letter, fontSize);\r\n    }\r\n  });\r\n  return [width, fontSize];\r\n};\r\n/**\r\n * construct the trees from combos data\r\n * @param array the combos array\r\n * @param nodes the nodes array\r\n * @return the tree\r\n */\r\n\r\n\r\nexports.getTextSize = getTextSize;\r\n\r\nvar plainCombosToTrees = function plainCombosToTrees(array, nodes) {\r\n  var result = [];\r\n  var addedMap = {};\r\n  var modelMap = {};\r\n  array.forEach(function (d) {\r\n    modelMap[d.id] = d;\r\n  });\r\n  array.forEach(function (d, i) {\r\n    var cd = (0, _util.clone)(d);\r\n    cd.itemType = 'combo';\r\n    cd.children = undefined;\r\n\r\n    if (cd.parentId === cd.id) {\r\n      console.warn(\"The parentId for combo \" + cd.id + \" can not be the same as the combo's id\");\r\n      delete cd.parentId;\r\n    } else if (cd.parentId && !modelMap[cd.parentId]) {\r\n      console.warn(\"The parent combo for combo \" + cd.id + \" does not exist!\");\r\n      delete cd.parentId;\r\n    }\r\n\r\n    var mappedObj = addedMap[cd.id];\r\n\r\n    if (mappedObj) {\r\n      cd.children = mappedObj.children;\r\n      addedMap[cd.id] = cd;\r\n      mappedObj = cd;\r\n\r\n      if (!mappedObj.parentId) {\r\n        result.push(mappedObj);\r\n        return;\r\n      }\r\n\r\n      var mappedParent = addedMap[mappedObj.parentId];\r\n\r\n      if (mappedParent) {\r\n        if (mappedParent.children) mappedParent.children.push(cd);else mappedParent.children = [cd];\r\n      } else {\r\n        var parent_1 = {\r\n          id: mappedObj.parentId,\r\n          children: [mappedObj]\r\n        };\r\n        addedMap[mappedObj.parentId] = parent_1;\r\n        addedMap[cd.id] = cd;\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if ((0, _util.isString)(d.parentId)) {\r\n      var parent_2 = addedMap[d.parentId];\r\n\r\n      if (parent_2) {\r\n        if (parent_2.children) parent_2.children.push(cd);else parent_2.children = [cd];\r\n        addedMap[cd.id] = cd;\r\n      } else {\r\n        var pa = {\r\n          id: d.parentId,\r\n          children: [cd]\r\n        };\r\n        addedMap[pa.id] = pa;\r\n        addedMap[cd.id] = cd;\r\n      }\r\n    } else {\r\n      result.push(cd);\r\n      addedMap[cd.id] = cd;\r\n    }\r\n  }); // proccess the nodes\r\n\r\n  var nodeMap = {};\r\n  (nodes || []).forEach(function (node) {\r\n    nodeMap[node.id] = node;\r\n    var combo = addedMap[node.comboId];\r\n\r\n    if (combo) {\r\n      var cnode = {\r\n        id: node.id,\r\n        comboId: node.comboId\r\n      };\r\n      if (combo.children) combo.children.push(cnode);else combo.children = [cnode];\r\n      cnode.itemType = 'node';\r\n      addedMap[node.id] = cnode;\r\n    }\r\n  }); // assign the depth for each element\r\n\r\n  var maxDepth = 0;\r\n  result.forEach(function (tree) {\r\n    tree.depth = maxDepth + 10;\r\n    traverse(tree, function (child) {\r\n      var parent;\r\n      var itemType = addedMap[child.id].itemType;\r\n\r\n      if (itemType === 'node') {\r\n        parent = addedMap[child.comboId];\r\n      } else {\r\n        parent = addedMap[child.parentId];\r\n      }\r\n\r\n      if (parent) {\r\n        if (itemType === 'node') child.depth = maxDepth + 1;else child.depth = maxDepth + 10;\r\n      } else {\r\n        child.depth = maxDepth + 10;\r\n      }\r\n\r\n      if (maxDepth < child.depth) maxDepth = child.depth;\r\n      var oriNodeModel = nodeMap[child.id];\r\n\r\n      if (oriNodeModel) {\r\n        oriNodeModel.depth = child.depth;\r\n      }\r\n\r\n      return true;\r\n    });\r\n  });\r\n  return result;\r\n};\r\n\r\nexports.plainCombosToTrees = plainCombosToTrees;\r\n\r\nvar reconstructTree = function reconstructTree(trees, subtreeId, newParentId) {\r\n  var brothers = trees;\r\n  var subtree;\r\n  var comboChildsMap = {\r\n    root: {\r\n      children: trees\r\n    }\r\n  };\r\n  var foundSubTree = false;\r\n  var oldParentId = 'root';\r\n  (trees || []).forEach(function (tree) {\r\n    if (foundSubTree) return;\r\n\r\n    if (tree.id === subtreeId) {\r\n      subtree = tree;\r\n\r\n      if (tree.itemType === 'combo') {\r\n        subtree.parentId = newParentId;\r\n      } else {\r\n        subtree.comboId = newParentId;\r\n      }\r\n\r\n      foundSubTree = true;\r\n      return;\r\n    }\r\n\r\n    traverseTree(tree, function (child) {\r\n      comboChildsMap[child.id] = {\r\n        children: child.children\r\n      }; // store the old parent id to delete the subtree from the old parent's children in next recursion\r\n\r\n      brothers = comboChildsMap[child.parentId || child.comboId || 'root'].children;\r\n\r\n      if (child && (child.removed || subtreeId === child.id) && brothers) {\r\n        oldParentId = child.parentId || child.comboId || 'root';\r\n        subtree = child; // re-assign the parentId or comboId for the moved subtree\r\n\r\n        if (child.itemType === 'combo') {\r\n          subtree.parentId = newParentId;\r\n        } else {\r\n          subtree.comboId = newParentId;\r\n        }\r\n\r\n        foundSubTree = true;\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    });\r\n  });\r\n  brothers = comboChildsMap[oldParentId].children;\r\n  var index = brothers ? brothers.indexOf(subtree) : -1;\r\n  if (index > -1) brothers.splice(index, 1); // 如果遍历完整棵树还没有找到，说明之前就不在树中\r\n\r\n  if (!foundSubTree) {\r\n    subtree = {\r\n      id: subtreeId,\r\n      itemType: 'node',\r\n      comboId: newParentId\r\n    };\r\n    comboChildsMap[subtreeId] = {\r\n      children: undefined\r\n    };\r\n  } // append to new parent\r\n\r\n\r\n  if (subtreeId) {\r\n    var found_1 = false; // newParentId is undefined means the subtree will have no parent\r\n\r\n    if (newParentId) {\r\n      var newParentDepth_1 = 0;\r\n      (trees || []).forEach(function (tree) {\r\n        if (found_1) return; // terminate\r\n\r\n        traverseTree(tree, function (child) {\r\n          // append subtree to the new parent ans assign the depth to the subtree\r\n          if (newParentId === child.id) {\r\n            found_1 = true;\r\n            if (child.children) child.children.push(subtree);else child.children = [subtree];\r\n            newParentDepth_1 = child.depth;\r\n            if (subtree.itemType === 'node') subtree.depth = newParentDepth_1 + 2;else subtree.depth = newParentDepth_1 + 1;\r\n            return false; // terminate\r\n          }\r\n\r\n          return true;\r\n        });\r\n      });\r\n    } else if ((!newParentId || !found_1) && subtree.itemType !== 'node') {\r\n      // if the newParentId is undefined or it is not found in the tree, add the subTree to the root\r\n      trees.push(subtree);\r\n    } // update the depth of the subtree and its children from the subtree\r\n\r\n\r\n    var currentDepth_1 = subtree.depth;\r\n    traverseTree(subtree, function (child) {\r\n      if (child.itemType === 'node') currentDepth_1 += 2;else currentDepth_1 += 1;\r\n      child.depth = currentDepth_1;\r\n      return true;\r\n    });\r\n  }\r\n\r\n  return trees;\r\n};\r\n\r\nexports.reconstructTree = reconstructTree;\r\n\r\nvar getComboBBox = function getComboBBox(children, graph) {\r\n  var comboBBox = {\r\n    minX: Infinity,\r\n    minY: Infinity,\r\n    maxX: -Infinity,\r\n    maxY: -Infinity,\r\n    x: undefined,\r\n    y: undefined,\r\n    width: undefined,\r\n    height: undefined,\r\n    centerX: undefined,\r\n    centerY: undefined\r\n  };\r\n\r\n  if (!children || children.length === 0) {\r\n    return comboBBox;\r\n  }\r\n\r\n  children.forEach(function (child) {\r\n    var childItem = graph.findById(child.id);\r\n    if (!childItem || !childItem.isVisible()) return; // ignore hidden children\r\n\r\n    childItem.set('bboxCanvasCache', undefined);\r\n    var childBBox = childItem.getCanvasBBox();\r\n    if (childBBox.x && comboBBox.minX > childBBox.minX) comboBBox.minX = childBBox.minX;\r\n    if (childBBox.y && comboBBox.minY > childBBox.minY) comboBBox.minY = childBBox.minY;\r\n    if (childBBox.x && comboBBox.maxX < childBBox.maxX) comboBBox.maxX = childBBox.maxX;\r\n    if (childBBox.y && comboBBox.maxY < childBBox.maxY) comboBBox.maxY = childBBox.maxY;\r\n  });\r\n  comboBBox.x = (comboBBox.minX + comboBBox.maxX) / 2;\r\n  comboBBox.y = (comboBBox.minY + comboBBox.maxY) / 2;\r\n  comboBBox.width = comboBBox.maxX - comboBBox.minX;\r\n  comboBBox.height = comboBBox.maxY - comboBBox.minY;\r\n  comboBBox.centerX = (comboBBox.minX + comboBBox.maxX) / 2;\r\n  comboBBox.centerY = (comboBBox.minY + comboBBox.maxY) / 2;\r\n  Object.keys(comboBBox).forEach(function (key) {\r\n    if (comboBBox[key] === Infinity || comboBBox[key] === -Infinity) {\r\n      comboBBox[key] = undefined;\r\n    }\r\n  });\r\n  return comboBBox;\r\n};\r\n\r\nexports.getComboBBox = getComboBBox;\r\n\r\nvar shouldRefreshEdge = function shouldRefreshEdge(cfg) {\r\n  var refreshEdge = (0, _util.isNumber)(cfg.x) || (0, _util.isNumber)(cfg.y) || cfg.type || cfg.anchorPoints || cfg.size;\r\n  if (cfg.style) refreshEdge = refreshEdge || (0, _util.isNumber)(cfg.style.r) || (0, _util.isNumber)(cfg.style.width) || (0, _util.isNumber)(cfg.style.height) || (0, _util.isNumber)(cfg.style.rx) || (0, _util.isNumber)(cfg.style.ry);\r\n  return refreshEdge;\r\n};\r\n\r\nexports.shouldRefreshEdge = shouldRefreshEdge;\r\n\r\nvar cloneBesidesImg = function cloneBesidesImg(obj) {\r\n  var clonedObj = {};\r\n  Object.keys(obj).forEach(function (key1) {\r\n    var obj2 = obj[key1];\r\n\r\n    if ((0, _util.isObject)(obj2)) {\r\n      var clonedObj2_1 = {};\r\n      Object.keys(obj2).forEach(function (key2) {\r\n        var v = obj2[key2];\r\n        if (key2 === 'img' && !(0, _util.isString)(v)) return;\r\n        clonedObj2_1[key2] = (0, _util.clone)(v);\r\n      });\r\n      clonedObj[key1] = clonedObj2_1;\r\n    } else {\r\n      clonedObj[key1] = (0, _util.clone)(obj2);\r\n    }\r\n  });\r\n  return clonedObj;\r\n};\r\n\r\nexports.cloneBesidesImg = cloneBesidesImg;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\nvar subjectColor = 'rgb(95, 149, 255)';\r\nvar backColor = 'rgb(255, 255, 255)';\r\nvar textColor = 'rgb(0, 0, 0)';\r\nvar activeFill = 'rgb(247, 250, 255)';\r\nvar nodeMainFill = 'rgb(239, 244, 255)';\r\nvar comboFill = 'rgb(253, 253, 253)';\r\nvar disabledFill = 'rgb(250, 250, 250)';\r\nvar edgeMainStroke = 'rgb(224, 224, 224)';\r\nvar edgeInactiveStroke = 'rgb(234, 234, 234)';\r\nvar edgeDisablesStroke = 'rgb(245, 245, 245)';\r\nvar inactiveStroke = 'rgb(191, 213, 255)';\r\nvar highlightStroke = '#4572d9';\r\nvar highlightFill = 'rgb(223, 234, 255)';\r\nvar colorSet = {\r\n  // for nodes\r\n  mainStroke: subjectColor,\r\n  mainFill: nodeMainFill,\r\n  activeStroke: subjectColor,\r\n  activeFill: activeFill,\r\n  inactiveStroke: inactiveStroke,\r\n  inactiveFill: activeFill,\r\n  selectedStroke: subjectColor,\r\n  selectedFill: backColor,\r\n  highlightStroke: highlightStroke,\r\n  highlightFill: highlightFill,\r\n  disableStroke: edgeMainStroke,\r\n  disableFill: disabledFill,\r\n  // for edges\r\n  edgeMainStroke: edgeMainStroke,\r\n  edgeActiveStroke: subjectColor,\r\n  edgeInactiveStroke: edgeInactiveStroke,\r\n  edgeSelectedStroke: subjectColor,\r\n  edgeHighlightStroke: subjectColor,\r\n  edgeDisableStroke: edgeDisablesStroke,\r\n  // for combos\r\n  comboMainStroke: edgeMainStroke,\r\n  comboMainFill: comboFill,\r\n  comboActiveStroke: subjectColor,\r\n  comboActiveFill: activeFill,\r\n  comboInactiveStroke: edgeMainStroke,\r\n  comboInactiveFill: comboFill,\r\n  comboSelectedStroke: subjectColor,\r\n  comboSelectedFill: comboFill,\r\n  comboHighlightStroke: highlightStroke,\r\n  comboHighlightFill: comboFill,\r\n  comboDisableStroke: edgeInactiveStroke,\r\n  comboDisableFill: disabledFill\r\n};\r\nvar _default = {\r\n  version: '0.3.0',\r\n  rootContainerClassName: 'root-container',\r\n  nodeContainerClassName: 'node-container',\r\n  edgeContainerClassName: 'edge-container',\r\n  comboContainerClassName: 'combo-container',\r\n  delegateContainerClassName: 'delegate-container',\r\n  defaultLoopPosition: 'top',\r\n  nodeLabel: {\r\n    style: {\r\n      fill: '#000',\r\n      fontSize: 12,\r\n      textAlign: 'center',\r\n      textBaseline: 'middle'\r\n    },\r\n    offset: 4 // 节点的默认文本不居中时的偏移量\r\n\r\n  },\r\n  defaultNode: {\r\n    type: 'circle',\r\n    style: {\r\n      lineWidth: 1,\r\n      stroke: colorSet.mainStroke,\r\n      fill: nodeMainFill\r\n    },\r\n    size: 20,\r\n    color: colorSet.mainStroke,\r\n    linkPoints: {\r\n      size: 8,\r\n      lineWidth: 1,\r\n      fill: colorSet.activeFill,\r\n      stroke: colorSet.activeStroke\r\n    }\r\n  },\r\n  // 节点应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展\r\n  nodeStateStyles: {\r\n    active: {\r\n      fill: colorSet.activeFill,\r\n      stroke: colorSet.activeStroke,\r\n      lineWidth: 2,\r\n      shadowColor: colorSet.mainStroke,\r\n      shadowBlur: 10\r\n    },\r\n    selected: {\r\n      fill: colorSet.selectedFill,\r\n      stroke: colorSet.selectedStroke,\r\n      lineWidth: 4,\r\n      shadowColor: colorSet.selectedStroke,\r\n      shadowBlur: 10,\r\n      'text-shape': {\r\n        fontWeight: 500\r\n      }\r\n    },\r\n    highlight: {\r\n      fill: colorSet.highlightFill,\r\n      stroke: colorSet.highlightStroke,\r\n      lineWidth: 2,\r\n      'text-shape': {\r\n        fontWeight: 500\r\n      }\r\n    },\r\n    inactive: {\r\n      fill: colorSet.inactiveFill,\r\n      stroke: colorSet.inactiveStroke,\r\n      lineWidth: 1\r\n    },\r\n    disable: {\r\n      fill: colorSet.disableFill,\r\n      stroke: colorSet.disableStroke,\r\n      lineWidth: 1\r\n    }\r\n  },\r\n  edgeLabel: {\r\n    style: {\r\n      fill: textColor,\r\n      textAlign: 'center',\r\n      textBaseline: 'middle',\r\n      fontSize: 12\r\n    }\r\n  },\r\n  defaultEdge: {\r\n    type: 'line',\r\n    size: 1,\r\n    style: {\r\n      stroke: colorSet.edgeMainStroke,\r\n      lineAppendWidth: 2\r\n    },\r\n    color: colorSet.edgeMainStroke\r\n  },\r\n  // 边应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展\r\n  edgeStateStyles: {\r\n    active: {\r\n      stroke: colorSet.edgeActiveStroke,\r\n      lineWidth: 1\r\n    },\r\n    selected: {\r\n      stroke: colorSet.edgeSelectedStroke,\r\n      lineWidth: 2,\r\n      shadowColor: colorSet.edgeSelectedStroke,\r\n      shadowBlur: 10,\r\n      'text-shape': {\r\n        fontWeight: 500\r\n      }\r\n    },\r\n    highlight: {\r\n      stroke: colorSet.edgeHighlightStroke,\r\n      lineWidth: 2,\r\n      'text-shape': {\r\n        fontWeight: 500\r\n      }\r\n    },\r\n    inactive: {\r\n      stroke: colorSet.edgeInactiveStroke,\r\n      lineWidth: 1\r\n    },\r\n    disable: {\r\n      stroke: colorSet.edgeDisableStroke,\r\n      lineWidth: 1\r\n    }\r\n  },\r\n  comboLabel: {\r\n    style: {\r\n      fill: textColor,\r\n      // textAlign: 'center',\r\n      textBaseline: 'middle',\r\n      fontSize: 12\r\n    },\r\n    refY: 10,\r\n    refX: 10 // Combo 的默认文本不居中时的偏移量\r\n\r\n  },\r\n  defaultCombo: {\r\n    type: 'circle',\r\n    style: {\r\n      fill: colorSet.comboMainFill,\r\n      lineWidth: 1,\r\n      stroke: colorSet.comboMainStroke,\r\n      r: 5,\r\n      width: 20,\r\n      height: 10\r\n    },\r\n    size: [20, 5],\r\n    color: colorSet.comboMainStroke,\r\n    padding: [25, 20, 15, 20]\r\n  },\r\n  // combo 应用状态后的样式，默认仅提供 active、selected、highlight、inactive、disable，用户可以自己扩展\r\n  comboStateStyles: {\r\n    active: {\r\n      stroke: colorSet.comboActiveStroke,\r\n      lineWidth: 1,\r\n      fill: colorSet.comboActiveFill\r\n    },\r\n    selected: {\r\n      stroke: colorSet.comboSelectedStroke,\r\n      lineWidth: 2,\r\n      fill: colorSet.comboSelectedFill,\r\n      shadowColor: colorSet.comboSelectedStroke,\r\n      shadowBlur: 10,\r\n      'text-shape': {\r\n        fontWeight: 500\r\n      }\r\n    },\r\n    highlight: {\r\n      stroke: colorSet.comboHighlightStroke,\r\n      lineWidth: 2,\r\n      fill: colorSet.comboHighlightFill,\r\n      'text-shape': {\r\n        fontWeight: 500\r\n      }\r\n    },\r\n    inactive: {\r\n      stroke: colorSet.comboInactiveStroke,\r\n      fill: colorSet.comboInactiveFill,\r\n      lineWidth: 1\r\n    },\r\n    disable: {\r\n      stroke: colorSet.comboDisableStroke,\r\n      fill: colorSet.comboDisableFill,\r\n      lineWidth: 1\r\n    }\r\n  },\r\n  delegateStyle: {\r\n    fill: '#F3F9FF',\r\n    fillOpacity: 0.5,\r\n    stroke: '#1890FF',\r\n    strokeOpacity: 0.9,\r\n    lineDash: [5, 5]\r\n  }\r\n};\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\nvar _default = {\r\n  ' ': 0.3329986572265625,\r\n  a: 0.5589996337890625,\r\n  A: 0.6569992065429687,\r\n  b: 0.58599853515625,\r\n  B: 0.6769989013671875,\r\n  c: 0.5469985961914062,\r\n  C: 0.7279998779296875,\r\n  d: 0.58599853515625,\r\n  D: 0.705999755859375,\r\n  e: 0.554998779296875,\r\n  E: 0.63699951171875,\r\n  f: 0.37299957275390627,\r\n  F: 0.5769989013671875,\r\n  g: 0.5909988403320312,\r\n  G: 0.7479995727539063,\r\n  h: 0.555999755859375,\r\n  H: 0.7199996948242188,\r\n  i: 0.255999755859375,\r\n  I: 0.23699951171875,\r\n  j: 0.26699981689453123,\r\n  J: 0.5169998168945312,\r\n  k: 0.5289993286132812,\r\n  K: 0.6899993896484375,\r\n  l: 0.23499908447265624,\r\n  L: 0.5879989624023437,\r\n  m: 0.854998779296875,\r\n  M: 0.8819992065429687,\r\n  n: 0.5589996337890625,\r\n  N: 0.7189987182617188,\r\n  o: 0.58599853515625,\r\n  O: 0.7669998168945312,\r\n  p: 0.58599853515625,\r\n  P: 0.6419998168945312,\r\n  q: 0.58599853515625,\r\n  Q: 0.7669998168945312,\r\n  r: 0.3649993896484375,\r\n  R: 0.6759994506835938,\r\n  s: 0.504998779296875,\r\n  S: 0.6319992065429687,\r\n  t: 0.354998779296875,\r\n  T: 0.6189987182617187,\r\n  u: 0.5599990844726562,\r\n  U: 0.7139999389648437,\r\n  v: 0.48199920654296874,\r\n  V: 0.6389999389648438,\r\n  w: 0.754998779296875,\r\n  W: 0.929998779296875,\r\n  x: 0.5089996337890625,\r\n  X: 0.63699951171875,\r\n  y: 0.4959991455078125,\r\n  Y: 0.66199951171875,\r\n  z: 0.48699951171875,\r\n  Z: 0.6239990234375,\r\n  '0': 0.6,\r\n  '1': 0.40099945068359377,\r\n  '2': 0.6,\r\n  '3': 0.6,\r\n  '4': 0.6,\r\n  '5': 0.6,\r\n  '6': 0.6,\r\n  '7': 0.5469985961914062,\r\n  '8': 0.6,\r\n  '9': 0.6,\r\n  '[': 0.3329986572265625,\r\n  ']': 0.3329986572265625,\r\n  ',': 0.26399993896484375,\r\n  '.': 0.26399993896484375,\r\n  ';': 0.26399993896484375,\r\n  ':': 0.26399993896484375,\r\n  '{': 0.3329986572265625,\r\n  '}': 0.3329986572265625,\r\n  '\\\\': 0.5,\r\n  '|': 0.19499969482421875,\r\n  '=': 0.604998779296875,\r\n  '+': 0.604998779296875,\r\n  '-': 0.604998779296875,\r\n  _: 0.5,\r\n  '`': 0.3329986572265625,\r\n  ' ~': 0.8329986572265625,\r\n  '!': 0.3329986572265625,\r\n  '@': 0.8579986572265625,\r\n  '#': 0.6,\r\n  $: 0.6,\r\n  '%': 0.9699996948242188,\r\n  '^': 0.517999267578125,\r\n  '&': 0.7259994506835937,\r\n  '*': 0.505999755859375,\r\n  '(': 0.3329986572265625,\r\n  ')': 0.3329986572265625,\r\n  '<': 0.604998779296875,\r\n  '>': 0.604998779296875,\r\n  '/': 0.5,\r\n  '?': 0.53699951171875\r\n};\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nObject.defineProperty(exports, \"ModeController\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _mode.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"ViewController\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _view.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"ItemController\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _item.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"StateController\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _state.default;\r\n  }\r\n});\r\n\r\nvar _mode = _interopRequireDefault(require(\"./mode\"));\r\n\r\nvar _view = _interopRequireDefault(require(\"./view\"));\r\n\r\nvar _item = _interopRequireDefault(require(\"./item\"));\r\n\r\nvar _state = _interopRequireDefault(require(\"./state\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _behavior = _interopRequireDefault(require(\"../../behavior/behavior\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar ModeController =\r\n/** @class */\r\nfunction () {\r\n  function ModeController(graph) {\r\n    this.graph = graph;\r\n    this.destroyed = false;\r\n    this.modes = graph.get('modes') || {\r\n      default: []\r\n    };\r\n    this.formatModes();\r\n    this.mode = graph.get('defaultMode') || 'default';\r\n    this.currentBehaves = [];\r\n    this.setMode(this.mode);\r\n  }\r\n\r\n  ModeController.prototype.formatModes = function () {\r\n    var modes = this.modes;\r\n    (0, _util.each)(modes, function (mode) {\r\n      (0, _util.each)(mode, function (behavior, i) {\r\n        if ((0, _util.isString)(behavior)) {\r\n          mode[i] = {\r\n            type: behavior\r\n          };\r\n        }\r\n      });\r\n    });\r\n  };\r\n\r\n  ModeController.prototype.setBehaviors = function (mode) {\r\n    var graph = this.graph;\r\n    var behaviors = this.modes[mode];\r\n    var behaves = [];\r\n    var behave;\r\n    (0, _util.each)(behaviors || [], function (behavior) {\r\n      var BehaviorInstance = _behavior.default.getBehavior(behavior.type || behavior);\r\n\r\n      if (!BehaviorInstance) {\r\n        return;\r\n      }\r\n\r\n      behave = new BehaviorInstance(behavior);\r\n\r\n      if (behave) {\r\n        behave.bind(graph);\r\n        behaves.push(behave);\r\n      }\r\n    });\r\n    this.currentBehaves = behaves;\r\n  };\r\n\r\n  ModeController.mergeBehaviors = function (modeBehaviors, behaviors) {\r\n    (0, _util.each)(behaviors, function (behavior) {\r\n      if (modeBehaviors.indexOf(behavior) < 0) {\r\n        if ((0, _util.isString)(behavior)) {\r\n          behavior = {\r\n            type: behavior\r\n          };\r\n        }\r\n\r\n        modeBehaviors.push(behavior);\r\n      }\r\n    });\r\n    return modeBehaviors;\r\n  };\r\n\r\n  ModeController.filterBehaviors = function (modeBehaviors, behaviors) {\r\n    var result = [];\r\n    modeBehaviors.forEach(function (behavior) {\r\n      var type = '';\r\n\r\n      if ((0, _util.isString)(behavior)) {\r\n        type = behavior;\r\n      } else {\r\n        // eslint-disable-next-line prefer-destructuring\r\n        type = behavior.type;\r\n      }\r\n\r\n      if (behaviors.indexOf(type) < 0) {\r\n        result.push(behavior);\r\n      }\r\n    });\r\n    return result;\r\n  };\r\n\r\n  ModeController.prototype.setMode = function (mode) {\r\n    var _a = this,\r\n        modes = _a.modes,\r\n        graph = _a.graph;\r\n\r\n    var current = mode;\r\n    var behaviors = modes[current];\r\n\r\n    if (!behaviors) {\r\n      return;\r\n    }\r\n\r\n    graph.emit('beforemodechange', {\r\n      mode: mode\r\n    });\r\n    (0, _util.each)(this.currentBehaves, function (behave) {\r\n      if (behave.delegate) behave.delegate.remove();\r\n      behave.unbind(graph);\r\n    });\r\n    this.setBehaviors(current);\r\n    graph.emit('aftermodechange', {\r\n      mode: mode\r\n    });\r\n    this.mode = mode;\r\n  };\r\n\r\n  ModeController.prototype.getMode = function () {\r\n    return this.mode;\r\n  };\r\n  /**\r\n   * 动态增加或删除 Behavior\r\n   *\r\n   * @param {ModeType[]} behaviors\r\n   * @param {(ModeType[] | ModeType)} modes\r\n   * @param {boolean} isAdd\r\n   * @returns {Mode}\r\n   * @memberof Mode\r\n   */\r\n\r\n\r\n  ModeController.prototype.manipulateBehaviors = function (behaviors, modes, isAdd) {\r\n    var _this = this;\r\n\r\n    var behaves;\r\n\r\n    if (!(0, _util.isArray)(behaviors)) {\r\n      behaves = [behaviors];\r\n    } else {\r\n      behaves = behaviors;\r\n    }\r\n\r\n    if ((0, _util.isArray)(modes)) {\r\n      (0, _util.each)(modes, function (mode) {\r\n        if (!_this.modes[mode]) {\r\n          if (isAdd) {\r\n            _this.modes[mode] = behaves;\r\n          }\r\n        } else if (isAdd) {\r\n          _this.modes[mode] = ModeController.mergeBehaviors(_this.modes[mode] || [], behaves);\r\n        } else {\r\n          _this.modes[mode] = ModeController.filterBehaviors(_this.modes[mode] || [], behaves);\r\n        }\r\n      });\r\n      return this;\r\n    }\r\n\r\n    var currentMode = modes;\r\n\r\n    if (!modes) {\r\n      currentMode = this.mode; // isString(this.mode) ? this.mode : this.mode.type\r\n    }\r\n\r\n    if (!this.modes[currentMode]) {\r\n      if (isAdd) {\r\n        this.modes[currentMode] = behaves;\r\n      }\r\n    }\r\n\r\n    if (isAdd) {\r\n      this.modes[currentMode] = ModeController.mergeBehaviors(this.modes[currentMode] || [], behaves);\r\n    } else {\r\n      this.modes[currentMode] = ModeController.filterBehaviors(this.modes[currentMode] || [], behaves);\r\n    }\r\n\r\n    this.setMode(this.mode);\r\n    return this;\r\n  };\r\n  /**\r\n   * 更新行为参数\r\n   * @param {string | ModeOption | ModeType} behavior 需要更新的行为\r\n   * @param {string | string[]} modes 指定的模式中的行为，不指定则为 default\r\n   * @return {Graph} Graph\r\n   */\r\n\r\n\r\n  ModeController.prototype.updateBehavior = function (behavior, newCfg, mode) {\r\n    if ((0, _util.isString)(behavior)) {\r\n      behavior = {\r\n        type: behavior\r\n      };\r\n    }\r\n\r\n    var behaviorSet = [];\r\n\r\n    if (!mode || mode === this.mode || mode === 'default') {\r\n      behaviorSet = this.currentBehaves;\r\n\r\n      if (!behaviorSet || !behaviorSet.length) {\r\n        console.warn('Update behavior failed! There is no behaviors in this mode on the graph.');\r\n        return this;\r\n      }\r\n\r\n      var length_1 = behaviorSet.length;\r\n\r\n      for (var i = 0; i < length_1; i++) {\r\n        var behave = behaviorSet[i];\r\n\r\n        if (behave.type === behavior.type) {\r\n          behave.updateCfg(newCfg);\r\n          return this;\r\n        }\r\n\r\n        if (i === length_1 - 1) console.warn('Update behavior failed! There is no such behavior in the mode');\r\n      }\r\n    } else {\r\n      behaviorSet = this.modes[mode];\r\n\r\n      if (!behaviorSet || !behaviorSet.length) {\r\n        console.warn('Update behavior failed! There is no behaviors in this mode on the graph.');\r\n        return this;\r\n      }\r\n\r\n      var length_2 = behaviorSet.length;\r\n\r\n      for (var i = 0; i < length_2; i++) {\r\n        var behave = behaviorSet[i];\r\n\r\n        if (behave.type === behavior.type || behave === behavior.type) {\r\n          if (behave === behavior.type) behave = {\r\n            type: behave\r\n          };\r\n          Object.assign(behave, newCfg);\r\n          behaviorSet[i] = behave;\r\n          return this;\r\n        }\r\n\r\n        if (i === length_2 - 1) console.warn('Update behavior failed! There is no such behavior in the mode');\r\n      }\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  ModeController.prototype.destroy = function () {\r\n    this.graph = null;\r\n    this.modes = null;\r\n    this.currentBehaves = null;\r\n    this.destroyed = true;\r\n  };\r\n\r\n  return ModeController;\r\n}();\r\n\r\nvar _default = ModeController;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _domUtil = require(\"@antv/dom-util\");\r\n\r\nvar _base = require(\"../../util/base\");\r\n\r\nvar _math = require(\"../../util/math\");\r\n\r\nvar ViewController =\r\n/** @class */\r\nfunction () {\r\n  function ViewController(graph) {\r\n    this.destroyed = false;\r\n    this.graph = graph;\r\n    this.destroyed = false;\r\n  } // get view center coordinate\r\n\r\n\r\n  ViewController.prototype.getViewCenter = function () {\r\n    var padding = this.getFormatPadding();\r\n    var graph = this.graph;\r\n    var width = this.graph.get('width');\r\n    var height = graph.get('height');\r\n    return {\r\n      x: (width - padding[1] - padding[3]) / 2 + padding[3],\r\n      y: (height - padding[0] - padding[2]) / 2 + padding[0]\r\n    };\r\n  };\r\n\r\n  ViewController.prototype.fitCenter = function () {\r\n    var graph = this.graph;\r\n    var group = graph.get('group');\r\n    group.resetMatrix();\r\n    var bbox = group.getCanvasBBox();\r\n    if (bbox.width === 0 || bbox.height === 0) return;\r\n    var viewCenter = this.getViewCenter();\r\n    var groupCenter = {\r\n      x: bbox.x + bbox.width / 2,\r\n      y: bbox.y + bbox.height / 2\r\n    };\r\n    graph.translate(viewCenter.x - groupCenter.x, viewCenter.y - groupCenter.y);\r\n  }; // fit view graph\r\n\r\n\r\n  ViewController.prototype.fitView = function () {\r\n    var graph = this.graph;\r\n    var padding = this.getFormatPadding();\r\n    var width = graph.get('width');\r\n    var height = graph.get('height');\r\n    var group = graph.get('group');\r\n    group.resetMatrix();\r\n    var bbox = group.getCanvasBBox();\r\n    if (bbox.width === 0 || bbox.height === 0) return;\r\n    var viewCenter = this.getViewCenter();\r\n    var groupCenter = {\r\n      x: bbox.x + bbox.width / 2,\r\n      y: bbox.y + bbox.height / 2\r\n    };\r\n    graph.translate(viewCenter.x - groupCenter.x, viewCenter.y - groupCenter.y);\r\n    var w = (width - padding[1] - padding[3]) / bbox.width;\r\n    var h = (height - padding[0] - padding[2]) / bbox.height;\r\n    var ratio = w;\r\n\r\n    if (w > h) {\r\n      ratio = h;\r\n    }\r\n\r\n    graph.zoom(ratio, viewCenter);\r\n  };\r\n\r\n  ViewController.prototype.getFormatPadding = function () {\r\n    var padding = this.graph.get('fitViewPadding');\r\n    return (0, _base.formatPadding)(padding);\r\n  };\r\n\r\n  ViewController.prototype.focusPoint = function (point, animate, animateCfg) {\r\n    var _this = this;\r\n\r\n    var viewCenter = this.getViewCenter();\r\n    var modelCenter = this.getPointByCanvas(viewCenter.x, viewCenter.y);\r\n    var viewportMatrix = this.graph.get('group').getMatrix();\r\n    if (!viewportMatrix) viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n\r\n    if (animate) {\r\n      var dx_1 = (modelCenter.x - point.x) * viewportMatrix[0];\r\n      var dy_1 = (modelCenter.y - point.y) * viewportMatrix[4];\r\n      var lastX_1 = 0;\r\n      var lastY_1 = 0;\r\n      var newX_1 = 0;\r\n      var newY_1 = 0; // 动画每次平移一点，直到目标位置\r\n\r\n      this.graph.get('canvas').animate(function (ratio) {\r\n        newX_1 = dx_1 * ratio;\r\n        newY_1 = dy_1 * ratio;\r\n\r\n        _this.graph.translate(newX_1 - lastX_1, newY_1 - lastY_1);\r\n\r\n        lastX_1 = newX_1;\r\n        lastY_1 = newY_1;\r\n      }, (0, _tslib.__assign)({}, animateCfg));\r\n    } else {\r\n      this.graph.translate((modelCenter.x - point.x) * viewportMatrix[0], (modelCenter.y - point.y) * viewportMatrix[4]);\r\n    }\r\n  };\r\n  /**\r\n   * 将 Canvas 坐标转成视口坐标\r\n   * @param canvasX canvas x 坐标\r\n   * @param canvasY canvas y 坐标\r\n   */\r\n\r\n\r\n  ViewController.prototype.getPointByCanvas = function (canvasX, canvasY) {\r\n    var viewportMatrix = this.graph.get('group').getMatrix();\r\n\r\n    if (!viewportMatrix) {\r\n      viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n    }\r\n\r\n    var point = (0, _math.invertMatrix)({\r\n      x: canvasX,\r\n      y: canvasY\r\n    }, viewportMatrix);\r\n    return point;\r\n  };\r\n  /**\r\n   * 将页面坐标转成视口坐标\r\n   * @param clientX 页面 x 坐标\r\n   * @param clientY 页面 y 坐标\r\n   */\r\n\r\n\r\n  ViewController.prototype.getPointByClient = function (clientX, clientY) {\r\n    var canvas = this.graph.get('canvas');\r\n    var canvasPoint = canvas.getPointByClient(clientX, clientY);\r\n    return this.getPointByCanvas(canvasPoint.x, canvasPoint.y);\r\n  };\r\n  /**\r\n   * 将视口坐标转成页面坐标\r\n   * @param x 视口 x 坐标\r\n   * @param y 视口 y 坐标\r\n   */\r\n\r\n\r\n  ViewController.prototype.getClientByPoint = function (x, y) {\r\n    var canvas = this.graph.get('canvas');\r\n    var canvasPoint = this.getCanvasByPoint(x, y);\r\n    var point = canvas.getClientByPoint(canvasPoint.x, canvasPoint.y);\r\n    return {\r\n      x: point.x,\r\n      y: point.y\r\n    };\r\n  };\r\n  /**\r\n   * 将视口坐标转成 Canvas 坐标\r\n   * @param x 视口 x 坐标\r\n   * @param y 视口 y 坐标\r\n   */\r\n\r\n\r\n  ViewController.prototype.getCanvasByPoint = function (x, y) {\r\n    var viewportMatrix = this.graph.get('group').getMatrix();\r\n\r\n    if (!viewportMatrix) {\r\n      viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n    }\r\n\r\n    return (0, _math.applyMatrix)({\r\n      x: x,\r\n      y: y\r\n    }, viewportMatrix);\r\n  };\r\n  /**\r\n   * 将元素移动到画布中心\r\n   * @param item Item 实例或 id\r\n   * @param {boolean} animate 是否带有动画地移动\r\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\r\n   */\r\n\r\n\r\n  ViewController.prototype.focus = function (item, animate, animateCfg) {\r\n    if ((0, _util.isString)(item)) {\r\n      item = this.graph.findById(item);\r\n    }\r\n\r\n    if (item) {\r\n      var x = 0,\r\n          y = 0;\r\n\r\n      if (item.getType && item.getType() === 'edge') {\r\n        var sourceMatrix = item.getSource().get('group').getMatrix();\r\n        var targetMatrix = item.getTarget().get('group').getMatrix();\r\n\r\n        if (sourceMatrix && targetMatrix) {\r\n          x = (sourceMatrix[6] + targetMatrix[6]) / 2;\r\n          y = (sourceMatrix[7] + targetMatrix[7]) / 2;\r\n        } else if (sourceMatrix || targetMatrix) {\r\n          x = sourceMatrix ? sourceMatrix[6] : targetMatrix[6];\r\n          y = sourceMatrix ? sourceMatrix[7] : targetMatrix[7];\r\n        }\r\n      } else {\r\n        var group = item.get('group');\r\n        var matrix = group.getMatrix();\r\n        if (!matrix) matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n        x = matrix[6];\r\n        y = matrix[7];\r\n      } // 用实际位置而不是model中的x,y,防止由于拖拽等的交互导致model的x,y并不是当前的x,y\r\n\r\n\r\n      this.focusPoint({\r\n        x: x,\r\n        y: y\r\n      }, animate, animateCfg);\r\n    }\r\n  };\r\n  /**\r\n   * 改变 canvas 画布的宽度和高度\r\n   * @param width canvas 宽度\r\n   * @param height canvas 高度\r\n   */\r\n\r\n\r\n  ViewController.prototype.changeSize = function (width, height) {\r\n    var graph = this.graph;\r\n\r\n    if (!(0, _util.isNumber)(width) || !(0, _util.isNumber)(height)) {\r\n      throw Error('invalid canvas width & height, please make sure width & height type is number');\r\n    }\r\n\r\n    graph.set({\r\n      width: width,\r\n      height: height\r\n    });\r\n    var canvas = graph.get('canvas');\r\n    canvas.changeSize(width, height); // change the size of grid plugin if it exists on graph\r\n\r\n    var plugins = graph.get('plugins');\r\n    plugins.forEach(function (plugin) {\r\n      if (plugin.get('gridContainer')) {\r\n        var minZoom = graph.get('minZoom');\r\n        (0, _domUtil.modifyCSS)(plugin.get('container'), {\r\n          width: width + \"px\",\r\n          height: height + \"px\"\r\n        });\r\n        (0, _domUtil.modifyCSS)(plugin.get('gridContainer'), {\r\n          width: width / minZoom + \"px\",\r\n          height: height / minZoom + \"px\",\r\n          left: 0,\r\n          top: 0\r\n        });\r\n      }\r\n    });\r\n  };\r\n\r\n  ViewController.prototype.destroy = function () {\r\n    this.graph = null;\r\n    this.destroyed = false;\r\n  };\r\n\r\n  return ViewController;\r\n}();\r\n\r\nvar _default = ViewController;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.processParallelEdges = exports.calculationItemsBBox = exports.isNaN = exports.isViewportChanged = exports.cloneEvent = exports.formatPadding = exports.uniqueId = void 0;\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _behavior = require(\"../interface/behavior\");\r\n\r\nvar uniqueId = function uniqueId(type) {\r\n  return type + \"-\" + Math.random() + Date.now();\r\n};\r\n/**\r\n * turn padding into [top, right, bottom, right]\r\n * @param  {Number|Array} padding input padding\r\n * @return {array} output\r\n */\r\n\r\n\r\nexports.uniqueId = uniqueId;\r\n\r\nvar formatPadding = function formatPadding(padding) {\r\n  var top = 0;\r\n  var left = 0;\r\n  var right = 0;\r\n  var bottom = 0;\r\n\r\n  if ((0, _util.isNumber)(padding)) {\r\n    top = left = right = bottom = padding;\r\n  } else if ((0, _util.isString)(padding)) {\r\n    var intPadding = parseInt(padding, 10);\r\n    top = left = right = bottom = intPadding;\r\n  } else if ((0, _util.isArray)(padding)) {\r\n    top = padding[0];\r\n    right = !(0, _util.isNil)(padding[1]) ? padding[1] : padding[0];\r\n    bottom = !(0, _util.isNil)(padding[2]) ? padding[2] : padding[0];\r\n    left = !(0, _util.isNil)(padding[3]) ? padding[3] : right;\r\n  }\r\n\r\n  return [top, right, bottom, left];\r\n};\r\n/**\r\n * clone event\r\n * @param e\r\n */\r\n\r\n\r\nexports.formatPadding = formatPadding;\r\n\r\nvar cloneEvent = function cloneEvent(e) {\r\n  var event = new _behavior.G6GraphEvent(e.type, e);\r\n  event.clientX = e.clientX;\r\n  event.clientY = e.clientY;\r\n  event.x = e.x;\r\n  event.y = e.y;\r\n  event.target = e.target;\r\n  event.currentTarget = e.currentTarget;\r\n  event.bubbles = true;\r\n  event.item = e.item;\r\n  return event;\r\n};\r\n/**\r\n * 判断 viewport 是否改变，通过和单位矩阵对比\r\n * @param matrix Viewport 的 Matrix\r\n */\r\n\r\n\r\nexports.cloneEvent = cloneEvent;\r\n\r\nvar isViewportChanged = function isViewportChanged(matrix) {\r\n  // matrix 为 null， 则说明没有变化\r\n  if (!matrix) {\r\n    return false;\r\n  }\r\n\r\n  var MATRIX_LEN = 9;\r\n  var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n\r\n  for (var i = 0; i < MATRIX_LEN; i++) {\r\n    if (matrix[i] !== ORIGIN_MATRIX[i]) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexports.isViewportChanged = isViewportChanged;\r\n\r\nvar isNaN = function isNaN(input) {\r\n  return Number.isNaN(Number(input));\r\n};\r\n/**\r\n * 计算一组 Item 的 BBox\r\n * @param items 选中的一组Item，可以是 node 或 combo\r\n */\r\n\r\n\r\nexports.isNaN = isNaN;\r\n\r\nvar calculationItemsBBox = function calculationItemsBBox(items) {\r\n  var minx = Infinity;\r\n  var maxx = -Infinity;\r\n  var miny = Infinity;\r\n  var maxy = -Infinity; // 获取已节点的所有最大最小x y值\r\n\r\n  for (var i = 0; i < items.length; i++) {\r\n    var element = items[i];\r\n    var bbox = element.getBBox();\r\n    var minX = bbox.minX,\r\n        minY = bbox.minY,\r\n        maxX = bbox.maxX,\r\n        maxY = bbox.maxY;\r\n\r\n    if (minX < minx) {\r\n      minx = minX;\r\n    }\r\n\r\n    if (minY < miny) {\r\n      miny = minY;\r\n    }\r\n\r\n    if (maxX > maxx) {\r\n      maxx = maxX;\r\n    }\r\n\r\n    if (maxY > maxy) {\r\n      maxy = maxY;\r\n    }\r\n  }\r\n\r\n  var x = Math.floor(minx);\r\n  var y = Math.floor(miny);\r\n  var width = Math.ceil(maxx) - Math.floor(minx);\r\n  var height = Math.ceil(maxy) - Math.floor(miny);\r\n  return {\r\n    x: x,\r\n    y: y,\r\n    width: width,\r\n    height: height,\r\n    minX: minx,\r\n    minY: miny,\r\n    maxX: maxx,\r\n    maxY: maxy\r\n  };\r\n};\r\n/**\r\n * 若 edges 中存在两端点相同的边，使用 quadratic 边并自动计算 curveOffset 使它们不相互重叠\r\n * 文档: https://g6.antv.vision/en/docs/api/Util\r\n * @param edges 边数据集合\r\n * @param offsetDiff 相邻两边的 offset 之差\r\n * @param multiEdgeType\r\n * @param singleEdgeType\r\n * @param loopEdgeType\r\n */\r\n\r\n\r\nexports.calculationItemsBBox = calculationItemsBBox;\r\n\r\nvar processParallelEdges = function processParallelEdges(edges, offsetDiff, multiEdgeType, singleEdgeType, loopEdgeType) {\r\n  if (offsetDiff === void 0) {\r\n    offsetDiff = 15;\r\n  }\r\n\r\n  if (multiEdgeType === void 0) {\r\n    multiEdgeType = 'quadratic';\r\n  }\r\n\r\n  if (singleEdgeType === void 0) {\r\n    singleEdgeType = undefined;\r\n  }\r\n\r\n  if (loopEdgeType === void 0) {\r\n    loopEdgeType = undefined;\r\n  }\r\n\r\n  var len = edges.length;\r\n  var cod = offsetDiff * 2;\r\n  var loopPosition = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];\r\n  var edgeMap = {};\r\n  var tags = [];\r\n  var reverses = {};\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    var edge = edges[i];\r\n    var source = edge.source,\r\n        target = edge.target;\r\n    var sourceTarget = source + \"-\" + target;\r\n    if (tags[i]) continue;\r\n\r\n    if (!edgeMap[sourceTarget]) {\r\n      edgeMap[sourceTarget] = [];\r\n    }\r\n\r\n    tags[i] = true;\r\n    edgeMap[sourceTarget].push(edge);\r\n\r\n    for (var j = 0; j < len; j++) {\r\n      if (i === j) continue;\r\n      var sedge = edges[j];\r\n      var src = sedge.source;\r\n      var dst = sedge.target; // 两个节点之间共同的边\r\n      // 第一条的source = 第二条的target\r\n      // 第一条的target = 第二条的source\r\n\r\n      if (!tags[j]) {\r\n        if (source === dst && target === src) {\r\n          edgeMap[sourceTarget].push(sedge);\r\n          tags[j] = true;\r\n          reverses[src + \"|\" + dst + \"|\" + (edgeMap[sourceTarget].length - 1)] = true;\r\n        } else if (source === src && target === dst) {\r\n          edgeMap[sourceTarget].push(sedge);\r\n          tags[j] = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  for (var key in edgeMap) {\r\n    var arcEdges = edgeMap[key];\r\n    var length_1 = arcEdges.length;\r\n\r\n    for (var k = 0; k < length_1; k++) {\r\n      var current = arcEdges[k];\r\n\r\n      if (current.source === current.target) {\r\n        if (loopEdgeType) current.type = loopEdgeType; // 超过8条自环边，则需要重新处理\r\n\r\n        current.loopCfg = {\r\n          position: loopPosition[k % 8],\r\n          dist: Math.floor(k / 8) * 20 + 50\r\n        };\r\n        continue;\r\n      }\r\n\r\n      if (length_1 === 1 && singleEdgeType && current.source !== current.target) {\r\n        current.type = singleEdgeType;\r\n        continue;\r\n      }\r\n\r\n      current.type = multiEdgeType;\r\n      var sign = (k % 2 === 0 ? 1 : -1) * (reverses[current.source + \"|\" + current.target + \"|\" + k] ? -1 : 1);\r\n\r\n      if (length_1 % 2 === 1) {\r\n        current.curveOffset = sign * Math.ceil(k / 2) * cod;\r\n      } else {\r\n        current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\r\n      }\r\n    }\r\n  }\r\n\r\n  return edges;\r\n};\r\n\r\nexports.processParallelEdges = processParallelEdges;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.G6GraphEvent = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _gBase = require(\"@antv/g-base\");\r\n\r\nvar G6GraphEvent =\r\n/** @class */\r\nfunction (_super) {\r\n  (0, _tslib.__extends)(G6GraphEvent, _super);\r\n\r\n  function G6GraphEvent(type, event) {\r\n    var _this = _super.call(this, type, event) || this;\r\n\r\n    _this.item = event.item;\r\n    _this.canvasX = event.canvasX;\r\n    _this.canvasY = event.canvasY;\r\n    _this.wheelDelta = event.wheelDelta;\r\n    _this.detail = event.detail;\r\n    return _this;\r\n  }\r\n\r\n  return G6GraphEvent;\r\n}(_gBase.Event);\r\n\r\nexports.G6GraphEvent = G6GraphEvent;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _edge = _interopRequireDefault(require(\"../../item/edge\"));\r\n\r\nvar _node = _interopRequireDefault(require(\"../../item/node\"));\r\n\r\nvar _combo = _interopRequireDefault(require(\"../../item/combo\"));\r\n\r\nvar _graphic = require(\"../../util/graphic\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar NODE = 'node';\r\nvar EDGE = 'edge';\r\nvar VEDGE = 'vedge';\r\nvar COMBO = 'combo';\r\nvar CFG_PREFIX = 'default';\r\nvar MAPPER_SUFFIX = 'Mapper';\r\nvar STATE_SUFFIX = 'stateStyles';\r\n\r\nvar ItemController =\r\n/** @class */\r\nfunction () {\r\n  function ItemController(graph) {\r\n    this.graph = graph;\r\n    this.destroyed = false;\r\n  }\r\n  /**\r\n   * 增加 Item 实例\r\n   *\r\n   * @param {ITEM_TYPE} type 实例类型，node 或 edge\r\n   * @param {(NodeConfig & EdgeConfig)} model 数据模型\r\n   * @returns {(Item)}\r\n   * @memberof ItemController\r\n   */\r\n\r\n\r\n  ItemController.prototype.addItem = function (type, model) {\r\n    var graph = this.graph;\r\n    var vType = type === VEDGE ? EDGE : type;\r\n    var parent = graph.get(vType + \"Group\") || graph.get('group');\r\n    var upperType = (0, _util.upperFirst)(vType);\r\n    var item = null; // 获取 this.get('styles') 中的值\r\n\r\n    var styles = graph.get(vType + (0, _util.upperFirst)(STATE_SUFFIX)) || {};\r\n    var defaultModel = graph.get(CFG_PREFIX + upperType);\r\n\r\n    if (model[STATE_SUFFIX]) {\r\n      // 设置 this.get('styles') 中的值\r\n      styles = model[STATE_SUFFIX];\r\n    }\r\n\r\n    if (defaultModel) {\r\n      // 很多布局会直接修改原数据模型，所以不能用 merge 的形式，逐个写入原 model 中\r\n      (0, _util.each)(defaultModel, function (val, cfg) {\r\n        if ((0, _util.isObject)(val) && !(0, _util.isArray)(val)) {\r\n          model[cfg] = (0, _util.deepMix)({}, val, model[cfg]);\r\n        } else if ((0, _util.isArray)(val)) {\r\n          model[cfg] = model[cfg] || (0, _util.clone)(defaultModel[cfg]);\r\n        } else {\r\n          model[cfg] = model[cfg] || defaultModel[cfg];\r\n        }\r\n      });\r\n    }\r\n\r\n    var mapper = graph.get(vType + MAPPER_SUFFIX);\r\n\r\n    if (mapper) {\r\n      var mappedModel_1 = mapper(model);\r\n\r\n      if (mappedModel_1[STATE_SUFFIX]) {\r\n        // 设置 this.get('styles') 中的值\r\n        styles = mappedModel_1[STATE_SUFFIX];\r\n        delete mappedModel_1[STATE_SUFFIX];\r\n      } // 如果配置了 defaultEdge 或 defaultNode，则将默认配置的数据也合并进去\r\n\r\n\r\n      (0, _util.each)(mappedModel_1, function (val, cfg) {\r\n        if ((0, _util.isObject)(val) && !(0, _util.isArray)(val)) {\r\n          model[cfg] = (0, _util.deepMix)({}, model[cfg], val);\r\n        } else {\r\n          model[cfg] = mappedModel_1[cfg] || model[cfg];\r\n        }\r\n      });\r\n    }\r\n\r\n    graph.emit('beforeadditem', {\r\n      type: type,\r\n      model: model\r\n    });\r\n\r\n    if (type === EDGE || type === VEDGE) {\r\n      var source = void 0;\r\n      var target = void 0;\r\n      source = model.source; // eslint-disable-line prefer-destructuring\r\n\r\n      target = model.target; // eslint-disable-line prefer-destructuring\r\n\r\n      if (source && (0, _util.isString)(source)) {\r\n        source = graph.findById(source);\r\n      }\r\n\r\n      if (target && (0, _util.isString)(target)) {\r\n        target = graph.findById(target);\r\n      }\r\n\r\n      if (!source || !target) {\r\n        console.warn(\"The source or target node of edge \" + model.id + \" does not exist!\");\r\n        return;\r\n      }\r\n\r\n      if (source.getType && source.getType() === 'combo') {\r\n        model.isComboEdge = true; // graph.updateCombo(source as ICombo);\r\n      }\r\n\r\n      if (target.getType && target.getType() === 'combo') {\r\n        model.isComboEdge = true; // graph.updateCombo(target as ICombo);\r\n      }\r\n\r\n      item = new _edge.default({\r\n        model: model,\r\n        source: source,\r\n        target: target,\r\n        styles: styles,\r\n        linkCenter: graph.get('linkCenter'),\r\n        group: parent.addGroup()\r\n      });\r\n    } else if (type === NODE) {\r\n      item = new _node.default({\r\n        model: model,\r\n        styles: styles,\r\n        group: parent.addGroup()\r\n      });\r\n    } else if (type === COMBO) {\r\n      var children = model.children;\r\n      var comboBBox = (0, _graphic.getComboBBox)(children, graph);\r\n      if (!isNaN(comboBBox.x)) model.x = comboBBox.x;else if (isNaN(model.x)) model.x = Math.random() * 100;\r\n      if (!isNaN(comboBBox.y)) model.y = comboBBox.y;else if (isNaN(model.y)) model.y = Math.random() * 100;\r\n      var comboGroup = parent.addGroup();\r\n      comboGroup.setZIndex(model.depth);\r\n      item = new _combo.default({\r\n        model: model,\r\n        styles: styles,\r\n        bbox: model.collapsed ? (0, _graphic.getComboBBox)([], graph) : comboBBox,\r\n        group: comboGroup\r\n      });\r\n      var comboModel_1 = item.getModel();\r\n      (children || []).forEach(function (child) {\r\n        var childItem = graph.findById(child.id);\r\n        item.addChild(childItem);\r\n        child.depth = comboModel_1.depth + 2;\r\n      }); // collapse the combo if the collapsed is true in the model\r\n\r\n      if (model.collapsed) {\r\n        setTimeout(function () {\r\n          graph.collapseCombo(item);\r\n        }, 16);\r\n      }\r\n    }\r\n\r\n    if (item) {\r\n      graph.get(type + \"s\").push(item);\r\n      graph.get('itemMap')[item.get('id')] = item;\r\n      graph.emit('afteradditem', {\r\n        item: item,\r\n        model: model\r\n      }); // eslint-disable-next-line consistent-return\r\n\r\n      return item;\r\n    }\r\n  };\r\n  /**\r\n   * 更新节点或边\r\n   *\r\n   * @param {Item} item ID 或 实例\r\n   * @param {(EdgeConfig | Partial<NodeConfig>)} cfg 数据模型\r\n   * @returns\r\n   * @memberof ItemController\r\n   */\r\n\r\n\r\n  ItemController.prototype.updateItem = function (item, cfg) {\r\n    var _a, _b;\r\n\r\n    var graph = this.graph;\r\n\r\n    if ((0, _util.isString)(item)) {\r\n      item = graph.findById(item);\r\n    }\r\n\r\n    if (!item || item.destroyed) {\r\n      return;\r\n    } // 更新的 item 的类型\r\n\r\n\r\n    var type = '';\r\n    if (item.getType) type = item.getType();\r\n    var mapper = graph.get(type + MAPPER_SUFFIX);\r\n    var model = item.getModel();\r\n    var isOnlyMove = item.isOnlyMove(cfg);\r\n\r\n    if (mapper) {\r\n      var result = (0, _util.deepMix)({}, model, cfg);\r\n      var mappedModel = mapper(result); // 将 update 时候用户传入的参数与mapperModel做deepMix，以便复用之前设置的参数值\r\n\r\n      var newModel = (0, _util.deepMix)({}, model, mappedModel, cfg);\r\n\r\n      if (mappedModel[STATE_SUFFIX]) {\r\n        item.set('styles', newModel[STATE_SUFFIX]);\r\n        delete newModel[STATE_SUFFIX];\r\n      }\r\n\r\n      (0, _util.each)(newModel, function (val, key) {\r\n        cfg[key] = val;\r\n      });\r\n    } else {\r\n      // merge update传进来的对象参数，model中没有的数据不做处理，对象和字符串值也不做处理，直接替换原来的\r\n      (0, _util.each)(cfg, function (val, key) {\r\n        if (model[key]) {\r\n          if ((0, _util.isObject)(val) && !(0, _util.isArray)(val)) {\r\n            cfg[key] = (0, _tslib.__assign)((0, _tslib.__assign)({}, model[key]), cfg[key]);\r\n          }\r\n        }\r\n      });\r\n    } // emit beforeupdateitem 事件\r\n\r\n\r\n    graph.emit('beforeupdateitem', {\r\n      item: item,\r\n      cfg: cfg\r\n    });\r\n\r\n    if (type === EDGE) {\r\n      // 若是边要更新source || target, 为了不影响示例内部model，并且重新计算startPoint和endPoint，手动设置\r\n      if (cfg.source) {\r\n        var source = cfg.source;\r\n\r\n        if ((0, _util.isString)(source)) {\r\n          source = graph.findById(source);\r\n        }\r\n\r\n        item.setSource(source);\r\n      }\r\n\r\n      if (cfg.target) {\r\n        var target = cfg.target;\r\n\r\n        if ((0, _util.isString)(target)) {\r\n          target = graph.findById(target);\r\n        }\r\n\r\n        item.setTarget(target);\r\n      }\r\n\r\n      item.update(cfg);\r\n    } // item.update(cfg);\r\n\r\n\r\n    if (type === NODE || type === COMBO) {\r\n      item.update(cfg, isOnlyMove);\r\n      var edges_1 = item.getEdges();\r\n      var refreshEdge = (0, _graphic.shouldRefreshEdge)(cfg);\r\n      if (refreshEdge && type === NODE) (0, _util.each)(edges_1, function (edge) {\r\n        edge.refresh();\r\n      });else if (refreshEdge && type === COMBO) {\r\n        var shapeFactory = item.get('shapeFactory');\r\n        var shapeType = model.type || 'circle';\r\n        var comboAnimate = model.animate === undefined || cfg.animate === undefined ? (_b = (_a = shapeFactory[shapeType]) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.animate : model.animate || cfg.animate;\r\n\r\n        if (comboAnimate) {\r\n          setTimeout(function () {\r\n            if (!item || item.destroyed) return;\r\n            var keyShape = item.getKeyShape();\r\n            if (!keyShape || keyShape.destroyed) return;\r\n            (0, _util.each)(edges_1, function (edge) {\r\n              if (edge && !edge.destroyed) edge.refresh();\r\n            });\r\n          }, 201);\r\n        } else {\r\n          (0, _util.each)(edges_1, function (edge) {\r\n            edge.refresh();\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    graph.emit('afterupdateitem', {\r\n      item: item,\r\n      cfg: cfg\r\n    });\r\n  };\r\n  /**\r\n   * 根据 combo 的子元素更新 combo 的位置及大小\r\n   *\r\n   * @param {ICombo} combo ID 或 实例\r\n   * @returns\r\n   * @memberof ItemController\r\n   */\r\n\r\n\r\n  ItemController.prototype.updateCombo = function (combo, children) {\r\n    var _this = this;\r\n\r\n    var _a, _b;\r\n\r\n    var graph = this.graph;\r\n\r\n    if ((0, _util.isString)(combo)) {\r\n      combo = graph.findById(combo);\r\n    }\r\n\r\n    if (!combo || combo.destroyed) {\r\n      return;\r\n    }\r\n\r\n    var model = combo.getModel();\r\n    var comboBBox = (0, _graphic.getComboBBox)(model.collapsed ? [] : children, graph);\r\n    combo.set('bbox', comboBBox);\r\n    combo.update({\r\n      x: comboBBox.x,\r\n      y: comboBBox.y\r\n    });\r\n    var shapeFactory = combo.get('shapeFactory');\r\n    var shapeType = model.type || 'circle';\r\n    var comboAnimate = model.animate === undefined ? (_b = (_a = shapeFactory[shapeType]) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.animate : model.animate;\r\n\r\n    if (comboAnimate) {\r\n      setTimeout(function () {\r\n        if (!combo || combo.destroyed) return;\r\n        var keyShape = combo.getKeyShape();\r\n        if (!keyShape || keyShape.destroyed) return;\r\n        combo.getShapeCfg(model); // 更新 combo 缓存的 size\r\n\r\n        _this.updateComboEdges(combo);\r\n      }, 201);\r\n    } else {\r\n      this.updateComboEdges(combo);\r\n    }\r\n  };\r\n\r\n  ItemController.prototype.updateComboEdges = function (combo) {\r\n    var combEdges = combo.getEdges() || [];\r\n\r\n    for (var i = 0; i < combEdges.length; i++) {\r\n      var edge = combEdges[i];\r\n\r\n      if (edge && !edge.destroyed) {\r\n        var edgeSF = edge.get('shapeFactory');\r\n        var edgeCfg = edge.getShapeCfg(edge.getModel());\r\n        var edgeGroup = edge.getContainer();\r\n        edgeGroup.clear();\r\n        var keyShape = edgeSF.draw(edgeCfg.type, edgeCfg, edgeGroup);\r\n        edge.set('keyShape', keyShape);\r\n        keyShape.set('isKeyShape', true);\r\n        keyShape.set('draggable', true);\r\n        edge.setOriginStyle();\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * 收起 combo，隐藏相关元素\r\n   */\r\n\r\n\r\n  ItemController.prototype.collapseCombo = function (combo) {\r\n    var graph = this.graph;\r\n\r\n    if ((0, _util.isString)(combo)) {\r\n      combo = graph.findById(combo);\r\n    }\r\n\r\n    var children = combo.getChildren();\r\n    children.nodes.forEach(function (node) {\r\n      graph.hideItem(node);\r\n    });\r\n    children.combos.forEach(function (c) {\r\n      graph.hideItem(c);\r\n    });\r\n  };\r\n  /**\r\n   * 展开 combo，相关元素出现\r\n   * 若子 combo 原先是收起状态，则保持它的收起状态\r\n   */\r\n\r\n\r\n  ItemController.prototype.expandCombo = function (combo) {\r\n    var graph = this.graph;\r\n\r\n    if ((0, _util.isString)(combo)) {\r\n      combo = graph.findById(combo);\r\n    }\r\n\r\n    var children = combo.getChildren();\r\n    children.nodes.forEach(function (node) {\r\n      graph.showItem(node);\r\n    });\r\n    children.combos.forEach(function (c) {\r\n      if (c.getModel().collapsed) {\r\n        c.show();\r\n      } else {\r\n        graph.showItem(c);\r\n      }\r\n    });\r\n  };\r\n  /**\r\n   * 删除指定的节点或边\r\n   *\r\n   * @param {Item} item item ID 或实例\r\n   * @returns {void}\r\n   * @memberof ItemController\r\n   */\r\n\r\n\r\n  ItemController.prototype.removeItem = function (item) {\r\n    var _this = this;\r\n\r\n    var graph = this.graph;\r\n\r\n    if ((0, _util.isString)(item)) {\r\n      item = graph.findById(item);\r\n    }\r\n\r\n    if (!item || item.destroyed) {\r\n      return;\r\n    }\r\n\r\n    var itemModel = (0, _util.clone)(item.getModel());\r\n    graph.emit('beforeremoveitem', {\r\n      item: itemModel\r\n    });\r\n    var type = '';\r\n    if (item.getType) type = item.getType();\r\n    var items = graph.get(type + \"s\");\r\n    var index = items.indexOf(item);\r\n    if (index > -1) items.splice(index, 1);\r\n\r\n    if (type === EDGE) {\r\n      var vitems = graph.get(\"v\" + type + \"s\");\r\n      var vindex = vitems.indexOf(item);\r\n      if (vindex > -1) vitems.splice(vindex, 1);\r\n    }\r\n\r\n    var itemId = item.get('id');\r\n    var itemMap = graph.get('itemMap');\r\n    delete itemMap[itemId];\r\n    var comboTrees = graph.get('comboTrees');\r\n    var id = item.get('id');\r\n\r\n    if (type === NODE) {\r\n      var comboId = item.getModel().comboId;\r\n\r\n      if (comboTrees && comboId) {\r\n        var brothers_1 = comboTrees;\r\n        var found_1 = false; // the flag to terminate the forEach circulation\r\n        // remove the node from the children array of its parent fromt he tree\r\n\r\n        comboTrees.forEach(function (ctree) {\r\n          if (found_1) return;\r\n          (0, _graphic.traverseTree)(ctree, function (combo) {\r\n            if (combo.id === id && brothers_1) {\r\n              var bidx = brothers_1.indexOf(combo);\r\n              brothers_1.splice(bidx, 1);\r\n              found_1 = true;\r\n              return false; // terminate the traverse\r\n            }\r\n\r\n            brothers_1 = combo.children;\r\n            return true;\r\n          });\r\n        });\r\n      } // 若移除的是节点，需要将与之相连的边一同删除\r\n\r\n\r\n      var edges = item.getEdges();\r\n\r\n      for (var i = edges.length - 1; i >= 0; i--) {\r\n        graph.removeItem(edges[i], false);\r\n      }\r\n\r\n      if (comboId) graph.updateCombo(comboId);\r\n    } else if (type === COMBO) {\r\n      var parentId = item.getModel().parentId;\r\n      var comboInTree_1; // find the subtree rooted at the item to be removed\r\n\r\n      var found_2 = false; // the flag to terminate the forEach circulation\r\n\r\n      (comboTrees || []).forEach(function (ctree) {\r\n        if (found_2) return;\r\n        (0, _graphic.traverseTree)(ctree, function (combo) {\r\n          if (combo.id === id) {\r\n            comboInTree_1 = combo;\r\n            found_2 = true;\r\n            return false; // terminate the traverse\r\n          }\r\n\r\n          return true;\r\n        });\r\n      });\r\n      comboInTree_1.removed = true;\r\n\r\n      if (comboInTree_1 && comboInTree_1.children) {\r\n        comboInTree_1.children.forEach(function (child) {\r\n          _this.removeItem(child.id);\r\n        });\r\n      } // 若移除的是 combo，需要将与之相连的边一同删除\r\n\r\n\r\n      var edges = item.getEdges();\r\n\r\n      for (var i = edges.length; i >= 0; i--) {\r\n        graph.removeItem(edges[i], false);\r\n      }\r\n\r\n      if (parentId) graph.updateCombo(parentId);\r\n    }\r\n\r\n    item.destroy();\r\n    graph.emit('afterremoveitem', {\r\n      item: itemModel\r\n    });\r\n  };\r\n  /**\r\n   * 更新 item 状态\r\n   *\r\n   * @param {Item} item Item 实例\r\n   * @param {string} state 状态名称\r\n   * @param {boolean} value 是否启用状态或状态值\r\n   * @returns {void}\r\n   * @memberof ItemController\r\n   */\r\n\r\n\r\n  ItemController.prototype.setItemState = function (item, state, value) {\r\n    var graph = this.graph;\r\n    var stateName = state;\r\n\r\n    if ((0, _util.isString)(value)) {\r\n      stateName = state + \":\" + value;\r\n    } // 已经存在要设置的 state，或不存在 state 的样式为 undefined\r\n\r\n\r\n    if (item.hasState(stateName) === value && value || // 当该状态已经存在且现在需要设置为 true 时，不需要继续。当该状态不存在，且设置为 false 时，需要继续\r\n    (0, _util.isString)(value) && item.hasState(stateName)) {\r\n      // 当该状态 value 是字符串，且已经存在该状态，不需要继续\r\n      return;\r\n    }\r\n\r\n    graph.emit('beforeitemstatechange', {\r\n      item: item,\r\n      state: stateName,\r\n      enabled: value\r\n    });\r\n    item.setState(state, value);\r\n    graph.autoPaint();\r\n    graph.emit('afteritemstatechange', {\r\n      item: item,\r\n      state: stateName,\r\n      enabled: value\r\n    });\r\n  };\r\n  /**\r\n   * 将指定状态的优先级提升为最高优先级\r\n   * @param {Item} item 元素id或元素实例\r\n   * @param state 状态名称\r\n   */\r\n\r\n\r\n  ItemController.prototype.priorityState = function (item, state) {\r\n    var graph = this.graph;\r\n    var currentItem = item;\r\n\r\n    if ((0, _util.isString)(item)) {\r\n      currentItem = graph.findById(item);\r\n    } // 先取消已有的 state\r\n\r\n\r\n    this.setItemState(currentItem, state, false); // 再设置state，则此时该优先级为最高\r\n\r\n    this.setItemState(currentItem, state, true);\r\n  };\r\n  /**\r\n   * 清除所有指定的状态\r\n   *\r\n   * @param {Item} item Item 实例\r\n   * @param {string[]} states 状态名称集合\r\n   * @memberof ItemController\r\n   */\r\n\r\n\r\n  ItemController.prototype.clearItemStates = function (item, states) {\r\n    var graph = this.graph;\r\n\r\n    if ((0, _util.isString)(item)) {\r\n      item = graph.findById(item);\r\n    }\r\n\r\n    graph.emit('beforeitemstatesclear', {\r\n      item: item,\r\n      states: states\r\n    });\r\n    item.clearStates(states);\r\n    graph.emit('afteritemstatesclear', {\r\n      item: item,\r\n      states: states\r\n    });\r\n  };\r\n  /**\r\n   * 刷新指定的 Item\r\n   *\r\n   * @param {Item} item Item ID 或 实例\r\n   * @memberof ItemController\r\n   */\r\n\r\n\r\n  ItemController.prototype.refreshItem = function (item) {\r\n    var graph = this.graph;\r\n\r\n    if ((0, _util.isString)(item)) {\r\n      item = graph.findById(item);\r\n    }\r\n\r\n    graph.emit('beforeitemrefresh', {\r\n      item: item\r\n    }); // 调用 Item 的 refresh 方法，实现刷新功能\r\n\r\n    item.refresh();\r\n    graph.emit('afteritemrefresh', {\r\n      item: item\r\n    });\r\n  };\r\n  /**\r\n   * 根据 graph 上用 combos 数据生成的 comboTree 来增加所有 combos\r\n   *\r\n   * @param {ComboTree[]} comboTrees graph 上用 combos 数据生成的 comboTree\r\n   * @param {ComboConfig[]} comboModels combos 数据\r\n   * @memberof ItemController\r\n   */\r\n\r\n\r\n  ItemController.prototype.addCombos = function (comboTrees, comboModels) {\r\n    var _this = this;\r\n\r\n    var graph = this.graph;\r\n    (comboTrees || []).forEach(function (ctree) {\r\n      (0, _graphic.traverseTreeUp)(ctree, function (child) {\r\n        var comboModel;\r\n        comboModels.forEach(function (model) {\r\n          if (model.id === child.id) {\r\n            model.children = child.children;\r\n            model.depth = child.depth;\r\n            comboModel = model;\r\n          }\r\n        });\r\n\r\n        if (comboModel) {\r\n          _this.addItem('combo', comboModel);\r\n        }\r\n\r\n        return true;\r\n      });\r\n    });\r\n    var comboGroup = graph.get('comboGroup');\r\n    if (comboGroup) comboGroup.sort();\r\n  };\r\n  /**\r\n   * 改变Item的显示状态\r\n   *\r\n   * @param {Item} item Item ID 或 实例\r\n   * @param {boolean} visible 是否显示\r\n   * @memberof ItemController\r\n   */\r\n\r\n\r\n  ItemController.prototype.changeItemVisibility = function (item, visible) {\r\n    var _this = this;\r\n\r\n    var graph = this.graph;\r\n\r\n    if ((0, _util.isString)(item)) {\r\n      item = graph.findById(item);\r\n    }\r\n\r\n    if (!item) {\r\n      console.warn('The item to be shown or hidden does not exist!');\r\n      return;\r\n    }\r\n\r\n    graph.emit('beforeitemvisibilitychange', {\r\n      item: item,\r\n      visible: visible\r\n    });\r\n    item.changeVisibility(visible);\r\n\r\n    if (item.getType && item.getType() === NODE) {\r\n      var edges = item.getEdges();\r\n      (0, _util.each)(edges, function (edge) {\r\n        // 若隐藏节点，则将与之关联的边也隐藏\r\n        // 若显示节点，则将与之关联的边也显示，但是需要判断边两端的节点都是可见的\r\n        if (visible && !(edge.get('source').isVisible() && edge.get('target').isVisible())) {\r\n          return;\r\n        }\r\n\r\n        _this.changeItemVisibility(edge, visible);\r\n      });\r\n    } else if (item.getType && item.getType() === COMBO) {\r\n      var comboTrees = graph.get('comboTrees');\r\n      var id_1 = item.get('id');\r\n      var children_1 = [];\r\n      var found_3 = false; // flag the terminate the forEach\r\n\r\n      (comboTrees || []).forEach(function (ctree) {\r\n        if (found_3) return;\r\n        if (!ctree.children || ctree.children.length === 0) return;\r\n        (0, _graphic.traverseTree)(ctree, function (combo) {\r\n          if (combo.id === id_1) {\r\n            children_1 = combo.children;\r\n            found_3 = true;\r\n            return false; // terminate the traverse\r\n          }\r\n\r\n          return true;\r\n        });\r\n      });\r\n\r\n      if (children_1 && (!visible || visible && !item.getModel().collapsed)) {\r\n        children_1.forEach(function (child) {\r\n          var childItem = graph.findById(child.id);\r\n\r\n          _this.changeItemVisibility(childItem, visible);\r\n        });\r\n      }\r\n\r\n      var edges = item.getEdges();\r\n      (0, _util.each)(edges, function (edge) {\r\n        // 若隐藏 combo，则将与 combo 本身关联的边也隐藏\r\n        // 若显示 combo，则将与 combo 本身关联的边也显示，但是需要判断边两端的节点都是可见的\r\n        if (visible && !(edge.get('source').isVisible() && edge.get('target').isVisible())) {\r\n          return;\r\n        }\r\n\r\n        _this.changeItemVisibility(edge, visible);\r\n      });\r\n    }\r\n\r\n    graph.emit('afteritemvisibilitychange', {\r\n      item: item,\r\n      visible: visible\r\n    });\r\n    return item;\r\n  };\r\n\r\n  ItemController.prototype.destroy = function () {\r\n    this.graph = null;\r\n    this.destroyed = true;\r\n  };\r\n\r\n  return ItemController;\r\n}();\r\n\r\nvar _default = ItemController;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _item = _interopRequireDefault(require(\"./item\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar END_MAP = {\r\n  source: 'start',\r\n  target: 'end'\r\n};\r\nvar ITEM_NAME_SUFFIX = 'Node'; // 端点的后缀，如 sourceNode, targetNode\r\n\r\nvar POINT_NAME_SUFFIX = 'Point'; // 起点或者结束点的后缀，如 startPoint, endPoint\r\n\r\nvar ANCHOR_NAME_SUFFIX = 'Anchor';\r\n\r\nvar Edge =\r\n/** @class */\r\nfunction (_super) {\r\n  (0, _tslib.__extends)(Edge, _super);\r\n\r\n  function Edge() {\r\n    return _super !== null && _super.apply(this, arguments) || this;\r\n  }\r\n\r\n  Edge.prototype.getDefaultCfg = function () {\r\n    return {\r\n      type: 'edge',\r\n      sourceNode: null,\r\n      targetNode: null,\r\n      startPoint: null,\r\n      endPoint: null,\r\n      linkCenter: false\r\n    };\r\n  };\r\n\r\n  Edge.prototype.setEnd = function (name, value) {\r\n    var pointName = END_MAP[name] + POINT_NAME_SUFFIX;\r\n    var itemName = name + ITEM_NAME_SUFFIX;\r\n    var preItem = this.get(itemName);\r\n\r\n    if (preItem && !preItem.destroyed) {\r\n      // 如果之前存在节点，则移除掉边\r\n      preItem.removeEdge(this);\r\n    }\r\n\r\n    if ((0, _util.isPlainObject)(value)) {\r\n      // 如果设置成具体的点，则清理节点\r\n      this.set(pointName, value);\r\n      this.set(itemName, null);\r\n    } else {\r\n      value.addEdge(this);\r\n      this.set(itemName, value);\r\n      this.set(pointName, null);\r\n    }\r\n  };\r\n  /**\r\n   * 获取连接点的坐标\r\n   * @param name source | target\r\n   * @param model 边的数据模型\r\n   * @param controlPoints 控制点\r\n   */\r\n\r\n\r\n  Edge.prototype.getLinkPoint = function (name, model, controlPoints) {\r\n    var pointName = END_MAP[name] + POINT_NAME_SUFFIX;\r\n    var itemName = name + ITEM_NAME_SUFFIX;\r\n    var point = this.get(pointName);\r\n\r\n    if (!point) {\r\n      var item = this.get(itemName);\r\n      var anchorName = name + ANCHOR_NAME_SUFFIX;\r\n      var prePoint = this.getPrePoint(name, controlPoints);\r\n      var anchorIndex = model[anchorName];\r\n\r\n      if (!(0, _util.isNil)(anchorIndex)) {\r\n        // 如果有锚点，则使用锚点索引获取连接点\r\n        point = item.getLinkPointByAnchor(anchorIndex);\r\n      } // 如果锚点没有对应的点或者没有锚点，则直接计算连接点\r\n\r\n\r\n      point = point || item.getLinkPoint(prePoint);\r\n\r\n      if (!(0, _util.isNil)(point.index)) {\r\n        this.set(name + \"AnchorIndex\", point.index);\r\n      }\r\n    }\r\n\r\n    return point;\r\n  };\r\n  /**\r\n   * 获取同端点进行连接的点，计算交汇点\r\n   * @param name\r\n   * @param controlPoints\r\n   */\r\n\r\n\r\n  Edge.prototype.getPrePoint = function (name, controlPoints) {\r\n    if (controlPoints && controlPoints.length) {\r\n      var index = name === 'source' ? 0 : controlPoints.length - 1;\r\n      return controlPoints[index];\r\n    }\r\n\r\n    var oppositeName = name === 'source' ? 'target' : 'source'; // 取另一个节点的位置\r\n\r\n    return this.getEndPoint(oppositeName);\r\n  };\r\n  /**\r\n   * 获取端点的位置\r\n   * @param name\r\n   */\r\n\r\n\r\n  Edge.prototype.getEndPoint = function (name) {\r\n    var itemName = name + ITEM_NAME_SUFFIX;\r\n    var pointName = END_MAP[name] + POINT_NAME_SUFFIX;\r\n    var item = this.get(itemName); // 如果有端点，直接使用 model\r\n\r\n    if (item) {\r\n      return item.get('model');\r\n    } // 否则直接使用点\r\n\r\n\r\n    return this.get(pointName);\r\n  };\r\n  /**\r\n   * 通过端点的中心获取控制点\r\n   * @param model\r\n   */\r\n\r\n\r\n  Edge.prototype.getControlPointsByCenter = function (model) {\r\n    var sourcePoint = this.getEndPoint('source');\r\n    var targetPoint = this.getEndPoint('target');\r\n    var shapeFactory = this.get('shapeFactory');\r\n    var type = model.type;\r\n    return shapeFactory.getControlPoints(type, {\r\n      startPoint: sourcePoint,\r\n      endPoint: targetPoint\r\n    });\r\n  };\r\n\r\n  Edge.prototype.getEndCenter = function (name) {\r\n    var itemName = name + ITEM_NAME_SUFFIX;\r\n    var pointName = END_MAP[name] + POINT_NAME_SUFFIX;\r\n    var item = this.get(itemName); // 如果有端点，直接使用 model\r\n\r\n    if (item) {\r\n      var bbox = item.getBBox();\r\n      return {\r\n        x: bbox.centerX,\r\n        y: bbox.centerY\r\n      };\r\n    } // 否则直接使用点\r\n\r\n\r\n    return this.get(pointName);\r\n  };\r\n\r\n  Edge.prototype.init = function () {\r\n    _super.prototype.init.call(this); // 初始化两个端点\r\n\r\n\r\n    this.setSource(this.get('source'));\r\n    this.setTarget(this.get('target'));\r\n  };\r\n\r\n  Edge.prototype.getShapeCfg = function (model) {\r\n    var self = this;\r\n    var linkCenter = self.get('linkCenter'); // 如果连接到中心，忽视锚点、忽视控制点\r\n\r\n    var cfg = _super.prototype.getShapeCfg.call(this, model);\r\n\r\n    if (linkCenter) {\r\n      cfg.startPoint = self.getEndCenter('source');\r\n      cfg.endPoint = self.getEndCenter('target');\r\n    } else {\r\n      var controlPoints = cfg.controlPoints || self.getControlPointsByCenter(cfg);\r\n      cfg.startPoint = self.getLinkPoint('source', model, controlPoints);\r\n      cfg.endPoint = self.getLinkPoint('target', model, controlPoints);\r\n    }\r\n\r\n    cfg.sourceNode = self.get('sourceNode');\r\n    cfg.targetNode = self.get('targetNode');\r\n    return cfg;\r\n  };\r\n  /**\r\n   * 获取边的数据模型\r\n   */\r\n\r\n\r\n  Edge.prototype.getModel = function () {\r\n    var out = this.get('model');\r\n    var sourceItem = this.get(\"source\" + ITEM_NAME_SUFFIX);\r\n    var targetItem = this.get(\"target\" + ITEM_NAME_SUFFIX);\r\n\r\n    if (sourceItem) {\r\n      delete out[\"source\" + ITEM_NAME_SUFFIX];\r\n    } else {\r\n      out.source = this.get(\"start\" + POINT_NAME_SUFFIX);\r\n    }\r\n\r\n    if (targetItem) {\r\n      delete out[\"target\" + ITEM_NAME_SUFFIX];\r\n    } else {\r\n      out.target = this.get(\"end\" + POINT_NAME_SUFFIX);\r\n    }\r\n\r\n    if (!(0, _util.isString)(out.source) && !(0, _util.isPlainObject)(out.source)) {\r\n      out.source = out.source.getID();\r\n    }\r\n\r\n    if (!(0, _util.isString)(out.target) && !(0, _util.isPlainObject)(out.target)) {\r\n      out.target = out.target.getID();\r\n    }\r\n\r\n    return out;\r\n  };\r\n\r\n  Edge.prototype.setSource = function (source) {\r\n    this.setEnd('source', source);\r\n    this.set('source', source);\r\n  };\r\n\r\n  Edge.prototype.setTarget = function (target) {\r\n    this.setEnd('target', target);\r\n    this.set('target', target);\r\n  };\r\n\r\n  Edge.prototype.getSource = function () {\r\n    return this.get('source');\r\n  };\r\n\r\n  Edge.prototype.getTarget = function () {\r\n    return this.get('target');\r\n  };\r\n\r\n  Edge.prototype.updatePosition = function () {\r\n    return false;\r\n  };\r\n  /**\r\n   * 边不需要重计算容器位置，直接重新计算 path 位置\r\n   * @param {object} cfg 待更新数据\r\n   */\r\n\r\n\r\n  Edge.prototype.update = function (cfg, onlyMove) {\r\n    if (onlyMove === void 0) {\r\n      onlyMove = false;\r\n    }\r\n\r\n    var model = this.get('model');\r\n    var oriVisible = model.visible;\r\n    var cfgVisible = cfg.visible;\r\n    if (oriVisible !== cfgVisible && cfgVisible !== undefined) this.changeVisibility(cfgVisible);\r\n    var styles = this.get('styles');\r\n\r\n    if (cfg.stateStyles) {\r\n      // 更新 item 时更新 this.get('styles') 中的值\r\n      var stateStyles = cfg.stateStyles;\r\n      (0, _util.mix)(styles, stateStyles);\r\n      delete cfg.stateStyles;\r\n    }\r\n\r\n    Object.assign(model, cfg);\r\n    this.updateShape();\r\n    this.afterUpdate();\r\n    this.clearCache();\r\n  };\r\n\r\n  Edge.prototype.destroy = function () {\r\n    var sourceItem = this.get(\"source\" + ITEM_NAME_SUFFIX);\r\n    var targetItem = this.get(\"target\" + ITEM_NAME_SUFFIX);\r\n\r\n    if (sourceItem && !sourceItem.destroyed) {\r\n      sourceItem.removeEdge(this);\r\n    }\r\n\r\n    if (targetItem && !targetItem.destroyed) {\r\n      targetItem.removeEdge(this);\r\n    }\r\n\r\n    _super.prototype.destroy.call(this);\r\n  };\r\n\r\n  return Edge;\r\n}(_item.default);\r\n\r\nvar _default = Edge;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _shape = _interopRequireDefault(require(\"../element/shape\"));\r\n\r\nvar _graphic = require(\"../util/graphic\");\r\n\r\nvar _math = require(\"../util/math\");\r\n\r\nvar _base = require(\"../util/base\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar CACHE_BBOX = 'bboxCache';\r\nvar CACHE_CANVAS_BBOX = 'bboxCanvasCache';\r\nvar ARROWS = ['startArrow', 'endArrow'];\r\n\r\nvar ItemBase =\r\n/** @class */\r\nfunction () {\r\n  function ItemBase(cfg) {\r\n    this._cfg = {};\r\n    this.destroyed = false;\r\n    var defaultCfg = {\r\n      /**\r\n       * id\r\n       * @type {string}\r\n       */\r\n      id: undefined,\r\n\r\n      /**\r\n       * 类型\r\n       * @type {string}\r\n       */\r\n      type: 'item',\r\n\r\n      /**\r\n       * data model\r\n       * @type {object}\r\n       */\r\n      model: {},\r\n\r\n      /**\r\n       * g group\r\n       * @type {G.Group}\r\n       */\r\n      group: undefined,\r\n\r\n      /**\r\n       * is open animate\r\n       * @type {boolean}\r\n       */\r\n      animate: false,\r\n\r\n      /**\r\n       * visible - not group visible\r\n       * @type {boolean}\r\n       */\r\n      visible: true,\r\n\r\n      /**\r\n       * locked - lock node\r\n       * @type {boolean}\r\n       */\r\n      locked: false,\r\n\r\n      /**\r\n       * capture event\r\n       * @type {boolean}\r\n       */\r\n      event: true,\r\n\r\n      /**\r\n       * key shape to calculate item's bbox\r\n       * @type object\r\n       */\r\n      keyShape: undefined,\r\n\r\n      /**\r\n       * item's states, such as selected or active\r\n       * @type Array\r\n       */\r\n      states: []\r\n    };\r\n    this._cfg = Object.assign(defaultCfg, this.getDefaultCfg(), cfg);\r\n    var model = this.get('model');\r\n    var id = model.id;\r\n    var itemType = this.get('type');\r\n\r\n    if (!id) {\r\n      id = (0, _base.uniqueId)(itemType);\r\n      this.get('model').id = id;\r\n    }\r\n\r\n    this.set('id', id);\r\n    var group = cfg.group;\r\n\r\n    if (group) {\r\n      group.set('item', this);\r\n      group.set('id', id);\r\n    }\r\n\r\n    this.init();\r\n    this.draw();\r\n    var shapeType = model.shape || model.type || (itemType === 'edge' ? 'line' : 'circle');\r\n    var shapeFactory = this.get('shapeFactory');\r\n\r\n    if (shapeFactory && shapeFactory[shapeType]) {\r\n      var options = shapeFactory[shapeType].options; // merge the stateStyles from item and shape\r\n\r\n      if (options && options.stateStyles) {\r\n        var styles = this.get('styles') || model.stateStyles;\r\n        styles = (0, _util.deepMix)({}, options.stateStyles, styles);\r\n        this.set('styles', styles);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * 根据 keyshape 计算包围盒\r\n   */\r\n\r\n\r\n  ItemBase.prototype.calculateBBox = function () {\r\n    var keyShape = this.get('keyShape');\r\n    var group = this.get('group'); // 因为 group 可能会移动，所以必须通过父元素计算才能计算出正确的包围盒\r\n\r\n    var bbox = (0, _graphic.getBBox)(keyShape, group);\r\n    bbox.x = bbox.minX;\r\n    bbox.y = bbox.minY;\r\n    bbox.width = bbox.maxX - bbox.minX;\r\n    bbox.height = bbox.maxY - bbox.minY;\r\n    bbox.centerX = (bbox.minX + bbox.maxX) / 2;\r\n    bbox.centerY = (bbox.minY + bbox.maxY) / 2;\r\n    return bbox;\r\n  };\r\n  /**\r\n   * 根据 keyshape 计算包围盒\r\n   */\r\n\r\n\r\n  ItemBase.prototype.calculateCanvasBBox = function () {\r\n    var keyShape = this.get('keyShape');\r\n    var group = this.get('group'); // 因为 group 可能会移动，所以必须通过父元素计算才能计算出正确的包围盒\r\n\r\n    var bbox = (0, _graphic.getBBox)(keyShape, group);\r\n    bbox.x = bbox.minX;\r\n    bbox.y = bbox.minY;\r\n    bbox.width = bbox.maxX - bbox.minX;\r\n    bbox.height = bbox.maxY - bbox.minY;\r\n    bbox.centerX = (bbox.minX + bbox.maxX) / 2;\r\n    bbox.centerY = (bbox.minY + bbox.maxY) / 2;\r\n    return bbox;\r\n  };\r\n  /**\r\n   * draw shape\r\n   */\r\n\r\n\r\n  ItemBase.prototype.drawInner = function () {\r\n    var self = this;\r\n    var shapeFactory = self.get('shapeFactory');\r\n    var group = self.get('group');\r\n    var model = self.get('model');\r\n    group.clear();\r\n    var visible = model.visible;\r\n    if (visible !== undefined && !visible) self.changeVisibility(visible);\r\n\r\n    if (!shapeFactory) {\r\n      return;\r\n    }\r\n\r\n    self.updatePosition(model);\r\n    var cfg = self.getShapeCfg(model); // 可能会附加额外信息\r\n\r\n    var shapeType = cfg.type;\r\n    var keyShape = shapeFactory.draw(shapeType, cfg, group);\r\n\r\n    if (keyShape) {\r\n      self.set('keyShape', keyShape);\r\n      keyShape.set('isKeyShape', true);\r\n      keyShape.set('draggable', true);\r\n    }\r\n\r\n    this.setOriginStyle(); // 防止由于用户外部修改 model 中的 shape 导致 shape 不更新\r\n\r\n    this.set('currentShape', shapeType);\r\n    this.restoreStates(shapeFactory, shapeType);\r\n  };\r\n  /**\r\n   * 设置图元素原始样式\r\n   * @param keyShape 图元素 keyShape\r\n   * @param group Group 容器\r\n   */\r\n\r\n\r\n  ItemBase.prototype.setOriginStyle = function () {\r\n    var group = this.get('group');\r\n    var children = group.get('children');\r\n    var keyShape = this.getKeyShape();\r\n    var self = this;\r\n    var keyShapeName = keyShape.get('name');\r\n\r\n    if (!this.get('originStyle')) {\r\n      // 第一次 set originStyle，直接拿首次渲染所有图形的 attrs\r\n      var originStyles_1 = {};\r\n      (0, _util.each)(children, function (child) {\r\n        var shapeType = child.get('type');\r\n        var name = child.get('name');\r\n\r\n        if (name && name !== keyShapeName) {\r\n          originStyles_1[name] = shapeType !== 'image' ? (0, _util.clone)(child.attr()) : self.getShapeStyleByName(name);\r\n        } else {\r\n          // !name || name === keyShape\r\n          var keyShapeStyle = self.getShapeStyleByName(); // 可优化，需要去除 child.attr 中其他 shape 名的对象\r\n\r\n          if (keyShapeStyle.path) delete keyShapeStyle.path;\r\n          if (keyShapeStyle.matrix) delete keyShapeStyle.matrix;\r\n\r\n          if (!keyShapeName) {\r\n            Object.assign(originStyles_1, keyShapeStyle);\r\n          } else {\r\n            // 若 keyShape 有 name 且 !name，这个图形不是 keyShape，给这个图形一个 name\r\n            if (!name) {\r\n              var shapeName = (0, _base.uniqueId)('shape');\r\n              child.set('name', shapeName);\r\n              originStyles_1[shapeName] = shapeType !== 'image' ? (0, _util.clone)(child.attr()) : self.getShapeStyleByName(name);\r\n            } else originStyles_1[keyShapeName] = keyShapeStyle;\r\n          }\r\n        }\r\n      });\r\n      self.set('originStyle', originStyles_1);\r\n    } else {\r\n      // 第二次 set originStyles，需要找到不是 stateStyles 的样式，更新到 originStyles 中\r\n      // 上一次设置的 originStyle，是初始的 shape attrs\r\n      var styles_1 = this.getOriginStyle(); // let styles: ShapeStyle = {};\r\n\r\n      if (keyShapeName && !styles_1[keyShapeName]) styles_1[keyShapeName] = {}; // 获取当前状态样式\r\n\r\n      var currentStatesStyle_1 = this.getCurrentStatesStyle(); // 遍历当前所有图形的 attrs，找到不是 stateStyles 的样式更新到 originStyles 中\r\n\r\n      (0, _util.each)(children, function (child) {\r\n        var name = child.get('name');\r\n        var shapeAttrs = child.attr();\r\n\r\n        if (name && name !== keyShapeName) {\r\n          // 有 name 的非 keyShape 图形\r\n          var shapeStateStyle_1 = currentStatesStyle_1[name];\r\n          if (!styles_1[name]) styles_1[name] = {};\r\n\r\n          if (shapeStateStyle_1) {\r\n            Object.keys(shapeAttrs).forEach(function (key) {\r\n              var value = shapeAttrs[key];\r\n              if (value !== shapeStateStyle_1[key]) styles_1[name][key] = value;\r\n            });\r\n          } else {\r\n            styles_1[name] = child.get('type') !== 'image' ? (0, _util.clone)(shapeAttrs) : self.getShapeStyleByName(name);\r\n          }\r\n        } else {\r\n          var shapeAttrs_1 = child.attr();\r\n          var keyShapeStateStyles_1 = (0, _tslib.__assign)((0, _tslib.__assign)({}, currentStatesStyle_1), currentStatesStyle_1[keyShapeName]);\r\n          Object.keys(shapeAttrs_1).forEach(function (key) {\r\n            var value = shapeAttrs_1[key]; // 如果是对象且不是 arrow，则是其他 shape 的样式\r\n            // if (isPlainObject(value) && ARROWS.indexOf(name) === -1) return;\r\n\r\n            if (keyShapeStateStyles_1[key] !== value) {\r\n              if (keyShapeName) styles_1[keyShapeName][key] = value;else styles_1[key] = value;\r\n            }\r\n          });\r\n        }\r\n      });\r\n      if (styles_1.path) delete styles_1.path;\r\n      if (styles_1.matrix) delete styles_1.matrix;\r\n      if (styles_1.x) delete styles_1.x;\r\n      if (styles_1.y) delete styles_1.y;\r\n      if (styles_1[keyShapeName] && styles_1[keyShapeName].x) delete styles_1[keyShapeName].x;\r\n      if (styles_1[keyShapeName] && styles_1[keyShapeName].y) delete styles_1[keyShapeName].y;\r\n      self.set('originStyle', styles_1);\r\n    }\r\n  };\r\n  /**\r\n   * restore shape states\r\n   * @param shapeFactory\r\n   * @param shapeType\r\n   */\r\n\r\n\r\n  ItemBase.prototype.restoreStates = function (shapeFactory, shapeType) {\r\n    var self = this;\r\n    var states = self.get('states');\r\n    (0, _util.each)(states, function (state) {\r\n      shapeFactory.setState(shapeType, state, true, self);\r\n    });\r\n  };\r\n\r\n  ItemBase.prototype.init = function () {\r\n    var shapeFactory = _shape.default.getFactory(this.get('type'));\r\n\r\n    this.set('shapeFactory', shapeFactory);\r\n  };\r\n  /**\r\n   * 获取属性\r\n   * @internal 仅内部类使用\r\n   * @param  {String} key 属性名\r\n   * @return {object | string | number} 属性值\r\n   */\r\n\r\n\r\n  ItemBase.prototype.get = function (key) {\r\n    return this._cfg[key];\r\n  };\r\n  /**\r\n   * 设置属性\r\n   * @internal 仅内部类使用\r\n   * @param {String|Object} key 属性名，也可以是对象\r\n   * @param {object | string | number} val 属性值\r\n   */\r\n\r\n\r\n  ItemBase.prototype.set = function (key, val) {\r\n    if ((0, _util.isPlainObject)(key)) {\r\n      this._cfg = (0, _tslib.__assign)((0, _tslib.__assign)({}, this._cfg), key);\r\n    } else {\r\n      this._cfg[key] = val;\r\n    }\r\n  };\r\n\r\n  ItemBase.prototype.getDefaultCfg = function () {\r\n    return {};\r\n  };\r\n  /**\r\n   * 更新/刷新等操作后，清除 cache\r\n   */\r\n\r\n\r\n  ItemBase.prototype.clearCache = function () {\r\n    this.set(CACHE_BBOX, null);\r\n    this.set(CACHE_CANVAS_BBOX, null);\r\n  };\r\n  /**\r\n   * 渲染前的逻辑，提供给子类复写\r\n   */\r\n\r\n\r\n  ItemBase.prototype.beforeDraw = function () {};\r\n  /**\r\n   * 渲染后的逻辑，提供给子类复写\r\n   */\r\n\r\n\r\n  ItemBase.prototype.afterDraw = function () {};\r\n  /**\r\n   * 更新后做一些工作\r\n   */\r\n\r\n\r\n  ItemBase.prototype.afterUpdate = function () {};\r\n  /**\r\n   * draw shape\r\n   */\r\n\r\n\r\n  ItemBase.prototype.draw = function () {\r\n    this.beforeDraw();\r\n    this.drawInner();\r\n    this.afterDraw();\r\n  };\r\n\r\n  ItemBase.prototype.getShapeStyleByName = function (name) {\r\n    var group = this.get('group');\r\n    var currentShape;\r\n\r\n    if (name) {\r\n      currentShape = group.find(function (element) {\r\n        return element.get('name') === name;\r\n      });\r\n    } else {\r\n      currentShape = this.getKeyShape();\r\n    }\r\n\r\n    if (currentShape) {\r\n      var styles_2 = {};\r\n      (0, _util.each)(currentShape.attr(), function (val, key) {\r\n        // 修改 img 通过 updateItem 实现\r\n        if (key !== 'img') {\r\n          styles_2[key] = val;\r\n        }\r\n      });\r\n      return styles_2;\r\n    }\r\n\r\n    return {};\r\n  };\r\n\r\n  ItemBase.prototype.getShapeCfg = function (model) {\r\n    var styles = this.get('styles');\r\n\r\n    if (styles) {\r\n      // merge graph的item样式与数据模型中的样式\r\n      var newModel = model;\r\n      newModel.style = (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), model.style);\r\n      return newModel;\r\n    }\r\n\r\n    return model;\r\n  };\r\n  /**\r\n   * 获取指定状态的样式，去除了全局样式\r\n   * @param state 状态名称\r\n   */\r\n\r\n\r\n  ItemBase.prototype.getStateStyle = function (state) {\r\n    var styles = this.get('styles');\r\n    var stateStyle = styles && styles[state];\r\n    return stateStyle;\r\n  };\r\n  /**\r\n   * get keyshape style\r\n   */\r\n\r\n\r\n  ItemBase.prototype.getOriginStyle = function () {\r\n    return this.get('originStyle');\r\n  };\r\n\r\n  ItemBase.prototype.getCurrentStatesStyle = function () {\r\n    var self = this;\r\n    var styles = {};\r\n    var states = self.getStates();\r\n\r\n    if (!states || !states.length) {\r\n      return this.getOriginStyle();\r\n    }\r\n\r\n    (0, _util.each)(self.getStates(), function (state) {\r\n      styles = Object.assign(styles, self.getStateStyle(state));\r\n    });\r\n    return styles;\r\n  };\r\n  /**\r\n   * 更改元素状态， visible 不属于这个范畴\r\n   * @internal 仅提供内部类 graph 使用\r\n   * @param {String} state 状态名\r\n   * @param {Boolean} value 节点状态值\r\n   */\r\n\r\n\r\n  ItemBase.prototype.setState = function (state, value) {\r\n    var states = this.get('states');\r\n    var shapeFactory = this.get('shapeFactory');\r\n    var stateName = state;\r\n    var filterStateName = state;\r\n\r\n    if ((0, _util.isString)(value)) {\r\n      stateName = state + \":\" + value;\r\n      filterStateName = state + \":\";\r\n    }\r\n\r\n    var newStates = states;\r\n\r\n    if ((0, _util.isBoolean)(value)) {\r\n      var index = states.indexOf(filterStateName);\r\n\r\n      if (value) {\r\n        if (index > -1) {\r\n          return;\r\n        }\r\n\r\n        states.push(stateName);\r\n      } else if (index > -1) {\r\n        states.splice(index, 1);\r\n      }\r\n    } else if ((0, _util.isString)(value)) {\r\n      // 过滤掉 states 中 filterStateName 相关的状态\r\n      var filterStates = states.filter(function (name) {\r\n        return name.includes(filterStateName);\r\n      });\r\n\r\n      if (filterStates.length > 0) {\r\n        this.clearStates(filterStates);\r\n      }\r\n\r\n      newStates = newStates.filter(function (name) {\r\n        return !name.includes(filterStateName);\r\n      });\r\n      newStates.push(stateName);\r\n      this.set('states', newStates);\r\n    }\r\n\r\n    if (shapeFactory) {\r\n      var model = this.get('model');\r\n      var type = model.type; // 调用 shape/shape.ts 中的 setState\r\n\r\n      shapeFactory.setState(type, state, value, this);\r\n    }\r\n  };\r\n  /**\r\n   * 清除指定的状态，如果参数为空，则不做任务处理\r\n   * @param states 状态名称\r\n   */\r\n\r\n\r\n  ItemBase.prototype.clearStates = function (states) {\r\n    var self = this;\r\n    var originStates = self.getStates();\r\n    var shapeFactory = self.get('shapeFactory');\r\n    var model = self.get('model');\r\n    var shape = model.type;\r\n\r\n    if (!states) {\r\n      states = originStates;\r\n    }\r\n\r\n    if ((0, _util.isString)(states)) {\r\n      states = [states];\r\n    }\r\n\r\n    var newStates = originStates.filter(function (state) {\r\n      return states.indexOf(state) === -1;\r\n    });\r\n    self.set('states', newStates);\r\n    states.forEach(function (state) {\r\n      shapeFactory.setState(shape, state, false, self);\r\n    });\r\n  };\r\n  /**\r\n   * 节点的图形容器\r\n   * @return {G.Group} 图形容器\r\n   */\r\n\r\n\r\n  ItemBase.prototype.getContainer = function () {\r\n    return this.get('group');\r\n  };\r\n  /**\r\n   * 节点的关键形状，用于计算节点大小，连线截距等\r\n   * @return {IShapeBase} 关键形状\r\n   */\r\n\r\n\r\n  ItemBase.prototype.getKeyShape = function () {\r\n    return this.get('keyShape');\r\n  };\r\n  /**\r\n   * 节点数据模型\r\n   * @return {Object} 数据模型\r\n   */\r\n\r\n\r\n  ItemBase.prototype.getModel = function () {\r\n    return this.get('model');\r\n  };\r\n  /**\r\n   * 节点类型\r\n   * @return {string} 节点的类型\r\n   */\r\n\r\n\r\n  ItemBase.prototype.getType = function () {\r\n    return this.get('type');\r\n  };\r\n  /**\r\n   * 获取 Item 的ID\r\n   */\r\n\r\n\r\n  ItemBase.prototype.getID = function () {\r\n    return this.get('id');\r\n  };\r\n  /**\r\n   * 是否是 Item 对象，悬空边情况下进行判定\r\n   */\r\n\r\n\r\n  ItemBase.prototype.isItem = function () {\r\n    return true;\r\n  };\r\n  /**\r\n   * 获取当前元素的所有状态\r\n   * @return {Array} 元素的所有状态\r\n   */\r\n\r\n\r\n  ItemBase.prototype.getStates = function () {\r\n    return this.get('states');\r\n  };\r\n  /**\r\n   * 当前元素是否处于某状态\r\n   * @param {String} state 状态名\r\n   * @return {Boolean} 是否处于某状态\r\n   */\r\n\r\n\r\n  ItemBase.prototype.hasState = function (state) {\r\n    var states = this.getStates();\r\n    return states.indexOf(state) >= 0;\r\n  };\r\n  /**\r\n   * 刷新一般用于处理几种情况\r\n   * 1. item model 在外部被改变\r\n   * 2. 边的节点位置发生改变，需要重新计算边\r\n   *\r\n   * 因为数据从外部被修改无法判断一些属性是否被修改，直接走位置和 shape 的更新\r\n   */\r\n\r\n\r\n  ItemBase.prototype.refresh = function () {\r\n    var model = this.get('model'); // 更新元素位置\r\n\r\n    this.updatePosition(model); // 更新元素内容，样式\r\n\r\n    this.updateShape(); // 做一些更新之后的操作\r\n\r\n    this.afterUpdate(); // 清除缓存\r\n\r\n    this.clearCache();\r\n  };\r\n\r\n  ItemBase.prototype.isOnlyMove = function (cfg) {\r\n    return false;\r\n  };\r\n  /**\r\n   * 将更新应用到 model 上，刷新属性\r\n   * @internal 仅提供给 Graph 使用，外部直接调用 graph.update 接口\r\n   * @param  {Object} cfg       配置项，可以是增量信息\r\n   */\r\n\r\n\r\n  ItemBase.prototype.update = function (cfg, onlyMove) {\r\n    if (onlyMove === void 0) {\r\n      onlyMove = false;\r\n    }\r\n\r\n    var model = this.get('model');\r\n    var oriVisible = model.visible;\r\n    var cfgVisible = cfg.visible;\r\n    if (oriVisible !== cfgVisible && cfgVisible !== undefined) this.changeVisibility(cfgVisible);\r\n    var originPosition = {\r\n      x: model.x,\r\n      y: model.y\r\n    };\r\n    cfg.x = isNaN(cfg.x) ? model.x : cfg.x;\r\n    cfg.y = isNaN(cfg.y) ? model.y : cfg.y;\r\n    var styles = this.get('styles');\r\n\r\n    if (cfg.stateStyles) {\r\n      // 更新 item 时更新 this.get('styles') 中的值\r\n      var stateStyles = cfg.stateStyles;\r\n      (0, _util.mix)(styles, stateStyles);\r\n      delete cfg.stateStyles;\r\n    } // 直接将更新合到原数据模型上，可以保证用户在外部修改源数据然后刷新时的样式符合期待。\r\n\r\n\r\n    Object.assign(model, cfg); // isOnlyMove 仅用于node\r\n    // const onlyMove = this.isOnlyMove(cfg);\r\n    // 仅仅移动位置时，既不更新，也不重绘\r\n\r\n    if (onlyMove) {\r\n      this.updatePosition(cfg);\r\n    } else {\r\n      // 如果 x,y 有变化，先重置位置\r\n      if (originPosition.x !== cfg.x || originPosition.y !== cfg.y) {\r\n        this.updatePosition(cfg);\r\n      }\r\n\r\n      this.updateShape();\r\n    }\r\n\r\n    this.afterUpdate();\r\n    this.clearCache();\r\n  };\r\n  /**\r\n   * 更新元素内容，样式\r\n   */\r\n\r\n\r\n  ItemBase.prototype.updateShape = function () {\r\n    var shapeFactory = this.get('shapeFactory');\r\n    var model = this.get('model');\r\n    var shape = model.type; // 判定是否允许更新\r\n    // 1. 注册的节点允许更新\r\n    // 2. 更新后的 shape 等于原先的 shape\r\n\r\n    if (shapeFactory.shouldUpdate(shape) && shape === this.get('currentShape')) {\r\n      var updateCfg = this.getShapeCfg(model);\r\n      shapeFactory.baseUpdate(shape, updateCfg, this); // 更新完以后重新设置原始样式\r\n\r\n      this.setOriginStyle();\r\n    } else {\r\n      // 如果不满足上面两种状态，重新绘制\r\n      this.draw();\r\n    } // 更新后重置节点状态\r\n\r\n\r\n    this.restoreStates(shapeFactory, shape);\r\n  };\r\n  /**\r\n   * 更新位置，避免整体重绘\r\n   * @param {object} cfg 待更新数据\r\n   */\r\n\r\n\r\n  ItemBase.prototype.updatePosition = function (cfg) {\r\n    var model = this.get('model');\r\n    var x = (0, _util.isNil)(cfg.x) ? model.x : cfg.x;\r\n    var y = (0, _util.isNil)(cfg.y) ? model.y : cfg.y;\r\n    var group = this.get('group');\r\n\r\n    if ((0, _util.isNil)(x) || (0, _util.isNil)(y)) {\r\n      return false;\r\n    }\r\n\r\n    model.x = x;\r\n    model.y = y;\r\n    var matrix = group.getMatrix();\r\n    if (matrix && matrix[6] === x && matrix[7] === y) return false;\r\n    group.resetMatrix(); // G 4.0 element 中移除了矩阵相关方法，详见https://www.yuque.com/antv/blog/kxzk9g#4rMMV\r\n\r\n    (0, _math.translate)(group, {\r\n      x: x,\r\n      y: y\r\n    });\r\n    this.clearCache(); // 位置更新后需要清除缓存\r\n\r\n    return true;\r\n  };\r\n  /**\r\n   * 获取 item 的包围盒，这个包围盒是相对于 item 自己，不会将 matrix 计算在内\r\n   * @return {Object} 包含 x,y,width,height, centerX, centerY\r\n   */\r\n\r\n\r\n  ItemBase.prototype.getBBox = function () {\r\n    // 计算 bbox 开销有些大，缓存\r\n    var bbox = this.get(CACHE_BBOX);\r\n\r\n    if (!bbox) {\r\n      bbox = this.calculateBBox();\r\n      this.set(CACHE_BBOX, bbox);\r\n    }\r\n\r\n    return bbox;\r\n  };\r\n  /**\r\n   * 获取 item 相对于画布的包围盒，会将从顶层到当前元素的 matrix 都计算在内\r\n   * @return {Object} 包含 x,y,width,height, centerX, centerY\r\n   */\r\n\r\n\r\n  ItemBase.prototype.getCanvasBBox = function () {\r\n    // 计算 bbox 开销有些大，缓存\r\n    var bbox = this.get(CACHE_CANVAS_BBOX);\r\n\r\n    if (!bbox) {\r\n      bbox = this.calculateCanvasBBox();\r\n      this.set(CACHE_CANVAS_BBOX, bbox);\r\n    }\r\n\r\n    return bbox;\r\n  };\r\n  /**\r\n   * 将元素放到最前面\r\n   */\r\n\r\n\r\n  ItemBase.prototype.toFront = function () {\r\n    var group = this.get('group');\r\n    group.toFront();\r\n  };\r\n  /**\r\n   * 将元素放到最后面\r\n   */\r\n\r\n\r\n  ItemBase.prototype.toBack = function () {\r\n    var group = this.get('group');\r\n    group.toBack();\r\n  };\r\n  /**\r\n   * 显示元素\r\n   */\r\n\r\n\r\n  ItemBase.prototype.show = function () {\r\n    this.changeVisibility(true);\r\n  };\r\n  /**\r\n   * 隐藏元素\r\n   */\r\n\r\n\r\n  ItemBase.prototype.hide = function () {\r\n    this.changeVisibility(false);\r\n  };\r\n  /**\r\n   * 更改是否显示\r\n   * @param  {Boolean} visible 是否显示\r\n   */\r\n\r\n\r\n  ItemBase.prototype.changeVisibility = function (visible) {\r\n    var group = this.get('group');\r\n\r\n    if (visible) {\r\n      group.show();\r\n    } else {\r\n      group.hide();\r\n    }\r\n\r\n    this.set('visible', visible);\r\n  };\r\n  /**\r\n   * 元素是否可见\r\n   * @return {Boolean} 返回该元素是否可见\r\n   */\r\n\r\n\r\n  ItemBase.prototype.isVisible = function () {\r\n    return this.get('visible');\r\n  };\r\n  /**\r\n   * 是否拾取及出发该元素的交互事件\r\n   * @param {Boolean} enable 标识位\r\n   */\r\n\r\n\r\n  ItemBase.prototype.enableCapture = function (enable) {\r\n    var group = this.get('group');\r\n\r\n    if (group) {\r\n      group.set('capture', enable);\r\n    }\r\n  };\r\n\r\n  ItemBase.prototype.destroy = function () {\r\n    if (!this.destroyed) {\r\n      var animate = this.get('animate');\r\n      var group = this.get('group');\r\n\r\n      if (animate) {\r\n        group.stopAnimate();\r\n      }\r\n\r\n      this.clearCache();\r\n      group.remove();\r\n      this._cfg = null;\r\n      this.destroyed = true;\r\n    }\r\n  };\r\n\r\n  return ItemBase;\r\n}();\r\n\r\nvar _default = ItemBase;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = exports.ShapeFactoryBase = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _xml = require(\"./xml\");\r\n\r\nvar cache = {}; // ucfirst 开销过大，进行缓存\r\n// 首字母大写\r\n\r\nfunction ucfirst(str) {\r\n  if (!cache[str]) {\r\n    cache[str] = (0, _util.upperFirst)(str);\r\n  }\r\n\r\n  return cache[str];\r\n}\r\n/**\r\n * 工厂方法的基类\r\n * @type Shape.FactoryBase\r\n */\r\n\r\n\r\nvar ShapeFactoryBase = {\r\n  /**\r\n   * 默认的形状，当没有指定/匹配 shapeType 时，使用默认的\r\n   * @type {String}\r\n   */\r\n  defaultShapeType: 'defaultType',\r\n\r\n  /**\r\n   * 形状的 className，用于搜索\r\n   * @type {String}\r\n   */\r\n  className: null,\r\n\r\n  /**\r\n   * 获取绘制 Shape 的工具类，无状态\r\n   * @param  {String} type 类型\r\n   * @return {Shape} 工具类\r\n   */\r\n  getShape: function getShape(type) {\r\n    var self = this;\r\n    var shape = self[type] || self[self.defaultShapeType] || self['simple-circle'];\r\n    return shape;\r\n  },\r\n\r\n  /**\r\n   * 绘制图形\r\n   * @param  {String} type  类型\r\n   * @param  {Object} cfg 配置项\r\n   * @param  {G.Group} group 图形的分组\r\n   * @return {IShape} 图形对象\r\n   */\r\n  draw: function draw(type, cfg, group) {\r\n    var shape = this.getShape(type);\r\n    var rst = shape.draw(cfg, group);\r\n\r\n    if (shape.afterDraw) {\r\n      shape.afterDraw(cfg, group, rst);\r\n    }\r\n\r\n    return rst;\r\n  },\r\n\r\n  /**\r\n   * 更新\r\n   * @param  {String} type  类型\r\n   * @param  {Object} cfg 配置项\r\n   * @param  {G6.Item} item 节点、边、分组等\r\n   */\r\n  baseUpdate: function baseUpdate(type, cfg, item) {\r\n    var shape = this.getShape(type);\r\n\r\n    if (shape.update) {\r\n      // 防止没定义 update 函数\r\n      shape.update(cfg, item);\r\n    }\r\n\r\n    if (shape.afterUpdate) {\r\n      shape.afterUpdate(cfg, item);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 设置状态\r\n   * @param {String} type  类型\r\n   * @param {String} name  状态名\r\n   * @param {String | Boolean} value 状态值\r\n   * @param {G6.Item} item  节点、边、分组等\r\n   */\r\n  setState: function setState(type, name, value, item) {\r\n    var shape = this.getShape(type); // 调用 shape/shapeBase.ts 中的 setState 方法\r\n\r\n    shape.setState(name, value, item);\r\n  },\r\n\r\n  /**\r\n   * 是否允许更新，不重新绘制图形\r\n   * @param  {String} type 类型\r\n   * @return {Boolean} 是否允许使用更新\r\n   */\r\n  shouldUpdate: function shouldUpdate(type) {\r\n    var shape = this.getShape(type);\r\n    return !!shape.update;\r\n  },\r\n  getControlPoints: function getControlPoints(type, cfg) {\r\n    var shape = this.getShape(type);\r\n    return shape.getControlPoints(cfg);\r\n  },\r\n\r\n  /**\r\n   * 获取控制点\r\n   * @param {String} type 节点、边类型\r\n   * @param  {Object} cfg 节点、边的配置项\r\n   * @return {Array|null} 控制点的数组,如果为 null，则没有控制点\r\n   */\r\n  getAnchorPoints: function getAnchorPoints(type, cfg) {\r\n    var shape = this.getShape(type);\r\n    return shape.getAnchorPoints(cfg);\r\n  }\r\n};\r\n/**\r\n * 元素的框架\r\n */\r\n\r\nexports.ShapeFactoryBase = ShapeFactoryBase;\r\nvar ShapeFramework = {\r\n  // 默认样式及配置\r\n  options: {},\r\n\r\n  /**\r\n   * 绘制\r\n   */\r\n  draw: function draw(cfg, group) {\r\n    return this.drawShape(cfg, group);\r\n  },\r\n\r\n  /**\r\n   * 绘制\r\n   */\r\n  drawShape: function drawShape()\r\n  /* cfg, group */\r\n  {},\r\n\r\n  /**\r\n   * 绘制完成后的操作，便于用户继承现有的节点、边\r\n   */\r\n  afterDraw: function afterDraw()\r\n  /* cfg, group */\r\n  {},\r\n  // update(cfg, item) // 默认不定义\r\n  afterUpdate: function afterUpdate()\r\n  /* cfg, item */\r\n  {},\r\n\r\n  /**\r\n   * 设置节点、边状态\r\n   */\r\n  setState: function setState()\r\n  /* name, value, item */\r\n  {},\r\n\r\n  /**\r\n   * 获取控制点\r\n   * @param  {Object} cfg 节点、边的配置项\r\n   * @return {Array|null} 控制点的数组,如果为 null，则没有控制点\r\n   */\r\n  getControlPoints: function getControlPoints(cfg) {\r\n    return cfg.controlPoints;\r\n  },\r\n\r\n  /**\r\n   * 获取控制点\r\n   * @param  {Object} cfg 节点、边的配置项\r\n   * @return {Array|null} 控制点的数组,如果为 null，则没有控制点\r\n   */\r\n  getAnchorPoints: function getAnchorPoints(cfg) {\r\n    var defaultAnchorPoints = this.options.anchorPoints;\r\n    var anchorPoints = cfg.anchorPoints || defaultAnchorPoints;\r\n    return anchorPoints;\r\n  }\r\n  /* 如果没定义 update 方法，每次都调用 draw 方法\r\n  update(cfg, item) {\r\n     }\r\n  */\r\n\r\n};\r\n\r\nvar Shape =\r\n/** @class */\r\nfunction () {\r\n  function Shape() {}\r\n\r\n  Shape.registerFactory = function (factoryType, cfg) {\r\n    var className = ucfirst(factoryType);\r\n    var factoryBase = ShapeFactoryBase;\r\n    var shapeFactory = (0, _tslib.__assign)((0, _tslib.__assign)({}, factoryBase), cfg);\r\n    Shape[className] = shapeFactory;\r\n    shapeFactory.className = className;\r\n    return shapeFactory;\r\n  };\r\n\r\n  Shape.getFactory = function (factoryType) {\r\n    var className = ucfirst(factoryType);\r\n    return Shape[className];\r\n  };\r\n\r\n  Shape.registerNode = function (shapeType, nodeDefinition, extendShapeType) {\r\n    var shapeFactory = Shape.Node;\r\n    var shapeObj;\r\n\r\n    if (typeof nodeDefinition === 'string' || typeof nodeDefinition === 'function') {\r\n      var autoNodeDefinition = (0, _xml.createNodeFromXML)(nodeDefinition);\r\n      shapeObj = (0, _tslib.__assign)((0, _tslib.__assign)({}, shapeFactory.getShape('single-node')), autoNodeDefinition);\r\n    } else if (nodeDefinition.jsx) {\r\n      var jsx = nodeDefinition.jsx;\r\n      var autoNodeDefinition = (0, _xml.createNodeFromXML)(jsx);\r\n      shapeObj = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, shapeFactory.getShape('single-node')), autoNodeDefinition), nodeDefinition);\r\n    } else {\r\n      shapeFactory.getShape(extendShapeType);\r\n      var extendShape = extendShapeType ? shapeFactory.getShape(extendShapeType) : ShapeFramework;\r\n      shapeObj = (0, _tslib.__assign)((0, _tslib.__assign)({}, extendShape), nodeDefinition);\r\n    }\r\n\r\n    shapeObj.type = shapeType;\r\n    shapeObj.itemType = 'node';\r\n    shapeFactory[shapeType] = shapeObj;\r\n    return shapeObj;\r\n  };\r\n\r\n  Shape.registerEdge = function (shapeType, edgeDefinition, extendShapeType) {\r\n    var shapeFactory = Shape.Edge;\r\n    var extendShape = extendShapeType ? shapeFactory.getShape(extendShapeType) : ShapeFramework;\r\n    var shapeObj = (0, _tslib.__assign)((0, _tslib.__assign)({}, extendShape), edgeDefinition);\r\n    shapeObj.type = shapeType;\r\n    shapeObj.itemType = 'edge';\r\n    shapeFactory[shapeType] = shapeObj;\r\n    return shapeObj;\r\n  };\r\n\r\n  Shape.registerCombo = function (shapeType, comboDefinition, extendShapeType) {\r\n    var shapeFactory = Shape.Combo;\r\n    var extendShape = extendShapeType ? shapeFactory.getShape(extendShapeType) : ShapeFramework;\r\n    var shapeObj = (0, _tslib.__assign)((0, _tslib.__assign)({}, extendShape), comboDefinition);\r\n    shapeObj.type = shapeType;\r\n    shapeObj.itemType = 'combo';\r\n    shapeFactory[shapeType] = shapeObj;\r\n    return shapeObj;\r\n  };\r\n\r\n  return Shape;\r\n}();\r\n\r\nvar _default = Shape; // 注册 Node 的工厂方法\r\n\r\nexports.default = _default;\r\nShape.registerFactory('node', {\r\n  defaultShapeType: 'circle'\r\n}); // 注册 Edge 的工厂方法\r\n\r\nShape.registerFactory('edge', {\r\n  defaultShapeType: 'line'\r\n}); // 注册 Combo 的工厂方法\r\n\r\nShape.registerFactory('combo', {\r\n  defaultShapeType: 'circle'\r\n});","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.parseXML = parseXML;\r\nexports.getBBox = getBBox;\r\nexports.generateTarget = generateTarget;\r\nexports.compareTwoTarget = compareTwoTarget;\r\nexports.createNodeFromXML = createNodeFromXML;\r\nexports.xmlDataRenderer = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _graphic = require(\"../util/graphic\");\r\n\r\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\n/**\r\n * 一种更宽松的JSON 解析，如果遇到不符合规范的字段会直接转为字符串\r\n * @param text json 内容\r\n */\r\nfunction looseJSONParse(text) {\r\n  if (typeof text !== 'string') {\r\n    return text;\r\n  }\r\n\r\n  var safeParse = function safeParse(str) {\r\n    if (typeof str !== 'string') {\r\n      return str;\r\n    }\r\n\r\n    try {\r\n      return JSON.parse(str.trim());\r\n    } catch (e) {\r\n      return str.trim();\r\n    }\r\n  };\r\n\r\n  var firstAttempt = safeParse(text);\r\n\r\n  if (typeof firstAttempt !== 'string') {\r\n    return firstAttempt;\r\n  }\r\n\r\n  var tail = function tail(arr) {\r\n    return arr[arr.length - 1];\r\n  };\r\n\r\n  var str = text.trim();\r\n  var objectStack = [];\r\n  var syntaxStack = [];\r\n\r\n  var isLastPair = function isLastPair() {\r\n    var syntaxes = [];\r\n\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n      syntaxes[_i] = arguments[_i];\r\n    }\r\n\r\n    return syntaxes.some(function (syntax) {\r\n      return tail(syntaxStack) === syntax;\r\n    });\r\n  };\r\n\r\n  var getValueStore = function getValueStore() {\r\n    return tail(objectStack);\r\n  };\r\n\r\n  var rst = null;\r\n  var i = 0;\r\n  var temp = '';\r\n\r\n  while (i < str.length) {\r\n    var nowChar = str[i];\r\n    var isInString = isLastPair('\"', \"'\");\r\n\r\n    if (!isInString && !nowChar.trim()) {\r\n      i += 1;\r\n      continue;\r\n    }\r\n\r\n    var isLastTranslate = str[i - 1] === '\\\\';\r\n    var isInObject = isLastPair('}');\r\n    var isInArray = isLastPair(']');\r\n    var isWaitingValue = isLastPair(',');\r\n    var tempArr = getValueStore();\r\n\r\n    if (isInString) {\r\n      if (tail(syntaxStack) === nowChar && !isLastTranslate) {\r\n        syntaxStack.pop();\r\n        var value = safeParse(temp);\r\n        tempArr.push(value);\r\n        rst = value;\r\n        temp = '';\r\n      } else {\r\n        temp += nowChar;\r\n      }\r\n    } else if (isInArray && nowChar === ',') {\r\n      if (temp) {\r\n        tempArr.push(safeParse(temp));\r\n        temp = '';\r\n      }\r\n    } else if (isInObject && nowChar === ':') {\r\n      syntaxStack.push(',');\r\n\r\n      if (temp) {\r\n        tempArr.push(temp);\r\n        temp = '';\r\n      }\r\n    } else if (isWaitingValue && nowChar === ',') {\r\n      if (temp) {\r\n        tempArr.push(safeParse(temp));\r\n        temp = '';\r\n      }\r\n\r\n      syntaxStack.pop();\r\n    } else if (nowChar === '}' && (isInObject || isWaitingValue)) {\r\n      if (temp) {\r\n        tempArr.push(safeParse(temp));\r\n        temp = '';\r\n      }\r\n\r\n      if (isWaitingValue) {\r\n        syntaxStack.pop();\r\n      }\r\n\r\n      var obj = {};\r\n\r\n      for (var c = 1; c < tempArr.length; c += 2) {\r\n        obj[tempArr[c - 1]] = tempArr[c];\r\n      }\r\n\r\n      objectStack.pop();\r\n\r\n      if (objectStack.length) {\r\n        tail(objectStack).push(obj);\r\n      }\r\n\r\n      syntaxStack.pop();\r\n      rst = obj;\r\n    } else if (nowChar === ']' && isInArray) {\r\n      if (temp) {\r\n        tempArr.push(safeParse(temp));\r\n        temp = '';\r\n      }\r\n\r\n      objectStack.pop();\r\n\r\n      if (objectStack.length) {\r\n        tail(objectStack).push(tempArr);\r\n      }\r\n\r\n      syntaxStack.pop();\r\n      rst = tempArr;\r\n    } else if (nowChar === '{') {\r\n      objectStack.push([]);\r\n      syntaxStack.push('}');\r\n    } else if (nowChar === '[') {\r\n      objectStack.push([]);\r\n      syntaxStack.push(']');\r\n    } else if (nowChar === '\"') {\r\n      syntaxStack.push('\"');\r\n    } else if (nowChar === \"'\") {\r\n      syntaxStack.push(\"'\");\r\n    } else {\r\n      temp += nowChar;\r\n    }\r\n\r\n    i += 1;\r\n  }\r\n\r\n  return rst || temp;\r\n}\r\n\r\nvar keyConvert = function keyConvert(str) {\r\n  return str.split('-').reduce(function (a, b) {\r\n    return a + b.charAt(0).toUpperCase() + b.slice(1);\r\n  });\r\n};\r\n/**\r\n * 简单的一个{{}}模板渲染，不包含任何复杂语法\r\n * @param xml\r\n */\r\n\r\n\r\nvar xmlDataRenderer = function xmlDataRenderer(xml) {\r\n  return function (data) {\r\n    var len = xml.length;\r\n    var arr = [];\r\n    var i = 0;\r\n    var tmp = '';\r\n\r\n    while (i < len) {\r\n      if (xml[i] === '{' && xml[i + 1] === '{') {\r\n        arr.push(tmp);\r\n        tmp = '';\r\n        i += 2;\r\n      } else if (xml[i] === '}' && xml[i + 1] === '}') {\r\n        if (arr.length) {\r\n          var last = arr.pop();\r\n          tmp = (0, _util.get)(data, tmp, last.endsWith('=') ? \"\\\"{\" + tmp + \"}\\\"\" : tmp);\r\n          arr.push(last + tmp);\r\n        }\r\n\r\n        i += 2;\r\n        tmp = '';\r\n      } else {\r\n        tmp += xml[i];\r\n        i += 1;\r\n      }\r\n    }\r\n\r\n    arr.push(tmp);\r\n    return arr.map(function (e, index) {\r\n      return arr[index - 1] && arr[index - 1].endsWith('=') ? \"\\\"{\" + e + \"}\\\"\" : e;\r\n    }).join('');\r\n  };\r\n};\r\n/**\r\n * 解析XML，并转化为相应的JSON结构\r\n * @param xml xml解析后的节点\r\n */\r\n\r\n\r\nexports.xmlDataRenderer = xmlDataRenderer;\r\n\r\nfunction parseXML(xml, cfg) {\r\n  var attrs = {};\r\n  var keys = xml.getAttributeNames && xml.getAttributeNames() || [];\r\n  var children = xml.children && Array.from(xml.children).map(function (e) {\r\n    return parseXML(e, cfg);\r\n  });\r\n  var rst = {};\r\n  var tagName = xml.tagName ? xml.tagName.toLowerCase() : 'group';\r\n\r\n  if (tagName === 'text') {\r\n    attrs.text = xml.innerText;\r\n  }\r\n\r\n  rst.type = tagName;\r\n\r\n  if (tagName === 'img') {\r\n    rst.type = 'image';\r\n  }\r\n\r\n  Array.from(keys).forEach(function (k) {\r\n    var key = keyConvert(k);\r\n    var val = xml.getAttribute(k);\r\n\r\n    try {\r\n      if (key === 'style' || key === 'attrs') {\r\n        var style = looseJSONParse(val);\r\n        attrs = (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), style);\r\n      } else {\r\n        rst[key] = looseJSONParse(val);\r\n      }\r\n    } catch (e) {\r\n      if (key === 'style') {\r\n        throw e;\r\n      }\r\n\r\n      rst[key] = val;\r\n    }\r\n  });\r\n  rst.attrs = attrs;\r\n\r\n  if (cfg && cfg.style && rst.name && _typeof(cfg.style[rst.name]) === 'object') {\r\n    rst.attrs = (0, _tslib.__assign)((0, _tslib.__assign)({}, rst.attrs), cfg.style[rst.name]);\r\n  }\r\n\r\n  if (cfg && cfg.style && rst.keyshape) {\r\n    rst.attrs = (0, _tslib.__assign)((0, _tslib.__assign)({}, rst.attrs), cfg.style);\r\n  }\r\n\r\n  if (children.length) {\r\n    rst.children = children;\r\n  }\r\n\r\n  return rst;\r\n}\r\n/**\r\n * 根据偏移量和内部节点最终的bounding box来得出该shape最终的bbox\r\n */\r\n\r\n\r\nfunction getBBox(node, offset, chilrenBBox) {\r\n  var _a = node.attrs,\r\n      attrs = _a === void 0 ? {} : _a;\r\n  var bbox = {\r\n    x: offset.x || 0,\r\n    y: offset.y || 0,\r\n    width: chilrenBBox.width || 0,\r\n    height: chilrenBBox.height || 0\r\n  };\r\n  var shapeHeight, shapeWidth;\r\n\r\n  switch (node.type) {\r\n    case 'maker':\r\n    case 'circle':\r\n      if (attrs.r) {\r\n        shapeWidth = 2 * attrs.r;\r\n        shapeHeight = 2 * attrs.r;\r\n      }\r\n\r\n      break;\r\n\r\n    case 'text':\r\n      if (attrs.text) {\r\n        shapeWidth = (0, _graphic.getTextSize)(attrs.text, attrs.fontSize || 12)[0];\r\n        shapeHeight = 16;\r\n        bbox.y += shapeHeight;\r\n        bbox.height = shapeHeight;\r\n        bbox.width = shapeWidth;\r\n        node.attrs = (0, _tslib.__assign)({\r\n          fontSize: 12,\r\n          fill: '#000'\r\n        }, attrs);\r\n      }\r\n\r\n      break;\r\n\r\n    default:\r\n      if (attrs.width) {\r\n        shapeWidth = attrs.width;\r\n      }\r\n\r\n      if (attrs.height) {\r\n        shapeHeight = attrs.height;\r\n      }\r\n\r\n  }\r\n\r\n  if (shapeHeight >= 0) {\r\n    bbox.height = shapeHeight;\r\n  }\r\n\r\n  if (shapeWidth >= 0) {\r\n    bbox.width = shapeWidth;\r\n  }\r\n\r\n  if (attrs.marginTop) {\r\n    bbox.y += attrs.marginTop;\r\n  }\r\n\r\n  if (attrs.marginLeft) {\r\n    bbox.x += attrs.marginLeft;\r\n  }\r\n\r\n  return bbox;\r\n}\r\n/**\r\n * 把从xml计算出的结构填上位置信息，补全attrs\r\n * @param target\r\n * @param lastOffset\r\n */\r\n\r\n\r\nfunction generateTarget(target, lastOffset) {\r\n  var _a;\r\n\r\n  if (lastOffset === void 0) {\r\n    lastOffset = {\r\n      x: 0,\r\n      y: 0\r\n    };\r\n  }\r\n\r\n  var defaultBbox = (0, _tslib.__assign)({\r\n    x: 0,\r\n    y: 0,\r\n    width: 0,\r\n    height: 0\r\n  }, lastOffset);\r\n\r\n  if ((_a = target.children) === null || _a === void 0 ? void 0 : _a.length) {\r\n    var _b = target.attrs,\r\n        attrs = _b === void 0 ? {} : _b;\r\n    var marginTop = attrs.marginTop;\r\n    var offset = (0, _tslib.__assign)({}, lastOffset);\r\n\r\n    if (marginTop) {\r\n      offset.y += marginTop;\r\n    }\r\n\r\n    for (var index = 0; index < target.children.length; index++) {\r\n      target.children[index].attrs.key = (attrs.key || 'root') + \" -\" + index + \" \";\r\n      var node = generateTarget(target.children[index], offset);\r\n\r\n      if (node.bbox) {\r\n        var bbox = node.bbox;\r\n\r\n        if (node.attrs.next === 'inline') {\r\n          offset.x += node.bbox.width;\r\n        } else {\r\n          offset.y += node.bbox.height;\r\n        }\r\n\r\n        if (bbox.width + bbox.x > defaultBbox.width) {\r\n          defaultBbox.width = bbox.width + bbox.x;\r\n        }\r\n\r\n        if (bbox.height + bbox.y > defaultBbox.height) {\r\n          defaultBbox.height = bbox.height + bbox.y;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  target.bbox = getBBox(target, lastOffset, defaultBbox);\r\n  target.attrs = (0, _tslib.__assign)((0, _tslib.__assign)({}, target.attrs), target.bbox);\r\n  return target;\r\n}\r\n/**\r\n * 对比前后两个最终计算出来的node，并对比出最小改动,\r\n * 动作： 'add' 添加节点 ｜ ’delete‘ 删除节点 ｜ ’change‘ 改变节点attrs ｜ 'restructure' 重构节点\r\n * @param nowTarget\r\n * @param formerTarget\r\n */\r\n\r\n\r\nfunction compareTwoTarget(nowTarget, formerTarget) {\r\n  var _a, _b, _c, _d;\r\n\r\n  var type = (nowTarget || {}).type;\r\n  var key = ((formerTarget === null || formerTarget === void 0 ? void 0 : formerTarget.attrs) || {}).key;\r\n\r\n  if (key && nowTarget) {\r\n    nowTarget.attrs.key = key;\r\n  }\r\n\r\n  if (!nowTarget && formerTarget) {\r\n    return {\r\n      action: 'delete',\r\n      val: formerTarget,\r\n      type: type,\r\n      key: key\r\n    };\r\n  }\r\n\r\n  if (nowTarget && !formerTarget) {\r\n    return {\r\n      action: 'add',\r\n      val: nowTarget,\r\n      type: type\r\n    };\r\n  }\r\n\r\n  if (!nowTarget && !formerTarget) {\r\n    return {\r\n      action: 'same',\r\n      type: type\r\n    };\r\n  }\r\n\r\n  var children = [];\r\n\r\n  if (((_a = nowTarget.children) === null || _a === void 0 ? void 0 : _a.length) > 0 || ((_b = formerTarget.children) === null || _b === void 0 ? void 0 : _b.length) > 0) {\r\n    var length_1 = Math.max((_c = nowTarget.children) === null || _c === void 0 ? void 0 : _c.length, (_d = formerTarget.children) === null || _d === void 0 ? void 0 : _d.length);\r\n    var formerChilren = formerTarget.children || [];\r\n    var nowChilren = nowTarget.children || [];\r\n\r\n    for (var index = 0; index < length_1; index += 1) {\r\n      children.push(compareTwoTarget(nowChilren[index], formerChilren[index]));\r\n    }\r\n  }\r\n\r\n  var formerKeys = Object.keys(formerTarget.attrs);\r\n  var nowKeys = Object.keys(nowTarget.attrs);\r\n\r\n  if (formerTarget.type !== nowTarget.type) {\r\n    return {\r\n      action: 'restructure',\r\n      nowTarget: nowTarget,\r\n      formerTarget: formerTarget,\r\n      key: key,\r\n      children: children\r\n    };\r\n  }\r\n\r\n  if (formerKeys.filter(function (e) {\r\n    return e !== 'children';\r\n  }).some(function (e) {\r\n    return nowTarget.attrs[e] !== formerTarget.attrs[e] || !nowKeys.includes(e);\r\n  })) {\r\n    return {\r\n      action: 'change',\r\n      val: nowTarget,\r\n      children: children,\r\n      type: type,\r\n      key: key\r\n    };\r\n  }\r\n\r\n  return {\r\n    action: 'same',\r\n    children: children,\r\n    type: type,\r\n    key: key\r\n  };\r\n}\r\n/**\r\n * 根据xml或者返回xml的函数构建自定义节点的结构\r\n * @param gen\r\n */\r\n\r\n\r\nfunction createNodeFromXML(gen) {\r\n  var structures = {};\r\n\r\n  var compileXML = function compileXML(cfg) {\r\n    var rawStr = typeof gen === 'function' ? gen(cfg) : gen;\r\n    var target = xmlDataRenderer(rawStr)(cfg);\r\n    var xmlParser = document.createElement('div');\r\n    xmlParser.innerHTML = target;\r\n    var xml = xmlParser.children[0];\r\n    var result = generateTarget(parseXML(xml, cfg));\r\n    xmlParser.remove();\r\n    return result;\r\n  };\r\n\r\n  return {\r\n    draw: function draw(cfg, group) {\r\n      var resultTarget = compileXML(cfg);\r\n      var keyshape = group;\r\n\r\n      var renderTarget = function renderTarget(target) {\r\n        var _a = target.attrs,\r\n            attrs = _a === void 0 ? {} : _a,\r\n            bbox = target.bbox,\r\n            type = target.type,\r\n            children = target.children,\r\n            rest = (0, _tslib.__rest)(target, [\"attrs\", \"bbox\", \"type\", \"children\"]);\r\n\r\n        if (target.type !== 'group') {\r\n          var shape = group.addShape(target.type, (0, _tslib.__assign)({\r\n            attrs: attrs,\r\n            origin: {\r\n              bbox: bbox,\r\n              type: type,\r\n              children: children\r\n            }\r\n          }, rest));\r\n\r\n          if (target.keyshape) {\r\n            keyshape = shape;\r\n          }\r\n        }\r\n\r\n        if (target.children) {\r\n          target.children.forEach(function (n) {\r\n            return renderTarget(n);\r\n          });\r\n        }\r\n      };\r\n\r\n      renderTarget(resultTarget);\r\n      structures[cfg.id] = [resultTarget];\r\n      return keyshape;\r\n    },\r\n    update: function update(cfg, node) {\r\n      if (!structures[cfg.id]) {\r\n        structures[cfg.id] = [];\r\n      }\r\n\r\n      var container = node.getContainer();\r\n      var children = container.get('children');\r\n      var newTarget = compileXML(cfg);\r\n      var lastTarget = structures[cfg.id].pop();\r\n      var diffResult = compareTwoTarget(newTarget, lastTarget);\r\n\r\n      var addShape = function addShape(shape) {\r\n        var _a;\r\n\r\n        if (shape.type !== 'group') {\r\n          container.addShape(shape.type, {\r\n            attrs: shape.attrs\r\n          });\r\n        }\r\n\r\n        if ((_a = shape.children) === null || _a === void 0 ? void 0 : _a.length) {\r\n          shape.children.map(function (e) {\r\n            return addShape(e);\r\n          });\r\n        }\r\n      };\r\n\r\n      var delShape = function delShape(shape) {\r\n        var _a;\r\n\r\n        var targetShape = children.find(function (e) {\r\n          return e.attrs.key === shape.attrs.key;\r\n        });\r\n\r\n        if (targetShape) {\r\n          container.removeChild(targetShape);\r\n        }\r\n\r\n        if ((_a = shape.children) === null || _a === void 0 ? void 0 : _a.length) {\r\n          shape.children.map(function (e) {\r\n            return delShape(e);\r\n          });\r\n        }\r\n      };\r\n\r\n      var updateTarget = function updateTarget(target) {\r\n        var key = target.key;\r\n\r\n        if (target.type !== 'group') {\r\n          var targetShape = children.find(function (e) {\r\n            return e.attrs.key === key;\r\n          });\r\n\r\n          switch (target.action) {\r\n            case 'change':\r\n              if (targetShape) {\r\n                var originAttr = target.val.keyshape ? node.getOriginStyle() : {};\r\n                targetShape.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, originAttr), target.val.attrs));\r\n              }\r\n\r\n              break;\r\n\r\n            case 'add':\r\n              addShape(target.val);\r\n              break;\r\n\r\n            case 'delete':\r\n              delShape(target.val);\r\n              break;\r\n\r\n            case 'restructure':\r\n              delShape(target.formerTarget);\r\n              addShape(target.nowTarget);\r\n              break;\r\n\r\n            default:\r\n              break;\r\n          }\r\n        }\r\n\r\n        if (target.children) {\r\n          target.children.forEach(function (n) {\r\n            return updateTarget(n);\r\n          });\r\n        }\r\n      };\r\n\r\n      updateTarget(diffResult);\r\n      structures[cfg.id].push(newTarget);\r\n    },\r\n    getAnchorPoints: function getAnchorPoints() {\r\n      return [[0, 0.5], [1, 0.5], [0.5, 1], [0.5, 0]];\r\n    }\r\n  };\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _math = require(\"../util/math\");\r\n\r\nvar _item = _interopRequireDefault(require(\"./item\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar CACHE_ANCHOR_POINTS = 'anchorPointsCache';\r\nvar CACHE_BBOX = 'bboxCache';\r\n\r\nvar Node =\r\n/** @class */\r\nfunction (_super) {\r\n  (0, _tslib.__extends)(Node, _super);\r\n\r\n  function Node() {\r\n    return _super !== null && _super.apply(this, arguments) || this;\r\n  }\r\n\r\n  Node.prototype.getNearestPoint = function (points, curPoint) {\r\n    var index = 0;\r\n    var nearestPoint = points[0];\r\n    var minDistance = (0, _math.distance)(points[0], curPoint);\r\n\r\n    for (var i = 0; i < points.length; i++) {\r\n      var point = points[i];\r\n      var dis = (0, _math.distance)(point, curPoint);\r\n\r\n      if (dis < minDistance) {\r\n        nearestPoint = point;\r\n        minDistance = dis;\r\n        index = i;\r\n      }\r\n    }\r\n\r\n    nearestPoint.anchorIndex = index;\r\n    return nearestPoint;\r\n  };\r\n\r\n  Node.prototype.getDefaultCfg = function () {\r\n    return {\r\n      type: 'node',\r\n      edges: []\r\n    };\r\n  };\r\n  /**\r\n   * 获取从节点关联的所有边\r\n   */\r\n\r\n\r\n  Node.prototype.getEdges = function () {\r\n    return this.get('edges');\r\n  };\r\n  /**\r\n   * 获取所有的入边\r\n   */\r\n\r\n\r\n  Node.prototype.getInEdges = function () {\r\n    var self = this;\r\n    return this.get('edges').filter(function (edge) {\r\n      return edge.get('target') === self;\r\n    });\r\n  };\r\n  /**\r\n   * 获取所有的出边\r\n   */\r\n\r\n\r\n  Node.prototype.getOutEdges = function () {\r\n    var self = this;\r\n    return this.get('edges').filter(function (edge) {\r\n      return edge.get('source') === self;\r\n    });\r\n  };\r\n  /**\r\n   * 获取节点的邻居节点\r\n   *\r\n   * @returns {INode[]}\r\n   * @memberof Node\r\n   */\r\n\r\n\r\n  Node.prototype.getNeighbors = function (type) {\r\n    var _this = this;\r\n\r\n    var edges = this.get('edges');\r\n\r\n    if (type === 'target') {\r\n      // 当前节点为 source，它所指向的目标节点\r\n      var neighhborsConverter_1 = function neighhborsConverter_1(edge) {\r\n        return edge.getSource() === _this;\r\n      };\r\n\r\n      return edges.filter(neighhborsConverter_1).map(function (edge) {\r\n        return edge.getTarget();\r\n      });\r\n    }\r\n\r\n    if (type === 'source') {\r\n      // 当前节点为 target，它所指向的源节点\r\n      var neighhborsConverter_2 = function neighhborsConverter_2(edge) {\r\n        return edge.getTarget() === _this;\r\n      };\r\n\r\n      return edges.filter(neighhborsConverter_2).map(function (edge) {\r\n        return edge.getSource();\r\n      });\r\n    } // 若未指定 type ，则返回所有邻居\r\n\r\n\r\n    var neighhborsConverter = function neighhborsConverter(edge) {\r\n      return edge.getSource() === _this ? edge.getTarget() : edge.getSource();\r\n    };\r\n\r\n    return edges.map(neighhborsConverter);\r\n  };\r\n  /**\r\n   * 根据锚点的索引获取连接点\r\n   * @param  {Number} index 索引\r\n   */\r\n\r\n\r\n  Node.prototype.getLinkPointByAnchor = function (index) {\r\n    var anchorPoints = this.getAnchorPoints();\r\n    return anchorPoints[index];\r\n  };\r\n  /**\r\n   * 获取连接点\r\n   * @param point\r\n   */\r\n\r\n\r\n  Node.prototype.getLinkPoint = function (point) {\r\n    var keyShape = this.get('keyShape');\r\n    var type = keyShape.get('type');\r\n    var itemType = this.get('type');\r\n    var centerX;\r\n    var centerY;\r\n    var bbox = this.getBBox();\r\n\r\n    if (itemType === 'combo') {\r\n      centerX = bbox.centerX || (bbox.maxX + bbox.minX) / 2;\r\n      centerY = bbox.centerY || (bbox.maxY + bbox.minY) / 2;\r\n    } else {\r\n      centerX = bbox.centerX;\r\n      centerY = bbox.centerY;\r\n    }\r\n\r\n    var anchorPoints = this.getAnchorPoints();\r\n    var intersectPoint;\r\n\r\n    switch (type) {\r\n      case 'circle':\r\n        intersectPoint = (0, _math.getCircleIntersectByPoint)({\r\n          x: centerX,\r\n          y: centerY,\r\n          r: bbox.width / 2\r\n        }, point);\r\n        break;\r\n\r\n      case 'ellipse':\r\n        intersectPoint = (0, _math.getEllipseIntersectByPoint)({\r\n          x: centerX,\r\n          y: centerY,\r\n          rx: bbox.width / 2,\r\n          ry: bbox.height / 2\r\n        }, point);\r\n        break;\r\n\r\n      default:\r\n        intersectPoint = (0, _math.getRectIntersectByPoint)(bbox, point);\r\n    }\r\n\r\n    var linkPoint = intersectPoint; // 如果存在锚点，则使用交点计算最近的锚点\r\n\r\n    if (anchorPoints.length) {\r\n      if (!linkPoint) {\r\n        // 如果计算不出交点\r\n        linkPoint = point;\r\n      }\r\n\r\n      linkPoint = this.getNearestPoint(anchorPoints, linkPoint);\r\n    }\r\n\r\n    if (!linkPoint) {\r\n      // 如果最终依然没法找到锚点和连接点，直接返回中心点\r\n      linkPoint = {\r\n        x: centerX,\r\n        y: centerY\r\n      };\r\n    }\r\n\r\n    return linkPoint;\r\n  };\r\n  /**\r\n   * 获取锚点的定义\r\n   * @return {array} anchorPoints\r\n   */\r\n\r\n\r\n  Node.prototype.getAnchorPoints = function () {\r\n    var anchorPoints = this.get(CACHE_ANCHOR_POINTS);\r\n\r\n    if (!anchorPoints) {\r\n      anchorPoints = [];\r\n      var shapeFactory = this.get('shapeFactory');\r\n      var bbox_1 = this.getBBox();\r\n      var model = this.get('model');\r\n      var shapeCfg = this.getShapeCfg(model);\r\n      var type = model.type;\r\n      var points = shapeFactory.getAnchorPoints(type, shapeCfg) || [];\r\n      (0, _util.each)(points, function (pointArr, index) {\r\n        var point = {\r\n          x: bbox_1.minX + pointArr[0] * bbox_1.width,\r\n          y: bbox_1.minY + pointArr[1] * bbox_1.height,\r\n          anchorIndex: index\r\n        };\r\n        anchorPoints.push(point);\r\n      });\r\n      this.set(CACHE_ANCHOR_POINTS, anchorPoints);\r\n    }\r\n\r\n    return anchorPoints;\r\n  };\r\n  /**\r\n   * add edge\r\n   * @param edge Edge instance\r\n   */\r\n\r\n\r\n  Node.prototype.addEdge = function (edge) {\r\n    this.get('edges').push(edge);\r\n  };\r\n  /**\r\n   * 锁定节点\r\n   */\r\n\r\n\r\n  Node.prototype.lock = function () {\r\n    this.set('locked', true);\r\n  };\r\n  /**\r\n   * 解锁锁定的节点\r\n   */\r\n\r\n\r\n  Node.prototype.unlock = function () {\r\n    this.set('locked', false);\r\n  };\r\n\r\n  Node.prototype.hasLocked = function () {\r\n    return this.get('locked');\r\n  };\r\n  /**\r\n   * 移除边\r\n   * @param {Edge} edge 边\r\n   */\r\n\r\n\r\n  Node.prototype.removeEdge = function (edge) {\r\n    var edges = this.getEdges();\r\n    var index = edges.indexOf(edge);\r\n\r\n    if (index > -1) {\r\n      edges.splice(index, 1);\r\n    }\r\n  };\r\n\r\n  Node.prototype.clearCache = function () {\r\n    this.set(CACHE_BBOX, null); // 清理缓存的 bbox\r\n\r\n    this.set(CACHE_ANCHOR_POINTS, null);\r\n  };\r\n  /**\r\n   * 是否仅仅移动节点，其他属性没变化\r\n   * @param cfg 节点数据模型\r\n   */\r\n\r\n\r\n  Node.prototype.isOnlyMove = function (cfg) {\r\n    if (!cfg) {\r\n      return false;\r\n    }\r\n\r\n    var existX = !(0, _util.isNil)(cfg.x);\r\n    var existY = !(0, _util.isNil)(cfg.y);\r\n    var keys = Object.keys(cfg); // 仅有一个字段，包含 x 或者 包含 y\r\n    // 两个字段，同时有 x，同时有 y\r\n\r\n    return keys.length === 1 && (existX || existY) || keys.length === 2 && existX && existY;\r\n  };\r\n\r\n  return Node;\r\n}(_item.default);\r\n\r\nvar _default = Node;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _node = _interopRequireDefault(require(\"./node\"));\r\n\r\nvar _global = _interopRequireDefault(require(\"../global\"));\r\n\r\nvar _graphic = require(\"../util/graphic\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar CACHE_BBOX = 'bboxCache';\r\nvar CACHE_CANVAS_BBOX = 'bboxCanvasCache';\r\nvar CACHE_SIZE = 'sizeCache';\r\nvar CACHE_ANCHOR_POINTS = 'anchorPointsCache';\r\n\r\nvar Combo =\r\n/** @class */\r\nfunction (_super) {\r\n  (0, _tslib.__extends)(Combo, _super);\r\n\r\n  function Combo() {\r\n    return _super !== null && _super.apply(this, arguments) || this;\r\n  }\r\n\r\n  Combo.prototype.getDefaultCfg = function () {\r\n    return {\r\n      type: 'combo',\r\n      nodes: [],\r\n      edges: [],\r\n      combos: []\r\n    };\r\n  };\r\n\r\n  Combo.prototype.getShapeCfg = function (model) {\r\n    var styles = this.get('styles');\r\n    var bbox = this.get('bbox');\r\n\r\n    if (styles && bbox) {\r\n      // merge graph的item样式与数据模型中的样式\r\n      var newModel = model;\r\n      var size = {\r\n        r: Math.hypot(bbox.height, bbox.width) / 2 || _global.default.defaultCombo.size[0] / 2,\r\n        width: bbox.width || _global.default.defaultCombo.size[0],\r\n        height: bbox.height || _global.default.defaultCombo.size[1]\r\n      };\r\n      newModel.style = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), model.style), size);\r\n      var padding = model.padding || _global.default.defaultCombo.padding;\r\n\r\n      if ((0, _util.isNumber)(padding)) {\r\n        size.r += padding;\r\n        size.width += padding * 2;\r\n        size.height += padding * 2;\r\n      } else {\r\n        size.r += padding[0];\r\n        size.width += padding[1] + padding[3] || padding[1] * 2;\r\n        size.height += padding[0] + padding[2] || padding[0] * 2;\r\n      }\r\n\r\n      this.set(CACHE_SIZE, size);\r\n      return newModel;\r\n    }\r\n\r\n    return model;\r\n  };\r\n  /**\r\n   * 根据 keyshape 计算包围盒\r\n   */\r\n\r\n\r\n  Combo.prototype.calculateCanvasBBox = function () {\r\n    if (this.destroyed) return;\r\n    var keyShape = this.get('keyShape');\r\n    var group = this.get('group'); // 因为 group 可能会移动，所以必须通过父元素计算才能计算出正确的包围盒\r\n\r\n    var bbox = (0, _graphic.getBBox)(keyShape, group);\r\n    bbox.centerX = (bbox.minX + bbox.maxX) / 2;\r\n    bbox.centerY = (bbox.minY + bbox.maxY) / 2;\r\n    var cacheSize = this.get(CACHE_SIZE);\r\n    var cacheBBox = this.get(CACHE_BBOX) || {};\r\n    var oriX = cacheBBox.x;\r\n    var oriY = cacheBBox.x;\r\n\r\n    if (cacheSize) {\r\n      cacheSize.width = Math.max(cacheSize.width, bbox.width);\r\n      cacheSize.height = Math.max(cacheSize.height, bbox.height);\r\n      var type = keyShape.get('type');\r\n\r\n      if (type === 'circle') {\r\n        bbox.width = cacheSize.r * 2;\r\n        bbox.height = cacheSize.r * 2;\r\n      } else {\r\n        bbox.width = cacheSize.width;\r\n        bbox.height = cacheSize.height;\r\n      }\r\n\r\n      bbox.minX = bbox.centerX - bbox.width / 2;\r\n      bbox.minY = bbox.centerY - bbox.height / 2;\r\n      bbox.maxX = bbox.centerX + bbox.width / 2;\r\n      bbox.maxY = bbox.centerY + bbox.height / 2;\r\n    } else {\r\n      bbox.width = bbox.maxX - bbox.minX;\r\n      bbox.height = bbox.maxY - bbox.minY;\r\n      bbox.centerX = (bbox.minX + bbox.maxX) / 2;\r\n      bbox.centerY = (bbox.minY + bbox.maxY) / 2;\r\n    }\r\n\r\n    bbox.x = bbox.minX;\r\n    bbox.y = bbox.minY;\r\n    if (bbox.x !== oriX || bbox.y !== oriY) this.set(CACHE_ANCHOR_POINTS, null);\r\n    return bbox;\r\n  };\r\n  /**\r\n   * 获取 Combo 中所有的子元素，包括 Combo、Node 及 Edge\r\n   */\r\n\r\n\r\n  Combo.prototype.getChildren = function () {\r\n    var self = this;\r\n    return {\r\n      nodes: self.getNodes(),\r\n      combos: self.getCombos()\r\n    };\r\n  };\r\n  /**\r\n   * 获取 Combo 中所有子节点\r\n   */\r\n\r\n\r\n  Combo.prototype.getNodes = function () {\r\n    var self = this;\r\n    return self.get('nodes');\r\n  };\r\n  /**\r\n   * 获取 Combo 中所有子 combo\r\n   */\r\n\r\n\r\n  Combo.prototype.getCombos = function () {\r\n    var self = this;\r\n    return self.get('combos');\r\n  };\r\n  /**\r\n   * 向 Combo 中增加子 combo 或 node\r\n   * @param item Combo 或节点实例\r\n   * @return boolean 添加成功返回 true，否则返回 false\r\n   */\r\n\r\n\r\n  Combo.prototype.addChild = function (item) {\r\n    var self = this;\r\n    var itemType = item.getType();\r\n\r\n    switch (itemType) {\r\n      case 'node':\r\n        self.addNode(item);\r\n        break;\r\n\r\n      case 'combo':\r\n        self.addCombo(item);\r\n        break;\r\n\r\n      default:\r\n        console.warn('Only node or combo items are allowed to be added into a combo');\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n  /**\r\n   * 向 Combo 中增加 combo\r\n   * @param combo Combo 实例\r\n   * @return boolean 添加成功返回 true，否则返回 false\r\n   */\r\n\r\n\r\n  Combo.prototype.addCombo = function (combo) {\r\n    var self = this;\r\n    self.get('combos').push(combo);\r\n    return true;\r\n  };\r\n  /**\r\n   * 向 Combo 中添加节点\r\n   * @param node 节点实例\r\n   * @return boolean 添加成功返回 true，否则返回 false\r\n   */\r\n\r\n\r\n  Combo.prototype.addNode = function (node) {\r\n    var self = this;\r\n    self.get('nodes').push(node);\r\n    return true;\r\n  };\r\n  /**\r\n   * 向 Combo 中增加子 combo 或 node\r\n   * @param item Combo 或节点实例\r\n   * @return boolean 添加成功返回 true，否则返回 false\r\n   */\r\n\r\n\r\n  Combo.prototype.removeChild = function (item) {\r\n    var self = this;\r\n    var itemType = item.getType();\r\n\r\n    switch (itemType) {\r\n      case 'node':\r\n        self.removeNode(item);\r\n        break;\r\n\r\n      case 'combo':\r\n        self.removeCombo(item);\r\n        break;\r\n\r\n      default:\r\n        console.warn('Only node or combo items are allowed to be added into a combo');\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n  /**\r\n   * 从 Combo 中移除指定的 combo\r\n   * @param combo Combo 实例\r\n   * @return boolean 移除成功返回 true，否则返回 false\r\n   */\r\n\r\n\r\n  Combo.prototype.removeCombo = function (combo) {\r\n    if (!combo) return;\r\n    var combos = this.getCombos();\r\n    var index = combos.indexOf(combo);\r\n\r\n    if (index > -1) {\r\n      combos.splice(index, 1);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n  /**\r\n   * 向 Combo 中移除指定的节点\r\n   * @param node 节点实例\r\n   * @return boolean 移除成功返回 true，否则返回 false\r\n   */\r\n\r\n\r\n  Combo.prototype.removeNode = function (node) {\r\n    if (!node) return;\r\n    var nodes = this.getNodes();\r\n    var index = nodes.indexOf(node);\r\n\r\n    if (index > -1) {\r\n      nodes.splice(index, 1);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  Combo.prototype.isOnlyMove = function (cfg) {\r\n    return false;\r\n  };\r\n  /**\r\n   * 获取 item 的包围盒，这个包围盒是相对于 item 自己，不会将 matrix 计算在内\r\n   * @return {Object} 包含 x,y,width,height, centerX, centerY\r\n   */\r\n\r\n\r\n  Combo.prototype.getBBox = function () {\r\n    this.set(CACHE_CANVAS_BBOX, null);\r\n    var bbox = this.calculateCanvasBBox();\r\n    return bbox;\r\n  };\r\n\r\n  Combo.prototype.clearCache = function () {\r\n    this.set(CACHE_BBOX, null); // 清理缓存的 bbox\r\n\r\n    this.set(CACHE_CANVAS_BBOX, null);\r\n    this.set(CACHE_ANCHOR_POINTS, null);\r\n  };\r\n\r\n  Combo.prototype.destroy = function () {\r\n    if (!this.destroyed) {\r\n      var animate = this.get('animate');\r\n      var group = this.get('group');\r\n\r\n      if (animate) {\r\n        group.stopAnimate();\r\n      }\r\n\r\n      this.clearCache();\r\n      this.set(CACHE_SIZE, null);\r\n      this.set('bbox', null);\r\n      group.remove();\r\n      this._cfg = null;\r\n      this.destroyed = true;\r\n    }\r\n  };\r\n\r\n  return Combo;\r\n}(_node.default);\r\n\r\nvar _default = Combo;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar timer = null;\r\n\r\nvar StateController =\r\n/** @class */\r\nfunction () {\r\n  function StateController(graph) {\r\n    this.graph = graph;\r\n    /**\r\n     * this.cachedStates = {\r\n     *    enabled: {\r\n     *        hover: [Node]\r\n     *    },\r\n     *     disabled: {}\r\n     *  }\r\n     */\r\n\r\n    this.cachedStates = {\r\n      enabled: {},\r\n      disabled: {}\r\n    };\r\n    this.destroyed = false;\r\n  }\r\n  /**\r\n   * 检查 cache 的可用性\r\n   *\r\n   * @private\r\n   * @param {Item} item\r\n   * @param {string} state\r\n   * @param {object} cache\r\n   * @returns\r\n   * @memberof State\r\n   */\r\n\r\n\r\n  StateController.checkCache = function (item, state, cache) {\r\n    if (!cache[state]) {\r\n      return;\r\n    }\r\n\r\n    var index = cache[state].indexOf(item);\r\n\r\n    if (index >= 0) {\r\n      cache[state].splice(index, 1);\r\n    }\r\n  };\r\n  /**\r\n   * 缓存 state\r\n   *\r\n   * @private\r\n   * @param {Item} item Item 实例\r\n   * @param {string} state 状态名称\r\n   * @param {object} states\r\n   * @memberof State\r\n   */\r\n\r\n\r\n  StateController.cacheState = function (item, state, states) {\r\n    if (!states[state]) {\r\n      states[state] = [];\r\n    }\r\n\r\n    states[state].push(item);\r\n  };\r\n  /**\r\n   * 更新 Item 的状态\r\n   *\r\n   * @param {Item} item Item实例\r\n   * @param {string} state 状态名称\r\n   * @param {boolean} enabled 状态是否可用\r\n   * @memberof State\r\n   */\r\n\r\n\r\n  StateController.prototype.updateState = function (item, state, enabled) {\r\n    var _this = this;\r\n\r\n    var checkCache = StateController.checkCache,\r\n        cacheState = StateController.cacheState;\r\n\r\n    if (item.destroyed) {\r\n      return;\r\n    }\r\n\r\n    var cachedStates = this.cachedStates;\r\n    var enabledStates = cachedStates.enabled;\r\n    var disabledStates = cachedStates.disabled;\r\n\r\n    if (enabled) {\r\n      checkCache(item, state, disabledStates);\r\n      cacheState(item, state, enabledStates);\r\n    } else {\r\n      checkCache(item, state, enabledStates);\r\n      cacheState(item, state, disabledStates);\r\n    }\r\n\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n    }\r\n\r\n    timer = setTimeout(function () {\r\n      timer = null;\r\n\r\n      _this.updateGraphStates();\r\n    }, 16);\r\n  };\r\n  /**\r\n   * 批量更新 states，兼容 updateState，支持更新一个 state\r\n   *\r\n   * @param {Item} item\r\n   * @param {(string | string[])} states\r\n   * @param {boolean} enabled\r\n   * @memberof State\r\n   */\r\n\r\n\r\n  StateController.prototype.updateStates = function (item, states, enabled) {\r\n    var _this = this;\r\n\r\n    if ((0, _util.isString)(states)) {\r\n      this.updateState(item, states, enabled);\r\n    } else {\r\n      states.forEach(function (state) {\r\n        _this.updateState(item, state, enabled);\r\n      });\r\n    }\r\n  };\r\n  /**\r\n   * 更新 states\r\n   *\r\n   * @memberof State\r\n   */\r\n\r\n\r\n  StateController.prototype.updateGraphStates = function () {\r\n    var states = this.graph.get('states');\r\n    var cachedStates = this.cachedStates;\r\n    (0, _util.each)(cachedStates.disabled, function (val, key) {\r\n      if (states[key]) {\r\n        states[key] = states[key].filter(function (item) {\r\n          return val.indexOf(item) < 0 && !val.destroyed;\r\n        });\r\n      }\r\n    });\r\n    (0, _util.each)(cachedStates.enabled, function (val, key) {\r\n      if (!states[key]) {\r\n        states[key] = val;\r\n      } else {\r\n        var map_1 = {};\r\n        states[key].forEach(function (item) {\r\n          if (!item.destroyed) {\r\n            map_1[item.get('id')] = true;\r\n          }\r\n        });\r\n        val.forEach(function (item) {\r\n          if (!item.destroyed) {\r\n            var id = item.get('id');\r\n\r\n            if (!map_1[id]) {\r\n              map_1[id] = true;\r\n              states[key].push(item);\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n    this.graph.emit('graphstatechange', {\r\n      states: states\r\n    });\r\n    this.cachedStates = {\r\n      enabled: {},\r\n      disabled: {}\r\n    };\r\n  };\r\n\r\n  StateController.prototype.destroy = function () {\r\n    this.graph = null;\r\n    this.cachedStates = null;\r\n\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n    }\r\n\r\n    timer = null;\r\n    this.destroyed = true;\r\n  };\r\n\r\n  return StateController;\r\n}();\r\n\r\nvar _default = StateController;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _pathUtil = require(\"@antv/path-util\");\r\n\r\nvar _path = require(\"../util/path\");\r\n\r\nvar _math = require(\"../util/math\");\r\n\r\nvar _convexHull = require(\"../element/hull/convexHull\");\r\n\r\nvar _bubbleset = require(\"../element/hull/bubbleset\");\r\n\r\n/**\r\n * 用于包裹内部的成员的轮廓。\r\n * convex hull(凸包)：http://geomalgorithms.com/a10-_hull-1.html#Monotone%20Chain\r\n * bubble: 使用 bubbleset算法，refer: http://vialab.science.uoit.ca/wp-content/papercite-data/pdf/col2009c.pdf\r\n * 通过配置 padding 可以调节包裹轮廓对节点的松紧程度\r\n */\r\nvar Hull =\r\n/** @class */\r\nfunction () {\r\n  function Hull(graph, cfg) {\r\n    this.cfg = (0, _util.deepMix)(this.getDefaultCfg(), cfg);\r\n    this.graph = graph;\r\n    this.id = this.cfg.id;\r\n    this.group = this.cfg.group;\r\n    this.members = this.cfg.members.map(function (item) {\r\n      return (0, _util.isString)(item) ? graph.findById(item) : item;\r\n    });\r\n    this.nonMembers = this.cfg.nonMembers.map(function (item) {\r\n      return (0, _util.isString)(item) ? graph.findById(item) : item;\r\n    });\r\n    this.setPadding();\r\n    this.setType();\r\n    this.path = this.calcPath(this.members, this.nonMembers);\r\n    this.render();\r\n  }\r\n\r\n  Hull.prototype.getDefaultCfg = function () {\r\n    return {\r\n      id: 'g6-hull',\r\n      type: 'round-convex',\r\n      members: [],\r\n      nonMembers: [],\r\n      style: {\r\n        fill: 'lightblue',\r\n        stroke: 'blue',\r\n        opacity: 0.2\r\n      },\r\n      padding: 10\r\n    };\r\n  };\r\n\r\n  Hull.prototype.setPadding = function () {\r\n    var nodeSize = this.members.length && this.members[0].getKeyShape().getCanvasBBox().width / 2;\r\n    this.padding = this.cfg.padding > 0 ? this.cfg.padding + nodeSize : 10 + nodeSize;\r\n    this.cfg.bubbleCfg = {\r\n      nodeR0: this.padding - nodeSize,\r\n      nodeR1: this.padding - nodeSize,\r\n      morphBuffer: this.padding - nodeSize\r\n    };\r\n  };\r\n\r\n  Hull.prototype.setType = function () {\r\n    this.type = this.cfg.type;\r\n\r\n    if (this.members.length < 3) {\r\n      this.type = 'round-convex';\r\n    }\r\n\r\n    if (this.type !== 'round-convex' && this.type !== 'smooth-convex' && this.type !== 'bubble') {\r\n      console.warn('The hull type should be either round-convex, smooth-convex or bubble, round-convex is used by default.');\r\n      this.type = 'round-convex';\r\n    }\r\n  };\r\n\r\n  Hull.prototype.calcPath = function (members, nonMembers) {\r\n    var contour, path, hull;\r\n\r\n    switch (this.type) {\r\n      case 'round-convex':\r\n        contour = (0, _convexHull.genConvexHull)(members);\r\n        hull = (0, _path.roundedHull)(contour.map(function (p) {\r\n          return [p.x, p.y];\r\n        }), this.padding);\r\n        path = (0, _pathUtil.parsePathString)(hull);\r\n        break;\r\n\r\n      case 'smooth-convex':\r\n        contour = (0, _convexHull.genConvexHull)(members);\r\n\r\n        if (contour.length === 2) {\r\n          hull = (0, _path.roundedHull)(contour.map(function (p) {\r\n            return [p.x, p.y];\r\n          }), this.padding);\r\n          path = (0, _pathUtil.parsePathString)(hull);\r\n        } else if (contour.length > 2) {\r\n          hull = (0, _path.paddedHull)(contour.map(function (p) {\r\n            return [p.x, p.y];\r\n          }), this.padding);\r\n          path = (0, _path.getClosedSpline)(hull);\r\n        }\r\n\r\n        break;\r\n\r\n      case 'bubble':\r\n        contour = (0, _bubbleset.genBubbleSet)(members, nonMembers, this.cfg.bubbleCfg);\r\n        path = contour.length >= 2 && (0, _path.getClosedSpline)(contour);\r\n        break;\r\n\r\n      default:\r\n    }\r\n\r\n    return path;\r\n  };\r\n\r\n  Hull.prototype.render = function () {\r\n    this.group.addShape('path', {\r\n      attrs: (0, _tslib.__assign)({\r\n        path: this.path\r\n      }, this.cfg.style),\r\n      id: this.id,\r\n      name: this.cfg.id\r\n    });\r\n    this.group.toBack();\r\n  };\r\n  /**\r\n   * 增加hull的成员，同时如果该成员原先在nonMembers中，则从nonMembers中去掉\r\n   * @param item 节点实例\r\n   * @return boolean 添加成功返回 true，否则返回 false\r\n   */\r\n\r\n\r\n  Hull.prototype.addMember = function (item) {\r\n    if (!item) return;\r\n    if ((0, _util.isString)(item)) item = this.graph.findById(item);\r\n    this.members.push(item);\r\n    var index = this.nonMembers.indexOf(item);\r\n\r\n    if (index > -1) {\r\n      this.nonMembers.splice(index, 1);\r\n    }\r\n\r\n    this.updateData(this.members, this.nonMembers);\r\n    return true;\r\n  };\r\n  /**\r\n   * 增加hull需要排除的节点，同时如果该成员原先在members中，则从members中去掉\r\n   * @param item 节点实例\r\n   * @return boolean 添加成功返回 true，否则返回 false\r\n   */\r\n\r\n\r\n  Hull.prototype.addNonMember = function (item) {\r\n    if (!item) return;\r\n    if ((0, _util.isString)(item)) item = this.graph.findById(item);\r\n    this.nonMembers.push(item);\r\n    var index = this.members.indexOf(item);\r\n\r\n    if (index > -1) {\r\n      this.members.splice(index, 1);\r\n    }\r\n\r\n    this.updateData(this.members, this.nonMembers);\r\n    return true;\r\n  };\r\n  /**\r\n   * 移除hull中的成员\r\n   * @param node 节点实例\r\n   * @return boolean 移除成功返回 true，否则返回 false\r\n   */\r\n\r\n\r\n  Hull.prototype.removeMember = function (item) {\r\n    if (!item) return;\r\n    if ((0, _util.isString)(item)) item = this.graph.findById(item);\r\n    var index = this.members.indexOf(item);\r\n\r\n    if (index > -1) {\r\n      this.members.splice(index, 1);\r\n      this.updateData(this.members, this.nonMembers);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n  /**\r\n   * @param node 节点实例\r\n   * @return boolean 移除成功返回 true，否则返回 false\r\n   */\r\n\r\n\r\n  Hull.prototype.removeNonMember = function (item) {\r\n    if (!item) return;\r\n    if ((0, _util.isString)(item)) item = this.graph.findById(item);\r\n    var index = this.nonMembers.indexOf(item);\r\n\r\n    if (index > -1) {\r\n      this.nonMembers.splice(index, 1);\r\n      this.updateData(this.members, this.nonMembers);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  Hull.prototype.updateData = function (members, nonMembers) {\r\n    var _this = this;\r\n\r\n    this.group.findById(this.id).remove();\r\n    if (members) this.members = members.map(function (item) {\r\n      return (0, _util.isString)(item) ? _this.graph.findById(item) : item;\r\n    });\r\n    if (nonMembers) this.nonMembers = nonMembers.map(function (item) {\r\n      return (0, _util.isString)(item) ? _this.graph.findById(item) : item;\r\n    });\r\n    this.path = this.calcPath(this.members, this.nonMembers);\r\n    this.render();\r\n  };\r\n\r\n  Hull.prototype.updateStyle = function (cfg) {\r\n    var path = this.group.findById(this.id);\r\n    path.attr((0, _tslib.__assign)({}, cfg));\r\n  };\r\n  /**\r\n   * 更新 hull\r\n   * @param cfg hull 配置项\r\n   */\r\n\r\n\r\n  Hull.prototype.updateCfg = function (cfg) {\r\n    var _this = this;\r\n\r\n    this.cfg = (0, _util.deepMix)(this.cfg, cfg);\r\n    this.id = this.cfg.id;\r\n    this.group = this.cfg.group;\r\n\r\n    if (cfg.members) {\r\n      this.members = this.cfg.members.map(function (item) {\r\n        return (0, _util.isString)(item) ? _this.graph.findById(item) : item;\r\n      });\r\n    }\r\n\r\n    if (cfg.nonMembers) {\r\n      this.nonMembers = this.cfg.nonMembers.map(function (item) {\r\n        return (0, _util.isString)(item) ? _this.graph.findById(item) : item;\r\n      });\r\n    } // TODO padding 设置太大，会影响到 contain 结果\r\n\r\n\r\n    this.setPadding();\r\n    this.setType();\r\n    this.path = this.calcPath(this.members, this.nonMembers);\r\n    this.render();\r\n  };\r\n  /**\r\n   * 判断是否在hull内部\r\n   * @param item\r\n   */\r\n\r\n\r\n  Hull.prototype.contain = function (item) {\r\n    var _this = this;\r\n\r\n    var nodeItem;\r\n\r\n    if ((0, _util.isString)(item)) {\r\n      nodeItem = this.graph.findById(item);\r\n    } else {\r\n      nodeItem = item;\r\n    }\r\n\r\n    var shapePoints;\r\n    var shape = nodeItem.getKeyShape();\r\n\r\n    if (nodeItem.get('type') === 'path') {\r\n      shapePoints = (0, _path.pathToPoints)(shape.attr('path'));\r\n    } else {\r\n      var shapeBBox = shape.getCanvasBBox();\r\n      shapePoints = [[shapeBBox.minX, shapeBBox.minY], [shapeBBox.maxX, shapeBBox.minY], [shapeBBox.maxX, shapeBBox.maxY], [shapeBBox.minX, shapeBBox.maxY]];\r\n    }\r\n\r\n    shapePoints = shapePoints.map(function (canvasPoint) {\r\n      var point = _this.graph.getPointByCanvas(canvasPoint[0], canvasPoint[1]);\r\n\r\n      return [point.x, point.y];\r\n    });\r\n    return (0, _math.isPolygonsIntersect)(shapePoints, (0, _path.pathToPoints)(this.path));\r\n  };\r\n\r\n  Hull.prototype.destroy = function () {\r\n    this.group.remove();\r\n    this.cfg = null;\r\n  };\r\n\r\n  return Hull;\r\n}();\r\n\r\nvar _default = Hull;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.roundedHull = roundedHull;\r\nexports.paddedHull = paddedHull;\r\nexports.getClosedSpline = exports.pathToPoints = exports.pointsToPolygon = exports.getControlPoint = exports.getSpline = void 0;\r\n\r\nvar _matrixUtil = require(\"@antv/matrix-util\");\r\n\r\nvar _pathUtil = require(\"@antv/path-util\");\r\n\r\n/**\r\n * 替换字符串中的字段\r\n * @param {String} str 模版字符串\r\n * @param {Object} o json data\r\n */\r\nvar substitute = function substitute(str, o) {\r\n  if (!str || !o) {\r\n    return str;\r\n  }\r\n\r\n  return str.replace(/\\\\?\\{([^{}]+)\\}/g, function (match, name) {\r\n    if (match.charAt(0) === '\\\\') {\r\n      return match.slice(1);\r\n    }\r\n\r\n    var res = o[name];\r\n    if (res === 0) res = '0';\r\n    return res || '';\r\n  });\r\n};\r\n/**\r\n * 给定坐标获取三次贝塞尔曲线的 M 及 C 值\r\n * @param points coordinate set\r\n */\r\n\r\n\r\nvar getSpline = function getSpline(points) {\r\n  var data = [];\r\n\r\n  if (points.length < 2) {\r\n    throw new Error(\"point length must largn than 2, now it's \" + points.length);\r\n  }\r\n\r\n  for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\r\n    var point = points_1[_i];\r\n    var x = point.x,\r\n        y = point.y;\r\n    data.push(x);\r\n    data.push(y);\r\n  }\r\n\r\n  var spliePath = (0, _pathUtil.catmullRom2Bezier)(data);\r\n  spliePath.unshift(['M', points[0].x, points[0].y]);\r\n  return spliePath;\r\n};\r\n/**\r\n * 根据起始点、相对位置、偏移量计算控制点\r\n * @param  {IPoint} startPoint 起始点，包含 x,y\r\n * @param  {IPoint} endPoint  结束点, 包含 x,y\r\n * @param  {Number} percent   相对位置,范围 0-1\r\n * @param  {Number} offset    偏移量\r\n * @return {IPoint} 控制点，包含 x,y\r\n */\r\n\r\n\r\nexports.getSpline = getSpline;\r\n\r\nvar getControlPoint = function getControlPoint(startPoint, endPoint, percent, offset) {\r\n  if (percent === void 0) {\r\n    percent = 0;\r\n  }\r\n\r\n  if (offset === void 0) {\r\n    offset = 0;\r\n  }\r\n\r\n  var point = {\r\n    x: (1 - percent) * startPoint.x + percent * endPoint.x,\r\n    y: (1 - percent) * startPoint.y + percent * endPoint.y\r\n  };\r\n  var tangent = [0, 0];\r\n\r\n  _matrixUtil.vec2.normalize(tangent, [endPoint.x - startPoint.x, endPoint.y - startPoint.y]);\r\n\r\n  if (!tangent || !tangent[0] && !tangent[1]) {\r\n    tangent = [0, 0];\r\n  }\r\n\r\n  var perpendicular = [-tangent[1] * offset, tangent[0] * offset]; // 垂直向量\r\n\r\n  point.x += perpendicular[0];\r\n  point.y += perpendicular[1];\r\n  return point;\r\n};\r\n/**\r\n * 点集转化为Path多边形\r\n * @param {Array} points 点集\r\n * @param {Boolen} z 是否封闭\r\n * @return {Array} Path\r\n */\r\n\r\n\r\nexports.getControlPoint = getControlPoint;\r\n\r\nvar pointsToPolygon = function pointsToPolygon(points, z) {\r\n  var length = points.length;\r\n\r\n  if (!length) {\r\n    return '';\r\n  }\r\n\r\n  var path = '';\r\n  var str = '';\r\n\r\n  for (var i = 0; i < length; i++) {\r\n    var item = points[i];\r\n\r\n    if (i === 0) {\r\n      str = 'M{x} {y}';\r\n    } else {\r\n      str = 'L{x} {y}';\r\n    }\r\n\r\n    path += substitute(str, item);\r\n  }\r\n\r\n  if (z) {\r\n    path += 'Z';\r\n  }\r\n\r\n  return path;\r\n};\r\n\r\nexports.pointsToPolygon = pointsToPolygon;\r\n\r\nvar pathToPoints = function pathToPoints(path) {\r\n  var points = [];\r\n  path.forEach(function (seg) {\r\n    var command = seg[0];\r\n\r\n    if (command !== 'A') {\r\n      for (var i = 1; i < seg.length; i = i + 2) {\r\n        points.push([seg[i], seg[i + 1]]);\r\n      }\r\n    } else {\r\n      var length_1 = seg.length;\r\n      points.push([seg[length_1 - 2], seg[length_1 - 1]]);\r\n    }\r\n  });\r\n  return points;\r\n};\r\n/**\r\n * 生成平滑的闭合曲线\r\n * @param points\r\n */\r\n\r\n\r\nexports.pathToPoints = pathToPoints;\r\n\r\nvar getClosedSpline = function getClosedSpline(points) {\r\n  if (points.length < 2) {\r\n    throw new Error(\"point length must largn than 2, now it's \" + points.length);\r\n  }\r\n\r\n  var first = points[0];\r\n  var second = points[1];\r\n  var last = points[points.length - 1];\r\n  var lastSecond = points[points.length - 2];\r\n  points.unshift(last);\r\n  points.unshift(lastSecond);\r\n  points.push(first);\r\n  points.push(second);\r\n  var closedPath = [];\r\n\r\n  for (var i = 1; i < points.length - 2; i += 1) {\r\n    var x0 = points[i - 1].x;\r\n    var y0 = points[i - 1].y;\r\n    var x1 = points[i].x;\r\n    var y1 = points[i].y;\r\n    var x2 = points[i + 1].x;\r\n    var y2 = points[i + 1].y;\r\n    var x3 = i !== points.length - 2 ? points[i + 2].x : x2;\r\n    var y3 = i !== points.length - 2 ? points[i + 2].y : y2;\r\n    var cp1x = x1 + (x2 - x0) / 6;\r\n    var cp1y = y1 + (y2 - y0) / 6;\r\n    var cp2x = x2 - (x3 - x1) / 6;\r\n    var cp2y = y2 - (y3 - y1) / 6;\r\n    closedPath.push(['C', cp1x, cp1y, cp2x, cp2y, x2, y2]);\r\n  }\r\n\r\n  closedPath.unshift(['M', last.x, last.y]);\r\n  return closedPath;\r\n};\r\n\r\nexports.getClosedSpline = getClosedSpline;\r\n\r\nvar vecScaleTo = function vecScaleTo(v, length) {\r\n  // Vector with direction of v with specified length\r\n  return _matrixUtil.vec2.scale([0, 0], _matrixUtil.vec2.normalize([0, 0], v), length);\r\n};\r\n\r\nvar unitNormal = function unitNormal(p0, p1) {\r\n  // Returns the unit normal to the line segment from p0 to p1.\r\n  var n = [p0[1] - p1[1], p1[0] - p0[0]];\r\n  var nLength = Math.sqrt(n[0] * n[0] + n[1] * n[1]);\r\n\r\n  if (nLength === 0) {\r\n    throw new Error('p0 should not be equal to p1');\r\n  }\r\n\r\n  return [n[0] / nLength, n[1] / nLength];\r\n};\r\n\r\nvar vecFrom = function vecFrom(p0, p1) {\r\n  // Vector from p0 to p1\r\n  return [p1[0] - p0[0], p1[1] - p0[1]];\r\n};\r\n/**\r\n * 传入的节点作为多边形顶点，生成有圆角的多边形\r\n * @param polyPoints 多边形顶点\r\n * @param padding 在原多边形基础上增加最终轮廓和原多边形的空白间隔\r\n */\r\n\r\n\r\nfunction roundedHull(polyPoints, padding) {\r\n  // The rounded hull path around a single point\r\n  var roundedHull1 = function roundedHull1(points) {\r\n    var p1 = [points[0][0], points[0][1] - padding];\r\n    var p2 = [points[0][0], points[0][1] + padding];\r\n    return \"M \" + p1 + \" A \" + padding + \",\" + padding + \",0,0,0,\" + p2 + \" A \" + padding + \",\" + padding + \",0,0,0,\" + p1;\r\n  }; // The rounded hull path around two points\r\n\r\n\r\n  var roundedHull2 = function roundedHull2(points) {\r\n    var offsetVector = _matrixUtil.vec2.scale([0, 0], unitNormal(points[0], points[1]), padding);\r\n\r\n    var invOffsetVector = _matrixUtil.vec2.scale([0, 0], offsetVector, -1);\r\n\r\n    var p0 = _matrixUtil.vec2.add([0, 0], points[0], offsetVector);\r\n\r\n    var p1 = _matrixUtil.vec2.add([0, 0], points[1], offsetVector);\r\n\r\n    var p2 = _matrixUtil.vec2.add([0, 0], points[1], invOffsetVector);\r\n\r\n    var p3 = _matrixUtil.vec2.add([0, 0], points[0], invOffsetVector);\r\n\r\n    return \"M \" + p0 + \" L \" + p1 + \" A \" + [padding, padding, '0,0,0', p2].join(',') + \" L \" + p3 + \" A \" + [padding, padding, '0,0,0', p0].join(',');\r\n  }; // 特殊情况处理：节点数小于等于2\r\n\r\n\r\n  if (!polyPoints || polyPoints.length < 1) return '';\r\n  if (polyPoints.length === 1) return roundedHull1(polyPoints);\r\n  if (polyPoints.length === 2) return roundedHull2(polyPoints);\r\n  var segments = new Array(polyPoints.length); // Calculate each offset (outwards) segment of the convex hull.\r\n\r\n  for (var segmentIndex = 0; segmentIndex < segments.length; ++segmentIndex) {\r\n    var p0 = segmentIndex === 0 ? polyPoints[polyPoints.length - 1] : polyPoints[segmentIndex - 1];\r\n    var p1 = polyPoints[segmentIndex]; // Compute the offset vector for the line segment, with length = padding.\r\n\r\n    var offset = _matrixUtil.vec2.scale([0, 0], unitNormal(p0, p1), padding);\r\n\r\n    segments[segmentIndex] = [_matrixUtil.vec2.add([0, 0], p0, offset), _matrixUtil.vec2.add([0, 0], p1, offset)];\r\n  }\r\n\r\n  var arcData = \"A \" + [padding, padding, '0,0,0,'].join(',');\r\n  segments = segments.map(function (segment, index) {\r\n    var pathFragment = '';\r\n\r\n    if (index === 0) {\r\n      pathFragment = \"M \" + segments[segments.length - 1][1] + \" \";\r\n    }\r\n\r\n    pathFragment += arcData + segment[0] + \" L \" + segment[1];\r\n    return pathFragment;\r\n  });\r\n  return segments.join(' ');\r\n}\r\n/**\r\n * 传入的节点作为多边形顶点，生成平滑的闭合多边形\r\n * @param polyPoints\r\n * @param padding\r\n */\r\n\r\n\r\nfunction paddedHull(polyPoints, padding) {\r\n  var pointCount = polyPoints.length;\r\n\r\n  var smoothHull1 = function smoothHull1(points) {\r\n    // Returns the path for a circular hull around a single point.\r\n    var p1 = [points[0][0], points[0][1] - padding];\r\n    var p2 = [points[0][0], points[0][1] + padding];\r\n    return \"M \" + p1 + \" A \" + [padding, padding, '0,0,0', p2].join(',') + \" A \" + [padding, padding, '0,0,0', p1].join(',');\r\n  }; // Returns the path for a rounded hull around two points.\r\n\r\n\r\n  var smoothHull2 = function smoothHull2(points) {\r\n    var v = vecFrom(points[0], points[1]);\r\n    var extensionVec = vecScaleTo(v, padding);\r\n\r\n    var extension0 = _matrixUtil.vec2.add([0, 0], points[0], _matrixUtil.vec2.scale([0, 0], extensionVec, -1));\r\n\r\n    var extension1 = _matrixUtil.vec2.add([0, 0], points[1], extensionVec);\r\n\r\n    var tangentHalfLength = 1.2 * padding;\r\n    var controlDelta = vecScaleTo(_matrixUtil.vec2.normalize([0, 0], v), tangentHalfLength);\r\n\r\n    var invControlDelta = _matrixUtil.vec2.scale([0, 0], controlDelta, -1);\r\n\r\n    var control0 = _matrixUtil.vec2.add([0, 0], extension0, invControlDelta);\r\n\r\n    var control1 = _matrixUtil.vec2.add([0, 0], extension1, invControlDelta);\r\n\r\n    var control3 = _matrixUtil.vec2.add([0, 0], extension0, controlDelta); // return [\r\n    //   ['M', extension0[0], extension0[1]],\r\n    //   ['C', control0, control1, extension1],\r\n    //   ['S', control3, extension0],\r\n    //   'Z',\r\n    // ];\r\n\r\n\r\n    return \"M \" + extension0 + \" C \" + [control0, control1, extension1].join(',') + \" S \" + [control3, extension0].join(',') + \" Z\";\r\n  }; // Handle special cases\r\n\r\n\r\n  if (!polyPoints || pointCount < 1) return '';\r\n  if (pointCount === 1) return smoothHull1(polyPoints);\r\n  if (pointCount === 2) return smoothHull2(polyPoints);\r\n  var hullPoints = polyPoints.map(function (point, index) {\r\n    var pNext = polyPoints[(index + 1) % pointCount];\r\n    return {\r\n      p: point,\r\n      v: _matrixUtil.vec2.normalize([0, 0], vecFrom(point, pNext))\r\n    };\r\n  }); // Compute the expanded hull points, and the nearest prior control point for each.\r\n\r\n  for (var i = 0; i < hullPoints.length; ++i) {\r\n    var priorIndex = i > 0 ? i - 1 : pointCount - 1;\r\n\r\n    var extensionVec = _matrixUtil.vec2.normalize([0, 0], _matrixUtil.vec2.add([0, 0], hullPoints[priorIndex].v, _matrixUtil.vec2.scale([0, 0], hullPoints[i].v, -1)));\r\n\r\n    hullPoints[i].p = _matrixUtil.vec2.add([0, 0], hullPoints[i].p, _matrixUtil.vec2.scale([0, 0], extensionVec, padding));\r\n  }\r\n\r\n  return hullPoints.map(function (obj) {\r\n    var point = obj.p;\r\n    return {\r\n      x: point[0],\r\n      y: point[1]\r\n    };\r\n  });\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.genConvexHull = exports.cross = void 0;\r\n\r\n/**\r\n * Use cross product to judge the direction of the turn.\r\n * Returns a positive value, if OAB makes a clockwise turn,\r\n * negative for counter-clockwise turn, and zero if the points are collinear.\r\n */\r\nvar cross = function cross(a, b, o) {\r\n  return (a.y - o.y) * (b.x - o.x) - (a.x - o.x) * (b.y - o.y);\r\n};\r\n/**\r\n * Generate a convex hull of given points. Andrew's monotone chain algorithm.\r\n * @param points An array of [x, y] representing the coordinates of points.\r\n * @return a list of vertices of the convex hull in counter-clockwise order,\r\n */\r\n\r\n\r\nexports.cross = cross;\r\n\r\nvar genConvexHull = function genConvexHull(items) {\r\n  var points = items.map(function (item) {\r\n    return {\r\n      x: item.getModel().x,\r\n      y: item.getModel().y\r\n    };\r\n  });\r\n  points.sort(function (a, b) {\r\n    return a.x === b.x ? a.y - b.y : a.x - b.x;\r\n  });\r\n\r\n  if (points.length === 1) {\r\n    return points;\r\n  } // build the lower hull\r\n\r\n\r\n  var lower = [];\r\n\r\n  for (var i = 0; i < points.length; i++) {\r\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\r\n      lower.pop();\r\n    }\r\n\r\n    lower.push(points[i]);\r\n  } // build the upper hull\r\n\r\n\r\n  var upper = [];\r\n\r\n  for (var i = points.length - 1; i >= 0; i--) {\r\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {\r\n      upper.pop();\r\n    }\r\n\r\n    upper.push(points[i]);\r\n  }\r\n\r\n  upper.pop();\r\n  lower.pop();\r\n  var strictHull = lower.concat(upper);\r\n  return strictHull;\r\n};\r\n\r\nexports.genConvexHull = genConvexHull;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.genBubbleSet = void 0;\r\n\r\nvar _math = require(\"../../util/math\");\r\n\r\nvar defaultOps = {\r\n  maxRoutingIterations: 100,\r\n  maxMarchingIterations: 100,\r\n  pixelGroupSize: 2,\r\n  edgeR0: 10,\r\n  edgeR1: 10,\r\n  nodeR0: 5,\r\n  nodeR1: 10,\r\n  morphBuffer: 5,\r\n  threshold: 0.001,\r\n  skip: 16,\r\n  nodeInfluenceFactor: 1,\r\n  edgeInfluenceFactor: 1,\r\n  negativeNodeInfluenceFactor: -0.5\r\n};\r\n/**\r\n * Marching square algorithm for traching the contour of a pixel group\r\n * https://www.emanueleferonato.com/2013/03/01/using-marching-squares-algorithm-to-trace-the-contour-of-an-image/\r\n * @param potentialArea\r\n * @param threshold\r\n */\r\n\r\nfunction MarchingSquares(contour, potentialArea, threshold) {\r\n  var marched = false;\r\n\r\n  var getVal = function getVal(x, y) {\r\n    return potentialArea.cells[x + y * potentialArea.width];\r\n  };\r\n\r\n  var getState = function getState(x, y) {\r\n    var squareVal = 0;\r\n\r\n    if (getVal(x - 1, y - 1) >= threshold) {\r\n      squareVal += 1;\r\n    }\r\n\r\n    if (getVal(x, y - 1) > threshold) {\r\n      squareVal += 2;\r\n    }\r\n\r\n    if (getVal(x - 1, y) > threshold) {\r\n      squareVal += 4;\r\n    }\r\n\r\n    if (getVal(x, y) > threshold) {\r\n      squareVal += 8;\r\n    }\r\n\r\n    return squareVal;\r\n  };\r\n\r\n  var doMarch = function doMarch(xPos, yPos) {\r\n    var x = xPos;\r\n    var y = yPos;\r\n    var prevX;\r\n    var prevY;\r\n\r\n    for (var i = 0; i < potentialArea.width * potentialArea.height; i++) {\r\n      prevX = x;\r\n      prevY = y;\r\n\r\n      if (contour.findIndex(function (item) {\r\n        return item.x === x && item.y === y;\r\n      }) > -1) {\r\n        if (contour[0].x !== x || contour[0].y !== y) {// encountered a loop but haven't returned to start: change direction using conditionals and continue back to start\r\n        } else {\r\n          return true;\r\n        }\r\n      } else {\r\n        contour.push({\r\n          x: x,\r\n          y: y\r\n        });\r\n      }\r\n\r\n      var state = getState(x, y); // assign the move direction according to state of the square\r\n\r\n      switch (state) {\r\n        case -1:\r\n          console.warn('Marched out of bounds');\r\n          return true;\r\n\r\n        case 0:\r\n        case 3:\r\n        case 2:\r\n        case 7:\r\n          x++; // go right\r\n\r\n          break;\r\n\r\n        case 12:\r\n        case 14:\r\n        case 4:\r\n          x--; // go left\r\n\r\n          break;\r\n\r\n        case 6:\r\n          // go left if come from up else go right\r\n          if (prevX === 0) {\r\n            if (prevY === -1) {\r\n              x -= 1;\r\n            } else {\r\n              x += 1;\r\n            }\r\n          }\r\n\r\n          break;\r\n\r\n        case 1:\r\n        case 13:\r\n        case 5:\r\n          y--; // go up\r\n\r\n          break;\r\n\r\n        case 9:\r\n          // go up if come from right else go down\r\n          if (prevX === 1) {\r\n            if (prevY === 0) {\r\n              y -= 1;\r\n            } else {\r\n              y += 1;\r\n            }\r\n          }\r\n\r\n          break;\r\n\r\n        case 10:\r\n        case 8:\r\n        case 11:\r\n          y++; // go down\r\n\r\n          break;\r\n\r\n        default:\r\n          console.warn(\"Marching squares invalid state: \" + state);\r\n          return true;\r\n      }\r\n    }\r\n  };\r\n\r\n  this.march = function () {\r\n    for (var x = 0; x < potentialArea.width && !marched; x += 1) {\r\n      for (var y = 0; y < potentialArea.height && !marched; y += 1) {\r\n        if (getVal(x, y) > threshold && getState(x, y) !== 15) {\r\n          marched = doMarch(x, y);\r\n        }\r\n      }\r\n    }\r\n\r\n    return marched;\r\n  };\r\n}\r\n/**\r\n * Space partition & assign value to each cell\r\n * @param points\r\n */\r\n\r\n\r\nvar initGridCells = function initGridCells(width, height, pixelGroupSize) {\r\n  var scaleWidth = Math.ceil(width / pixelGroupSize);\r\n  var scaleHeight = Math.ceil(height / pixelGroupSize);\r\n  var gridCells = new Float32Array(Math.max(0, scaleWidth * scaleHeight)).fill(0);\r\n  return {\r\n    cells: gridCells,\r\n    width: scaleWidth,\r\n    height: scaleHeight\r\n  };\r\n};\r\n/**\r\n * Find the optimal already visited member to item;\r\n   Optimal: minimize cost(j) = distance(i,j) ∗ countObstacles(i,j)\r\n * @param item\r\n * @param visited\r\n */\r\n\r\n\r\nvar pickBestNeighbor = function pickBestNeighbor(item, visited, nonMembers) {\r\n  var closestNeighbour = null;\r\n  var minCost = Number.POSITIVE_INFINITY;\r\n  visited.forEach(function (neighbourItem) {\r\n    var itemP = {\r\n      x: item.getModel().x,\r\n      y: item.getModel().y\r\n    };\r\n    var neighbourItemP = {\r\n      x: neighbourItem.getModel().x,\r\n      y: neighbourItem.getModel().y\r\n    };\r\n    var dist = (0, _math.squareDist)(itemP, neighbourItemP);\r\n    var directLine = new _math.Line(itemP.x, itemP.y, neighbourItemP.x, neighbourItemP.y);\r\n    var numberObstacles = nonMembers.reduce(function (count, _item) {\r\n      if ((0, _math.fractionToLine)(_item, directLine) > 0) {\r\n        return count + 1;\r\n      }\r\n\r\n      return count;\r\n    }, 0);\r\n\r\n    if (dist * Math.pow(numberObstacles + 1, 2) < minCost) {\r\n      closestNeighbour = neighbourItem;\r\n      minCost = dist * Math.pow(numberObstacles + 1, 2);\r\n    }\r\n  });\r\n  return closestNeighbour;\r\n};\r\n/**\r\n * 返回和线相交的item中，离边的起点最近的item\r\n * @param items\r\n * @param line\r\n */\r\n\r\n\r\nvar getIntersectItem = function getIntersectItem(items, line) {\r\n  var minDistance = Number.POSITIVE_INFINITY;\r\n  var closestItem = null;\r\n  items.forEach(function (item) {\r\n    var distance = (0, _math.fractionToLine)(item, line); // find closest intersection\r\n\r\n    if (distance >= 0 && distance < minDistance) {\r\n      closestItem = item;\r\n      minDistance = distance;\r\n    }\r\n  });\r\n  return closestItem;\r\n};\r\n/**\r\n * Modify the directLine and Route virtual edges around obstacles\r\n */\r\n\r\n\r\nvar computeRoute = function computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer) {\r\n  var checkedLines = [];\r\n  var linesToCheck = [];\r\n  linesToCheck.push(directLine);\r\n  var hasIntersection = true;\r\n  var iterations = 0;\r\n\r\n  var pointExists = function pointExists(point, lines) {\r\n    var flag = false;\r\n    lines.forEach(function (line) {\r\n      if (flag) return;\r\n\r\n      if ((0, _math.isPointsOverlap)(point, {\r\n        x: line.x1,\r\n        y: line.y1\r\n      }) || (0, _math.isPointsOverlap)(point, {\r\n        x: line.x2,\r\n        y: line.y2\r\n      })) {\r\n        flag = true;\r\n      }\r\n    });\r\n    return flag;\r\n  };\r\n\r\n  var isPointInNonMembers = function isPointInNonMembers(point, _nonMembers) {\r\n    for (var _i = 0, _nonMembers_1 = _nonMembers; _i < _nonMembers_1.length; _i++) {\r\n      var item = _nonMembers_1[_i];\r\n      var bbox = item.getBBox();\r\n      var itemContour = [[bbox.x, bbox.y], [bbox.x + bbox.width, bbox.y], [bbox.x, bbox.y + bbox.height], [bbox.x + bbox.width, bbox.y + bbox.height]];\r\n\r\n      if ((0, _math.isPointInPolygon)(itemContour, point.x, point.y)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }; // outer loop end when no more intersections or out of iterations\r\n\r\n\r\n  while (hasIntersection && iterations < maxRoutingIterations) {\r\n    hasIntersection = false;\r\n\r\n    var _loop_1 = function _loop_1() {\r\n      var line = linesToCheck.pop();\r\n      var closestItem = getIntersectItem(nonMembers, line);\r\n\r\n      if (closestItem) {\r\n        var _a = (0, _math.itemIntersectByLine)(closestItem, line),\r\n            intersections_1 = _a[0],\r\n            countIntersections = _a[1]; // if line passes through item\r\n\r\n\r\n        if (countIntersections === 2) {\r\n          var testReroute = function testReroute(isFirst) {\r\n            var tempMorphBuffer = morphBuffer;\r\n            var virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst); // test the virtualNode already exists\r\n\r\n            var exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);\r\n            var pointInside = isPointInNonMembers(virtualNode, nonMembers);\r\n\r\n            while (!exist && pointInside && tempMorphBuffer >= 1) {\r\n              // try a smaller buffer\r\n              tempMorphBuffer /= 1.5;\r\n              virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst);\r\n              exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);\r\n              pointInside = isPointInNonMembers(virtualNode, nonMembers);\r\n            } // 第二次route时不要求pointInside\r\n\r\n\r\n            if (virtualNode && !exist && (!isFirst || !pointInside)) {\r\n              // add 2 rerouted lines to check\r\n              linesToCheck.push(new _math.Line(line.x1, line.y1, virtualNode.x, virtualNode.y));\r\n              linesToCheck.push(new _math.Line(virtualNode.x, virtualNode.y, line.x2, line.y2));\r\n              hasIntersection = true;\r\n            }\r\n          };\r\n\r\n          testReroute(true);\r\n\r\n          if (!hasIntersection) {\r\n            // if we didn't find a valid point around the first corner, try the second\r\n            testReroute(false);\r\n          }\r\n        }\r\n      } // no intersection found, mark this line as completed\r\n\r\n\r\n      if (!hasIntersection) {\r\n        checkedLines.push(line);\r\n      }\r\n\r\n      iterations += 1;\r\n    }; // inner loop end when out of lines or found an intersection\r\n\r\n\r\n    while (!hasIntersection && linesToCheck.length) {\r\n      _loop_1();\r\n    }\r\n  } // 加入剩余的线\r\n\r\n\r\n  while (linesToCheck.length) {\r\n    checkedLines.push(linesToCheck.pop());\r\n  }\r\n\r\n  return checkedLines;\r\n};\r\n/**\r\n *  Connect item with visited members using direct line or virtual edges\r\n */\r\n\r\n\r\nfunction getRoute(item, nonMembers, visited, maxRoutingIterations, morphBuffer) {\r\n  var optimalNeighbor = pickBestNeighbor(item, visited, nonMembers);\r\n\r\n  if (optimalNeighbor === null) {\r\n    return [];\r\n  } //  merge the consecutive lines\r\n\r\n\r\n  var mergeLines = function mergeLines(checkedLines) {\r\n    var finalRoute = [];\r\n\r\n    while (checkedLines.length > 0) {\r\n      var line1 = checkedLines.pop();\r\n\r\n      if (checkedLines.length === 0) {\r\n        finalRoute.push(line1);\r\n        break;\r\n      }\r\n\r\n      var line2 = checkedLines.pop();\r\n      var mergeLine = new _math.Line(line1.x1, line1.y1, line2.x2, line2.y2);\r\n      var closestItem = getIntersectItem(nonMembers, mergeLine); // merge most recent line and previous line\r\n\r\n      if (!closestItem) {\r\n        checkedLines.push(mergeLine);\r\n      } else {\r\n        finalRoute.push(line1);\r\n        checkedLines.push(line2);\r\n      }\r\n    }\r\n\r\n    return finalRoute;\r\n  };\r\n\r\n  var directLine = new _math.Line(item.getModel().x, item.getModel().y, optimalNeighbor.getModel().x, optimalNeighbor.getModel().y);\r\n  var checkedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);\r\n  var finalRoute = mergeLines(checkedLines);\r\n  return finalRoute;\r\n}\r\n/**\r\n * Calculate the countor that includes the  selected items and exclues the non-selected items\r\n * @param graph\r\n * @param members\r\n * @param nonMembers\r\n * @param options\r\n */\r\n\r\n\r\nvar genBubbleSet = function genBubbleSet(members, nonMembers, ops) {\r\n  // eslint-disable-next-line no-redeclare\r\n  var options = Object.assign(defaultOps, ops);\r\n  var centroid = (0, _math.getPointsCenter)(members.map(function (item) {\r\n    return {\r\n      x: item.getModel().x,\r\n      y: item.getModel().y\r\n    };\r\n  })); // 按照到中心距离远近排序\r\n\r\n  members = members.sort(function (a, b) {\r\n    return (0, _math.squareDist)({\r\n      x: a.getModel().x,\r\n      y: a.getModel().y\r\n    }, centroid) - (0, _math.squareDist)({\r\n      x: b.getModel().x,\r\n      y: b.getModel().y\r\n    }, centroid);\r\n  });\r\n  var visited = [];\r\n  var virtualEdges = [];\r\n  members.forEach(function (item) {\r\n    var lines = getRoute(item, nonMembers, visited, options.maxRoutingIterations, options.morphBuffer);\r\n    lines.forEach(function (l) {\r\n      virtualEdges.push(l);\r\n    });\r\n    visited.push(item);\r\n  }); // 由于edge也可以作为member和nonMember传入，暂时不考虑把edges作为参数传入genBubbleSet\r\n  // edges && edges.forEach(e => {\r\n  //   virtualEdges.push(new Line(e.getSource().getModel().x, e.getSource().getModel().y, e.getTarget().getModel().x, e.getTarget().getModel().y));\r\n  // });\r\n\r\n  var activeRegion = getActiveRregion(members, virtualEdges, options.nodeR0);\r\n  var potentialArea = initGridCells(activeRegion.width, activeRegion.height, options.pixelGroupSize); // Use march squares to generate contour\r\n\r\n  var contour = [];\r\n  var hull = [];\r\n\r\n  for (var iterations = 0; iterations < options.maxMarchingIterations; iterations++) {\r\n    fillPotentialArea(members, nonMembers, virtualEdges, activeRegion, potentialArea, options);\r\n    contour = [];\r\n    hull = [];\r\n    if (!new MarchingSquares(contour, potentialArea, options.threshold).march()) continue;\r\n    var marchedPath = contour.map(function (point) {\r\n      return {\r\n        x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX),\r\n        y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY)\r\n      };\r\n    }); // const marchedPath = marchingSquares(potentialArea, options.threshold).map(point => ({ x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX), y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY) }))\r\n\r\n    if (marchedPath) {\r\n      var size = marchedPath.length;\r\n\r\n      if (options.skip > 1) {\r\n        size = Math.floor(marchedPath.length / options.skip); // if we reduced too much (fewer than three points in reduced surface) reduce skip and try again\r\n\r\n        while (size < 3 && options.skip > 1) {\r\n          options.skip -= 1;\r\n          size = Math.floor(marchedPath.length / options.skip);\r\n        }\r\n      } // copy hull values\r\n\r\n\r\n      for (var i = 0, j = 0; j < size; j += 1, i += options.skip) {\r\n        hull.push({\r\n          x: marchedPath[i].x,\r\n          y: marchedPath[i].y\r\n        });\r\n      }\r\n    }\r\n\r\n    var isContourValid = function isContourValid() {\r\n      for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {\r\n        var item = members_1[_i];\r\n        var hullPoints = hull.map(function (point) {\r\n          return [point.x, point.y];\r\n        });\r\n        if (!(0, _math.isPointInPolygon)(hullPoints, item.getBBox().centerX, item.getBBox().centerY)) return false;\r\n      } // 不强制要求所有nonMembers都没有包含在内\r\n      // for (const item of nonMembers) {\r\n      //   if (isPointInPolygon({ x: item.getBBox().centerX, y: item.getBBox().centerY }, contour)) return false\r\n      // }\r\n\r\n\r\n      return true;\r\n    };\r\n\r\n    if (hull && isContourValid()) {\r\n      return hull;\r\n    } // update parameters for next iteraction\r\n\r\n\r\n    options.threshold *= 0.9;\r\n\r\n    if (iterations <= options.maxMarchingIterations * 0.5) {\r\n      options.memberInfluenceFactor *= 1.2;\r\n      options.edgeInfluenceFactor *= 1.2;\r\n    } else if (options.nonMemberInfluenceFactor !== 0 && nonMembers.length > 0) {\r\n      // after half the iterations, start increasing positive energy and lowering the threshold\r\n      options.nonMemberInfluenceFactor *= 0.8;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return hull;\r\n};\r\n/**\r\n * unionboundingbox\r\n * @param members\r\n * @param edges\r\n */\r\n\r\n\r\nexports.genBubbleSet = genBubbleSet;\r\n\r\nfunction getActiveRregion(members, edges, offset) {\r\n  var activeRegion = {\r\n    minX: Number.POSITIVE_INFINITY,\r\n    minY: Number.POSITIVE_INFINITY,\r\n    maxX: Number.NEGATIVE_INFINITY,\r\n    maxY: Number.NEGATIVE_INFINITY,\r\n    width: 0,\r\n    height: 0,\r\n    x: 0,\r\n    y: 0\r\n  };\r\n  var bboxes = [];\r\n  members.forEach(function (item) {\r\n    bboxes.push(item.getBBox());\r\n  });\r\n  edges.forEach(function (l) {\r\n    bboxes.push(l.getBBox());\r\n  });\r\n\r\n  for (var _i = 0, bboxes_1 = bboxes; _i < bboxes_1.length; _i++) {\r\n    var bbox = bboxes_1[_i];\r\n    activeRegion.minX = (bbox.minX < activeRegion.minX ? bbox.minX : activeRegion.minX) - offset;\r\n    activeRegion.minY = (bbox.minY < activeRegion.minY ? bbox.minY : activeRegion.minY) - offset;\r\n    activeRegion.maxX = (bbox.maxX > activeRegion.maxX ? bbox.maxX : activeRegion.maxX) + offset;\r\n    activeRegion.maxY = (bbox.maxY > activeRegion.maxY ? bbox.maxY : activeRegion.maxY) + offset;\r\n  }\r\n\r\n  activeRegion.width = activeRegion.maxX - activeRegion.minX;\r\n  activeRegion.height = activeRegion.maxY - activeRegion.minY;\r\n  activeRegion.x = activeRegion.minX;\r\n  activeRegion.y = activeRegion.minY;\r\n  return activeRegion;\r\n}\r\n\r\nfunction fillPotentialArea(members, nonMembers, edges, activeRegion, potentialArea, options) {\r\n  function pos2GridIx(x, offset) {\r\n    var gridIx = Math.floor((x - offset) / options.pixelGroupSize);\r\n    return gridIx < 0 ? 0 : gridIx;\r\n  }\r\n\r\n  function gridIx2Pos(x, offset) {\r\n    return x * options.pixelGroupSize + offset;\r\n  } // using inverse a for numerical stability\r\n\r\n\r\n  var nodeInfA = (options.nodeR0 - options.nodeR1) * (options.nodeR0 - options.nodeR1);\r\n  var edgeInfA = (options.edgeR0 - options.edgeR1) * (options.edgeR0 - options.edgeR1);\r\n\r\n  var getAffectedRegion = function getAffectedRegion(bbox, thresholdR) {\r\n    var startX = Math.min(pos2GridIx(bbox.minX, thresholdR + activeRegion.minX), potentialArea.width);\r\n    var startY = Math.min(pos2GridIx(bbox.minY, thresholdR + activeRegion.minY), potentialArea.height);\r\n    var endX = Math.min(pos2GridIx(bbox.maxX, -thresholdR + activeRegion.minX), potentialArea.width);\r\n    var endY = Math.min(pos2GridIx(bbox.maxY, -thresholdR + activeRegion.minY), potentialArea.height);\r\n    return [startX, startY, endX, endY];\r\n  };\r\n\r\n  var addItemInfluence = function addItemInfluence(item, influenceFactor) {\r\n    var bbox = item.getBBox();\r\n\r\n    var _a = getAffectedRegion(bbox, options.nodeR1),\r\n        startX = _a[0],\r\n        startY = _a[1],\r\n        endX = _a[2],\r\n        endY = _a[3]; // calculate item influence for each cell\r\n\r\n\r\n    for (var y = startY; y < endY; y += 1) {\r\n      for (var x = startX; x < endX; x += 1) {\r\n        if (influenceFactor < 0 && potentialArea[x + y * potentialArea.width] <= 0) {\r\n          continue;\r\n        }\r\n\r\n        var tempX = gridIx2Pos(x, activeRegion.minX);\r\n        var tempY = gridIx2Pos(y, activeRegion.minY);\r\n        var distanceSq = (0, _math.pointRectSquareDist)({\r\n          x: tempX,\r\n          y: tempY\r\n        }, {\r\n          x: bbox.minX,\r\n          y: bbox.minY,\r\n          width: bbox.width,\r\n          height: bbox.height\r\n        });\r\n\r\n        if (distanceSq < Math.pow(options.nodeR1, 2)) {\r\n          var dr = Math.sqrt(distanceSq) - options.nodeR1;\r\n          potentialArea.cells[x + y * potentialArea.width] += influenceFactor * dr * dr;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  var addEdgeInfluence = function addEdgeInfluence(line, influenceFactor) {\r\n    var bbox = line.getBBox();\r\n\r\n    var _a = getAffectedRegion(bbox, options.edgeR1),\r\n        startX = _a[0],\r\n        startY = _a[1],\r\n        endX = _a[2],\r\n        endY = _a[3]; // for every point in active part of potentialArea, calculate distance to nearest point on line and add influence\r\n\r\n\r\n    for (var y = startY; y < endY; y += 1) {\r\n      for (var x = startX; x < endX; x += 1) {\r\n        if (influenceFactor < 0 && potentialArea.cells[x + y * potentialArea.width] <= 0) {\r\n          continue;\r\n        }\r\n\r\n        var tempX = gridIx2Pos(x, activeRegion.minX);\r\n        var tempY = gridIx2Pos(y, activeRegion.minY);\r\n        var minDistanceSq = (0, _math.pointLineSquareDist)({\r\n          x: tempX,\r\n          y: tempY\r\n        }, line); // only influence if less than r1\r\n\r\n        if (minDistanceSq < Math.pow(options.edgeR1, 2)) {\r\n          var mdr = Math.sqrt(minDistanceSq) - options.edgeR1;\r\n          potentialArea.cells[x + y * potentialArea.width] += influenceFactor * mdr * mdr;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  if (options.nodeInfluenceFactor) {\r\n    members.forEach(function (item) {\r\n      addItemInfluence(item, options.nodeInfluenceFactor / nodeInfA);\r\n    });\r\n  }\r\n\r\n  if (options.edgeInfluenceFactor) {\r\n    edges.forEach(function (edge) {\r\n      addEdgeInfluence(edge, options.edgeInfluenceFactor / edgeInfA);\r\n    });\r\n  }\r\n\r\n  if (options.negativeNodeInfluenceFactor) {\r\n    nonMembers.forEach(function (item) {\r\n      addItemInfluence(item, options.negativeNodeInfluenceFactor / nodeInfA);\r\n    });\r\n  }\r\n}\r\n\r\nfunction rerouteLine(item, buffer, intersections, wrapNormal) {\r\n  var bbox = item.getBBox();\r\n  var topIntersect = intersections[0],\r\n      leftIntersect = intersections[1],\r\n      bottomIntersect = intersections[2],\r\n      rightIntersect = intersections[3];\r\n  var cornerPos = {\r\n    topLeft: {\r\n      x: bbox.minX - buffer,\r\n      y: bbox.minY - buffer\r\n    },\r\n    topRight: {\r\n      x: bbox.maxX + buffer,\r\n      y: bbox.minY - buffer\r\n    },\r\n    bottomLeft: {\r\n      x: bbox.minX - buffer,\r\n      y: bbox.maxY + buffer\r\n    },\r\n    bottomRight: {\r\n      x: bbox.maxX + buffer,\r\n      y: bbox.maxY + buffer\r\n    }\r\n  };\r\n  var totalArea = bbox.height * bbox.width;\r\n\r\n  function calcHalfArea(intersect1, intersect2) {\r\n    return bbox.width * ((intersect1.y - bbox.minY + (intersect2.y - bbox.minY)) * 0.5);\r\n  } // 根据线和boundingbox相交的情况，确定control point的位置\r\n\r\n\r\n  if (leftIntersect) {\r\n    // 相交区域有三角形\r\n    if (topIntersect) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\r\n    if (bottomIntersect) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight; // 相交区域分成上下两个梯形，比较面积\r\n\r\n    var topArea = calcHalfArea(leftIntersect, rightIntersect);\r\n\r\n    if (topArea < totalArea * 0.5) {\r\n      if (leftIntersect.y > rightIntersect.y) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\r\n      return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\r\n    }\r\n\r\n    if (leftIntersect.y < rightIntersect.y) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\r\n    return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\r\n  }\r\n\r\n  if (rightIntersect) {\r\n    if (topIntersect) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\r\n    if (bottomIntersect) return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\r\n  } // 相交区域分成左右两个梯形\r\n\r\n\r\n  var leftArea = calcHalfArea(topIntersect, bottomIntersect);\r\n\r\n  if (leftArea < totalArea * 0.5) {\r\n    if (topIntersect.x > bottomIntersect.x) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\r\n    return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\r\n  }\r\n\r\n  if (topIntersect.x < bottomIntersect.x) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\r\n  return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\r\n}","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nObject.defineProperty(exports, \"Arrow\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _arrow.default;\r\n  }\r\n});\r\nObject.defineProperty(exports, \"Marker\", {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _marker.default;\r\n  }\r\n});\r\nexports.default = void 0;\r\n\r\nvar _shape = _interopRequireDefault(require(\"./shape\"));\r\n\r\nrequire(\"./node\");\r\n\r\nrequire(\"./edge\");\r\n\r\nrequire(\"./combo\");\r\n\r\nrequire(\"./combos\");\r\n\r\nrequire(\"./nodes\");\r\n\r\nvar _arrow = _interopRequireDefault(require(\"./arrow\"));\r\n\r\nvar _marker = _interopRequireDefault(require(\"./marker\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar _default = _shape.default;\r\nexports.default = _default;","\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _base = require(\"../util/base\");\r\n\r\nvar _global = _interopRequireDefault(require(\"../global\"));\r\n\r\nvar _shape = _interopRequireDefault(require(\"./shape\"));\r\n\r\nvar _shapeBase = require(\"./shapeBase\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar singleNode = {\r\n  itemType: 'node',\r\n  // 单个图形的类型\r\n  shapeType: 'single-node',\r\n\r\n  /**\r\n   * 文本相对图形的位置，默认以中心点\r\n   * 位置包括： top, bottom, left, right, center\r\n   * @type {String}\r\n   */\r\n  labelPosition: 'center',\r\n\r\n  /**\r\n   * 文本相对偏移，当 labelPosition 不为 center 时有效\r\n   * @type {Number}\r\n   */\r\n  offset: _global.default.nodeLabel.offset,\r\n\r\n  /**\r\n   * 获取节点宽高\r\n   * @internal 返回节点的大小，以 [width, height] 的方式维护\r\n   * @param  {Object} cfg 节点的配置项\r\n   * @return {Array} 宽高\r\n   */\r\n  getSize: function getSize(cfg) {\r\n    var size = cfg.size || this.getOptions({}).size || _global.default.defaultNode.size; // size 是数组，但长度为1，则补长度为2\r\n\r\n\r\n    if ((0, _util.isArray)(size) && size.length === 1) {\r\n      size = [size[0], size[0]];\r\n    } // size 为数字，则转换为数组\r\n\r\n\r\n    if (!(0, _util.isArray)(size)) {\r\n      size = [size, size];\r\n    }\r\n\r\n    return size;\r\n  },\r\n  // 私有方法，不希望扩展的节点复写这个方法\r\n  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg) {\r\n    var labelPosition = labelCfg.position || this.labelPosition; // 默认的位置（最可能的情形），所以放在最上面\r\n\r\n    if (labelPosition === 'center') {\r\n      return {\r\n        x: 0,\r\n        y: 0,\r\n        text: cfg.label\r\n      };\r\n    }\r\n\r\n    var offset = labelCfg.offset;\r\n\r\n    if ((0, _util.isNil)(offset)) {\r\n      // 考虑 offset = 0 的场景，不用用 labelCfg.offset || Global.nodeLabel.offset\r\n      offset = this.offset; // 不居中时的偏移量\r\n    }\r\n\r\n    var size = this.getSize(cfg);\r\n    var width = size[0];\r\n    var height = size[1];\r\n    var style;\r\n\r\n    switch (labelPosition) {\r\n      case 'top':\r\n        style = {\r\n          x: 0,\r\n          y: 0 - height / 2 - offset,\r\n          textBaseline: 'bottom' // 文本在图形的上面\r\n\r\n        };\r\n        break;\r\n\r\n      case 'bottom':\r\n        style = {\r\n          x: 0,\r\n          y: height / 2 + offset,\r\n          textBaseline: 'top'\r\n        };\r\n        break;\r\n\r\n      case 'left':\r\n        style = {\r\n          x: 0 - width / 2 - offset,\r\n          y: 0,\r\n          textAlign: 'right'\r\n        };\r\n        break;\r\n\r\n      default:\r\n        style = {\r\n          x: width / 2 + offset,\r\n          y: 0,\r\n          textAlign: 'left'\r\n        };\r\n        break;\r\n    }\r\n\r\n    style.text = cfg.label;\r\n    return style;\r\n  },\r\n  getLabelBgStyleByPosition: function getLabelBgStyleByPosition(label, cfg, labelCfg, group) {\r\n    if (!label) {\r\n      return {};\r\n    }\r\n\r\n    var bbox = label.getBBox();\r\n    var backgroundStyle = labelCfg.style && labelCfg.style.background;\r\n\r\n    if (!backgroundStyle) {\r\n      return {};\r\n    }\r\n\r\n    var padding = (0, _base.formatPadding)(backgroundStyle.padding);\r\n    var backgroundWidth = bbox.width + padding[1] + padding[3];\r\n    var backgroundHeight = bbox.height + padding[0] + padding[2];\r\n    var offset = labelCfg.offset;\r\n\r\n    if ((0, _util.isNil)(offset)) {\r\n      // 考虑 offset = 0 的场景，不用用 labelCfg.offset || Global.nodeLabel.offset\r\n      offset = this.offset; // 不居中时的偏移量\r\n    }\r\n\r\n    var style;\r\n    style = {\r\n      x: bbox.minX - padding[3],\r\n      y: bbox.minY - padding[0]\r\n    };\r\n    style = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, style), backgroundStyle), {\r\n      width: backgroundWidth,\r\n      height: backgroundHeight\r\n    });\r\n    return style;\r\n  },\r\n  drawShape: function drawShape(cfg, group) {\r\n    var shapeType = this.shapeType; // || this.type，都已经加了 shapeType\r\n\r\n    var style = this.getShapeStyle(cfg);\r\n    var shape = group.addShape(shapeType, {\r\n      attrs: style,\r\n      draggable: true,\r\n      name: 'node-shape'\r\n    });\r\n    return shape;\r\n  },\r\n\r\n  /**\r\n   * 更新linkPoints\r\n   * @param {Object} cfg 节点数据配置项\r\n   * @param {Group} group Item所在的group\r\n   */\r\n  updateLinkPoints: function updateLinkPoints(cfg, group) {\r\n    var defaultLinkPoints = this.getOptions(cfg).linkPoints;\r\n    var markLeft = group.find(function (element) {\r\n      return element.get('className') === 'link-point-left';\r\n    });\r\n    var markRight = group.find(function (element) {\r\n      return element.get('className') === 'link-point-right';\r\n    });\r\n    var markTop = group.find(function (element) {\r\n      return element.get('className') === 'link-point-top';\r\n    });\r\n    var markBottom = group.find(function (element) {\r\n      return element.get('className') === 'link-point-bottom';\r\n    });\r\n    var currentLinkPoints;\r\n\r\n    if (markLeft) {\r\n      currentLinkPoints = markLeft.attr();\r\n    }\r\n\r\n    if (markRight && !currentLinkPoints) {\r\n      currentLinkPoints = markRight.attr();\r\n    }\r\n\r\n    if (markTop && !currentLinkPoints) {\r\n      currentLinkPoints = markTop.attr();\r\n    }\r\n\r\n    if (markBottom && !currentLinkPoints) {\r\n      currentLinkPoints = markBottom.attr();\r\n    }\r\n\r\n    if (!currentLinkPoints) currentLinkPoints = defaultLinkPoints;\r\n    var linkPoints = (0, _util.mix)({}, currentLinkPoints, cfg.linkPoints);\r\n    var markFill = linkPoints.fill,\r\n        markStroke = linkPoints.stroke,\r\n        borderWidth = linkPoints.lineWidth;\r\n    var markSize = linkPoints.size / 2;\r\n    if (!markSize) markSize = linkPoints.r;\r\n\r\n    var _a = cfg.linkPoints ? cfg.linkPoints : {\r\n      left: undefined,\r\n      right: undefined,\r\n      top: undefined,\r\n      bottom: undefined\r\n    },\r\n        left = _a.left,\r\n        right = _a.right,\r\n        top = _a.top,\r\n        bottom = _a.bottom;\r\n\r\n    var size = this.getSize(cfg);\r\n    var width = size[0];\r\n    var height = size[1];\r\n    var styles = {\r\n      r: markSize,\r\n      fill: markFill,\r\n      stroke: markStroke,\r\n      lineWidth: borderWidth\r\n    };\r\n\r\n    if (markLeft) {\r\n      if (!left && left !== undefined) {\r\n        markLeft.remove();\r\n      } else {\r\n        markLeft.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\r\n          x: -width / 2,\r\n          y: 0\r\n        }));\r\n      }\r\n    } else if (left) {\r\n      group.addShape('circle', {\r\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\r\n          x: -width / 2,\r\n          y: 0\r\n        }),\r\n        className: 'link-point-left',\r\n        name: 'link-point-left',\r\n        isAnchorPoint: true\r\n      });\r\n    }\r\n\r\n    if (markRight) {\r\n      if (!right && right !== undefined) {\r\n        markRight.remove();\r\n      }\r\n\r\n      markRight.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\r\n        x: width / 2,\r\n        y: 0\r\n      }));\r\n    } else if (right) {\r\n      group.addShape('circle', {\r\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\r\n          x: width / 2,\r\n          y: 0\r\n        }),\r\n        className: 'link-point-right',\r\n        name: 'link-point-right',\r\n        isAnchorPoint: true\r\n      });\r\n    }\r\n\r\n    if (markTop) {\r\n      if (!top && top !== undefined) {\r\n        markTop.remove();\r\n      }\r\n\r\n      markTop.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\r\n        x: 0,\r\n        y: -height / 2\r\n      }));\r\n    } else if (top) {\r\n      group.addShape('circle', {\r\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\r\n          x: 0,\r\n          y: -height / 2\r\n        }),\r\n        className: 'link-point-top',\r\n        name: 'link-point-top',\r\n        isAnchorPoint: true\r\n      });\r\n    }\r\n\r\n    if (markBottom) {\r\n      if (!bottom && bottom !== undefined) {\r\n        markBottom.remove();\r\n      } else {\r\n        markBottom.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\r\n          x: 0,\r\n          y: height / 2\r\n        }));\r\n      }\r\n    } else if (bottom) {\r\n      group.addShape('circle', {\r\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\r\n          x: 0,\r\n          y: height / 2\r\n        }),\r\n        className: 'link-point-bottom',\r\n        name: 'link-point-bottom',\r\n        isAnchorPoint: true\r\n      });\r\n    }\r\n  },\r\n  updateShape: function updateShape(cfg, item, keyShapeStyle, hasIcon) {\r\n    var keyShape = item.get('keyShape');\r\n    keyShape.attr((0, _tslib.__assign)({}, keyShapeStyle));\r\n    this.updateLabel(cfg, item); // special for some types of nodes\r\n\r\n    if (hasIcon) {\r\n      this.updateIcon(cfg, item);\r\n    }\r\n  },\r\n  updateIcon: function updateIcon(cfg, item) {\r\n    var _this = this;\r\n\r\n    var group = item.getContainer();\r\n    var icon = this.getOptions(cfg).icon;\r\n    var show = (cfg.icon ? cfg.icon : {\r\n      show: undefined\r\n    }).show;\r\n    var iconShape = group.find(function (element) {\r\n      return element.get('className') === _this.type + \"-icon\";\r\n    });\r\n\r\n    if (iconShape) {\r\n      // 若原先存在 icon\r\n      if (show || show === undefined) {\r\n        // 若传入 show: true, 或没有设置，则更新原有的 icon 样式\r\n        var iconConfig = (0, _util.mix)({}, iconShape.attr(), icon);\r\n        var w = iconConfig.width,\r\n            h = iconConfig.height;\r\n        iconShape.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, iconConfig), {\r\n          x: -w / 2,\r\n          y: -h / 2\r\n        }));\r\n      } else {\r\n        // 若传入了 show: false 则删除原先的 icon\r\n        iconShape.remove();\r\n      }\r\n    } else if (show) {\r\n      // 如果原先不存在 icon，但传入了 show: true，则新增 icon\r\n      var w = icon.width,\r\n          h = icon.height;\r\n      group.addShape('image', {\r\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, icon), {\r\n          x: -w / 2,\r\n          y: -h / 2\r\n        }),\r\n        className: this.type + \"-icon\",\r\n        name: this.type + \"-icon\"\r\n      }); // to ensure the label is on the top of all the shapes\r\n\r\n      var labelShape = group.find(function (element) {\r\n        return element.get('className') === \"node-label\";\r\n      });\r\n\r\n      if (labelShape) {\r\n        labelShape.toFront();\r\n      }\r\n    }\r\n  }\r\n};\r\nvar singleNodeDef = (0, _tslib.__assign)((0, _tslib.__assign)({}, _shapeBase.shapeBase), singleNode);\r\n\r\n_shape.default.registerNode('single-node', singleNodeDef);","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.shapeBase = exports.CLS_LABEL_BG_SUFFIX = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _global = _interopRequireDefault(require(\"../global\"));\r\n\r\nvar _matrixUtil = require(\"@antv/matrix-util\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _graphic = require(\"../util/graphic\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\nvar transform = _matrixUtil.ext.transform;\r\nvar CLS_SHAPE_SUFFIX = '-shape';\r\nvar CLS_LABEL_SUFFIX = '-label';\r\nvar ARROWS = ['startArrow', 'endArrow'];\r\nvar SHAPE_DEFAULT_ATTRS = {\r\n  lineWidth: 1,\r\n  stroke: undefined,\r\n  fill: undefined,\r\n  lineAppendWidth: 1,\r\n  opacity: undefined,\r\n  strokeOpacity: undefined,\r\n  fillOpacity: undefined,\r\n  x: 0,\r\n  y: 0,\r\n  r: 10,\r\n  width: 20,\r\n  height: 20,\r\n  shadowColor: undefined,\r\n  shadowBlur: 0,\r\n  shadowOffsetX: 0,\r\n  shadowOffsetY: 0\r\n};\r\nvar PATH_SHAPE_DEFAULT_ATTRS = {\r\n  lineWidth: 1,\r\n  stroke: '#000',\r\n  lineDash: undefined,\r\n  startArrow: false,\r\n  endArrow: false,\r\n  opacity: undefined,\r\n  strokeOpacity: undefined,\r\n  fillOpacity: undefined,\r\n  shadowColor: undefined,\r\n  shadowBlur: 0,\r\n  shadowOffsetX: 0,\r\n  shadowOffsetY: 0\r\n};\r\nvar SHAPES_DEFAULT_ATTRS = {\r\n  edge: PATH_SHAPE_DEFAULT_ATTRS,\r\n  node: SHAPE_DEFAULT_ATTRS,\r\n  combo: SHAPE_DEFAULT_ATTRS\r\n};\r\nvar CLS_LABEL_BG_SUFFIX = '-label-bg'; // 单个 shape 带有一个 label，共用这段代码\r\n\r\nexports.CLS_LABEL_BG_SUFFIX = CLS_LABEL_BG_SUFFIX;\r\nvar shapeBase = {\r\n  // 默认样式及配置\r\n  options: {},\r\n  itemType: '',\r\n\r\n  /**\r\n   * 形状的类型，例如 circle，ellipse，polyline...\r\n   */\r\n  type: '',\r\n  getCustomConfig: function getCustomConfig(cfg) {\r\n    return {};\r\n  },\r\n  getOptions: function getOptions(cfg) {\r\n    return (0, _util.deepMix)({\r\n      // 解决局部渲染导致的文字移动残影问题\r\n      labelCfg: {\r\n        style: {\r\n          fontFamily: typeof window !== 'undefined' && window.getComputedStyle ? window.getComputedStyle(document.body, null).getPropertyValue('font-family') || 'Arial, sans-serif' : 'Arial, sans-serif'\r\n        }\r\n      },\r\n      descriptionCfg: {\r\n        style: {\r\n          fontFamily: typeof window !== 'undefined' && window.getComputedStyle ? window.getComputedStyle(document.body, null).getPropertyValue('font-family') || 'Arial, sans-serif' : 'Arial, sans-serif'\r\n        }\r\n      }\r\n    }, this.options, this.getCustomConfig(cfg) || {}, cfg);\r\n  },\r\n\r\n  /**\r\n   * 绘制节点/边，包含文本\r\n   * @override\r\n   * @param  {Object} cfg 节点的配置项\r\n   * @param  {G.Group} group 节点的容器\r\n   * @return {IShape} 绘制的图形\r\n   */\r\n  draw: function draw(cfg, group) {\r\n    var shape = this.drawShape(cfg, group);\r\n    shape.set('className', this.itemType + CLS_SHAPE_SUFFIX);\r\n\r\n    if (cfg.label) {\r\n      var label = this.drawLabel(cfg, group);\r\n      label.set('className', this.itemType + CLS_LABEL_SUFFIX);\r\n    }\r\n\r\n    return shape;\r\n  },\r\n\r\n  /**\r\n   * 绘制完成后的操作，便于用户继承现有的节点、边\r\n   * @param cfg\r\n   * @param group\r\n   * @param keyShape\r\n   */\r\n  afterDraw: function afterDraw(cfg, group, keyShape) {},\r\n  drawShape: function drawShape(cfg, group) {\r\n    return null;\r\n  },\r\n  drawLabel: function drawLabel(cfg, group) {\r\n    var defaultLabelCfg = this.getOptions(cfg).labelCfg; // image的情况下有可能为null\r\n\r\n    var labelCfg = defaultLabelCfg || {};\r\n    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);\r\n    var rotate = labelStyle.rotate;\r\n    delete labelStyle.rotate;\r\n    var label = group.addShape('text', {\r\n      attrs: labelStyle,\r\n      draggable: true,\r\n      className: 'text-shape',\r\n      name: 'text-shape'\r\n    });\r\n\r\n    if (rotate) {\r\n      var labelBBox = label.getBBox();\r\n      var labelMatrix = label.getMatrix();\r\n\r\n      if (!labelMatrix) {\r\n        labelMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n      }\r\n\r\n      if (labelStyle.rotateCenter) {\r\n        switch (labelStyle.rotateCenter) {\r\n          case 'center':\r\n            labelMatrix = transform(labelMatrix, [['t', -labelBBox.width / 2, -labelBBox.height / 2], ['r', rotate], ['t', labelBBox.width / 2, labelBBox.height / 2]]);\r\n            break;\r\n\r\n          case 'lefttop':\r\n            labelMatrix = transform(labelMatrix, [['t', -labelStyle.x, -labelStyle.y], ['r', rotate], ['t', labelStyle.x, labelStyle.y]]);\r\n            break;\r\n\r\n          case 'leftcenter':\r\n            labelMatrix = transform(labelMatrix, [['t', -labelStyle.x, -labelStyle.y - labelBBox.height / 2], ['r', rotate], ['t', labelStyle.x, labelStyle.y + labelBBox.height / 2]]);\r\n            break;\r\n\r\n          default:\r\n            labelMatrix = transform(labelMatrix, [['t', -labelBBox.width / 2, -labelBBox.height / 2], ['r', rotate], ['t', labelBBox.width / 2, labelBBox.height / 2]]);\r\n            break;\r\n        }\r\n      } else {\r\n        labelMatrix = transform(labelMatrix, [['t', -labelStyle.x, -labelStyle.y - labelBBox.height / 2], ['r', rotate], ['t', labelStyle.x, labelStyle.y + labelBBox.height / 2]]);\r\n      }\r\n\r\n      label.setMatrix(labelMatrix);\r\n    }\r\n\r\n    if (labelStyle.background) {\r\n      var rect = this.drawLabelBg(cfg, group, label);\r\n      var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;\r\n      rect.set('classname', labelBgClassname);\r\n      label.toFront();\r\n    }\r\n\r\n    return label;\r\n  },\r\n  drawLabelBg: function drawLabelBg(cfg, group, label) {\r\n    var defaultLabelCfg = this.options.labelCfg;\r\n    var labelCfg = (0, _util.mix)({}, defaultLabelCfg, cfg.labelCfg);\r\n    var style = this.getLabelBgStyleByPosition(label, cfg, labelCfg, group);\r\n    var rect = group.addShape('rect', {\r\n      name: 'text-bg-shape',\r\n      attrs: style\r\n    });\r\n    return rect;\r\n  },\r\n  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg, group) {\r\n    return {\r\n      text: cfg.label\r\n    };\r\n  },\r\n  getLabelBgStyleByPosition: function getLabelBgStyleByPosition(label, cfg, labelCfg, group) {\r\n    return {};\r\n  },\r\n\r\n  /**\r\n   * 获取文本的配置项\r\n   * @param cfg 节点的配置项\r\n   * @param labelCfg 文本的配置项\r\n   * @param group 父容器，label 的定位可能与图形相关\r\n   */\r\n  getLabelStyle: function getLabelStyle(cfg, labelCfg, group) {\r\n    var calculateStyle = this.getLabelStyleByPosition(cfg, labelCfg, group);\r\n    var attrName = this.itemType + \"Label\"; // 取 nodeLabel，edgeLabel 的配置项\r\n\r\n    var defaultStyle = _global.default[attrName] ? _global.default[attrName].style : null;\r\n    var labelStyle = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, defaultStyle), calculateStyle), labelCfg.style);\r\n    return labelStyle;\r\n  },\r\n\r\n  /**\r\n   * 获取图形的配置项\r\n   * @param cfg\r\n   */\r\n  getShapeStyle: function getShapeStyle(cfg) {\r\n    return cfg.style;\r\n  },\r\n\r\n  /**\r\n   * 更新节点，包含文本\r\n   * @override\r\n   * @param  {Object} cfg 节点/边的配置项\r\n   * @param  {G6.Item} item 节点/边\r\n   */\r\n  update: function update(cfg, item) {\r\n    this.updateShapeStyle(cfg, item);\r\n    this.updateLabel(cfg, item);\r\n  },\r\n  updateShapeStyle: function updateShapeStyle(cfg, item) {\r\n    var group = item.getContainer();\r\n    var shape = item.getKeyShape();\r\n    var shapeStyle = (0, _util.mix)({}, shape.attr(), cfg.style);\r\n\r\n    var _loop_1 = function _loop_1(key) {\r\n      var _a;\r\n\r\n      var style = shapeStyle[key];\r\n\r\n      if ((0, _util.isPlainObject)(style)) {\r\n        // 更新图元素样式，支持更新子元素\r\n        var subShape = group.find(function (element) {\r\n          return element.get('name') === key;\r\n        });\r\n\r\n        if (subShape) {\r\n          subShape.attr(style);\r\n        }\r\n      } else {\r\n        shape.attr((_a = {}, _a[key] = style, _a));\r\n      }\r\n    };\r\n\r\n    for (var key in shapeStyle) {\r\n      _loop_1(key);\r\n    }\r\n  },\r\n  updateLabel: function updateLabel(cfg, item) {\r\n    var group = item.getContainer();\r\n    var defaultLabelCfg = this.getOptions({}).labelCfg;\r\n    var labelClassName = this.itemType + CLS_LABEL_SUFFIX;\r\n    var label = group.find(function (element) {\r\n      return element.get('className') === labelClassName;\r\n    });\r\n    var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;\r\n    var labelBg = group.find(function (element) {\r\n      return element.get('classname') === labelBgClassname;\r\n    }); // 防止 cfg.label = \"\" 的情况\r\n\r\n    if (cfg.label || cfg.label === '') {\r\n      // 若传入的新配置中有 label，（用户没传入但原先有 label，label 也会有值）\r\n      if (!label) {\r\n        // 若原先不存在 label，则绘制一个新的 label\r\n        var newLabel = this.drawLabel(cfg, group);\r\n        newLabel.set('className', labelClassName);\r\n      } else {\r\n        // 若原先存在 label，则更新样式。与 getLabelStyle 不同在于这里需要融合当前 label 的样式\r\n        // 用于融合 style 以外的属性：position, offset, ...\r\n        var currentLabelCfg = {};\r\n\r\n        if (item.getModel) {\r\n          currentLabelCfg = item.getModel().labelCfg;\r\n        } // 这里不能去掉\r\n\r\n\r\n        var labelCfg = (0, _util.deepMix)({}, defaultLabelCfg, currentLabelCfg, cfg.labelCfg); // 获取位置信息\r\n\r\n        var calculateStyle = this.getLabelStyleByPosition(cfg, labelCfg, group); // 取 nodeLabel，edgeLabel 的配置项\r\n\r\n        var cfgStyle = cfg.labelCfg ? cfg.labelCfg.style : undefined;\r\n        var cfgBgStyle = labelCfg.style && labelCfg.style.background; // 需要融合当前\b label 的样式 label.attr()。不再需要全局/默认样式，因为已经应用在当前的 label 上\r\n\r\n        var labelStyle = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, label.attr()), calculateStyle), cfgStyle);\r\n        var rotate = labelStyle.rotate;\r\n        delete labelStyle.rotate; // 计算 label 的旋转矩阵\r\n\r\n        if (rotate) {\r\n          // if G 4.x define the rotateAtStart, use it directly instead of using the following codes\r\n          var rotateMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n          rotateMatrix = transform(rotateMatrix, [['t', -labelStyle.x, -labelStyle.y], ['r', rotate], ['t', labelStyle.x, labelStyle.y]]);\r\n          label.resetMatrix();\r\n          label.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, labelStyle), {\r\n            matrix: rotateMatrix\r\n          }));\r\n        } else {\r\n          label.resetMatrix();\r\n          label.attr(labelStyle);\r\n        }\r\n\r\n        if (!labelBg) {\r\n          if (labelStyle.background) {\r\n            labelBg = this.drawLabelBg(cfg, group, label);\r\n            labelBg.set('classname', labelBgClassname);\r\n            label.toFront();\r\n          }\r\n        } else if (labelStyle.background) {\r\n          var calculateBgStyle = this.getLabelBgStyleByPosition(label, cfg, labelCfg, group);\r\n          var labelBgStyle = (0, _tslib.__assign)((0, _tslib.__assign)({}, calculateBgStyle), cfgBgStyle);\r\n          labelBg.resetMatrix();\r\n\r\n          if (rotate) {\r\n            var bgRotateMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n            bgRotateMatrix = transform(bgRotateMatrix, [['t', -labelBgStyle.x, -labelBgStyle.y], ['r', rotate], ['t', labelBgStyle.x, labelBgStyle.y]]);\r\n            labelBgStyle.matrix = bgRotateMatrix;\r\n          }\r\n\r\n          labelBg.attr(labelBgStyle);\r\n        } else {\r\n          group.removeChild(labelBg);\r\n        }\r\n      }\r\n    }\r\n  },\r\n  // update(cfg, item) // 默认不定义\r\n  afterUpdate: function afterUpdate(cfg, item) {},\r\n\r\n  /**\r\n   * 设置节点的状态，主要是交互状态，业务状态请在 draw 方法中实现\r\n   * 单图形的节点仅考虑 selected、active 状态，有其他状态需求的用户自己复写这个方法\r\n   * @override\r\n   * @param  {String} name 状态名称\r\n   * @param  {String | Boolean} value 状态值\r\n   * @param  {G6.Item} item 节点\r\n   */\r\n  setState: function setState(name, value, item) {\r\n    var _a, _b;\r\n\r\n    var shape = item.get('keyShape');\r\n    if (!shape || shape.destroyed) return;\r\n    var type = item.getType();\r\n    var stateName = (0, _util.isBoolean)(value) ? name : name + \":\" + value;\r\n    var shapeStateStyle = this.getStateStyle(stateName, item);\r\n    var itemStateStyle = item.getStateStyle(stateName); // const originStyle = item.getOriginStyle();\r\n    // 不允许设置一个不存在的状态\r\n\r\n    if (!itemStateStyle && !shapeStateStyle) {\r\n      return;\r\n    } // 要设置或取消的状态的样式\r\n    // 当没有 state 状态时，默认使用 model.stateStyles 中的样式\r\n\r\n\r\n    var styles = (0, _util.mix)({}, itemStateStyle || shapeStateStyle);\r\n    var group = item.getContainer(); // 从图元素现有的样式中删除本次要取消的 states 中存在的属性值。使用对象检索更快\r\n\r\n    var keptAttrs = {\r\n      x: 1,\r\n      y: 1,\r\n      cx: 1,\r\n      cy: 1\r\n    };\r\n\r\n    if (type === 'combo') {\r\n      keptAttrs.r = 1;\r\n      keptAttrs.width = 1;\r\n      keptAttrs.height = 1;\r\n    }\r\n\r\n    if (value) {\r\n      var _loop_2 = function _loop_2(key) {\r\n        var _c;\r\n\r\n        var style = styles[key];\r\n\r\n        if ((0, _util.isPlainObject)(style) && !ARROWS.includes(key)) {\r\n          var subShape = group.find(function (element) {\r\n            return element.get('name') === key;\r\n          });\r\n\r\n          if (subShape) {\r\n            subShape.attr(style);\r\n          }\r\n        } else {\r\n          // 非纯对象，则认为是设置到 keyShape 上面的\r\n          shape.attr((_c = {}, _c[key] = style, _c));\r\n        }\r\n      }; // style 为要设置的状态的样式\r\n\r\n\r\n      for (var key in styles) {\r\n        _loop_2(key);\r\n      }\r\n    } else {\r\n      // 所有生效的 state 的样式\r\n      var enableStatesStyle = (0, _graphic.cloneBesidesImg)(item.getCurrentStatesStyle());\r\n      var model = item.getModel(); // 原始样式\r\n\r\n      var originStyle_1 = (0, _util.mix)({}, model.style, (0, _graphic.cloneBesidesImg)(item.getOriginStyle()));\r\n      var keyShapeName_1 = shape.get('name'); // cloning  shape.attr(), keys.forEach to avoid cloning the img attr, which leads to maximum clone heap #2383\r\n      // const keyShapeStyles = clone(shape.attr())\r\n\r\n      var shapeAttrs_1 = shape.attr();\r\n      var keyShapeStyles_1 = {};\r\n      Object.keys(shapeAttrs_1).forEach(function (key) {\r\n        if (key === 'img') return;\r\n        var attr = shapeAttrs_1[key];\r\n\r\n        if (attr && _typeof(attr) === 'object') {\r\n          keyShapeStyles_1[key] = (0, _util.clone)(attr);\r\n        } else {\r\n          keyShapeStyles_1[key] = attr;\r\n        }\r\n      }); // 已有样式 - 要取消的状态的样式\r\n\r\n      var filtetDisableStatesStyle = {};\r\n\r\n      var _loop_3 = function _loop_3(p) {\r\n        var style = styles[p];\r\n\r\n        if ((0, _util.isPlainObject)(style) && !ARROWS.includes(p)) {\r\n          var subShape_1 = group.find(function (element) {\r\n            return element.get('name') === p;\r\n          });\r\n\r\n          if (subShape_1) {\r\n            var subShapeStyles_1 = (0, _util.clone)(subShape_1.attr());\r\n            (0, _util.each)(style, function (v, key) {\r\n              if (p === keyShapeName_1 && keyShapeStyles_1[key] && !keptAttrs[key]) {\r\n                delete keyShapeStyles_1[key];\r\n                var value_1 = originStyle_1[p][key] || SHAPES_DEFAULT_ATTRS[type][key];\r\n                shape.attr(key, value_1);\r\n              } else if (subShapeStyles_1[key] || subShapeStyles_1[key] === 0) {\r\n                delete subShapeStyles_1[key];\r\n                var value_2 = originStyle_1[p][key] || SHAPES_DEFAULT_ATTRS[type][key];\r\n                subShape_1.attr(key, value_2);\r\n              }\r\n            });\r\n            filtetDisableStatesStyle[p] = subShapeStyles_1;\r\n          }\r\n        } else {\r\n          if (keyShapeStyles_1[p] && !keptAttrs[p]) {\r\n            delete keyShapeStyles_1[p];\r\n            var value_3 = originStyle_1[p] || (originStyle_1[keyShapeName_1] ? originStyle_1[keyShapeName_1][p] : undefined) || SHAPES_DEFAULT_ATTRS[type][p];\r\n            shape.attr(p, value_3);\r\n          }\r\n        }\r\n      }; // styles 为要取消的状态的样式\r\n\r\n\r\n      for (var p in styles) {\r\n        _loop_3(p);\r\n      } // 从图元素现有的样式中删除本次要取消的 states 中存在的属性值后，\r\n      // 如果 keyShape 有 name 属性，则 filtetDisableStatesStyle 的格式为 { keyShapeName: {} }\r\n      // 否则为普通对象\r\n\r\n\r\n      if (!keyShapeName_1) {\r\n        (0, _util.mix)(filtetDisableStatesStyle, keyShapeStyles_1);\r\n      } else {\r\n        filtetDisableStatesStyle[keyShapeName_1] = keyShapeStyles_1;\r\n      }\r\n\r\n      for (var key in enableStatesStyle) {\r\n        if (keptAttrs[key]) continue;\r\n        var enableStyle = enableStatesStyle[key];\r\n\r\n        if (!(0, _util.isPlainObject)(enableStyle) || ARROWS.includes(key)) {\r\n          // 把样式属性merge到keyShape中\r\n          if (!keyShapeName_1) {\r\n            (0, _util.mix)(originStyle_1, (_a = {}, _a[key] = enableStyle, _a));\r\n          } else {\r\n            (0, _util.mix)(originStyle_1[keyShapeName_1], (_b = {}, _b[key] = enableStyle, _b));\r\n            delete originStyle_1[key];\r\n          }\r\n\r\n          delete enableStatesStyle[key];\r\n        }\r\n      }\r\n\r\n      var originstyles = {};\r\n      (0, _util.deepMix)(originstyles, originStyle_1, filtetDisableStatesStyle, enableStatesStyle);\r\n      var keyShapeSetted = false;\r\n\r\n      var _loop_4 = function _loop_4(originKey) {\r\n        var _d, _e;\r\n\r\n        var style = originstyles[originKey];\r\n\r\n        if ((0, _util.isPlainObject)(style) && !ARROWS.includes(originKey)) {\r\n          var subShape = group.find(function (element) {\r\n            return element.get('name') === originKey;\r\n          });\r\n\r\n          if (subShape) {\r\n            if (originKey === keyShapeName_1) {\r\n              if (type === 'combo') {\r\n                delete style.r;\r\n                delete style.width;\r\n                delete style.height;\r\n              }\r\n\r\n              keyShapeSetted = true;\r\n            }\r\n\r\n            subShape.attr(style);\r\n          }\r\n        } else if (!keyShapeSetted) {\r\n          var value_4 = style || SHAPES_DEFAULT_ATTRS[type][originKey]; // 当更新 combo 状态时，当不存在 keyShapeName 时候，则认为是设置到 keyShape 上面的\r\n\r\n          if (type === 'combo') {\r\n            if (!keyShapeName_1) {\r\n              shape.attr((_d = {}, _d[originKey] = value_4, _d));\r\n            }\r\n          } else {\r\n            shape.attr((_e = {}, _e[originKey] = value_4, _e));\r\n          }\r\n        }\r\n      };\r\n\r\n      for (var originKey in originstyles) {\r\n        _loop_4(originKey);\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 获取不同状态下的样式\r\n   *\r\n   * @param {string} name 状态名称\r\n   * @param {Item} item Node或Edge的实例\r\n   * @return {object} 样式\r\n   */\r\n  getStateStyle: function getStateStyle(name, item) {\r\n    var model = item.getModel();\r\n    var type = item.getType();\r\n\r\n    var _a = this.getOptions(model),\r\n        stateStyles = _a.stateStyles,\r\n        _b = _a.style,\r\n        style = _b === void 0 ? {} : _b;\r\n\r\n    var modelStateStyle = model.stateStyles ? model.stateStyles[name] : stateStyles && stateStyles[name];\r\n\r\n    if (type === 'combo') {\r\n      return (0, _util.clone)(modelStateStyle);\r\n    }\r\n\r\n    return (0, _util.mix)({}, style, modelStateStyle);\r\n  },\r\n\r\n  /**\r\n   * 获取控制点\r\n   * @param  {Object} cfg 节点、边的配置项\r\n   * @return {Array|null} 控制点的数组,如果为 null，则没有控制点\r\n   */\r\n  getControlPoints: function getControlPoints(cfg) {\r\n    return cfg.controlPoints;\r\n  },\r\n\r\n  /**\r\n   * 获取控制点\r\n   * @param  {Object} cfg 节点、边的配置项\r\n   * @return {Array|null} 锚点的数组,如果为 null，则没有锚点\r\n   */\r\n  getAnchorPoints: function getAnchorPoints(cfg) {\r\n    var anchorPoints = this.getOptions(cfg).anchorPoints;\r\n    return anchorPoints;\r\n  }\r\n};\r\nexports.shapeBase = shapeBase;","\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _graphic = require(\"../util/graphic\");\r\n\r\nvar _math = require(\"../util/math\");\r\n\r\nvar _path = require(\"../util/path\");\r\n\r\nvar _global = _interopRequireDefault(require(\"../global\"));\r\n\r\nvar _shape = _interopRequireDefault(require(\"./shape\"));\r\n\r\nvar _shapeBase = require(\"./shapeBase\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * @fileOverview 自定义边\r\n * @description 自定义边中有大量逻辑同自定义节点重复，虽然可以提取成为 mixin ，但是考虑到代码的可读性，还是单独实现。\r\n */\r\nvar CLS_SHAPE = 'edge-shape'; // start,end 倒置，center 不变\r\n\r\nfunction revertAlign(labelPosition) {\r\n  var textAlign = labelPosition;\r\n\r\n  if (labelPosition === 'start') {\r\n    textAlign = 'end';\r\n  } else if (labelPosition === 'end') {\r\n    textAlign = 'start';\r\n  }\r\n\r\n  return textAlign;\r\n}\r\n\r\nvar singleEdge = {\r\n  itemType: 'edge',\r\n\r\n  /**\r\n   * 文本的位置\r\n   * @type {String}\r\n   */\r\n  labelPosition: 'center',\r\n\r\n  /**\r\n   * 文本的 x 偏移\r\n   * @type {Number}\r\n   */\r\n  refX: 0,\r\n\r\n  /**\r\n   * 文本的 y 偏移\r\n   * @type {Number}\r\n   */\r\n  refY: 0,\r\n\r\n  /**\r\n   * 文本是否跟着线自动旋转，默认 false\r\n   * @type {Boolean}\r\n   */\r\n  labelAutoRotate: false,\r\n  // 自定义边时的配置\r\n  options: {\r\n    size: _global.default.defaultEdge.size,\r\n    style: {\r\n      x: 0,\r\n      y: 0,\r\n      stroke: _global.default.defaultEdge.style.stroke,\r\n      lineAppendWidth: _global.default.defaultEdge.style.lineAppendWidth\r\n    },\r\n    labelCfg: {\r\n      style: {\r\n        fill: _global.default.edgeLabel.style.fill,\r\n        fontSize: _global.default.edgeLabel.style.fontSize\r\n      }\r\n    },\r\n    stateStyles: (0, _tslib.__assign)({}, _global.default.edgeStateStyles)\r\n  },\r\n\r\n  /**\r\n   * 获取边的 path\r\n   * @internal 供扩展的边覆盖\r\n   * @param  {Array} points 构成边的点的集合\r\n   * @return {Array} 构成 path 的数组\r\n   */\r\n  getPath: function getPath(points) {\r\n    var path = [];\r\n    (0, _util.each)(points, function (point, index) {\r\n      if (index === 0) {\r\n        path.push(['M', point.x, point.y]);\r\n      } else {\r\n        path.push(['L', point.x, point.y]);\r\n      }\r\n    });\r\n    return path;\r\n  },\r\n  getShapeStyle: function getShapeStyle(cfg) {\r\n    var defaultStyle = this.options.style;\r\n    var strokeStyle = {\r\n      stroke: cfg.color\r\n    }; // 如果设置了color，则覆盖默认的stroke属性\r\n\r\n    var style = (0, _util.mix)({}, defaultStyle, strokeStyle, cfg.style);\r\n    var size = cfg.size || _global.default.defaultEdge.size;\r\n    cfg = this.getPathPoints(cfg);\r\n    var startPoint = cfg.startPoint,\r\n        endPoint = cfg.endPoint;\r\n    var controlPoints = this.getControlPoints(cfg);\r\n    var points = [startPoint]; // 添加起始点\r\n    // 添加控制点\r\n\r\n    if (controlPoints) {\r\n      points = points.concat(controlPoints);\r\n    } // 添加结束点\r\n\r\n\r\n    points.push(endPoint);\r\n    var path = this.getPath(points);\r\n    var styles = (0, _util.mix)({}, _global.default.defaultEdge.style, {\r\n      stroke: _global.default.defaultEdge.color,\r\n      lineWidth: size,\r\n      path: path\r\n    }, style);\r\n    return styles;\r\n  },\r\n  updateShapeStyle: function updateShapeStyle(cfg, item) {\r\n    var group = item.getContainer();\r\n    var strokeStyle = {\r\n      stroke: cfg.color\r\n    };\r\n    var shape = group.find(function (element) {\r\n      return element.get('className') === 'edge-shape';\r\n    }) || item.getKeyShape();\r\n    var size = cfg.size;\r\n    cfg = this.getPathPoints(cfg);\r\n    var startPoint = cfg.startPoint,\r\n        endPoint = cfg.endPoint;\r\n    var controlPoints = this.getControlPoints(cfg); // || cfg.controlPoints;\r\n\r\n    var points = [startPoint]; // 添加起始点\r\n    // 添加控制点\r\n\r\n    if (controlPoints) {\r\n      points = points.concat(controlPoints);\r\n    } // 添加结束点\r\n\r\n\r\n    points.push(endPoint);\r\n    var currentAttr = shape.attr();\r\n    var previousStyle = (0, _util.mix)({}, strokeStyle, currentAttr, cfg.style);\r\n    var source = cfg.sourceNode;\r\n    var target = cfg.targetNode;\r\n    var routeCfg = {\r\n      radius: previousStyle.radius\r\n    };\r\n\r\n    if (!controlPoints) {\r\n      routeCfg = {\r\n        source: source,\r\n        target: target,\r\n        offset: previousStyle.offset,\r\n        radius: previousStyle.radius\r\n      };\r\n    }\r\n\r\n    if (currentAttr.endArrow && previousStyle.endArrow === false) {\r\n      cfg.style.endArrow = {\r\n        path: ''\r\n      };\r\n    }\r\n\r\n    if (currentAttr.startArrow && previousStyle.startArrow === false) {\r\n      cfg.style.startArrow = {\r\n        path: ''\r\n      };\r\n    }\r\n\r\n    var path = this.getPath(points, routeCfg);\r\n    var style = (0, _util.mix)(strokeStyle, shape.attr(), {\r\n      lineWidth: size,\r\n      path: path\r\n    }, cfg.style);\r\n\r\n    if (shape) {\r\n      shape.attr(style);\r\n    }\r\n  },\r\n  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg, group) {\r\n    var labelPosition = labelCfg.position || this.labelPosition; // 文本的位置用户可以传入\r\n\r\n    var style = {};\r\n    var pathShape = group && group.find(function (element) {\r\n      return element.get('className') === CLS_SHAPE;\r\n    }); // 不对 pathShape 进行判空，如果线不存在，说明有问题了\r\n\r\n    var pointPercent;\r\n\r\n    if (labelPosition === 'start') {\r\n      pointPercent = 0;\r\n    } else if (labelPosition === 'end') {\r\n      pointPercent = 1;\r\n    } else {\r\n      pointPercent = 0.5;\r\n    } // 偏移量\r\n\r\n\r\n    var offsetX = labelCfg.refX || this.refX;\r\n    var offsetY = labelCfg.refY || this.refY; // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移\r\n\r\n    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {\r\n      style.x = cfg.startPoint.x + offsetX;\r\n      style.y = cfg.startPoint.y + offsetY;\r\n      style.text = cfg.label;\r\n      return style;\r\n    }\r\n\r\n    var autoRotate;\r\n    if ((0, _util.isNil)(labelCfg.autoRotate)) autoRotate = this.labelAutoRotate;else autoRotate = labelCfg.autoRotate;\r\n    var offsetStyle = (0, _graphic.getLabelPosition)(pathShape, pointPercent, offsetX, offsetY, autoRotate);\r\n    style.x = offsetStyle.x;\r\n    style.y = offsetStyle.y;\r\n    style.rotate = offsetStyle.rotate;\r\n    style.textAlign = this._getTextAlign(labelPosition, offsetStyle.angle);\r\n    style.text = cfg.label;\r\n    return style;\r\n  },\r\n  getLabelBgStyleByPosition: function getLabelBgStyleByPosition(label, cfg, labelCfg, group) {\r\n    if (!label) {\r\n      return {};\r\n    }\r\n\r\n    var bbox = label.getBBox();\r\n    var backgroundStyle = labelCfg.style && labelCfg.style.background;\r\n\r\n    if (!backgroundStyle) {\r\n      return {};\r\n    }\r\n\r\n    var padding = backgroundStyle.padding;\r\n    var backgroundWidth = bbox.width + padding[1] + padding[3];\r\n    var backgroundHeight = bbox.height + padding[0] + padding[2];\r\n    var labelPosition = labelCfg.position || this.labelPosition;\r\n    var style = (0, _tslib.__assign)((0, _tslib.__assign)({}, backgroundStyle), {\r\n      width: backgroundWidth,\r\n      height: backgroundHeight,\r\n      x: bbox.minX - padding[2],\r\n      y: bbox.minY - padding[0],\r\n      rotate: 0\r\n    });\r\n    var autoRotate;\r\n    if ((0, _util.isNil)(labelCfg.autoRotate)) autoRotate = this.labelAutoRotate;else autoRotate = labelCfg.autoRotate;\r\n    var pathShape = group && group.find(function (element) {\r\n      return element.get('className') === CLS_SHAPE;\r\n    }); // 不对 pathShape 进行判空，如果线不存在，说明有问题了\r\n\r\n    var pointPercent;\r\n\r\n    if (labelPosition === 'start') {\r\n      pointPercent = 0;\r\n    } else if (labelPosition === 'end') {\r\n      pointPercent = 1;\r\n    } else {\r\n      pointPercent = 0.5;\r\n    } // 偏移量\r\n\r\n\r\n    var offsetX = labelCfg.refX || this.refX;\r\n    var offsetY = labelCfg.refY || this.refY; // // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移\r\n\r\n    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {\r\n      style.x = cfg.startPoint.x + offsetX - backgroundWidth / 2;\r\n      style.y = cfg.startPoint.y + offsetY - backgroundHeight / 2;\r\n      return style;\r\n    }\r\n\r\n    var offsetStyle = (0, _graphic.getLabelPosition)(pathShape, pointPercent, offsetX - backgroundWidth / 2, offsetY + backgroundHeight / 2, autoRotate);\r\n    var rad = offsetStyle.angle;\r\n\r\n    if (rad > 1 / 2 * Math.PI && rad < 3 * 1 / 2 * Math.PI) {\r\n      offsetStyle = (0, _graphic.getLabelPosition)(pathShape, pointPercent, offsetX + backgroundWidth / 2, offsetY + backgroundHeight / 2, autoRotate);\r\n    }\r\n\r\n    if (autoRotate) {\r\n      style.x = offsetStyle.x;\r\n      style.y = offsetStyle.y;\r\n    }\r\n\r\n    style.rotate = offsetStyle.rotate;\r\n    return style;\r\n  },\r\n  // 获取文本对齐方式\r\n  _getTextAlign: function _getTextAlign(labelPosition, angle) {\r\n    var textAlign = 'center';\r\n\r\n    if (!angle) {\r\n      return labelPosition;\r\n    }\r\n\r\n    angle = angle % (Math.PI * 2); // 取模\r\n\r\n    if (labelPosition !== 'center') {\r\n      if (angle >= 0 && angle <= Math.PI / 2 || angle >= 3 / 2 * Math.PI && angle < 2 * Math.PI) {\r\n        textAlign = labelPosition;\r\n      } else {\r\n        textAlign = revertAlign(labelPosition);\r\n      }\r\n    }\r\n\r\n    return textAlign;\r\n  },\r\n\r\n  /**\r\n   * @internal 获取边的控制点\r\n   * @param  {Object} cfg 边的配置项\r\n   * @return {Array} 控制点的数组\r\n   */\r\n  getControlPoints: function getControlPoints(cfg) {\r\n    return cfg.controlPoints;\r\n  },\r\n\r\n  /**\r\n   * @internal 处理需要重计算点和边的情况\r\n   * @param {Object} cfg 边的配置项\r\n   * @return {Object} 边的配置项\r\n   */\r\n  getPathPoints: function getPathPoints(cfg) {\r\n    return cfg;\r\n  },\r\n\r\n  /**\r\n   * 绘制边\r\n   * @override\r\n   * @param  {Object} cfg   边的配置项\r\n   * @param  {G.Group} group 边的容器\r\n   * @return {IShape} 图形\r\n   */\r\n  drawShape: function drawShape(cfg, group) {\r\n    var shapeStyle = this.getShapeStyle(cfg);\r\n    var shape = group.addShape('path', {\r\n      className: CLS_SHAPE,\r\n      name: CLS_SHAPE,\r\n      attrs: shapeStyle\r\n    });\r\n    return shape;\r\n  },\r\n  drawLabel: function drawLabel(cfg, group) {\r\n    var defaultLabelCfg = this.options.labelCfg;\r\n    var defaultFontFamily;\r\n    if (typeof window !== 'undefined' && typeof window.getComputedStyle !== 'undefined') defaultFontFamily = window.getComputedStyle(document.body, null).getPropertyValue('font-family') || 'Arial, sans-serif';else defaultFontFamily = 'Arial, sans-serif';\r\n    var labelCfg = (0, _util.deepMix)({\r\n      fontFamily: defaultFontFamily\r\n    }, defaultLabelCfg, cfg.labelCfg);\r\n    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);\r\n    var rotate = labelStyle.rotate;\r\n    delete labelStyle.rotate;\r\n    var label = group.addShape('text', {\r\n      attrs: labelStyle,\r\n      name: 'text-shape'\r\n    });\r\n\r\n    if (rotate) {\r\n      label.rotateAtStart(rotate);\r\n    }\r\n\r\n    if (labelStyle.background) {\r\n      var rect = this.drawLabelBg(cfg, group, label);\r\n      var labelBgClassname = this.itemType + _shapeBase.CLS_LABEL_BG_SUFFIX;\r\n      rect.set('classname', labelBgClassname);\r\n      label.toFront();\r\n    }\r\n\r\n    return label;\r\n  },\r\n  drawLabelBg: function drawLabelBg(cfg, group, label) {\r\n    var defaultLabelCfg = this.options.labelCfg;\r\n    var labelCfg = (0, _util.deepMix)({}, defaultLabelCfg, cfg.labelCfg);\r\n    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);\r\n    var rotate = labelStyle.rotate;\r\n    var style = this.getLabelBgStyleByPosition(label, cfg, labelCfg, group);\r\n    delete style.rotate;\r\n    var rect = group.addShape('rect', {\r\n      name: 'text-bg-shape',\r\n      attrs: style\r\n    });\r\n    if (rotate) rect.rotateAtStart(rotate);\r\n    return rect;\r\n  }\r\n};\r\nvar singleEdgeDef = (0, _tslib.__assign)((0, _tslib.__assign)({}, _shapeBase.shapeBase), singleEdge);\r\n\r\n_shape.default.registerEdge('single-edge', singleEdgeDef); // 直线, 不支持控制点\r\n\r\n\r\n_shape.default.registerEdge('line', {\r\n  // 控制点不生效\r\n  getControlPoints: function getControlPoints() {\r\n    return undefined;\r\n  }\r\n}, 'single-edge'); // 直线\r\n\r\n\r\n_shape.default.registerEdge('spline', {\r\n  getPath: function getPath(points) {\r\n    var path = (0, _path.getSpline)(points);\r\n    return path;\r\n  }\r\n}, 'single-edge');\r\n\r\n_shape.default.registerEdge('arc', {\r\n  curveOffset: 20,\r\n  clockwise: 1,\r\n  getControlPoints: function getControlPoints(cfg) {\r\n    var startPoint = cfg.startPoint,\r\n        endPoint = cfg.endPoint;\r\n    var midPoint = {\r\n      x: (startPoint.x + endPoint.x) / 2,\r\n      y: (startPoint.y + endPoint.y) / 2\r\n    };\r\n    var center;\r\n    var arcPoint; // 根据给定点计算圆弧\r\n\r\n    if (cfg.controlPoints !== undefined) {\r\n      arcPoint = cfg.controlPoints[0];\r\n      center = (0, _math.getCircleCenterByPoints)(startPoint, arcPoint, endPoint); // 根据控制点和直线关系决定 clockwise值\r\n\r\n      if (startPoint.x <= endPoint.x && startPoint.y > endPoint.y) {\r\n        this.clockwise = center.x > arcPoint.x ? 0 : 1;\r\n      } else if (startPoint.x <= endPoint.x && startPoint.y < endPoint.y) {\r\n        this.clockwise = center.x > arcPoint.x ? 1 : 0;\r\n      } else if (startPoint.x > endPoint.x && startPoint.y <= endPoint.y) {\r\n        this.clockwise = center.y < arcPoint.y ? 0 : 1;\r\n      } else {\r\n        this.clockwise = center.y < arcPoint.y ? 1 : 0;\r\n      } // 若给定点和两端点共线，无法生成圆弧，绘制直线\r\n\r\n\r\n      if ((arcPoint.x - startPoint.x) / (arcPoint.y - startPoint.y) === (endPoint.x - startPoint.x) / (endPoint.y - startPoint.y)) {\r\n        return [];\r\n      }\r\n    } else {\r\n      // 根据直线连线中点的的偏移计算圆弧\r\n      // 若用户给定偏移量则根据其计算，否则按照默认偏移值计算\r\n      if (cfg.curveOffset === undefined) {\r\n        cfg.curveOffset = this.curveOffset;\r\n      }\r\n\r\n      if ((0, _util.isArray)(cfg.curveOffset)) {\r\n        cfg.curveOffset = cfg.curveOffset[0];\r\n      }\r\n\r\n      if (cfg.curveOffset < 0) {\r\n        this.clockwise = 0;\r\n      } else {\r\n        this.clockwise = 1;\r\n      }\r\n\r\n      var vec = {\r\n        x: endPoint.x - startPoint.x,\r\n        y: endPoint.y - startPoint.y\r\n      };\r\n      var edgeAngle = Math.atan2(vec.y, vec.x);\r\n      arcPoint = {\r\n        x: cfg.curveOffset * Math.cos(-Math.PI / 2 + edgeAngle) + midPoint.x,\r\n        y: cfg.curveOffset * Math.sin(-Math.PI / 2 + edgeAngle) + midPoint.y\r\n      };\r\n      center = (0, _math.getCircleCenterByPoints)(startPoint, arcPoint, endPoint);\r\n    }\r\n\r\n    var radius = (0, _math.distance)(startPoint, center);\r\n    var controlPoints = [{\r\n      x: radius,\r\n      y: radius\r\n    }];\r\n    return controlPoints;\r\n  },\r\n  getPath: function getPath(points) {\r\n    var path = [];\r\n    path.push(['M', points[0].x, points[0].y]); // 控制点与端点共线\r\n\r\n    if (points.length === 2) {\r\n      path.push(['L', points[1].x, points[1].y]);\r\n    } else {\r\n      path.push(['A', points[1].x, points[1].y, 0, 0, this.clockwise, points[2].x, points[2].y]);\r\n    }\r\n\r\n    return path;\r\n  }\r\n}, 'single-edge');\r\n\r\n_shape.default.registerEdge('quadratic', {\r\n  curvePosition: 0.5,\r\n  curveOffset: -20,\r\n  getControlPoints: function getControlPoints(cfg) {\r\n    var controlPoints = cfg.controlPoints; // 指定controlPoints\r\n\r\n    if (!controlPoints || !controlPoints.length) {\r\n      var startPoint = cfg.startPoint,\r\n          endPoint = cfg.endPoint;\r\n      if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\r\n      if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\r\n      if ((0, _util.isArray)(this.curveOffset)) cfg.curveOffset = cfg.curveOffset[0];\r\n      if ((0, _util.isArray)(this.curvePosition)) cfg.curvePosition = cfg.curveOffset[0];\r\n      var innerPoint = (0, _path.getControlPoint)(startPoint, endPoint, cfg.curvePosition, cfg.curveOffset);\r\n      controlPoints = [innerPoint];\r\n    }\r\n\r\n    return controlPoints;\r\n  },\r\n  getPath: function getPath(points) {\r\n    var path = [];\r\n    path.push(['M', points[0].x, points[0].y]);\r\n    path.push(['Q', points[1].x, points[1].y, points[2].x, points[2].y]);\r\n    return path;\r\n  }\r\n}, 'single-edge');\r\n\r\n_shape.default.registerEdge('cubic', {\r\n  curvePosition: [1 / 2, 1 / 2],\r\n  curveOffset: [-20, 20],\r\n  getControlPoints: function getControlPoints(cfg) {\r\n    var controlPoints = cfg.controlPoints; // 指定 controlPoints\r\n\r\n    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\r\n    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\r\n    if ((0, _util.isNumber)(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];\r\n    if ((0, _util.isNumber)(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];\r\n\r\n    if (!controlPoints || !controlPoints.length || controlPoints.length < 2) {\r\n      var startPoint = cfg.startPoint,\r\n          endPoint = cfg.endPoint;\r\n      var innerPoint1 = (0, _path.getControlPoint)(startPoint, endPoint, cfg.curvePosition[0], cfg.curveOffset[0]);\r\n      var innerPoint2 = (0, _path.getControlPoint)(startPoint, endPoint, cfg.curvePosition[1], cfg.curveOffset[1]);\r\n      controlPoints = [innerPoint1, innerPoint2];\r\n    }\r\n\r\n    return controlPoints;\r\n  },\r\n  getPath: function getPath(points) {\r\n    var path = [];\r\n    path.push(['M', points[0].x, points[0].y]);\r\n    path.push(['C', points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);\r\n    return path;\r\n  }\r\n}, 'single-edge'); // 垂直方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点\r\n\r\n\r\n_shape.default.registerEdge('cubic-vertical', {\r\n  curvePosition: [1 / 2, 1 / 2],\r\n  minCurveOffset: [0, 0],\r\n  curveOffset: undefined,\r\n  getControlPoints: function getControlPoints(cfg) {\r\n    var startPoint = cfg.startPoint,\r\n        endPoint = cfg.endPoint;\r\n    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\r\n    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\r\n    if (cfg.minCurveOffset === undefined) cfg.minCurveOffset = this.minCurveOffset;\r\n    if ((0, _util.isNumber)(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];\r\n    if ((0, _util.isNumber)(cfg.minCurveOffset)) cfg.minCurveOffset = [cfg.minCurveOffset, -cfg.minCurveOffset];\r\n    if ((0, _util.isNumber)(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];\r\n    var yDist = endPoint.y - startPoint.y;\r\n    var curveOffset = [0, 0];\r\n\r\n    if (cfg.curveOffset) {\r\n      curveOffset = cfg.curveOffset;\r\n    } else if (Math.abs(yDist) < Math.abs(cfg.minCurveOffset[0])) {\r\n      curveOffset = cfg.minCurveOffset;\r\n    }\r\n\r\n    var innerPoint1 = {\r\n      x: startPoint.x,\r\n      y: startPoint.y + yDist * this.curvePosition[0] + curveOffset[0]\r\n    };\r\n    var innerPoint2 = {\r\n      x: endPoint.x,\r\n      y: endPoint.y - yDist * this.curvePosition[1] + curveOffset[1]\r\n    };\r\n    return [innerPoint1, innerPoint2];\r\n  }\r\n}, 'cubic'); // 水平方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点\r\n\r\n\r\n_shape.default.registerEdge('cubic-horizontal', {\r\n  curvePosition: [1 / 2, 1 / 2],\r\n  minCurveOffset: [0, 0],\r\n  curveOffset: undefined,\r\n  getControlPoints: function getControlPoints(cfg) {\r\n    var startPoint = cfg.startPoint,\r\n        endPoint = cfg.endPoint;\r\n    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\r\n    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\r\n    if (cfg.minCurveOffset === undefined) cfg.minCurveOffset = this.minCurveOffset;\r\n    if ((0, _util.isNumber)(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];\r\n    if ((0, _util.isNumber)(cfg.minCurveOffset)) cfg.minCurveOffset = [cfg.minCurveOffset, -cfg.minCurveOffset];\r\n    if ((0, _util.isNumber)(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];\r\n    var xDist = endPoint.x - startPoint.x;\r\n    var curveOffset = [0, 0];\r\n\r\n    if (cfg.curveOffset) {\r\n      curveOffset = cfg.curveOffset;\r\n    } else if (Math.abs(xDist) < Math.abs(cfg.minCurveOffset[0])) {\r\n      curveOffset = cfg.minCurveOffset;\r\n    }\r\n\r\n    var innerPoint1 = {\r\n      x: startPoint.x + xDist * this.curvePosition[0] + curveOffset[0],\r\n      y: startPoint.y\r\n    };\r\n    var innerPoint2 = {\r\n      x: endPoint.x - xDist * this.curvePosition[1] + curveOffset[1],\r\n      y: endPoint.y\r\n    };\r\n    var controlPoints = [innerPoint1, innerPoint2];\r\n    return controlPoints;\r\n  }\r\n}, 'cubic');\r\n\r\n_shape.default.registerEdge('loop', {\r\n  getPathPoints: function getPathPoints(cfg) {\r\n    return (0, _graphic.getLoopCfgs)(cfg);\r\n  },\r\n  getControlPoints: function getControlPoints(cfg) {\r\n    return cfg.controlPoints;\r\n  },\r\n  afterDraw: function afterDraw(cfg) {\r\n    cfg.controlPoints = undefined;\r\n  },\r\n  afterUpdate: function afterUpdate(cfg) {\r\n    cfg.controlPoints = undefined;\r\n  }\r\n}, 'cubic');","\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _global = _interopRequireDefault(require(\"../global\"));\r\n\r\nvar _shape = _interopRequireDefault(require(\"./shape\"));\r\n\r\nvar _shapeBase = require(\"./shapeBase\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nvar singleCombo = {\r\n  itemType: 'combo',\r\n  // 单个图形的类型\r\n  shapeType: 'single-combo',\r\n\r\n  /**\r\n   * Combo 标题文本相对图形的位置，默认为 top\r\n   * 位置包括： top, bottom, left, right, center\r\n   * @type {String}\r\n   */\r\n  labelPosition: 'top',\r\n\r\n  /**\r\n   * 标题文本相对偏移，当 labelPosition 不为 center 时有效\r\n   * @type {Number}\r\n   */\r\n  refX: _global.default.comboLabel.refX,\r\n  refY: _global.default.comboLabel.refY,\r\n  options: {\r\n    style: {\r\n      stroke: _global.default.defaultCombo.style.stroke,\r\n      fill: _global.default.defaultCombo.style.fill,\r\n      lineWidth: _global.default.defaultCombo.style.lineWidth\r\n    },\r\n    labelCfg: {\r\n      style: {\r\n        fill: _global.default.comboLabel.style.fill,\r\n        fontSize: _global.default.comboLabel.style.fontSize\r\n      }\r\n    },\r\n    stateStyles: (0, _tslib.__assign)({}, _global.default.comboStateStyles)\r\n  },\r\n\r\n  /**\r\n   * 获取 Combo 宽高\r\n   * @internal 返回 Combo 的大小，以 [width, height] 的方式维护\r\n   * @param  {Object} cfg Combo 的配置项\r\n   * @return {Array} 宽高\r\n   */\r\n  getSize: function getSize(cfg) {\r\n    var size = (0, _util.clone)(cfg.size || this.options.size || _global.default.defaultCombo.size); // size 是数组，若长度为 1，则补长度为 2\r\n\r\n    if ((0, _util.isArray)(size) && size.length === 1) {\r\n      size = [size[0], size[0]];\r\n    } // size 为数字，则转换为数组\r\n\r\n\r\n    if (!(0, _util.isArray)(size)) {\r\n      size = [size, size];\r\n    }\r\n\r\n    return size;\r\n  },\r\n  // 私有方法，不希望扩展的 Combo 复写这个方法\r\n  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg) {\r\n    var labelPosition = labelCfg.position || this.labelPosition;\r\n    var cfgStyle = cfg.style;\r\n    var padding = cfg.padding || this.options.padding;\r\n    if ((0, _util.isArray)(padding)) padding = padding[0];\r\n    var refX = labelCfg.refX,\r\n        refY = labelCfg.refY; // 考虑 refX 和 refY = 0 的场景，不用用 labelCfg.refX || Global.nodeLabel.refX\r\n\r\n    if ((0, _util.isNil)(refX)) {\r\n      refX = this.refX; // 不居中时的偏移量\r\n    }\r\n\r\n    if ((0, _util.isNil)(refY)) {\r\n      refY = this.refY; // 不居中时的偏移量\r\n    }\r\n\r\n    var size = this.getSize(cfg);\r\n    var r = Math.max(cfgStyle.r, size[0] / 2) || size[0] / 2;\r\n    var dis = r + padding;\r\n    var style;\r\n\r\n    switch (labelPosition) {\r\n      case 'top':\r\n        style = {\r\n          x: 0,\r\n          y: -dis - refY,\r\n          textBaseline: 'bottom',\r\n          textAlign: 'center'\r\n        };\r\n        break;\r\n\r\n      case 'bottom':\r\n        style = {\r\n          x: 0,\r\n          y: dis + refY,\r\n          textBaseline: 'bottom',\r\n          textAlign: 'center'\r\n        };\r\n        break;\r\n\r\n      case 'left':\r\n        style = {\r\n          x: -dis + refX,\r\n          y: 0,\r\n          textAlign: 'left'\r\n        };\r\n        break;\r\n\r\n      case 'center':\r\n        style = {\r\n          x: 0,\r\n          y: 0,\r\n          text: cfg.label,\r\n          textAlign: 'center'\r\n        };\r\n        break;\r\n\r\n      default:\r\n        style = {\r\n          x: dis + refX,\r\n          y: 0,\r\n          textAlign: 'right'\r\n        };\r\n        break;\r\n    }\r\n\r\n    style.text = cfg.label;\r\n    return style;\r\n  },\r\n  drawShape: function drawShape(cfg, group) {\r\n    var shapeType = this.shapeType; // || this.type，都已经加了 shapeType\r\n\r\n    var style = this.getShapeStyle(cfg);\r\n    var shape = group.addShape(shapeType, {\r\n      attrs: style,\r\n      draggable: true,\r\n      name: 'combo-shape'\r\n    });\r\n    return shape;\r\n  },\r\n  updateShape: function updateShape(cfg, item, keyShapeStyle) {\r\n    var keyShape = item.get('keyShape');\r\n    var animate = cfg.animate === undefined ? this.options.animate : cfg.animate;\r\n\r\n    if (animate && keyShape.animate) {\r\n      keyShape.animate(keyShapeStyle, {\r\n        duration: 200,\r\n        easing: 'easeLinear'\r\n      });\r\n    } else {\r\n      keyShape.attr((0, _tslib.__assign)({}, keyShapeStyle));\r\n    }\r\n\r\n    this.updateLabel(cfg, item); // special for some types of nodes\r\n  }\r\n};\r\nvar singleComboDef = (0, _tslib.__assign)((0, _tslib.__assign)({}, _shapeBase.shapeBase), singleCombo);\r\n\r\n_shape.default.registerCombo('single-combo', singleComboDef);","\r\n\r\nrequire(\"./circle\");\r\n\r\nrequire(\"./rect\");","\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _global = _interopRequireDefault(require(\"../../global\"));\r\n\r\nvar _shape = _interopRequireDefault(require(\"../shape\"));\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n// 圆形 Combo\r\n_shape.default.registerCombo('circle', {\r\n  // 自定义节点时的配置\r\n  options: {\r\n    size: [_global.default.defaultCombo.size[0], _global.default.defaultCombo.size[0]],\r\n    padding: _global.default.defaultCombo.padding[0],\r\n    animate: true,\r\n    style: {\r\n      stroke: _global.default.defaultCombo.style.stroke,\r\n      fill: _global.default.defaultCombo.style.fill,\r\n      lineWidth: _global.default.defaultCombo.style.lineWidth\r\n    },\r\n    labelCfg: {\r\n      style: {\r\n        fill: _global.default.comboLabel.style.fill,\r\n        fontSize: _global.default.comboLabel.style.fontSize\r\n      },\r\n      refX: 0,\r\n      refY: 0\r\n    },\r\n    stateStyles: (0, _tslib.__assign)({}, _global.default.comboStateStyles)\r\n  },\r\n  shapeType: 'circle',\r\n  // 文本位置\r\n  labelPosition: 'top',\r\n  drawShape: function drawShape(cfg, group) {\r\n    var style = this.getShapeStyle(cfg);\r\n    delete style.height;\r\n    delete style.width;\r\n    var keyShape = group.addShape('circle', {\r\n      attrs: style,\r\n      className: 'circle-combo',\r\n      name: 'circle-combo',\r\n      draggable: true\r\n    });\r\n    return keyShape;\r\n  },\r\n\r\n  /**\r\n   * 获取 Combo 的样式，供基于该 Combo 自定义时使用\r\n   * @param {Object} cfg Combo 数据模型\r\n   * @return {Object} Combo 的样式\r\n   */\r\n  getShapeStyle: function getShapeStyle(cfg) {\r\n    var defaultStyle = this.options.style;\r\n    var padding = cfg.padding || this.options.padding;\r\n    if ((0, _util.isArray)(padding)) padding = padding[0];\r\n    var strokeStyle = {\r\n      stroke: cfg.color\r\n    }; // 如果设置了color，则覆盖默认的stroke属性\r\n\r\n    var style = (0, _util.mix)({}, defaultStyle, strokeStyle, cfg.style);\r\n    var r;\r\n\r\n    if (cfg.fixSize) {\r\n      r = (0, _util.isNumber)(cfg.fixSize) ? cfg.fixSize : cfg.fixSize[0];\r\n    } else {\r\n      var size = this.getSize(cfg);\r\n      if (!(0, _util.isNumber)(style.r) || isNaN(style.r)) r = size[0] / 2 || _global.default.defaultCombo.style.r;else r = Math.max(style.r, size[0] / 2) || size[0] / 2;\r\n    }\r\n\r\n    style.r = r + padding;\r\n    var styles = (0, _tslib.__assign)({\r\n      x: 0,\r\n      y: 0\r\n    }, style);\r\n    if (cfg.style) cfg.style.r = r;else {\r\n      cfg.style = {\r\n        r: r\r\n      };\r\n    }\r\n    return styles;\r\n  },\r\n  update: function update(cfg, item) {\r\n    var size = this.getSize(cfg);\r\n    var padding = cfg.padding || this.options.padding;\r\n    if ((0, _util.isArray)(padding)) padding = padding[0];\r\n    var cfgStyle = (0, _util.clone)(cfg.style);\r\n    var r;\r\n\r\n    if (cfg.fixSize) {\r\n      r = (0, _util.isNumber)(cfg.fixSize) ? cfg.fixSize : cfg.fixSize[0];\r\n    } else {\r\n      r = Math.max(cfgStyle.r, size[0] / 2) || size[0] / 2;\r\n    }\r\n\r\n    cfgStyle.r = r + padding;\r\n    var itemCacheSize = item.get('sizeCache');\r\n\r\n    if (itemCacheSize) {\r\n      itemCacheSize.r = cfgStyle.r;\r\n    } // 下面这些属性需要覆盖默认样式与目前样式，但若在 cfg 中有指定则应该被 cfg 的相应配置覆盖。\r\n\r\n\r\n    var strokeStyle = {\r\n      stroke: cfg.color\r\n    }; // 与 getShapeStyle 不同在于，update 时需要获取到当前的 style 进行融合。即新传入的配置项中没有涉及的属性，保留当前的配置。\r\n\r\n    var keyShape = item.get('keyShape');\r\n    var style = (0, _util.mix)({}, keyShape.attr(), strokeStyle, cfgStyle);\r\n    if (cfg.style) cfg.style.r = r;else {\r\n      cfg.style = {\r\n        r: r\r\n      };\r\n    }\r\n    this.updateShape(cfg, item, style, true);\r\n  }\r\n}, 'single-combo');","\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _global = _interopRequireDefault(require(\"../../global\"));\r\n\r\nvar _shape = _interopRequireDefault(require(\"../shape\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n_shape.default.registerCombo('rect', {\r\n  // 自定义 Combo 时的配置\r\n  options: {\r\n    size: [40, 5],\r\n    padding: [25, 20, 15, 20],\r\n    animate: true,\r\n    style: {\r\n      radius: 0,\r\n      stroke: _global.default.defaultCombo.style.stroke,\r\n      fill: _global.default.defaultCombo.style.fill,\r\n      lineWidth: _global.default.defaultCombo.style.lineWidth\r\n    },\r\n    // 文本样式配置\r\n    labelCfg: {\r\n      style: {\r\n        fill: _global.default.comboLabel.style.fill,\r\n        fontSize: _global.default.comboLabel.style.fontSize\r\n      }\r\n    },\r\n    // 连接点，默认为左右\r\n    anchorPoints: [[0, 0.5], [1, 0.5]],\r\n    stateStyles: (0, _tslib.__assign)({}, _global.default.comboStateStyles)\r\n  },\r\n  shapeType: 'rect',\r\n  labelPosition: 'top',\r\n  drawShape: function drawShape(cfg, group) {\r\n    var style = this.getShapeStyle(cfg);\r\n    var keyShape = group.addShape('rect', {\r\n      attrs: style,\r\n      className: 'rect-combo',\r\n      name: 'rect-combo',\r\n      draggable: true\r\n    });\r\n    return keyShape;\r\n  },\r\n  // 私有方法，不希望扩展的 Combo 复写这个方法\r\n  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg) {\r\n    var labelPosition = labelCfg.position || this.labelPosition;\r\n    var cfgStyle = cfg.style;\r\n    var padding = cfg.padding || this.options.padding;\r\n    if ((0, _util.isNumber)(padding)) padding = [padding, padding, padding, padding];\r\n    var refX = labelCfg.refX,\r\n        refY = labelCfg.refY; // 考虑 refX 和 refY = 0 的场景，不用用 labelCfg.refX || Global.nodeLabel.refY\r\n\r\n    if ((0, _util.isNil)(refX)) {\r\n      refX = this.refX; // 不居中时的偏移量\r\n    }\r\n\r\n    if ((0, _util.isNil)(refY)) {\r\n      refY = this.refY; // 不居中时的偏移量\r\n    }\r\n\r\n    var leftDis = cfgStyle.width / 2 + padding[3];\r\n    var topDis = cfgStyle.height / 2 + padding[0];\r\n    var style;\r\n\r\n    switch (labelPosition) {\r\n      case 'top':\r\n        style = {\r\n          x: 0 - leftDis + refX,\r\n          y: 0 - topDis + refY,\r\n          textBaseline: 'top',\r\n          textAlign: 'left'\r\n        };\r\n        break;\r\n\r\n      case 'bottom':\r\n        style = {\r\n          x: 0,\r\n          y: topDis + refY,\r\n          textBaseline: 'bottom',\r\n          textAlign: 'center'\r\n        };\r\n        break;\r\n\r\n      case 'left':\r\n        style = {\r\n          x: 0 - leftDis + refY,\r\n          y: 0,\r\n          textAlign: 'left'\r\n        };\r\n        break;\r\n\r\n      case 'center':\r\n        style = {\r\n          x: 0,\r\n          y: 0,\r\n          text: cfg.label,\r\n          textAlign: 'center'\r\n        };\r\n        break;\r\n\r\n      default:\r\n        style = {\r\n          x: leftDis + refX,\r\n          y: 0,\r\n          textAlign: 'right'\r\n        };\r\n        break;\r\n    }\r\n\r\n    style.text = cfg.label;\r\n    return style;\r\n  },\r\n\r\n  /**\r\n   * 获取节点的样式，供基于该节点自定义时使用\r\n   * @param {Object} cfg 节点数据模型\r\n   * @return {Object} 节点的样式\r\n   */\r\n  getShapeStyle: function getShapeStyle(cfg) {\r\n    var defaultStyle = this.options.style;\r\n    var padding = cfg.padding || this.options.padding;\r\n    if ((0, _util.isNumber)(padding)) padding = [padding, padding, padding, padding];\r\n    var strokeStyle = {\r\n      stroke: cfg.color\r\n    }; // 如果设置了color，则覆盖默认的stroke属性\r\n\r\n    var style = (0, _util.mix)({}, defaultStyle, strokeStyle, cfg.style);\r\n    var size = this.getSize(cfg);\r\n    var width;\r\n    var height;\r\n    var fixSize = cfg.collapsed && cfg.fixCollapseSize ? cfg.fixCollapseSize : cfg.fixSize;\r\n\r\n    if (fixSize) {\r\n      if ((0, _util.isNumber)(fixSize)) {\r\n        width = fixSize;\r\n        height = fixSize;\r\n      } else {\r\n        width = fixSize[0];\r\n        height = fixSize[1];\r\n      }\r\n    } else {\r\n      if (!(0, _util.isNumber)(style.width) || isNaN(style.width)) width = size[0] || _global.default.defaultCombo.style.width;else width = Math.max(style.width, size[0]) || size[0];\r\n      if (!(0, _util.isNumber)(style.height) || isNaN(style.height)) height = size[1] || _global.default.defaultCombo.style.height;else height = Math.max(style.height, size[1]) || size[1];\r\n    }\r\n\r\n    var x = -width / 2 - padding[3];\r\n    var y = -height / 2 - padding[0];\r\n    style.width = width + padding[1] + padding[3];\r\n    style.height = height + padding[0] + padding[2];\r\n    var styles = (0, _tslib.__assign)({\r\n      x: x,\r\n      y: y\r\n    }, style);\r\n\r\n    if (!cfg.style) {\r\n      cfg.style = {\r\n        width: width,\r\n        height: height\r\n      };\r\n    } else {\r\n      cfg.style.width = width;\r\n      cfg.style.height = height;\r\n    }\r\n\r\n    return styles;\r\n  },\r\n  update: function update(cfg, item) {\r\n    var size = this.getSize(cfg);\r\n    var padding = cfg.padding || this.options.padding;\r\n    if ((0, _util.isNumber)(padding)) padding = [padding, padding, padding, padding];\r\n    var cfgStyle = (0, _util.clone)(cfg.style);\r\n    var width, height;\r\n    var fixSize = cfg.collapsed && cfg.fixCollapseSize ? cfg.fixCollapseSize : cfg.fixSize;\r\n\r\n    if (fixSize) {\r\n      if ((0, _util.isNumber)(fixSize)) {\r\n        width = fixSize;\r\n        height = fixSize;\r\n      } else {\r\n        width = fixSize[0];\r\n        height = fixSize[1];\r\n      }\r\n    } else {\r\n      width = Math.max(cfgStyle.width, size[0]) || size[0];\r\n      height = Math.max(cfgStyle.height, size[1]) || size[1];\r\n    }\r\n\r\n    cfgStyle.width = width + padding[1] + padding[3];\r\n    cfgStyle.height = height + padding[0] + padding[2];\r\n    var itemCacheSize = item.get('sizeCache');\r\n\r\n    if (itemCacheSize) {\r\n      itemCacheSize.width = cfgStyle.width;\r\n      itemCacheSize.height = cfgStyle.height;\r\n    }\r\n\r\n    cfgStyle.x = -width / 2 - padding[3];\r\n    cfgStyle.y = -height / 2 - padding[0]; // 下面这些属性需要覆盖默认样式与目前样式，但若在 cfg 中有指定则应该被 cfg 的相应配置覆盖。\r\n\r\n    var strokeStyle = {\r\n      stroke: cfg.color\r\n    }; // 与 getShapeStyle 不同在于，update 时需要获取到当前的 style 进行融合。即新传入的配置项中没有涉及的属性，保留当前的配置。\r\n\r\n    var keyShape = item.get('keyShape');\r\n    var style = (0, _util.mix)({}, keyShape.attr(), strokeStyle, cfgStyle);\r\n\r\n    if (cfg.style) {\r\n      cfg.style.width = width;\r\n      cfg.style.height = height;\r\n    } else {\r\n      cfg.style = {\r\n        width: width,\r\n        height: height\r\n      };\r\n    }\r\n\r\n    this.updateShape(cfg, item, style, false);\r\n  },\r\n  updateShape: function updateShape(cfg, item, keyShapeStyle) {\r\n    var keyShape = item.get('keyShape');\r\n    var animate = cfg.animate === undefined ? this.options.animate : cfg.animate;\r\n\r\n    if (animate && keyShape.animate) {\r\n      keyShape.animate(keyShapeStyle, {\r\n        duration: 200,\r\n        easing: 'easeLinear'\r\n      });\r\n    } else {\r\n      keyShape.attr((0, _tslib.__assign)({}, keyShapeStyle));\r\n    }\r\n\r\n    this.updateLabel(cfg, item);\r\n  }\r\n}, 'single-combo');","\r\n\r\nrequire(\"./simple-circle\");\r\n\r\nrequire(\"./simple-rect\");\r\n\r\nrequire(\"./image\");","\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _global = _interopRequireDefault(require(\"../../global\"));\r\n\r\nvar _shape = _interopRequireDefault(require(\"../shape\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n// 带有图标的圆，可用于拓扑图中\r\n_shape.default.registerNode('simple-circle', {\r\n  // 自定义节点时的配置\r\n  options: {\r\n    size: _global.default.defaultNode.size,\r\n    style: {\r\n      x: 0,\r\n      y: 0,\r\n      stroke: _global.default.defaultNode.style.stroke,\r\n      fill: _global.default.defaultNode.style.fill,\r\n      lineWidth: _global.default.defaultNode.style.lineWidth\r\n    },\r\n    labelCfg: {\r\n      style: {\r\n        fill: _global.default.nodeLabel.style.fill,\r\n        fontSize: _global.default.nodeLabel.style.fontSize\r\n      }\r\n    },\r\n    stateStyles: (0, _tslib.__assign)({}, _global.default.nodeStateStyles)\r\n  },\r\n  shapeType: 'simple-circle',\r\n  // 文本位置\r\n  labelPosition: 'center',\r\n  drawShape: function drawShape(cfg, group) {\r\n    var style = this.getShapeStyle(cfg);\r\n    var keyShape = group.addShape('circle', {\r\n      attrs: style,\r\n      className: this.type + \"-keyShape\",\r\n      draggable: true\r\n    });\r\n    return keyShape;\r\n  },\r\n\r\n  /**\r\n   * 获取节点的样式，供基于该节点自定义时使用\r\n   * @param {Object} cfg 节点数据模型\r\n   * @return {Object} 节点的样式\r\n   */\r\n  getShapeStyle: function getShapeStyle(cfg) {\r\n    var defaultStyle = this.getOptions(cfg).style;\r\n    var strokeStyle = {\r\n      stroke: cfg.color\r\n    }; // 如果设置了color，则覆盖默认的stroke属性\r\n\r\n    var style = (0, _util.deepMix)({}, defaultStyle, strokeStyle);\r\n    var size = this.getSize(cfg);\r\n    var r = size[0] / 2;\r\n    var styles = (0, _tslib.__assign)({\r\n      x: 0,\r\n      y: 0,\r\n      r: r\r\n    }, style);\r\n    return styles;\r\n  },\r\n  update: function update(cfg, item) {\r\n    var size = this.getSize(cfg); // 下面这些属性需要覆盖默认样式与目前样式，但若在 cfg 中有指定则应该被 cfg 的相应配置覆盖。\r\n\r\n    var strokeStyle = {\r\n      stroke: cfg.color,\r\n      r: size[0] / 2\r\n    }; // 与 getShapeStyle 不同在于，update 时需要获取到当前的 style 进行融合。即新传入的配置项中没有涉及的属性，保留当前的配置。\r\n\r\n    var keyShape = item.get('keyShape');\r\n    var style = (0, _util.deepMix)({}, keyShape.attr(), strokeStyle, cfg.style);\r\n    this.updateShape(cfg, item, style, true);\r\n  }\r\n}, 'single-node');","\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _global = _interopRequireDefault(require(\"../../global\"));\r\n\r\nvar _shape = _interopRequireDefault(require(\"../shape\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n_shape.default.registerNode('simple-rect', {\r\n  // 自定义节点时的配置\r\n  options: {\r\n    size: [100, 30],\r\n    style: {\r\n      radius: 0,\r\n      stroke: _global.default.defaultNode.style.stroke,\r\n      fill: _global.default.defaultNode.style.fill,\r\n      lineWidth: _global.default.defaultNode.style.lineWidth\r\n    },\r\n    // 文本样式配置\r\n    labelCfg: {\r\n      style: {\r\n        fill: _global.default.nodeLabel.style.fill,\r\n        fontSize: _global.default.nodeLabel.style.fontSize\r\n      }\r\n    },\r\n    // 连接点，默认为左右\r\n    // anchorPoints: [{ x: 0, y: 0.5 }, { x: 1, y: 0.5 }]\r\n    anchorPoints: [[0, 0.5], [1, 0.5]],\r\n    stateStyles: (0, _tslib.__assign)({}, _global.default.nodeStateStyles)\r\n  },\r\n  shapeType: 'simple-rect',\r\n  labelPosition: 'center',\r\n  drawShape: function drawShape(cfg, group) {\r\n    var style = this.getShapeStyle(cfg);\r\n    var keyShape = group.addShape('rect', {\r\n      attrs: style,\r\n      className: this.type + \"-keyShape\",\r\n      name: this.type + \"-keyShape\",\r\n      draggable: true\r\n    });\r\n    return keyShape;\r\n  },\r\n\r\n  /**\r\n   * 获取节点的样式，供基于该节点自定义时使用\r\n   * @param {Object} cfg 节点数据模型\r\n   * @return {Object} 节点的样式\r\n   */\r\n  getShapeStyle: function getShapeStyle(cfg) {\r\n    var defaultStyle = this.getOptions(cfg).style;\r\n    var strokeStyle = {\r\n      stroke: cfg.color\r\n    }; // 如果设置了color，则覆盖默认的stroke属性\r\n\r\n    var style = (0, _util.mix)({}, defaultStyle, strokeStyle);\r\n    var size = this.getSize(cfg);\r\n    var width = style.width || size[0];\r\n    var height = style.height || size[1];\r\n    var styles = (0, _tslib.__assign)({\r\n      x: -width / 2,\r\n      y: -height / 2,\r\n      width: width,\r\n      height: height\r\n    }, style);\r\n    return styles;\r\n  },\r\n  update: function update(cfg, item) {\r\n    var group = item.getContainer(); // 这里不传 cfg 参数是因为 cfg.style 需要最后覆盖样式\r\n\r\n    var defaultStyle = this.getOptions({}).style;\r\n    var size = this.getSize(cfg);\r\n    var keyShape = item.get('keyShape');\r\n\r\n    if (!cfg.size) {\r\n      size[0] = keyShape.attr('width') || defaultStyle.width;\r\n      size[1] = keyShape.attr('height') || defaultStyle.height;\r\n    } // 下面这些属性需要覆盖默认样式与目前样式，但若在 cfg 中有指定则应该被 cfg 的相应配置覆盖。\r\n\r\n\r\n    var strokeStyle = {\r\n      stroke: cfg.color,\r\n      x: -size[0] / 2,\r\n      y: -size[1] / 2,\r\n      width: size[0],\r\n      height: size[1]\r\n    }; // 与 getShapeStyle 不同在于，update 时需要获取到当前的 style 进行融合。即新传入的配置项中没有涉及的属性，保留当前的配置。\r\n\r\n    var style = (0, _util.mix)({}, defaultStyle, keyShape.attr(), strokeStyle);\r\n    style = (0, _util.mix)(style, cfg.style);\r\n    this.updateShape(cfg, item, style, false);\r\n  }\r\n}, 'single-node');","\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _shape = _interopRequireDefault(require(\"../shape\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n/**\r\n * 基本的图片，可以添加文本，默认文本在图片的下面\r\n */\r\n_shape.default.registerNode('image', {\r\n  options: {\r\n    img: 'https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*eD7nT6tmYgAAAAAAAAAAAABkARQnAQ',\r\n    size: 200,\r\n    clipCfg: {\r\n      show: false,\r\n      type: 'circle',\r\n      // circle\r\n      r: 50,\r\n      // ellipse\r\n      rx: 50,\r\n      ry: 35,\r\n      // rect\r\n      width: 50,\r\n      height: 35,\r\n      // polygon\r\n      points: [[30, 12], [12, 30], [30, 48], [48, 30]],\r\n      // path\r\n      path: [['M', 25, 25], ['L', 50, 25], ['A', 12.5, 12.5, 0, 1, 1, 50, 50], ['A', 12.5, 12.5, 0, 1, 0, 50, 50], ['L', 25, 75], ['Z']],\r\n      // 坐标\r\n      x: 0,\r\n      y: 0 // clip 的属性样式\r\n      // style: {\r\n      //   lineWidth: 1\r\n      // },\r\n\r\n    }\r\n  },\r\n  shapeType: 'image',\r\n  labelPosition: 'bottom',\r\n  drawShape: function drawShape(cfg, group) {\r\n    var shapeType = this.shapeType; // || this.type，都已经加了 shapeType\r\n\r\n    var style = this.getShapeStyle(cfg);\r\n    delete style.fill;\r\n    var shape = group.addShape(shapeType, {\r\n      attrs: style,\r\n      className: this.type + \"-keyShape\",\r\n      name: this.type + \"-keyShape\",\r\n      draggable: true\r\n    });\r\n    this.drawClip(cfg, shape);\r\n    return shape;\r\n  },\r\n  drawClip: function drawClip(cfg, shape) {\r\n    var clip = this.getOptions(cfg).clipCfg;\r\n\r\n    if (!clip.show) {\r\n      return;\r\n    } // 支持 circle、rect、ellipse、Polygon 及自定义 path clip\r\n\r\n\r\n    var type = clip.type,\r\n        x = clip.x,\r\n        y = clip.y,\r\n        style = clip.style;\r\n\r\n    if (type === 'circle') {\r\n      var r = clip.r;\r\n      shape.setClip({\r\n        type: 'circle',\r\n        attrs: (0, _tslib.__assign)({\r\n          r: r,\r\n          x: x,\r\n          y: y\r\n        }, style)\r\n      });\r\n    } else if (type === 'rect') {\r\n      var width = clip.width,\r\n          height = clip.height;\r\n      var rectX = x - width / 2;\r\n      var rectY = y - height / 2;\r\n      shape.setClip({\r\n        type: 'rect',\r\n        attrs: (0, _tslib.__assign)({\r\n          x: rectX,\r\n          y: rectY,\r\n          width: width,\r\n          height: height\r\n        }, style)\r\n      });\r\n    } else if (type === 'ellipse') {\r\n      var rx = clip.rx,\r\n          ry = clip.ry;\r\n      shape.setClip({\r\n        type: 'ellipse',\r\n        attrs: (0, _tslib.__assign)({\r\n          x: x,\r\n          y: y,\r\n          rx: rx,\r\n          ry: ry\r\n        }, style)\r\n      });\r\n    } else if (type === 'polygon') {\r\n      var points = clip.points;\r\n      shape.setClip({\r\n        type: 'polygon',\r\n        attrs: (0, _tslib.__assign)({\r\n          points: points\r\n        }, style)\r\n      });\r\n    } else if (type === 'path') {\r\n      var path = clip.path;\r\n      shape.setClip({\r\n        type: 'path',\r\n        attrs: (0, _tslib.__assign)({\r\n          path: path\r\n        }, style)\r\n      });\r\n    }\r\n  },\r\n  getShapeStyle: function getShapeStyle(cfg) {\r\n    var defaultStyle = this.getOptions(cfg).style;\r\n    var size = this.getSize(cfg);\r\n    var img = this.getOptions(cfg).img;\r\n    var width = size[0];\r\n    var height = size[1];\r\n\r\n    if (defaultStyle) {\r\n      width = defaultStyle.width || size[0];\r\n      height = defaultStyle.height || size[1];\r\n    }\r\n\r\n    var style = (0, _tslib.__assign)({\r\n      x: -width / 2,\r\n      y: -height / 2,\r\n      width: width,\r\n      height: height,\r\n      img: img\r\n    }, defaultStyle);\r\n    return style;\r\n  },\r\n  updateShapeStyle: function updateShapeStyle(cfg, item) {\r\n    var group = item.getContainer();\r\n    var shapeClassName = this.itemType + \"-shape\";\r\n    var shape = group.find(function (element) {\r\n      return element.get('className') === shapeClassName;\r\n    }) || item.getKeyShape();\r\n    var shapeStyle = this.getShapeStyle(cfg);\r\n\r\n    if (shape) {\r\n      shape.attr(shapeStyle);\r\n    }\r\n  }\r\n}, 'single-node');","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\nvar _default = {\r\n  triangle: function triangle(width, length, d) {\r\n    if (width === void 0) {\r\n      width = 10;\r\n    }\r\n\r\n    if (length === void 0) {\r\n      length = 15;\r\n    }\r\n\r\n    if (d === void 0) {\r\n      d = 0;\r\n    }\r\n\r\n    var begin = d * 2;\r\n    var path = \"M \" + begin + \",0 L \" + (begin + length) + \",-\" + width / 2 + \" L \" + (begin + length) + \",\" + width / 2 + \" Z\";\r\n    return path;\r\n  },\r\n  vee: function vee(width, length, d) {\r\n    if (width === void 0) {\r\n      width = 15;\r\n    }\r\n\r\n    if (length === void 0) {\r\n      length = 20;\r\n    }\r\n\r\n    if (d === void 0) {\r\n      d = 0;\r\n    }\r\n\r\n    var begin = d * 2;\r\n    var path = \"M \" + begin + \",0 L \" + (begin + length) + \",-\" + width / 2 + \"\\n        L \" + (begin + 2 * length / 3) + \",0 L \" + (begin + length) + \",\" + width / 2 + \" Z\";\r\n    return path;\r\n  },\r\n  circle: function circle(r, d) {\r\n    if (r === void 0) {\r\n      r = 5;\r\n    }\r\n\r\n    if (d === void 0) {\r\n      d = 0;\r\n    }\r\n\r\n    var begin = d * 2;\r\n    var path = \"M \" + begin + \", 0\\n            a \" + r + \",\" + r + \" 0 1,0 \" + r * 2 + \",0\\n            a \" + r + \",\" + r + \" 0 1,0 \" + -r * 2 + \",0\";\r\n    return path;\r\n  },\r\n  rect: function rect(width, length, d) {\r\n    if (width === void 0) {\r\n      width = 10;\r\n    }\r\n\r\n    if (length === void 0) {\r\n      length = 10;\r\n    }\r\n\r\n    if (d === void 0) {\r\n      d = 0;\r\n    }\r\n\r\n    var begin = d * 2;\r\n    var path = \"M \" + begin + \",\" + -width / 2 + \" \\n        L \" + (begin + length) + \",\" + -width / 2 + \" \\n        L \" + (begin + length) + \",\" + width / 2 + \" \\n        L \" + begin + \",\" + width / 2 + \" Z\";\r\n    return path;\r\n  },\r\n  diamond: function diamond(width, length, d) {\r\n    if (width === void 0) {\r\n      width = 15;\r\n    }\r\n\r\n    if (length === void 0) {\r\n      length = 15;\r\n    }\r\n\r\n    if (d === void 0) {\r\n      d = 0;\r\n    }\r\n\r\n    var begin = d * 2;\r\n    var path = \"M \" + begin + \",0 \\n        L \" + (begin + length / 2) + \",\" + -width / 2 + \" \\n        L \" + (begin + length) + \",0 \\n        L \" + (begin + length / 2) + \",\" + width / 2 + \" Z\";\r\n    return path;\r\n  },\r\n  triangleRect: function triangleRect(tWidth, tLength, rWidth, rLength, gap, d) {\r\n    if (tWidth === void 0) {\r\n      tWidth = 15;\r\n    }\r\n\r\n    if (tLength === void 0) {\r\n      tLength = 15;\r\n    }\r\n\r\n    if (rWidth === void 0) {\r\n      rWidth = 15;\r\n    }\r\n\r\n    if (rLength === void 0) {\r\n      rLength = 3;\r\n    }\r\n\r\n    if (gap === void 0) {\r\n      gap = 5;\r\n    }\r\n\r\n    if (d === void 0) {\r\n      d = 0;\r\n    }\r\n\r\n    var begin = d * 2;\r\n    var rectBegin = begin + tLength + gap;\r\n    var path = \"M \" + begin + \",0 L \" + (begin + tLength) + \",-\" + tWidth / 2 + \" L \" + (begin + tLength) + \",\" + tWidth / 2 + \" Z\\n            M \" + rectBegin + \", -\" + rWidth / 2 + \"\\n            L \" + (rectBegin + rLength) + \" -\" + rWidth / 2 + \"\\n            L \" + (rectBegin + rLength) + \" \" + rWidth / 2 + \"\\n            L \" + rectBegin + \" \" + rWidth / 2 + \"\\n            Z\";\r\n    return path;\r\n  }\r\n};\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\nvar _default = {\r\n  collapse: function collapse(x, y, r) {\r\n    return [['M', x - r, y], ['a', r, r, 0, 1, 0, r * 2, 0], ['a', r, r, 0, 1, 0, -r * 2, 0], ['M', x - r + 4, y], ['L', x + r - 4, y]];\r\n  },\r\n  expand: function expand(x, y, r) {\r\n    return [['M', x - r, y], ['a', r, r, 0, 1, 0, r * 2, 0], ['a', r, r, 0, 1, 0, -r * 2, 0], ['M', x - r + 4, y], ['L', x - r + 2 * r - 4, y], ['M', x - r + r, y - r + 4], ['L', x, y + r - 4]];\r\n  },\r\n  upTriangle: function upTriangle(x, y, r) {\r\n    var l1 = r * Math.cos(Math.PI / 6);\r\n    var l2 = r * Math.sin(Math.PI / 6);\r\n    return [['M', x - l1, y + l2], ['L', x + l1, y + l2], ['L', x, y - r], ['Z']];\r\n  },\r\n  downTriangle: function downTriangle(x, y, r) {\r\n    var l1 = r * Math.cos(Math.PI / 6);\r\n    var l2 = r * Math.sin(Math.PI / 6);\r\n    return [['M', x - l1, y - l2], ['L', x + l1, y - l2], ['L', x, y + r], ['Z']];\r\n  }\r\n};\r\nexports.default = _default;","\r\n\r\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar MathUtil = _interopRequireWildcard(require(\"./math\"));\r\n\r\nvar GraphicUtil = _interopRequireWildcard(require(\"./graphic\"));\r\n\r\nvar PathUtil = _interopRequireWildcard(require(\"./path\"));\r\n\r\nvar BaseUtil = _interopRequireWildcard(require(\"./base\"));\r\n\r\nvar ColorUtil = _interopRequireWildcard(require(\"./color\"));\r\n\r\nvar _matrixUtil = require(\"@antv/matrix-util\");\r\n\r\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\r\n\r\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\r\n\r\nvar transform = _matrixUtil.ext.transform;\r\nvar Util = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, BaseUtil), GraphicUtil), PathUtil), MathUtil), ColorUtil), {\r\n  transform: transform,\r\n  mat3: _matrixUtil.mat3\r\n});\r\nvar _default = Util;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.defaultSubjectColors = void 0;\r\nvar defaultSubjectColors = ['#5F95FF', '#61DDAA', '#65789B', '#F6BD16', '#7262FD', '#78D3F8', '#9661BC', '#F6903D', '#008685', '#F08BB4'];\r\nexports.defaultSubjectColors = defaultSubjectColors;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar _tslib = require(\"tslib\");\r\n\r\nvar _util = require(\"@antv/util\");\r\n\r\nvar _base = require(\"../../util/base\");\r\n\r\nvar LayoutController =\r\n/** @class */\r\nfunction () {\r\n  function LayoutController(graph) {\r\n    this.graph = graph;\r\n    this.layoutCfg = graph.get('layout') || {};\r\n    this.layoutType = this.getLayoutType();\r\n    this.layoutMethods = [];\r\n    this.initLayout();\r\n  } // eslint-disable-next-line class-methods-use-this\r\n\r\n\r\n  LayoutController.prototype.initLayout = function () {// no data before rendering\r\n  };\r\n\r\n  LayoutController.prototype.getLayoutType = function () {\r\n    return this.getLayoutCfgType(this.layoutCfg);\r\n  };\r\n\r\n  LayoutController.prototype.getLayoutCfgType = function (layoutCfg) {\r\n    var type = layoutCfg.type; // type should be top priority\r\n\r\n    if (type) {\r\n      return type;\r\n    }\r\n\r\n    var pipes = layoutCfg.pipes;\r\n\r\n    if (Array.isArray(pipes)) {\r\n      return pipes.map(function (pipe) {\r\n        return (pipe === null || pipe === void 0 ? void 0 : pipe.type) || '';\r\n      });\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  LayoutController.prototype.isLayoutTypeSame = function (cfg) {\r\n    var current = this.getLayoutCfgType(cfg); // already has pipes\r\n\r\n    if (Array.isArray(this.layoutType)) {\r\n      return this.layoutType.every(function (type, index) {\r\n        return type === current[index];\r\n      });\r\n    }\r\n\r\n    return (cfg === null || cfg === void 0 ? void 0 : cfg.type) === this.layoutType;\r\n  }; // 绘制\r\n\r\n\r\n  LayoutController.prototype.refreshLayout = function () {\r\n    var graph = this.graph;\r\n    if (!graph) return;\r\n\r\n    if (graph.get('animate')) {\r\n      graph.positionsAnimate();\r\n    } else {\r\n      graph.refreshPositions();\r\n    }\r\n  }; // 更换布局\r\n\r\n\r\n  LayoutController.prototype.changeLayout = function (cfg) {\r\n    this.layoutCfg = cfg;\r\n    this.destoryLayoutMethods();\r\n    this.layout();\r\n  }; // 更换数据\r\n\r\n\r\n  LayoutController.prototype.changeData = function () {\r\n    this.destoryLayoutMethods();\r\n    this.layout();\r\n  };\r\n\r\n  LayoutController.prototype.destoryLayoutMethods = function () {\r\n    var layoutMethods = this.layoutMethods;\r\n    layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.forEach(function (layoutMethod) {\r\n      layoutMethod.destroy();\r\n    });\r\n    this.layoutMethods = [];\r\n  }; // 销毁布局，不能使用 this.destroy，因为 controller 还需要被使用，只是把布局算法销毁\r\n\r\n\r\n  LayoutController.prototype.destroyLayout = function () {\r\n    var graph = this.graph;\r\n    this.destoryLayoutMethods();\r\n    graph.set('layout', undefined);\r\n    this.layoutCfg = undefined;\r\n    this.layoutType = undefined;\r\n    this.layoutMethods = undefined;\r\n  }; // 从 this.graph 获取数据\r\n\r\n\r\n  LayoutController.prototype.setDataFromGraph = function () {\r\n    var nodes = [];\r\n    var hiddenNodes = [];\r\n    var edges = [];\r\n    var hiddenEdges = [];\r\n    var comboEdges = [];\r\n    var combos = [];\r\n    var hiddenCombos = [];\r\n    var nodeItems = this.graph.getNodes();\r\n    var edgeItems = this.graph.getEdges();\r\n    var comboItems = this.graph.getCombos();\r\n    var nodeLength = nodeItems.length;\r\n\r\n    for (var i = 0; i < nodeLength; i++) {\r\n      var nodeItem = nodeItems[i];\r\n      if (!nodeItem || nodeItem.destroyed) continue;\r\n      var model = nodeItem.getModel();\r\n\r\n      if (!nodeItem.isVisible()) {\r\n        hiddenNodes.push(model);\r\n        continue;\r\n      }\r\n\r\n      nodes.push(model);\r\n    }\r\n\r\n    var edgeLength = edgeItems.length;\r\n\r\n    for (var i = 0; i < edgeLength; i++) {\r\n      var edgeItem = edgeItems[i];\r\n      if (!edgeItem || edgeItem.destroyed) continue;\r\n      var model = edgeItem.getModel();\r\n\r\n      if (!edgeItem.isVisible()) {\r\n        hiddenEdges.push(model);\r\n        continue;\r\n      }\r\n\r\n      if (!model.isComboEdge) edges.push(model);else comboEdges.push(model);\r\n    }\r\n\r\n    var comboLength = comboItems.length;\r\n\r\n    for (var i = 0; i < comboLength; i++) {\r\n      var comboItem = comboItems[i];\r\n      if (comboItem.destroyed) continue;\r\n      var model = comboItem.getModel();\r\n\r\n      if (!comboItem.isVisible()) {\r\n        hiddenEdges.push(model);\r\n        continue;\r\n      }\r\n\r\n      combos.push(model);\r\n    }\r\n\r\n    return {\r\n      nodes: nodes,\r\n      hiddenNodes: hiddenNodes,\r\n      edges: edges,\r\n      hiddenEdges: hiddenEdges,\r\n      combos: combos,\r\n      hiddenCombos: hiddenCombos,\r\n      comboEdges: comboEdges\r\n    };\r\n  };\r\n\r\n  LayoutController.prototype.reLayoutMethod = function (layoutMethod, layoutCfg) {\r\n    var _this = this;\r\n\r\n    return new Promise(function (reslove, reject) {\r\n      var graph = _this.graph;\r\n      var layoutType = layoutCfg === null || layoutCfg === void 0 ? void 0 : layoutCfg.type; // 每个布局方法都需要注册\r\n\r\n      layoutCfg.onLayoutEnd = function () {\r\n        graph.emit('aftersublayout', {\r\n          type: layoutType\r\n        });\r\n        reslove();\r\n      };\r\n\r\n      layoutMethod.init(_this.data);\r\n\r\n      if (layoutType === 'force') {\r\n        layoutMethod.ticking = false;\r\n        layoutMethod.forceSimulation.stop();\r\n      }\r\n\r\n      graph.emit('beforesublayout', {\r\n        type: layoutType\r\n      });\r\n      layoutMethod.execute();\r\n      if (layoutMethod.isCustomLayout && layoutCfg.onLayoutEnd) layoutCfg.onLayoutEnd();\r\n    });\r\n  }; // 重新布局\r\n\r\n\r\n  LayoutController.prototype.relayout = function (reloadData) {\r\n    var _this = this;\r\n\r\n    var _a = this,\r\n        graph = _a.graph,\r\n        layoutMethods = _a.layoutMethods,\r\n        layoutCfg = _a.layoutCfg;\r\n\r\n    if (reloadData) {\r\n      this.data = this.setDataFromGraph();\r\n      var nodes = this.data.nodes;\r\n\r\n      if (!nodes) {\r\n        return false;\r\n      }\r\n\r\n      this.initPositions(layoutCfg.center, nodes);\r\n    }\r\n\r\n    graph.emit('beforelayout');\r\n    var start = Promise.resolve();\r\n    layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.forEach(function (layoutMethod, index) {\r\n      var currentCfg = layoutCfg[index];\r\n      start = start.then(function () {\r\n        return _this.reLayoutMethod(layoutMethod, currentCfg);\r\n      });\r\n    });\r\n    start.then(function () {\r\n      if (layoutCfg.onAllLayoutEnd) layoutCfg.onAllLayoutEnd();\r\n    }).catch(function (error) {\r\n      console.warn('relayout failed', error);\r\n    });\r\n  }; // 筛选参与布局的nodes和edges\r\n\r\n\r\n  LayoutController.prototype.filterLayoutData = function (data, cfg) {\r\n    var nodes = data.nodes,\r\n        edges = data.edges,\r\n        rest = (0, _tslib.__rest)(data, [\"nodes\", \"edges\"]);\r\n\r\n    if (!nodes) {\r\n      return data;\r\n    }\r\n\r\n    var nodesFilter;\r\n    var edegsFilter;\r\n\r\n    if ((0, _util.isFunction)(cfg === null || cfg === void 0 ? void 0 : cfg.nodesFilter)) {\r\n      nodesFilter = cfg.nodesFilter;\r\n    } else {\r\n      nodesFilter = function nodesFilter() {\r\n        return true;\r\n      };\r\n    }\r\n\r\n    if ((0, _util.isFunction)(cfg === null || cfg === void 0 ? void 0 : cfg.edgesFilter)) {\r\n      edegsFilter = cfg.edgesFilter;\r\n    } else {\r\n      var nodesMap_1 = nodes.reduce(function (acc, cur) {\r\n        acc[cur.id] = true;\r\n        return acc;\r\n      }, {});\r\n\r\n      edegsFilter = function edegsFilter(edge) {\r\n        return nodesMap_1[edge.source] && nodesMap_1[edge.target];\r\n      };\r\n    }\r\n\r\n    return (0, _tslib.__assign)({\r\n      nodes: nodes.filter(nodesFilter),\r\n      edges: edges.filter(edegsFilter)\r\n    }, rest);\r\n  };\r\n\r\n  LayoutController.prototype.getLayoutBBox = function (nodes) {\r\n    var graph = this.graph;\r\n    var graphGroupNodes = (0, _util.groupBy)(graph.getNodes(), function (n) {\r\n      return n.getModel().layoutOrder;\r\n    });\r\n    var layoutNodes = Object.values(graphGroupNodes).map(function (value) {\r\n      var bbox = (0, _base.calculationItemsBBox)(value);\r\n      bbox.size = [bbox.width, bbox.height];\r\n      return bbox;\r\n    });\r\n    var groupNodes = Object.values((0, _util.groupBy)(nodes, 'layoutOrder'));\r\n    return {\r\n      groupNodes: groupNodes,\r\n      layoutNodes: layoutNodes\r\n    };\r\n  }; // 控制布局动画\r\n  // eslint-disable-next-line class-methods-use-this\r\n\r\n\r\n  LayoutController.prototype.layoutAnimate = function () {}; // 将当前节点的平均中心移动到原点\r\n\r\n\r\n  LayoutController.prototype.moveToZero = function () {\r\n    var graph = this.graph;\r\n    var data = graph.get('data');\r\n    var nodes = data.nodes;\r\n\r\n    if (nodes[0].x === undefined || nodes[0].x === null || (0, _base.isNaN)(nodes[0].x)) {\r\n      return;\r\n    }\r\n\r\n    var meanCenter = [0, 0];\r\n    var nodeLength = nodes.length;\r\n\r\n    for (var i = 0; i < nodeLength; i++) {\r\n      var node = nodes[i];\r\n      meanCenter[0] += node.x;\r\n      meanCenter[1] += node.y;\r\n    }\r\n\r\n    meanCenter[0] /= nodes.length;\r\n    meanCenter[1] /= nodes.length;\r\n\r\n    for (var i = 0; i < nodeLength; i++) {\r\n      var node = nodes[i];\r\n      node.x -= meanCenter[0];\r\n      node.y -= meanCenter[1];\r\n    }\r\n  }; // 初始化节点到 center 附近\r\n\r\n\r\n  LayoutController.prototype.initPositions = function (center, nodes) {\r\n    var graph = this.graph;\r\n\r\n    if (!nodes) {\r\n      return false;\r\n    }\r\n\r\n    var nodeLength = nodes ? nodes.length : 0;\r\n    if (!nodeLength) return;\r\n    var width = graph.get('width') * 0.85;\r\n    var height = graph.get('height') * 0.85;\r\n    var horiNum = Math.ceil(Math.sqrt(nodeLength) * (width / height));\r\n    var vertiNum = Math.ceil(nodeLength / horiNum);\r\n    var horiGap = width / (horiNum - 1);\r\n    var vertiGap = height / (vertiNum - 1);\r\n    if (!isFinite(horiGap) || !horiGap) horiGap = 0;\r\n    if (!isFinite(vertiGap) || !horiGap) vertiGap = 0;\r\n    var beginX = center[0] - width / 2;\r\n    var beginY = center[1] - height / 2;\r\n    var allHavePos = true;\r\n\r\n    for (var i = 0; i < nodeLength; i++) {\r\n      var node = nodes[i];\r\n\r\n      if ((0, _base.isNaN)(node.x)) {\r\n        allHavePos = false;\r\n        node.x = i % horiNum * horiGap + beginX;\r\n      }\r\n\r\n      if ((0, _base.isNaN)(node.y)) {\r\n        allHavePos = false;\r\n        node.y = Math.floor(i / horiNum) * vertiGap + beginY;\r\n      }\r\n    }\r\n\r\n    return allHavePos;\r\n  };\r\n\r\n  LayoutController.prototype.destroy = function () {\r\n    this.graph = null;\r\n    this.destoryLayoutMethods();\r\n    this.destroyed = true;\r\n  };\r\n\r\n  return LayoutController;\r\n}();\r\n\r\nvar _default = LayoutController;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar EventController =\r\n/** @class */\r\nfunction () {\r\n  function EventController(graph) {\r\n    this.graph = graph;\r\n    this.destroyed = false;\r\n    this.initEvents();\r\n  }\r\n\r\n  return EventController;\r\n}();\r\n\r\nvar _default = EventController;\r\nexports.default = _default;","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nvar _exportNames = {\r\n  G6Event: true\r\n};\r\nexports.G6Event = void 0;\r\n\r\nvar _interface = require(\"../interface\");\r\n\r\nObject.keys(_interface).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\r\n  if (key in exports && exports[key] === _interface[key]) return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function get() {\r\n      return _interface[key];\r\n    }\r\n  });\r\n});\r\n// Behavior type file\r\nvar G6Event;\r\nexports.G6Event = G6Event;\r\n\r\n(function (G6Event) {\r\n  // common events\r\n  G6Event[\"CLICK\"] = \"click\";\r\n  G6Event[\"DBLCLICK\"] = \"dblclick\";\r\n  G6Event[\"MOUSEDOWN\"] = \"mousedown\";\r\n  G6Event[\"MOUDEUP\"] = \"mouseup\";\r\n  G6Event[\"CONTEXTMENU\"] = \"contextmenu\";\r\n  G6Event[\"MOUSEENTER\"] = \"mouseenter\";\r\n  G6Event[\"MOUSEOUT\"] = \"mouseout\";\r\n  G6Event[\"MOUSEOVER\"] = \"mouseover\";\r\n  G6Event[\"MOUSEMOVE\"] = \"mousemove\";\r\n  G6Event[\"MOUSELEAVE\"] = \"mouseleave\";\r\n  G6Event[\"DRAGSTART\"] = \"dragstart\";\r\n  G6Event[\"DRAGEND\"] = \"dragend\";\r\n  G6Event[\"DRAG\"] = \"drag\";\r\n  G6Event[\"DRAGENTER\"] = \"dragenter\";\r\n  G6Event[\"DRAGLEAVE\"] = \"dragleave\";\r\n  G6Event[\"DRAGOVER\"] = \"dragover\";\r\n  G6Event[\"DRAGOUT\"] = \"dragout\";\r\n  G6Event[\"DDROP\"] = \"drop\";\r\n  G6Event[\"KEYUP\"] = \"keyup\";\r\n  G6Event[\"KEYDOWN\"] = \"keydown\";\r\n  G6Event[\"WHEEL\"] = \"wheel\";\r\n  G6Event[\"FOCUS\"] = \"focus\";\r\n  G6Event[\"BLUR\"] = \"blur\"; // touch events\r\n\r\n  G6Event[\"TOUCHSTART\"] = \"touchstart\";\r\n  G6Event[\"TOUCHMOVE\"] = \"touchmove\";\r\n  G6Event[\"TOUCHEND\"] = \"touchend\";\r\n  G6Event[\"CANVAS_TOUCHSTART\"] = \"canvas:touchstart\";\r\n  G6Event[\"CANVAS_TOUCHMOVE\"] = \"canvas:touchmove\";\r\n  G6Event[\"CANVAS_TOUCHEND\"] = \"canvas:touchend\";\r\n  G6Event[\"NODE_TOUCHSTART\"] = \"node:touchstart\";\r\n  G6Event[\"NODE_TOUCHMOVE\"] = \"node:touchmove\";\r\n  G6Event[\"NODE_TOUCHEND\"] = \"node:touchend\";\r\n  G6Event[\"COMBO_TOUCHSTART\"] = \"combo:touchstart\";\r\n  G6Event[\"COMBO_TOUCHMOVE\"] = \"combo:touchmove\";\r\n  G6Event[\"COMBO_TOUCHEND\"] = \"combo:touchend\";\r\n  G6Event[\"EDGE_TOUCHSTART\"] = \"edge:touchstart\";\r\n  G6Event[\"EDGE_TOUCHMOVE\"] = \"edge:touchmove\";\r\n  G6Event[\"EDGE_TOUCHEND\"] = \"edge:touchend\"; // node events\r\n\r\n  G6Event[\"NODE_CONTEXTMENU\"] = \"node:contextmenu\";\r\n  G6Event[\"NODE_CLICK\"] = \"node:click\";\r\n  G6Event[\"NODE_DBLCLICK\"] = \"node:dblclick\";\r\n  G6Event[\"NODE_MOUSEDOWN\"] = \"node:mousedown\";\r\n  G6Event[\"NODE_MOUSEUP\"] = \"node:mouseup\";\r\n  G6Event[\"NODE_MOUSEENTER\"] = \"node:mouseenter\";\r\n  G6Event[\"NODE_MOUSELEAVE\"] = \"node:mouseleave\";\r\n  G6Event[\"NODE_MOUSEMOVE\"] = \"node:mousemove\";\r\n  G6Event[\"NODE_MOUSEOUT\"] = \"node:mouseout\";\r\n  G6Event[\"NODE_MOUSEOVER\"] = \"node:mouseover\";\r\n  G6Event[\"NODE_DROP\"] = \"node:drop\";\r\n  G6Event[\"NODE_DRAGOVER\"] = \"node:dragover\";\r\n  G6Event[\"NODE_DRAGENTER\"] = \"node:dragenter\";\r\n  G6Event[\"NODE_DRAGLEAVE\"] = \"node:dragleave\";\r\n  G6Event[\"NODE_DRAGSTART\"] = \"node:dragstart\";\r\n  G6Event[\"NODE_DRAG\"] = \"node:drag\";\r\n  G6Event[\"NODE_DRAGEND\"] = \"node:dragend\";\r\n  G6Event[\"NODE_TAP\"] = \"node:tap\";\r\n  G6Event[\"NODE_PANSTART\"] = \"node:panstart\";\r\n  G6Event[\"NODE_PANMOVE\"] = \"node:panmove\";\r\n  G6Event[\"NODE_PANEND\"] = \"node:panend\"; // combo, extends from nodes\r\n\r\n  G6Event[\"COMBO_CONTEXTMENU\"] = \"combo:contextmenu\";\r\n  G6Event[\"COMBO_CLICK\"] = \"combo:click\";\r\n  G6Event[\"COMBO_DBLCLICK\"] = \"combo:dblclick\";\r\n  G6Event[\"COMBO_MOUSEDOWN\"] = \"combo:mousedown\";\r\n  G6Event[\"COMBO_MOUSEUP\"] = \"combo:mouseup\";\r\n  G6Event[\"COMBO_MOUSEENTER\"] = \"combo:mouseenter\";\r\n  G6Event[\"COMBO_MOUSELEAVE\"] = \"combo:mouseleave\";\r\n  G6Event[\"COMBO_MOUSEMOVE\"] = \"combo:mousemove\";\r\n  G6Event[\"COMBO_MOUSEOUT\"] = \"combo:mouseout\";\r\n  G6Event[\"COMBO_MOUSEOVER\"] = \"combo:mouseover\";\r\n  G6Event[\"COMBO_DROP\"] = \"combo:drop\";\r\n  G6Event[\"COMBO_DRAGOVER\"] = \"combo:dragover\";\r\n  G6Event[\"COMBO_DRAGENTER\"] = \"combo:dragenter\";\r\n  G6Event[\"COMBO_DRAGLEAVE\"] = \"combo:dragleave\";\r\n  G6Event[\"COMBO_DRAGSTART\"] = \"combo:dragstart\";\r\n  G6Event[\"COMBO_DRAG\"] = \"combo:drag\";\r\n  G6Event[\"COMBO_DRAGEND\"] = \"combo:dragend\";\r\n  G6Event[\"COMBO_TAP\"] = \"combo:tap\";\r\n  G6Event[\"COMBO_PANSTART\"] = \"combo:panstart\";\r\n  G6Event[\"COMBO_PANMOVE\"] = \"combo:panmove\";\r\n  G6Event[\"COMBO_PANEND\"] = \"combo:panend\"; // edge events\r\n\r\n  G6Event[\"EDGE_CONTEXTMENU\"] = \"edge:contextmenu\";\r\n  G6Event[\"EDGE_CLICK\"] = \"edge:click\";\r\n  G6Event[\"EDGE_DBLCLICK\"] = \"edge:dblclick\";\r\n  G6Event[\"EDGE_MOUSEDOWN\"] = \"edge:mousedown\";\r\n  G6Event[\"EDGE_MOUSEUP\"] = \"edge:mouseup\";\r\n  G6Event[\"EDGE_MOUSEENTER\"] = \"edge:mouseenter\";\r\n  G6Event[\"EDGE_MOUSELEAVE\"] = \"edge:mouseleave\";\r\n  G6Event[\"EDGE_MOUSEMOVE\"] = \"edge:mousemove\";\r\n  G6Event[\"EDGE_MOUSEOUT\"] = \"edge:mouseout\";\r\n  G6Event[\"EDGE_MOUSEOVER\"] = \"edge:mouseover\";\r\n  G6Event[\"EDGE_DROP\"] = \"edge:drop\";\r\n  G6Event[\"EDGE_DRAGOVER\"] = \"edge:dragover\";\r\n  G6Event[\"EDGE_DRAGENTER\"] = \"edge:dragenter\";\r\n  G6Event[\"EDGE_DRAGLEAVE\"] = \"edge:dragleave\"; // canvas events\r\n\r\n  G6Event[\"CANVAS_CONTEXTMENU\"] = \"canvas:contextmenu\";\r\n  G6Event[\"CANVAS_CLICK\"] = \"canvas:click\";\r\n  G6Event[\"CANVAS_DBLCLICK\"] = \"canvas:dblclick\";\r\n  G6Event[\"CANVAS_MOUSEDOWN\"] = \"canvas:mousedown\";\r\n  G6Event[\"CANVAS_MOUSEUP\"] = \"canvas:mouseup\";\r\n  G6Event[\"CANVAS_MOUSEENTER\"] = \"canvas:mouseenter\";\r\n  G6Event[\"CANVAS_MOUSELEAVE\"] = \"canvas:mouseleave\";\r\n  G6Event[\"CANVAS_MOUSEMOVE\"] = \"canvas:mousemove\";\r\n  G6Event[\"CANVAS_MOUSEOUT\"] = \"canvas:mouseout\";\r\n  G6Event[\"CANVAS_MOUSEOVER\"] = \"canvas:mouseover\";\r\n  G6Event[\"CANVAS_DROP\"] = \"canvas:drop\";\r\n  G6Event[\"CANVAS_DRAGENTER\"] = \"canvas:dragenter\";\r\n  G6Event[\"CANVAS_DRAGLEAVE\"] = \"canvas:dragleave\";\r\n  G6Event[\"CANVAS_DRAGSTART\"] = \"canvas:dragstart\";\r\n  G6Event[\"CANVAS_DRAG\"] = \"canvas:drag\";\r\n  G6Event[\"CANVAS_DRAGEND\"] = \"canvas:dragend\";\r\n  G6Event[\"CANVAS_TAP\"] = \"canvas:tap\";\r\n  G6Event[\"CANVAS_PANSTART\"] = \"canvas:panstart\";\r\n  G6Event[\"CANVAS_PANMOVE\"] = \"canvas:panmove\";\r\n  G6Event[\"CANVAS_PANEND\"] = \"canvas:panend\"; // timing events\r\n\r\n  G6Event[\"BEFORERENDER\"] = \"beforerender\";\r\n  G6Event[\"AFTERRENDER\"] = \"afterrender\";\r\n  G6Event[\"BEFOREADDITEM\"] = \"beforeadditem\";\r\n  G6Event[\"AFTERADDITEM\"] = \"afteradditem\";\r\n  G6Event[\"BEFOREREMOVEITEM\"] = \"beforeremoveitem\";\r\n  G6Event[\"AFTERREMOVEITEM\"] = \"afterremoveitem\";\r\n  G6Event[\"BEFOREUPDATEITEM\"] = \"beforeupdateitem\";\r\n  G6Event[\"AFTERUPDATEITEM\"] = \"afterupdateitem\";\r\n  G6Event[\"BEFOREITEMVISIBILITYCHANGE\"] = \"beforeitemvisibilitychange\";\r\n  G6Event[\"AFTERITEMVISIBILITYCHANGE\"] = \"afteritemvisibilitychange\";\r\n  G6Event[\"BEFOREITEMSTATECHANGE\"] = \"beforeitemstatechange\";\r\n  G6Event[\"AFTERITEMSTATECHANGE\"] = \"afteritemstatechange\";\r\n  G6Event[\"BEFOREITEMREFRESH\"] = \"beforeitemrefresh\";\r\n  G6Event[\"AFTERITEMREFRESH\"] = \"afteritemrefresh\";\r\n  G6Event[\"BEFOREITEMSTATESCLEAR\"] = \"beforeitemstatesclear\";\r\n  G6Event[\"AFTERITEMSTATESCLEAR\"] = \"afteritemstatesclear\";\r\n  G6Event[\"BEFOREMODECHANGE\"] = \"beforemodechange\";\r\n  G6Event[\"AFTERMODECHANGE\"] = \"aftermodechange\";\r\n  G6Event[\"BEFORELAYOUT\"] = \"beforelayout\";\r\n  G6Event[\"AFTERLAYOUT\"] = \"afterlayout\";\r\n  G6Event[\"BEFORECREATEEDGE\"] = \"beforecreateedge\";\r\n  G6Event[\"AFTERCREATEEDGE\"] = \"aftercreateedge\";\r\n  G6Event[\"BEFOREGRAPHREFRESHPOSITION\"] = \"beforegraphrefreshposition\";\r\n  G6Event[\"AFTERGRAPHREFRESHPOSITION\"] = \"aftergraphrefreshposition\";\r\n  G6Event[\"BEFOREGRAPHREFRESH\"] = \"beforegraphrefresh\";\r\n  G6Event[\"AFTERGRAPHREFRESH\"] = \"aftergraphrefresh\";\r\n  G6Event[\"BEFOREANIMATE\"] = \"beforeanimate\";\r\n  G6Event[\"AFTERANIMATE\"] = \"afteranimate\";\r\n  G6Event[\"BEFOREPAINT\"] = \"beforepaint\";\r\n  G6Event[\"AFTERPAINT\"] = \"afterpaint\";\r\n  G6Event[\"BEFORECOLLAPSEEXPANDCOMBO\"] = \"beforecollapseexpandcombo\";\r\n  G6Event[\"AFTERCOLLAPSEEXPANDCOMBO\"] = \"aftercollapseexpandcombo\";\r\n  G6Event[\"GRAPHSTATECHANGE\"] = \"graphstatechange\";\r\n  G6Event[\"AFTERACTIVATERELATIONS\"] = \"afteractivaterelations\";\r\n  G6Event[\"NODESELECTCHANGE\"] = \"nodeselectchange\";\r\n  G6Event[\"TOOLTIPCHANGE\"] = \"tooltipchange\";\r\n  G6Event[\"WHEELZOOM\"] = \"wheelzoom\";\r\n  G6Event[\"VIEWPORTCHANGE\"] = \"viewportchange\";\r\n  G6Event[\"DRAGNODEEND\"] = \"dragnodeend\";\r\n  G6Event[\"STACKCHANGE\"] = \"stackchange\"; // Mobile event support\r\n\r\n  G6Event[\"TAP\"] = \"tap\";\r\n  G6Event[\"PINCHSTART\"] = \"pinchstart\";\r\n  G6Event[\"PINCHMOVE\"] = \"pinchmove\";\r\n  G6Event[\"PANSTART\"] = \"panstart\";\r\n  G6Event[\"PANMOVE\"] = \"panmove\";\r\n  G6Event[\"PANEND\"] = \"panend\";\r\n})(G6Event || (exports.G6Event = G6Event = {}));","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _graph = require(\"./graph\");\r\n\r\nObject.keys(_graph).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  if (key in exports && exports[key] === _graph[key]) return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function get() {\r\n      return _graph[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _behavior = require(\"./behavior\");\r\n\r\nObject.keys(_behavior).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  if (key in exports && exports[key] === _behavior[key]) return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function get() {\r\n      return _behavior[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _item = require(\"./item\");\r\n\r\nObject.keys(_item).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  if (key in exports && exports[key] === _item[key]) return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function get() {\r\n      return _item[key];\r\n    }\r\n  });\r\n});\r\n\r\nvar _shape = require(\"./shape\");\r\n\r\nObject.keys(_shape).forEach(function (key) {\r\n  if (key === \"default\" || key === \"__esModule\") return;\r\n  if (key in exports && exports[key] === _shape[key]) return;\r\n  Object.defineProperty(exports, key, {\r\n    enumerable: true,\r\n    get: function get() {\r\n      return _shape[key];\r\n    }\r\n  });\r\n});","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});","\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});"]}