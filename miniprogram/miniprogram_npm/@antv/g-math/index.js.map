{"version":3,"sources":["index.js","quadratic.js","line.js","util.js","bezier.js","cubic.js","arc.js","ellipse.js","polygon.js","segments.js","polyline.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;ACFA,AJYA,AENA,ADGA,AENA;ACFA,AJYA,AENA,ADGA,AENA;ACFA,AJYA,AENA,ADGA,AENA;ACFA,ACHA,ALeA,AENA,ADGA,AENA;ACFA,ACHA,ALeA,AENA,ADGA,AENA;ACFA,ACHA,ALeA,AENA,ADGA,AENA;AGRA,AFMA,ACHA,AHSA,ADGA,AENA;AGRA,AFMA,ACHA,AHSA,ADGA,AENA;AGRA,AFMA,ACHA,AHSA,ADGA,AENA;AGRA,AFMA,ACHA,AENA,ALeA,ADGA,AENA;AGRA,AFMA,ACHA,AENA,ALeA,ADGA,AENA;AGRA,AFMA,ACHA,AENA,ALeA,ADGA,AENA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,APqBA,AENA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,APqBA,AENA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,APqBA,AENA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,APqBA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,APqBA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,APqBA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AQxBA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AQxBA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AQxBA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AQxBA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AQxBA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AQxBA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AOrBA;AHUA,AFMA,ACHA,AENA,ALeA,AOrBA;AHUA,AFMA,ACHA,AENA,ALeA,AOrBA;AHUA,AFMA,ACHA,AENA,ALeA,AOrBA;AHUA,AFMA,ACHA,AENA,ALeA,AOrBA;AHUA,AFMA,ACHA,AENA,ALeA,AOrBA;AHUA,AFMA,ACHA,AENA,ALeA,AOrBA;AHUA,ADGA,AENA,ALeA,AOrBA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Util = exports.Polyline = exports.Polygon = exports.Line = exports.Arc = exports.Cubic = exports.Quad = void 0;\r\nvar quadratic_1 = require(\"./quadratic\");\r\nexports.Quad = quadratic_1.default;\r\nvar cubic_1 = require(\"./cubic\");\r\nexports.Cubic = cubic_1.default;\r\nvar arc_1 = require(\"./arc\");\r\nexports.Arc = arc_1.default;\r\nvar line_1 = require(\"./line\");\r\nexports.Line = line_1.default;\r\nvar polygon_1 = require(\"./polygon\");\r\nexports.Polygon = polygon_1.default;\r\nvar polyline_1 = require(\"./polyline\");\r\nexports.Polyline = polyline_1.default;\r\nvar Util = require(\"./util\");\r\nexports.Util = Util;\r\n//# sourceMappingURL=index.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar line_1 = require(\"./line\");\r\nvar util_1 = require(\"./util\");\r\nvar bezier_1 = require(\"./bezier\");\r\n// 差值公式\r\nfunction quadraticAt(p0, p1, p2, t) {\r\n    var onet = 1 - t;\r\n    return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;\r\n}\r\n// 求极值\r\nfunction extrema(p0, p1, p2) {\r\n    var a = p0 + p2 - 2 * p1;\r\n    if (util_1.isNumberEqual(a, 0)) {\r\n        return [0.5];\r\n    }\r\n    var rst = (p0 - p1) / a;\r\n    if (rst <= 1 && rst >= 0) {\r\n        return [rst];\r\n    }\r\n    return [];\r\n}\r\nfunction derivativeAt(p0, p1, p2, t) {\r\n    return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);\r\n}\r\n// 分割贝塞尔曲线\r\nfunction divideQuadratic(x1, y1, x2, y2, x3, y3, t) {\r\n    // 划分点\r\n    var xt = quadraticAt(x1, x2, x3, t);\r\n    var yt = quadraticAt(y1, y2, y3, t);\r\n    // 分割的第一条曲线的控制点\r\n    var controlPoint1 = line_1.default.pointAt(x1, y1, x2, y2, t);\r\n    // 分割的第二条曲线的控制点\r\n    var controlPoint2 = line_1.default.pointAt(x2, y2, x3, y3, t);\r\n    return [\r\n        [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],\r\n        [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3],\r\n    ];\r\n}\r\n// 使用迭代法取贝塞尔曲线的长度\r\nfunction quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {\r\n    if (iterationCount === 0) {\r\n        return (util_1.distance(x1, y1, x2, y2) + util_1.distance(x2, y2, x3, y3) + util_1.distance(x1, y1, x3, y3)) / 2;\r\n    }\r\n    var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);\r\n    var left = quadratics[0];\r\n    var right = quadratics[1];\r\n    left.push(iterationCount - 1);\r\n    right.push(iterationCount - 1);\r\n    return quadraticLength.apply(null, left) + quadraticLength.apply(null, right);\r\n}\r\nexports.default = {\r\n    box: function (x1, y1, x2, y2, x3, y3) {\r\n        var xExtrema = extrema(x1, x2, x3)[0];\r\n        var yExtrema = extrema(y1, y2, y3)[0];\r\n        // 控制点不加入 box 的计算\r\n        var xArr = [x1, x3];\r\n        var yArr = [y1, y3];\r\n        if (xExtrema !== undefined) {\r\n            xArr.push(quadraticAt(x1, x2, x3, xExtrema));\r\n        }\r\n        if (yExtrema !== undefined) {\r\n            yArr.push(quadraticAt(y1, y2, y3, yExtrema));\r\n        }\r\n        return util_1.getBBoxByArray(xArr, yArr);\r\n    },\r\n    length: function (x1, y1, x2, y2, x3, y3) {\r\n        return quadraticLength(x1, y1, x2, y2, x3, y3, 3);\r\n    },\r\n    nearestPoint: function (x1, y1, x2, y2, x3, y3, x0, y0) {\r\n        return bezier_1.nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);\r\n    },\r\n    pointDistance: function (x1, y1, x2, y2, x3, y3, x0, y0) {\r\n        var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);\r\n        return util_1.distance(point.x, point.y, x0, y0);\r\n    },\r\n    interpolationAt: quadraticAt,\r\n    pointAt: function (x1, y1, x2, y2, x3, y3, t) {\r\n        return {\r\n            x: quadraticAt(x1, x2, x3, t),\r\n            y: quadraticAt(y1, y2, y3, t),\r\n        };\r\n    },\r\n    divide: function (x1, y1, x2, y2, x3, y3, t) {\r\n        return divideQuadratic(x1, y1, x2, y2, x3, y3, t);\r\n    },\r\n    tangentAngle: function (x1, y1, x2, y2, x3, y3, t) {\r\n        var dx = derivativeAt(x1, x2, x3, t);\r\n        var dy = derivativeAt(y1, y2, y3, t);\r\n        var angle = Math.atan2(dy, dx);\r\n        return util_1.piMod(angle);\r\n    },\r\n};\r\n//# sourceMappingURL=quadratic.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = require(\"./util\");\r\nvar vec2 = require(\"gl-matrix/vec2\");\r\nexports.default = {\r\n    /**\r\n     * 计算线段的包围盒\r\n     * @param {number} x1 起始点 x\r\n     * @param {number} y1 起始点 y\r\n     * @param {number} x2 结束点 x\r\n     * @param {number} y2 结束点 y\r\n     * @return {object} 包围盒对象\r\n     */\r\n    box: function (x1, y1, x2, y2) {\r\n        return util_1.getBBoxByArray([x1, x2], [y1, y2]);\r\n    },\r\n    /**\r\n     * 线段的长度\r\n     * @param {number} x1 起始点 x\r\n     * @param {number} y1 起始点 y\r\n     * @param {number} x2 结束点 x\r\n     * @param {number} y2 结束点 y\r\n     * @return {number} 距离\r\n     */\r\n    length: function (x1, y1, x2, y2) {\r\n        return util_1.distance(x1, y1, x2, y2);\r\n    },\r\n    /**\r\n     * 根据比例获取点\r\n     * @param {number} x1 起始点 x\r\n     * @param {number} y1 起始点 y\r\n     * @param {number} x2 结束点 x\r\n     * @param {number} y2 结束点 y\r\n     * @param {number} t 指定比例\r\n     * @return {object} 包含 x, y 的点\r\n     */\r\n    pointAt: function (x1, y1, x2, y2, t) {\r\n        return {\r\n            x: (1 - t) * x1 + t * x2,\r\n            y: (1 - t) * y1 + t * y2,\r\n        };\r\n    },\r\n    /**\r\n     * 点到线段的距离\r\n     * @param {number} x1 起始点 x\r\n     * @param {number} y1 起始点 y\r\n     * @param {number} x2 结束点 x\r\n     * @param {number} y2 结束点 y\r\n     * @param {number} x  测试点 x\r\n     * @param {number} y  测试点 y\r\n     * @return {number} 距离\r\n     */\r\n    pointDistance: function (x1, y1, x2, y2, x, y) {\r\n        // 投影距离 x1, y1 的向量，假设 p, p1, p2 三个点，投影点为 a\r\n        // p1a = p1p.p1p2/|p1p2| * (p1p 的单位向量)\r\n        var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\r\n        if (cross < 0) {\r\n            return util_1.distance(x1, y1, x, y);\r\n        }\r\n        var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\r\n        if (cross > lengthSquare) {\r\n            return util_1.distance(x2, y2, x, y);\r\n        }\r\n        return this.pointToLine(x1, y1, x2, y2, x, y);\r\n    },\r\n    /**\r\n     * 点到直线的距离，而不是点到线段的距离\r\n     * @param {number} x1 起始点 x\r\n     * @param {number} y1 起始点 y\r\n     * @param {number} x2 结束点 x\r\n     * @param {number} y2 结束点 y\r\n     * @param {number} x  测试点 x\r\n     * @param {number} y  测试点 y\r\n     * @return {number} 距离\r\n     */\r\n    pointToLine: function (x1, y1, x2, y2, x, y) {\r\n        var d = [x2 - x1, y2 - y1];\r\n        // 如果端点相等，则判定点到点的距离\r\n        if (vec2.exactEquals(d, [0, 0])) {\r\n            return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\r\n        }\r\n        var u = [-d[1], d[0]];\r\n        vec2.normalize(u, u);\r\n        var a = [x - x1, y - y1];\r\n        return Math.abs(vec2.dot(a, u));\r\n    },\r\n    /**\r\n     * 线段的角度\r\n     * @param {number} x1 起始点 x\r\n     * @param {number} y1 起始点 y\r\n     * @param {number} x2 结束点 x\r\n     * @param {number} y2 结束点 y\r\n     * @return {number} 导数\r\n     */\r\n    tangentAngle: function (x1, y1, x2, y2) {\r\n        return Math.atan2(y2 - y1, x2 - x1);\r\n    },\r\n};\r\n//# sourceMappingURL=line.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.piMod = exports.getBBoxRange = exports.getBBoxByArray = exports.isNumberEqual = exports.distance = void 0;\r\nvar util_1 = require(\"@antv/util\");\r\n/**\r\n * 两点之间的距离\r\n * @param {number} x1 起始点 x\r\n * @param {number} y1 起始点 y\r\n * @param {number} x2 结束点 x\r\n * @param {number} y2 结束点 y\r\n * @return {number} 距离\r\n */\r\nfunction distance(x1, y1, x2, y2) {\r\n    var dx = x1 - x2;\r\n    var dy = y1 - y2;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\nexports.distance = distance;\r\nfunction isNumberEqual(v1, v2) {\r\n    return Math.abs(v1 - v2) < 0.001;\r\n}\r\nexports.isNumberEqual = isNumberEqual;\r\nfunction getBBoxByArray(xArr, yArr) {\r\n    var minX = util_1.min(xArr);\r\n    var minY = util_1.min(yArr);\r\n    var maxX = util_1.max(xArr);\r\n    var maxY = util_1.max(yArr);\r\n    return {\r\n        x: minX,\r\n        y: minY,\r\n        width: maxX - minX,\r\n        height: maxY - minY,\r\n    };\r\n}\r\nexports.getBBoxByArray = getBBoxByArray;\r\nfunction getBBoxRange(x1, y1, x2, y2) {\r\n    return {\r\n        minX: util_1.min([x1, x2]),\r\n        maxX: util_1.max([x1, x2]),\r\n        minY: util_1.min([y1, y2]),\r\n        maxY: util_1.max([y1, y2]),\r\n    };\r\n}\r\nexports.getBBoxRange = getBBoxRange;\r\nfunction piMod(angle) {\r\n    return (angle + Math.PI * 2) % (Math.PI * 2);\r\n}\r\nexports.piMod = piMod;\r\n//# sourceMappingURL=util.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.snapLength = exports.nearestPoint = void 0;\r\nvar util_1 = require(\"./util\");\r\nvar EPSILON = 0.0001;\r\n/**\r\n * 使用牛顿切割法求最近的点\r\n * @param {number[]} xArr      点的 x 数组\r\n * @param {number[]} yArr      点的 y 数组\r\n * @param {number}   x         指定的点 x\r\n * @param {number}   y         指定的点 y\r\n * @param {Function} tCallback 差值函数\r\n */\r\nfunction nearestPoint(xArr, yArr, x, y, tCallback, length) {\r\n    var t;\r\n    var d = Infinity;\r\n    var v0 = [x, y];\r\n    var segNum = 20;\r\n    if (length && length > 200) {\r\n        segNum = length / 10;\r\n    }\r\n    var increaseRate = 1 / segNum;\r\n    var interval = increaseRate / 10;\r\n    for (var i = 0; i <= segNum; i++) {\r\n        var _t = i * increaseRate;\r\n        var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];\r\n        var d1 = util_1.distance(v0[0], v0[1], v1[0], v1[1]);\r\n        if (d1 < d) {\r\n            t = _t;\r\n            d = d1;\r\n        }\r\n    }\r\n    // 提前终止\r\n    if (t === 0) {\r\n        return {\r\n            x: xArr[0],\r\n            y: yArr[0],\r\n        };\r\n    }\r\n    if (t === 1) {\r\n        var count = xArr.length;\r\n        return {\r\n            x: xArr[count - 1],\r\n            y: yArr[count - 1],\r\n        };\r\n    }\r\n    d = Infinity;\r\n    for (var i = 0; i < 32; i++) {\r\n        if (interval < EPSILON) {\r\n            break;\r\n        }\r\n        var prev = t - interval;\r\n        var next = t + interval;\r\n        var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];\r\n        var d1 = util_1.distance(v0[0], v0[1], v1[0], v1[1]);\r\n        if (prev >= 0 && d1 < d) {\r\n            t = prev;\r\n            d = d1;\r\n        }\r\n        else {\r\n            var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];\r\n            var d2 = util_1.distance(v0[0], v0[1], v2[0], v2[1]);\r\n            if (next <= 1 && d2 < d) {\r\n                t = next;\r\n                d = d2;\r\n            }\r\n            else {\r\n                interval *= 0.5;\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        x: tCallback.apply(null, xArr.concat([t])),\r\n        y: tCallback.apply(null, yArr.concat([t])),\r\n    };\r\n}\r\nexports.nearestPoint = nearestPoint;\r\n// 近似求解 https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2\r\nfunction snapLength(xArr, yArr) {\r\n    var totalLength = 0;\r\n    var count = xArr.length;\r\n    for (var i = 0; i < count; i++) {\r\n        var x = xArr[i];\r\n        var y = yArr[i];\r\n        var nextX = xArr[(i + 1) % count];\r\n        var nextY = yArr[(i + 1) % count];\r\n        totalLength += util_1.distance(x, y, nextX, nextY);\r\n    }\r\n    return totalLength / 2;\r\n}\r\nexports.snapLength = snapLength;\r\n//# sourceMappingURL=bezier.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = require(\"./util\");\r\nvar line_1 = require(\"./line\");\r\nvar bezier_1 = require(\"./bezier\");\r\nfunction cubicAt(p0, p1, p2, p3, t) {\r\n    var onet = 1 - t; // t * t * t 的性能大概是 Math.pow(t, 3) 的三倍\r\n    return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;\r\n}\r\nfunction derivativeAt(p0, p1, p2, p3, t) {\r\n    var onet = 1 - t;\r\n    return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));\r\n}\r\nfunction extrema(p0, p1, p2, p3) {\r\n    var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\r\n    var b = 6 * p0 - 12 * p1 + 6 * p2;\r\n    var c = 3 * p1 - 3 * p0;\r\n    var extremas = [];\r\n    var t1;\r\n    var t2;\r\n    var discSqrt;\r\n    if (util_1.isNumberEqual(a, 0)) {\r\n        if (!util_1.isNumberEqual(b, 0)) {\r\n            t1 = -c / b;\r\n            if (t1 >= 0 && t1 <= 1) {\r\n                extremas.push(t1);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        var disc = b * b - 4 * a * c;\r\n        if (util_1.isNumberEqual(disc, 0)) {\r\n            extremas.push(-b / (2 * a));\r\n        }\r\n        else if (disc > 0) {\r\n            discSqrt = Math.sqrt(disc);\r\n            t1 = (-b + discSqrt) / (2 * a);\r\n            t2 = (-b - discSqrt) / (2 * a);\r\n            if (t1 >= 0 && t1 <= 1) {\r\n                extremas.push(t1);\r\n            }\r\n            if (t2 >= 0 && t2 <= 1) {\r\n                extremas.push(t2);\r\n            }\r\n        }\r\n    }\r\n    return extremas;\r\n}\r\n// 分割贝塞尔曲线\r\nfunction divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {\r\n    // 划分点\r\n    var xt = cubicAt(x1, x2, x3, x4, t);\r\n    var yt = cubicAt(y1, y2, y3, y4, t);\r\n    // 计算两点之间的差值点\r\n    var c1 = line_1.default.pointAt(x1, y1, x2, y2, t);\r\n    var c2 = line_1.default.pointAt(x2, y2, x3, y3, t);\r\n    var c3 = line_1.default.pointAt(x3, y3, x4, y4, t);\r\n    var c12 = line_1.default.pointAt(c1.x, c1.y, c2.x, c2.y, t);\r\n    var c23 = line_1.default.pointAt(c2.x, c2.y, c3.x, c3.y, t);\r\n    return [\r\n        [x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt],\r\n        [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4],\r\n    ];\r\n}\r\n// 使用迭代法取贝塞尔曲线的长度，二阶和三阶分开写，更清晰和便于调试\r\nfunction cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {\r\n    if (iterationCount === 0) {\r\n        return bezier_1.snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);\r\n    }\r\n    var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);\r\n    var left = cubics[0];\r\n    var right = cubics[1];\r\n    left.push(iterationCount - 1);\r\n    right.push(iterationCount - 1);\r\n    return cubicLength.apply(null, left) + cubicLength.apply(null, right);\r\n}\r\nexports.default = {\r\n    extrema: extrema,\r\n    box: function (x1, y1, x2, y2, x3, y3, x4, y4) {\r\n        var xArr = [x1, x4];\r\n        var yArr = [y1, y4];\r\n        var xExtrema = extrema(x1, x2, x3, x4);\r\n        var yExtrema = extrema(y1, y2, y3, y4);\r\n        for (var i = 0; i < xExtrema.length; i++) {\r\n            xArr.push(cubicAt(x1, x2, x3, x4, xExtrema[i]));\r\n        }\r\n        for (var i = 0; i < yExtrema.length; i++) {\r\n            yArr.push(cubicAt(y1, y2, y3, y4, yExtrema[i]));\r\n        }\r\n        return util_1.getBBoxByArray(xArr, yArr);\r\n    },\r\n    length: function (x1, y1, x2, y2, x3, y3, x4, y4) {\r\n        // 迭代三次，划分成 8 段求长度\r\n        return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);\r\n    },\r\n    nearestPoint: function (x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {\r\n        return bezier_1.nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length);\r\n    },\r\n    pointDistance: function (x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {\r\n        var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length);\r\n        return util_1.distance(point.x, point.y, x0, y0);\r\n    },\r\n    interpolationAt: cubicAt,\r\n    pointAt: function (x1, y1, x2, y2, x3, y3, x4, y4, t) {\r\n        return {\r\n            x: cubicAt(x1, x2, x3, x4, t),\r\n            y: cubicAt(y1, y2, y3, y4, t),\r\n        };\r\n    },\r\n    divide: function (x1, y1, x2, y2, x3, y3, x4, y4, t) {\r\n        return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);\r\n    },\r\n    tangentAngle: function (x1, y1, x2, y2, x3, y3, x4, y4, t) {\r\n        var dx = derivativeAt(x1, x2, x3, x4, t);\r\n        var dy = derivativeAt(y1, y2, y3, y4, t);\r\n        return util_1.piMod(Math.atan2(dy, dx));\r\n    },\r\n};\r\n//# sourceMappingURL=cubic.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = require(\"./util\");\r\nvar ellipse_1 = require(\"./ellipse\");\r\n// 偏导数 x\r\nfunction derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {\r\n    return -1 * rx * Math.cos(xRotation) * Math.sin(angle) - ry * Math.sin(xRotation) * Math.cos(angle);\r\n}\r\n// 偏导数 y\r\nfunction derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {\r\n    return -1 * rx * Math.sin(xRotation) * Math.sin(angle) + ry * Math.cos(xRotation) * Math.cos(angle);\r\n}\r\n// x 的极值\r\nfunction xExtrema(rx, ry, xRotation) {\r\n    return Math.atan((-ry / rx) * Math.tan(xRotation));\r\n}\r\n// y 的极值\r\nfunction yExtrema(rx, ry, xRotation) {\r\n    return Math.atan(ry / (rx * Math.tan(xRotation)));\r\n}\r\n// 根据角度求 x 坐标\r\nfunction xAt(cx, cy, rx, ry, xRotation, angle) {\r\n    return rx * Math.cos(xRotation) * Math.cos(angle) - ry * Math.sin(xRotation) * Math.sin(angle) + cx;\r\n}\r\n// 根据角度求 y 坐标\r\nfunction yAt(cx, cy, rx, ry, xRotation, angle) {\r\n    return rx * Math.sin(xRotation) * Math.cos(angle) + ry * Math.cos(xRotation) * Math.sin(angle) + cy;\r\n}\r\n// 获取点在椭圆上的角度\r\nfunction getAngle(rx, ry, x0, y0) {\r\n    var angle = Math.atan2(y0 * rx, x0 * ry);\r\n    // 转换到 0 - 2PI 内\r\n    return (angle + Math.PI * 2) % (Math.PI * 2);\r\n}\r\n// 根据角度获取，x,y\r\nfunction getPoint(rx, ry, angle) {\r\n    return {\r\n        x: rx * Math.cos(angle),\r\n        y: ry * Math.sin(angle),\r\n    };\r\n}\r\n// 旋转\r\nfunction rotate(x, y, angle) {\r\n    var cos = Math.cos(angle);\r\n    var sin = Math.sin(angle);\r\n    return [x * cos - y * sin, x * sin + y * cos];\r\n}\r\nexports.default = {\r\n    /**\r\n     * 计算包围盒\r\n     * @param {number} cx         圆心 x\r\n     * @param {number} cy         圆心 y\r\n     * @param {number} rx         x 轴方向的半径\r\n     * @param {number} ry         y 轴方向的半径\r\n     * @param {number} xRotation  旋转角度\r\n     * @param {number} startAngle 起始角度\r\n     * @param {number} endAngle   结束角度\r\n     * @return {object} 包围盒对象\r\n     */\r\n    box: function (cx, cy, rx, ry, xRotation, startAngle, endAngle) {\r\n        var xDim = xExtrema(rx, ry, xRotation);\r\n        var minX = Infinity;\r\n        var maxX = -Infinity;\r\n        var xs = [startAngle, endAngle];\r\n        for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\r\n            var xAngle = xDim + i;\r\n            if (startAngle < endAngle) {\r\n                if (startAngle < xAngle && xAngle < endAngle) {\r\n                    xs.push(xAngle);\r\n                }\r\n            }\r\n            else {\r\n                if (endAngle < xAngle && xAngle < startAngle) {\r\n                    xs.push(xAngle);\r\n                }\r\n            }\r\n        }\r\n        for (var i = 0; i < xs.length; i++) {\r\n            var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);\r\n            if (x < minX) {\r\n                minX = x;\r\n            }\r\n            if (x > maxX) {\r\n                maxX = x;\r\n            }\r\n        }\r\n        var yDim = yExtrema(rx, ry, xRotation);\r\n        var minY = Infinity;\r\n        var maxY = -Infinity;\r\n        var ys = [startAngle, endAngle];\r\n        for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\r\n            var yAngle = yDim + i;\r\n            if (startAngle < endAngle) {\r\n                if (startAngle < yAngle && yAngle < endAngle) {\r\n                    ys.push(yAngle);\r\n                }\r\n            }\r\n            else {\r\n                if (endAngle < yAngle && yAngle < startAngle) {\r\n                    ys.push(yAngle);\r\n                }\r\n            }\r\n        }\r\n        for (var i = 0; i < ys.length; i++) {\r\n            var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);\r\n            if (y < minY) {\r\n                minY = y;\r\n            }\r\n            if (y > maxY) {\r\n                maxY = y;\r\n            }\r\n        }\r\n        return {\r\n            x: minX,\r\n            y: minY,\r\n            width: maxX - minX,\r\n            height: maxY - minY,\r\n        };\r\n    },\r\n    /**\r\n     * 获取圆弧的长度，计算圆弧长度时不考虑旋转角度，\r\n     * 仅跟 rx, ry, startAngle, endAngle 相关\r\n     * @param {number} cx         圆心 x\r\n     * @param {number} cy         圆心 y\r\n     * @param {number} rx         x 轴方向的半径\r\n     * @param {number} ry         y 轴方向的半径\r\n     * @param {number} xRotation  旋转角度\r\n     * @param {number} startAngle 起始角度\r\n     * @param {number} endAngle   结束角度\r\n     */\r\n    length: function (cx, cy, rx, ry, xRotation, startAngle, endAngle) { },\r\n    /**\r\n     * 获取指定点到圆弧的最近距离的点\r\n     * @param {number} cx         圆心 x\r\n     * @param {number} cy         圆心 y\r\n     * @param {number} rx         x 轴方向的半径\r\n     * @param {number} ry         y 轴方向的半径\r\n     * @param {number} xRotation  旋转角度\r\n     * @param {number} startAngle 起始角度\r\n     * @param {number} endAngle   结束角度\r\n     * @param {number} x0         指定点的 x\r\n     * @param {number} y0         指定点的 y\r\n     * @return {object} 到指定点最近距离的点\r\n     */\r\n    nearestPoint: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {\r\n        // 将最近距离问题转换成到椭圆中心 0,0 没有旋转的椭圆问题\r\n        var relativeVector = rotate(x0 - cx, y0 - cy, -xRotation);\r\n        var x1 = relativeVector[0], y1 = relativeVector[1];\r\n        // 计算点到椭圆的最近的点\r\n        var relativePoint = ellipse_1.default.nearestPoint(0, 0, rx, ry, x1, y1);\r\n        // 获取点在椭圆上的角度\r\n        var angle = getAngle(rx, ry, relativePoint.x, relativePoint.y);\r\n        // 点没有在圆弧上\r\n        if (angle < startAngle) {\r\n            // 小于起始圆弧\r\n            relativePoint = getPoint(rx, ry, startAngle);\r\n        }\r\n        else if (angle > endAngle) {\r\n            // 大于结束圆弧\r\n            relativePoint = getPoint(rx, ry, endAngle);\r\n        }\r\n        // 旋转到 xRotation 的角度\r\n        var vector = rotate(relativePoint.x, relativePoint.y, xRotation);\r\n        return {\r\n            x: vector[0] + cx,\r\n            y: vector[1] + cy,\r\n        };\r\n    },\r\n    pointDistance: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {\r\n        var nearestPoint = this.nearestPoint(cx, cy, rx, ry, x0, y0);\r\n        return util_1.distance(nearestPoint.x, nearestPoint.y, x0, y0);\r\n    },\r\n    pointAt: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {\r\n        var angle = (endAngle - startAngle) * t + startAngle;\r\n        return {\r\n            x: xAt(cx, cy, rx, ry, xRotation, angle),\r\n            y: yAt(cx, cy, rx, ry, xRotation, angle),\r\n        };\r\n    },\r\n    tangentAngle: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {\r\n        var angle = (endAngle - startAngle) * t + startAngle;\r\n        var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\r\n        var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\r\n        return util_1.piMod(Math.atan2(dy, dx));\r\n    },\r\n};\r\n//# sourceMappingURL=arc.js.map","\r\n/**\r\n * @fileoverview 椭圆的一些计算，\r\n *  - 周长计算参考：https://www.mathsisfun.com/geometry/ellipse-perimeter.html\r\n *  - 距离计算参考：https://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/\r\n * @author dxq613@gmail.com\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = require(\"./util\");\r\nfunction copysign(v1, v2) {\r\n    var absv = Math.abs(v1);\r\n    return v2 > 0 ? absv : absv * -1;\r\n}\r\nexports.default = {\r\n    /**\r\n     * 包围盒计算\r\n     * @param {number} x  椭圆中心 x\r\n     * @param {number} y  椭圆中心 y\r\n     * @param {number} rx 椭圆 x 方向半径\r\n     * @param {number} ry 椭圆 y 方向半径\r\n     * @return {object} 包围盒\r\n     */\r\n    box: function (x, y, rx, ry) {\r\n        return {\r\n            x: x - rx,\r\n            y: y - ry,\r\n            width: rx * 2,\r\n            height: ry * 2,\r\n        };\r\n    },\r\n    /**\r\n     * 计算周长，使用近似法\r\n     * @param {number} x  椭圆中心 x\r\n     * @param {number} y  椭圆中心 y\r\n     * @param {number} rx 椭圆 x 方向半径\r\n     * @param {number} ry 椭圆 y 方向半径\r\n     * @return {number} 椭圆周长\r\n     */\r\n    length: function (x, y, rx, ry) {\r\n        return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));\r\n    },\r\n    /**\r\n     * 距离椭圆最近的点\r\n     * @param {number} x  椭圆中心 x\r\n     * @param {number} y  椭圆中心 y\r\n     * @param {number} rx 椭圆 x 方向半径\r\n     * @param {number} ry 椭圆 y 方向半径\r\n     * @param {number} x0  指定的点 x\r\n     * @param {number} y0  指定的点 y\r\n     * @return {object} 椭圆上距离指定点最近的点\r\n     */\r\n    nearestPoint: function (x, y, rx, ry, x0, y0) {\r\n        var a = rx;\r\n        var b = ry;\r\n        // 假如椭圆半径为0则返回圆心\r\n        if (a === 0 || b === 0) {\r\n            return {\r\n                x: x,\r\n                y: y,\r\n            };\r\n        }\r\n        // 转换成 0， 0 为中心的椭圆计算\r\n        var relativeX = x0 - x;\r\n        var relativeY = y0 - y;\r\n        var px = Math.abs(relativeX);\r\n        var py = Math.abs(relativeY);\r\n        var squareA = a * a;\r\n        var squareB = b * b;\r\n        // const angle0 = Math.atan2(relativeY, relativeX);\r\n        var t = Math.PI / 4;\r\n        var nearestX; // 椭圆上的任一点\r\n        var nearestY;\r\n        // 迭代 4 次\r\n        for (var i = 0; i < 4; i++) {\r\n            nearestX = a * Math.cos(t);\r\n            nearestY = b * Math.sin(t);\r\n            var ex = ((squareA - squareB) * Math.pow(Math.cos(t), 3)) / a;\r\n            var ey = ((squareB - squareA) * Math.pow(Math.sin(t), 3)) / b;\r\n            var rx1 = nearestX - ex;\r\n            var ry1 = nearestY - ey;\r\n            var qx = px - ex;\r\n            var qy = py - ey;\r\n            var r = Math.hypot(ry1, rx1);\r\n            var q = Math.hypot(qy, qx);\r\n            var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\r\n            var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\r\n            t += delta_t;\r\n            t = Math.min(Math.PI / 2, Math.max(0, t));\r\n        }\r\n        return {\r\n            x: x + copysign(nearestX, relativeX),\r\n            y: y + copysign(nearestY, relativeY),\r\n        };\r\n    },\r\n    /**\r\n     * 点到椭圆最近的距离\r\n     * @param {number} x  椭圆中心 x\r\n     * @param {number} y  椭圆中心 y\r\n     * @param {number} rx 椭圆 x 方向半径\r\n     * @param {number} ry 椭圆 y 方向半径\r\n     * @param {number} x0  指定的点 x\r\n     * @param {number} y0  指定的点 y\r\n     * @return {number} 点到椭圆的距离\r\n     */\r\n    pointDistance: function (x, y, rx, ry, x0, y0) {\r\n        var nearestPoint = this.nearestPoint(x, y, rx, ry, x0, y0);\r\n        return util_1.distance(nearestPoint.x, nearestPoint.y, x0, y0);\r\n    },\r\n    /**\r\n     * 根据比例获取点\r\n     * @param {number} x 椭圆中心 x\r\n     * @param {number} y 椭圆中心 y\r\n     * @param {number} rx 椭圆 x 方向半径\r\n     * @param {number} ry 椭圆 y 方向半径\r\n     * @param {number} t 指定比例，x轴方向为 0\r\n     * @return {object} 点\r\n     */\r\n    pointAt: function (x, y, rx, ry, t) {\r\n        var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\r\n        return {\r\n            x: x + rx * Math.cos(angle),\r\n            y: y + ry * Math.sin(angle),\r\n        };\r\n    },\r\n    /**\r\n     * 根据比例计算切线角度\r\n     * @param {number} x 椭圆中心 x\r\n     * @param {number} y 椭圆中心 y\r\n     * @param {number} rx 椭圆 x 方向半径\r\n     * @param {number} ry 椭圆 y 方向半径\r\n     * @param {number} t 指定比例 0 - 1 之间，x轴方向为 0。在 0-1 范围之外是循环还是返回 null，还需要调整\r\n     * @return {number} 角度，在 0 - 2PI 之间\r\n     */\r\n    tangentAngle: function (x, y, rx, ry, t) {\r\n        var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\r\n        // 直接使用 x,y 的导数计算， x' = -rx * sin(t); y' = ry * cos(t);\r\n        var tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle));\r\n        // 也可以使用指定点的切线方程计算，成本有些高\r\n        // const point = this.pointAt(0, 0, rx, ry, t); // 椭圆的切线同椭圆的中心不相关\r\n        // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));\r\n        // if (angle >= 0 && angle <= Math.PI) {\r\n        //   tangentAngle += Math.PI;\r\n        // }\r\n        return util_1.piMod(tangentAngle);\r\n    },\r\n};\r\n//# sourceMappingURL=ellipse.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar segments_1 = require(\"./segments\");\r\nvar polyline_1 = require(\"./polyline\");\r\nfunction getAllPoints(points) {\r\n    var tmp = points.slice(0);\r\n    if (points.length) {\r\n        tmp.push(points[0]);\r\n    }\r\n    return tmp;\r\n}\r\nexports.default = {\r\n    /**\r\n     * 计算多边形的包围盒\r\n     * @param {array} points 点的集合 [x,y] 的形式\r\n     * @return {object} 包围盒\r\n     */\r\n    box: function (points) {\r\n        return polyline_1.default.box(points);\r\n    },\r\n    /**\r\n     * 计算多边形的长度\r\n     * @param {array} points 点的集合 [x,y] 的形式\r\n     * @return {object} 多边形边的长度\r\n     */\r\n    length: function (points) {\r\n        return segments_1.lengthOfSegment(getAllPoints(points));\r\n    },\r\n    /**\r\n     * 根据比例获取多边形的点\r\n     * @param {array} points 点的集合 [x,y] 的形式\r\n     * @param {number} t 在多边形的长度上的比例\r\n     * @return {object} 根据比例值计算出来的点\r\n     */\r\n    pointAt: function (points, t) {\r\n        return segments_1.pointAtSegments(getAllPoints(points), t);\r\n    },\r\n    /**\r\n     * 指定点到多边形的距离\r\n     * @param {array} points 点的集合 [x,y] 的形式\r\n     * @param {number} x 指定点的 x\r\n     * @param {number} y 指定点的 y\r\n     * @return {number} 点到多边形的距离\r\n     */\r\n    pointDistance: function (points, x, y) {\r\n        return segments_1.distanceAtSegment(getAllPoints(points), x, y);\r\n    },\r\n    /**\r\n     * 根据比例获取多边形的切线角度\r\n     * @param {array} points 点的集合 [x,y] 的形式\r\n     * @param {number} t 在多边形的长度上的比例\r\n     * @return {object} 根据比例值计算出来的角度\r\n     */\r\n    tangentAngle: function (points, t) {\r\n        return segments_1.angleAtSegments(getAllPoints(points), t);\r\n    },\r\n};\r\n//# sourceMappingURL=polygon.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.distanceAtSegment = exports.angleAtSegments = exports.pointAtSegments = exports.lengthOfSegment = void 0;\r\nvar line_1 = require(\"./line\");\r\nvar util_1 = require(\"./util\");\r\nfunction analyzePoints(points) {\r\n    // 计算每段的长度和总的长度\r\n    var totalLength = 0;\r\n    var segments = [];\r\n    for (var i = 0; i < points.length - 1; i++) {\r\n        var from = points[i];\r\n        var to = points[i + 1];\r\n        var length_1 = util_1.distance(from[0], from[1], to[0], to[1]);\r\n        var seg = {\r\n            from: from,\r\n            to: to,\r\n            length: length_1,\r\n        };\r\n        segments.push(seg);\r\n        totalLength += length_1;\r\n    }\r\n    return { segments: segments, totalLength: totalLength };\r\n}\r\nfunction lengthOfSegment(points) {\r\n    if (points.length < 2) {\r\n        return 0;\r\n    }\r\n    var totalLength = 0;\r\n    for (var i = 0; i < points.length - 1; i++) {\r\n        var from = points[i];\r\n        var to = points[i + 1];\r\n        totalLength += util_1.distance(from[0], from[1], to[0], to[1]);\r\n    }\r\n    return totalLength;\r\n}\r\nexports.lengthOfSegment = lengthOfSegment;\r\n/**\r\n * 按照比例在数据片段中获取点\r\n * @param {array} points 点的集合\r\n * @param {number} t 百分比 0-1\r\n * @return {object} 点的坐标\r\n */\r\nfunction pointAtSegments(points, t) {\r\n    // 边界判断\r\n    if (t > 1 || t < 0 || points.length < 2) {\r\n        return null;\r\n    }\r\n    var _a = analyzePoints(points), segments = _a.segments, totalLength = _a.totalLength;\r\n    // 多个点有可能重合\r\n    if (totalLength === 0) {\r\n        return {\r\n            x: points[0][0],\r\n            y: points[0][1],\r\n        };\r\n    }\r\n    // 计算比例\r\n    var startRatio = 0;\r\n    var point = null;\r\n    for (var i = 0; i < segments.length; i++) {\r\n        var seg = segments[i];\r\n        var from = seg.from, to = seg.to;\r\n        var currentRatio = seg.length / totalLength;\r\n        if (t >= startRatio && t <= startRatio + currentRatio) {\r\n            var localRatio = (t - startRatio) / currentRatio;\r\n            point = line_1.default.pointAt(from[0], from[1], to[0], to[1], localRatio);\r\n            break;\r\n        }\r\n        startRatio += currentRatio;\r\n    }\r\n    return point;\r\n}\r\nexports.pointAtSegments = pointAtSegments;\r\n/**\r\n * 按照比例在数据片段中获取切线的角度\r\n * @param {array} points 点的集合\r\n * @param {number} t 百分比 0-1\r\n */\r\nfunction angleAtSegments(points, t) {\r\n    // 边界判断\r\n    if (t > 1 || t < 0 || points.length < 2) {\r\n        return 0;\r\n    }\r\n    var _a = analyzePoints(points), segments = _a.segments, totalLength = _a.totalLength;\r\n    // 计算比例\r\n    var startRatio = 0;\r\n    var angle = 0;\r\n    for (var i = 0; i < segments.length; i++) {\r\n        var seg = segments[i];\r\n        var from = seg.from, to = seg.to;\r\n        var currentRatio = seg.length / totalLength;\r\n        if (t >= startRatio && t <= startRatio + currentRatio) {\r\n            angle = Math.atan2(to[1] - from[1], to[0] - from[0]);\r\n            break;\r\n        }\r\n        startRatio += currentRatio;\r\n    }\r\n    return angle;\r\n}\r\nexports.angleAtSegments = angleAtSegments;\r\nfunction distanceAtSegment(points, x, y) {\r\n    var minDistance = Infinity;\r\n    for (var i = 0; i < points.length - 1; i++) {\r\n        var point = points[i];\r\n        var nextPoint = points[i + 1];\r\n        var distance_1 = line_1.default.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);\r\n        if (distance_1 < minDistance) {\r\n            minDistance = distance_1;\r\n        }\r\n    }\r\n    return minDistance;\r\n}\r\nexports.distanceAtSegment = distanceAtSegment;\r\n//# sourceMappingURL=segments.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar segments_1 = require(\"./segments\");\r\nvar util_1 = require(\"./util\");\r\nexports.default = {\r\n    /**\r\n     * 计算多折线的包围盒\r\n     * @param {array} points 点的集合 [x,y] 的形式\r\n     * @return {object} 包围盒\r\n     */\r\n    box: function (points) {\r\n        var xArr = [];\r\n        var yArr = [];\r\n        for (var i = 0; i < points.length; i++) {\r\n            var point = points[i];\r\n            xArr.push(point[0]);\r\n            yArr.push(point[1]);\r\n        }\r\n        return util_1.getBBoxByArray(xArr, yArr);\r\n    },\r\n    /**\r\n     * 计算多折线的长度\r\n     * @param {array} points 点的集合 [x,y] 的形式\r\n     * @return {object} 多条边的长度\r\n     */\r\n    length: function (points) {\r\n        return segments_1.lengthOfSegment(points);\r\n    },\r\n    /**\r\n     * 根据比例获取多折线的点\r\n     * @param {array} points 点的集合 [x,y] 的形式\r\n     * @param {number} t 在多折线的长度上的比例\r\n     * @return {object} 根据比例值计算出来的点\r\n     */\r\n    pointAt: function (points, t) {\r\n        return segments_1.pointAtSegments(points, t);\r\n    },\r\n    /**\r\n     * 指定点到多折线的距离\r\n     * @param {array} points 点的集合 [x,y] 的形式\r\n     * @param {number} x 指定点的 x\r\n     * @param {number} y 指定点的 y\r\n     * @return {number} 点到多折线的距离\r\n     */\r\n    pointDistance: function (points, x, y) {\r\n        return segments_1.distanceAtSegment(points, x, y);\r\n    },\r\n    /**\r\n     * 根据比例获取多折线的切线角度\r\n     * @param {array} points 点的集合 [x,y] 的形式\r\n     * @param {number} t 在多折线的长度上的比例\r\n     * @return {object} 根据比例值计算出来的角度\r\n     */\r\n    tangentAngle: function (points, t) {\r\n        return segments_1.angleAtSegments(points, t);\r\n    },\r\n};\r\n//# sourceMappingURL=polyline.js.map"]}