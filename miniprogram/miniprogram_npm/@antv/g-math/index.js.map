{"version":3,"sources":["index.js","quadratic.js","line.js","util.js","bezier.js","cubic.js","arc.js","ellipse.js","polygon.js","segments.js","polyline.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;ACFA,AJYA,AENA,ADGA,AENA;ACFA,AJYA,AENA,ADGA,AENA;ACFA,AJYA,AENA,ADGA,AENA;ACFA,ACHA,ALeA,AENA,ADGA,AENA;ACFA,ACHA,ALeA,AENA,ADGA,AENA;ACFA,ACHA,ALeA,AENA,ADGA,AENA;AGRA,AFMA,ACHA,AHSA,ADGA,AENA;AGRA,AFMA,ACHA,AHSA,ADGA,AENA;AGRA,AFMA,ACHA,AHSA,ADGA,AENA;AGRA,AFMA,ACHA,AENA,ALeA,ADGA,AENA;AGRA,AFMA,ACHA,AENA,ALeA,ADGA,AENA;AGRA,AFMA,ACHA,AENA,ALeA,ADGA,AENA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,APqBA,AENA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,APqBA,AENA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,APqBA,AENA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,APqBA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,APqBA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,APqBA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA,ANkBA;AGRA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AMlBA,AENA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AQxBA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AQxBA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AQxBA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AQxBA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AQxBA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AQxBA,AT2BA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,ADGA,AQxBA;AHUA,AFMA,ACHA,AENA,ALeA,AOrBA;AHUA,AFMA,ACHA,AENA,ALeA,AOrBA;AHUA,AFMA,ACHA,AENA,ALeA,AOrBA;AHUA,AFMA,ACHA,AENA,ALeA,AOrBA;AHUA,AFMA,ACHA,AENA,ALeA,AOrBA;AHUA,AFMA,ACHA,AENA,ALeA,AOrBA;AHUA,AFMA,ACHA,AENA,ALeA,AOrBA;AHUA,ADGA,AENA,ALeA,AOrBA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ADGA,AENA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = exports.Polyline = exports.Polygon = exports.Line = exports.Arc = exports.Cubic = exports.Quad = void 0;\nvar quadratic_1 = require(\"./quadratic\");\nexports.Quad = quadratic_1.default;\nvar cubic_1 = require(\"./cubic\");\nexports.Cubic = cubic_1.default;\nvar arc_1 = require(\"./arc\");\nexports.Arc = arc_1.default;\nvar line_1 = require(\"./line\");\nexports.Line = line_1.default;\nvar polygon_1 = require(\"./polygon\");\nexports.Polygon = polygon_1.default;\nvar polyline_1 = require(\"./polyline\");\nexports.Polyline = polyline_1.default;\nvar Util = require(\"./util\");\nexports.Util = Util;\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar line_1 = require(\"./line\");\nvar util_1 = require(\"./util\");\nvar bezier_1 = require(\"./bezier\");\n// 差值公式\nfunction quadraticAt(p0, p1, p2, t) {\n    var onet = 1 - t;\n    return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;\n}\n// 求极值\nfunction extrema(p0, p1, p2) {\n    var a = p0 + p2 - 2 * p1;\n    if (util_1.isNumberEqual(a, 0)) {\n        return [0.5];\n    }\n    var rst = (p0 - p1) / a;\n    if (rst <= 1 && rst >= 0) {\n        return [rst];\n    }\n    return [];\n}\nfunction derivativeAt(p0, p1, p2, t) {\n    return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);\n}\n// 分割贝塞尔曲线\nfunction divideQuadratic(x1, y1, x2, y2, x3, y3, t) {\n    // 划分点\n    var xt = quadraticAt(x1, x2, x3, t);\n    var yt = quadraticAt(y1, y2, y3, t);\n    // 分割的第一条曲线的控制点\n    var controlPoint1 = line_1.default.pointAt(x1, y1, x2, y2, t);\n    // 分割的第二条曲线的控制点\n    var controlPoint2 = line_1.default.pointAt(x2, y2, x3, y3, t);\n    return [\n        [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],\n        [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3],\n    ];\n}\n// 使用迭代法取贝塞尔曲线的长度\nfunction quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {\n    if (iterationCount === 0) {\n        return (util_1.distance(x1, y1, x2, y2) + util_1.distance(x2, y2, x3, y3) + util_1.distance(x1, y1, x3, y3)) / 2;\n    }\n    var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);\n    var left = quadratics[0];\n    var right = quadratics[1];\n    left.push(iterationCount - 1);\n    right.push(iterationCount - 1);\n    return quadraticLength.apply(null, left) + quadraticLength.apply(null, right);\n}\nexports.default = {\n    box: function (x1, y1, x2, y2, x3, y3) {\n        var xExtrema = extrema(x1, x2, x3)[0];\n        var yExtrema = extrema(y1, y2, y3)[0];\n        // 控制点不加入 box 的计算\n        var xArr = [x1, x3];\n        var yArr = [y1, y3];\n        if (xExtrema !== undefined) {\n            xArr.push(quadraticAt(x1, x2, x3, xExtrema));\n        }\n        if (yExtrema !== undefined) {\n            yArr.push(quadraticAt(y1, y2, y3, yExtrema));\n        }\n        return util_1.getBBoxByArray(xArr, yArr);\n    },\n    length: function (x1, y1, x2, y2, x3, y3) {\n        return quadraticLength(x1, y1, x2, y2, x3, y3, 3);\n    },\n    nearestPoint: function (x1, y1, x2, y2, x3, y3, x0, y0) {\n        return bezier_1.nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);\n    },\n    pointDistance: function (x1, y1, x2, y2, x3, y3, x0, y0) {\n        var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);\n        return util_1.distance(point.x, point.y, x0, y0);\n    },\n    interpolationAt: quadraticAt,\n    pointAt: function (x1, y1, x2, y2, x3, y3, t) {\n        return {\n            x: quadraticAt(x1, x2, x3, t),\n            y: quadraticAt(y1, y2, y3, t),\n        };\n    },\n    divide: function (x1, y1, x2, y2, x3, y3, t) {\n        return divideQuadratic(x1, y1, x2, y2, x3, y3, t);\n    },\n    tangentAngle: function (x1, y1, x2, y2, x3, y3, t) {\n        var dx = derivativeAt(x1, x2, x3, t);\n        var dy = derivativeAt(y1, y2, y3, t);\n        var angle = Math.atan2(dy, dx);\n        return util_1.piMod(angle);\n    },\n};\n//# sourceMappingURL=quadratic.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar vec2 = require(\"gl-matrix/vec2\");\nexports.default = {\n    /**\n     * 计算线段的包围盒\n     * @param {number} x1 起始点 x\n     * @param {number} y1 起始点 y\n     * @param {number} x2 结束点 x\n     * @param {number} y2 结束点 y\n     * @return {object} 包围盒对象\n     */\n    box: function (x1, y1, x2, y2) {\n        return util_1.getBBoxByArray([x1, x2], [y1, y2]);\n    },\n    /**\n     * 线段的长度\n     * @param {number} x1 起始点 x\n     * @param {number} y1 起始点 y\n     * @param {number} x2 结束点 x\n     * @param {number} y2 结束点 y\n     * @return {number} 距离\n     */\n    length: function (x1, y1, x2, y2) {\n        return util_1.distance(x1, y1, x2, y2);\n    },\n    /**\n     * 根据比例获取点\n     * @param {number} x1 起始点 x\n     * @param {number} y1 起始点 y\n     * @param {number} x2 结束点 x\n     * @param {number} y2 结束点 y\n     * @param {number} t 指定比例\n     * @return {object} 包含 x, y 的点\n     */\n    pointAt: function (x1, y1, x2, y2, t) {\n        return {\n            x: (1 - t) * x1 + t * x2,\n            y: (1 - t) * y1 + t * y2,\n        };\n    },\n    /**\n     * 点到线段的距离\n     * @param {number} x1 起始点 x\n     * @param {number} y1 起始点 y\n     * @param {number} x2 结束点 x\n     * @param {number} y2 结束点 y\n     * @param {number} x  测试点 x\n     * @param {number} y  测试点 y\n     * @return {number} 距离\n     */\n    pointDistance: function (x1, y1, x2, y2, x, y) {\n        // 投影距离 x1, y1 的向量，假设 p, p1, p2 三个点，投影点为 a\n        // p1a = p1p.p1p2/|p1p2| * (p1p 的单位向量)\n        var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n        if (cross < 0) {\n            return util_1.distance(x1, y1, x, y);\n        }\n        var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n        if (cross > lengthSquare) {\n            return util_1.distance(x2, y2, x, y);\n        }\n        return this.pointToLine(x1, y1, x2, y2, x, y);\n    },\n    /**\n     * 点到直线的距离，而不是点到线段的距离\n     * @param {number} x1 起始点 x\n     * @param {number} y1 起始点 y\n     * @param {number} x2 结束点 x\n     * @param {number} y2 结束点 y\n     * @param {number} x  测试点 x\n     * @param {number} y  测试点 y\n     * @return {number} 距离\n     */\n    pointToLine: function (x1, y1, x2, y2, x, y) {\n        var d = [x2 - x1, y2 - y1];\n        // 如果端点相等，则判定点到点的距离\n        if (vec2.exactEquals(d, [0, 0])) {\n            return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n        }\n        var u = [-d[1], d[0]];\n        vec2.normalize(u, u);\n        var a = [x - x1, y - y1];\n        return Math.abs(vec2.dot(a, u));\n    },\n    /**\n     * 线段的角度\n     * @param {number} x1 起始点 x\n     * @param {number} y1 起始点 y\n     * @param {number} x2 结束点 x\n     * @param {number} y2 结束点 y\n     * @return {number} 导数\n     */\n    tangentAngle: function (x1, y1, x2, y2) {\n        return Math.atan2(y2 - y1, x2 - x1);\n    },\n};\n//# sourceMappingURL=line.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.piMod = exports.getBBoxRange = exports.getBBoxByArray = exports.isNumberEqual = exports.distance = void 0;\nvar util_1 = require(\"@antv/util\");\n/**\n * 两点之间的距离\n * @param {number} x1 起始点 x\n * @param {number} y1 起始点 y\n * @param {number} x2 结束点 x\n * @param {number} y2 结束点 y\n * @return {number} 距离\n */\nfunction distance(x1, y1, x2, y2) {\n    var dx = x1 - x2;\n    var dy = y1 - y2;\n    return Math.sqrt(dx * dx + dy * dy);\n}\nexports.distance = distance;\nfunction isNumberEqual(v1, v2) {\n    return Math.abs(v1 - v2) < 0.001;\n}\nexports.isNumberEqual = isNumberEqual;\nfunction getBBoxByArray(xArr, yArr) {\n    var minX = util_1.min(xArr);\n    var minY = util_1.min(yArr);\n    var maxX = util_1.max(xArr);\n    var maxY = util_1.max(yArr);\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY,\n    };\n}\nexports.getBBoxByArray = getBBoxByArray;\nfunction getBBoxRange(x1, y1, x2, y2) {\n    return {\n        minX: util_1.min([x1, x2]),\n        maxX: util_1.max([x1, x2]),\n        minY: util_1.min([y1, y2]),\n        maxY: util_1.max([y1, y2]),\n    };\n}\nexports.getBBoxRange = getBBoxRange;\nfunction piMod(angle) {\n    return (angle + Math.PI * 2) % (Math.PI * 2);\n}\nexports.piMod = piMod;\n//# sourceMappingURL=util.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.snapLength = exports.nearestPoint = void 0;\nvar util_1 = require(\"./util\");\nvar EPSILON = 0.0001;\n/**\n * 使用牛顿切割法求最近的点\n * @param {number[]} xArr      点的 x 数组\n * @param {number[]} yArr      点的 y 数组\n * @param {number}   x         指定的点 x\n * @param {number}   y         指定的点 y\n * @param {Function} tCallback 差值函数\n */\nfunction nearestPoint(xArr, yArr, x, y, tCallback, length) {\n    var t;\n    var d = Infinity;\n    var v0 = [x, y];\n    var segNum = 20;\n    if (length && length > 200) {\n        segNum = length / 10;\n    }\n    var increaseRate = 1 / segNum;\n    var interval = increaseRate / 10;\n    for (var i = 0; i <= segNum; i++) {\n        var _t = i * increaseRate;\n        var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];\n        var d1 = util_1.distance(v0[0], v0[1], v1[0], v1[1]);\n        if (d1 < d) {\n            t = _t;\n            d = d1;\n        }\n    }\n    // 提前终止\n    if (t === 0) {\n        return {\n            x: xArr[0],\n            y: yArr[0],\n        };\n    }\n    if (t === 1) {\n        var count = xArr.length;\n        return {\n            x: xArr[count - 1],\n            y: yArr[count - 1],\n        };\n    }\n    d = Infinity;\n    for (var i = 0; i < 32; i++) {\n        if (interval < EPSILON) {\n            break;\n        }\n        var prev = t - interval;\n        var next = t + interval;\n        var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];\n        var d1 = util_1.distance(v0[0], v0[1], v1[0], v1[1]);\n        if (prev >= 0 && d1 < d) {\n            t = prev;\n            d = d1;\n        }\n        else {\n            var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];\n            var d2 = util_1.distance(v0[0], v0[1], v2[0], v2[1]);\n            if (next <= 1 && d2 < d) {\n                t = next;\n                d = d2;\n            }\n            else {\n                interval *= 0.5;\n            }\n        }\n    }\n    return {\n        x: tCallback.apply(null, xArr.concat([t])),\n        y: tCallback.apply(null, yArr.concat([t])),\n    };\n}\nexports.nearestPoint = nearestPoint;\n// 近似求解 https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2\nfunction snapLength(xArr, yArr) {\n    var totalLength = 0;\n    var count = xArr.length;\n    for (var i = 0; i < count; i++) {\n        var x = xArr[i];\n        var y = yArr[i];\n        var nextX = xArr[(i + 1) % count];\n        var nextY = yArr[(i + 1) % count];\n        totalLength += util_1.distance(x, y, nextX, nextY);\n    }\n    return totalLength / 2;\n}\nexports.snapLength = snapLength;\n//# sourceMappingURL=bezier.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar line_1 = require(\"./line\");\nvar bezier_1 = require(\"./bezier\");\nfunction cubicAt(p0, p1, p2, p3, t) {\n    var onet = 1 - t; // t * t * t 的性能大概是 Math.pow(t, 3) 的三倍\n    return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;\n}\nfunction derivativeAt(p0, p1, p2, p3, t) {\n    var onet = 1 - t;\n    return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));\n}\nfunction extrema(p0, p1, p2, p3) {\n    var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\n    var b = 6 * p0 - 12 * p1 + 6 * p2;\n    var c = 3 * p1 - 3 * p0;\n    var extremas = [];\n    var t1;\n    var t2;\n    var discSqrt;\n    if (util_1.isNumberEqual(a, 0)) {\n        if (!util_1.isNumberEqual(b, 0)) {\n            t1 = -c / b;\n            if (t1 >= 0 && t1 <= 1) {\n                extremas.push(t1);\n            }\n        }\n    }\n    else {\n        var disc = b * b - 4 * a * c;\n        if (util_1.isNumberEqual(disc, 0)) {\n            extremas.push(-b / (2 * a));\n        }\n        else if (disc > 0) {\n            discSqrt = Math.sqrt(disc);\n            t1 = (-b + discSqrt) / (2 * a);\n            t2 = (-b - discSqrt) / (2 * a);\n            if (t1 >= 0 && t1 <= 1) {\n                extremas.push(t1);\n            }\n            if (t2 >= 0 && t2 <= 1) {\n                extremas.push(t2);\n            }\n        }\n    }\n    return extremas;\n}\n// 分割贝塞尔曲线\nfunction divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {\n    // 划分点\n    var xt = cubicAt(x1, x2, x3, x4, t);\n    var yt = cubicAt(y1, y2, y3, y4, t);\n    // 计算两点之间的差值点\n    var c1 = line_1.default.pointAt(x1, y1, x2, y2, t);\n    var c2 = line_1.default.pointAt(x2, y2, x3, y3, t);\n    var c3 = line_1.default.pointAt(x3, y3, x4, y4, t);\n    var c12 = line_1.default.pointAt(c1.x, c1.y, c2.x, c2.y, t);\n    var c23 = line_1.default.pointAt(c2.x, c2.y, c3.x, c3.y, t);\n    return [\n        [x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt],\n        [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4],\n    ];\n}\n// 使用迭代法取贝塞尔曲线的长度，二阶和三阶分开写，更清晰和便于调试\nfunction cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {\n    if (iterationCount === 0) {\n        return bezier_1.snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);\n    }\n    var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);\n    var left = cubics[0];\n    var right = cubics[1];\n    left.push(iterationCount - 1);\n    right.push(iterationCount - 1);\n    return cubicLength.apply(null, left) + cubicLength.apply(null, right);\n}\nexports.default = {\n    extrema: extrema,\n    box: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n        var xArr = [x1, x4];\n        var yArr = [y1, y4];\n        var xExtrema = extrema(x1, x2, x3, x4);\n        var yExtrema = extrema(y1, y2, y3, y4);\n        for (var i = 0; i < xExtrema.length; i++) {\n            xArr.push(cubicAt(x1, x2, x3, x4, xExtrema[i]));\n        }\n        for (var i = 0; i < yExtrema.length; i++) {\n            yArr.push(cubicAt(y1, y2, y3, y4, yExtrema[i]));\n        }\n        return util_1.getBBoxByArray(xArr, yArr);\n    },\n    length: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n        // 迭代三次，划分成 8 段求长度\n        return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);\n    },\n    nearestPoint: function (x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {\n        return bezier_1.nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length);\n    },\n    pointDistance: function (x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {\n        var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length);\n        return util_1.distance(point.x, point.y, x0, y0);\n    },\n    interpolationAt: cubicAt,\n    pointAt: function (x1, y1, x2, y2, x3, y3, x4, y4, t) {\n        return {\n            x: cubicAt(x1, x2, x3, x4, t),\n            y: cubicAt(y1, y2, y3, y4, t),\n        };\n    },\n    divide: function (x1, y1, x2, y2, x3, y3, x4, y4, t) {\n        return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);\n    },\n    tangentAngle: function (x1, y1, x2, y2, x3, y3, x4, y4, t) {\n        var dx = derivativeAt(x1, x2, x3, x4, t);\n        var dy = derivativeAt(y1, y2, y3, y4, t);\n        return util_1.piMod(Math.atan2(dy, dx));\n    },\n};\n//# sourceMappingURL=cubic.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar ellipse_1 = require(\"./ellipse\");\n// 偏导数 x\nfunction derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {\n    return -1 * rx * Math.cos(xRotation) * Math.sin(angle) - ry * Math.sin(xRotation) * Math.cos(angle);\n}\n// 偏导数 y\nfunction derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {\n    return -1 * rx * Math.sin(xRotation) * Math.sin(angle) + ry * Math.cos(xRotation) * Math.cos(angle);\n}\n// x 的极值\nfunction xExtrema(rx, ry, xRotation) {\n    return Math.atan((-ry / rx) * Math.tan(xRotation));\n}\n// y 的极值\nfunction yExtrema(rx, ry, xRotation) {\n    return Math.atan(ry / (rx * Math.tan(xRotation)));\n}\n// 根据角度求 x 坐标\nfunction xAt(cx, cy, rx, ry, xRotation, angle) {\n    return rx * Math.cos(xRotation) * Math.cos(angle) - ry * Math.sin(xRotation) * Math.sin(angle) + cx;\n}\n// 根据角度求 y 坐标\nfunction yAt(cx, cy, rx, ry, xRotation, angle) {\n    return rx * Math.sin(xRotation) * Math.cos(angle) + ry * Math.cos(xRotation) * Math.sin(angle) + cy;\n}\n// 获取点在椭圆上的角度\nfunction getAngle(rx, ry, x0, y0) {\n    var angle = Math.atan2(y0 * rx, x0 * ry);\n    // 转换到 0 - 2PI 内\n    return (angle + Math.PI * 2) % (Math.PI * 2);\n}\n// 根据角度获取，x,y\nfunction getPoint(rx, ry, angle) {\n    return {\n        x: rx * Math.cos(angle),\n        y: ry * Math.sin(angle),\n    };\n}\n// 旋转\nfunction rotate(x, y, angle) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    return [x * cos - y * sin, x * sin + y * cos];\n}\nexports.default = {\n    /**\n     * 计算包围盒\n     * @param {number} cx         圆心 x\n     * @param {number} cy         圆心 y\n     * @param {number} rx         x 轴方向的半径\n     * @param {number} ry         y 轴方向的半径\n     * @param {number} xRotation  旋转角度\n     * @param {number} startAngle 起始角度\n     * @param {number} endAngle   结束角度\n     * @return {object} 包围盒对象\n     */\n    box: function (cx, cy, rx, ry, xRotation, startAngle, endAngle) {\n        var xDim = xExtrema(rx, ry, xRotation);\n        var minX = Infinity;\n        var maxX = -Infinity;\n        var xs = [startAngle, endAngle];\n        for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n            var xAngle = xDim + i;\n            if (startAngle < endAngle) {\n                if (startAngle < xAngle && xAngle < endAngle) {\n                    xs.push(xAngle);\n                }\n            }\n            else {\n                if (endAngle < xAngle && xAngle < startAngle) {\n                    xs.push(xAngle);\n                }\n            }\n        }\n        for (var i = 0; i < xs.length; i++) {\n            var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);\n            if (x < minX) {\n                minX = x;\n            }\n            if (x > maxX) {\n                maxX = x;\n            }\n        }\n        var yDim = yExtrema(rx, ry, xRotation);\n        var minY = Infinity;\n        var maxY = -Infinity;\n        var ys = [startAngle, endAngle];\n        for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n            var yAngle = yDim + i;\n            if (startAngle < endAngle) {\n                if (startAngle < yAngle && yAngle < endAngle) {\n                    ys.push(yAngle);\n                }\n            }\n            else {\n                if (endAngle < yAngle && yAngle < startAngle) {\n                    ys.push(yAngle);\n                }\n            }\n        }\n        for (var i = 0; i < ys.length; i++) {\n            var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);\n            if (y < minY) {\n                minY = y;\n            }\n            if (y > maxY) {\n                maxY = y;\n            }\n        }\n        return {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY,\n        };\n    },\n    /**\n     * 获取圆弧的长度，计算圆弧长度时不考虑旋转角度，\n     * 仅跟 rx, ry, startAngle, endAngle 相关\n     * @param {number} cx         圆心 x\n     * @param {number} cy         圆心 y\n     * @param {number} rx         x 轴方向的半径\n     * @param {number} ry         y 轴方向的半径\n     * @param {number} xRotation  旋转角度\n     * @param {number} startAngle 起始角度\n     * @param {number} endAngle   结束角度\n     */\n    length: function (cx, cy, rx, ry, xRotation, startAngle, endAngle) { },\n    /**\n     * 获取指定点到圆弧的最近距离的点\n     * @param {number} cx         圆心 x\n     * @param {number} cy         圆心 y\n     * @param {number} rx         x 轴方向的半径\n     * @param {number} ry         y 轴方向的半径\n     * @param {number} xRotation  旋转角度\n     * @param {number} startAngle 起始角度\n     * @param {number} endAngle   结束角度\n     * @param {number} x0         指定点的 x\n     * @param {number} y0         指定点的 y\n     * @return {object} 到指定点最近距离的点\n     */\n    nearestPoint: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {\n        // 将最近距离问题转换成到椭圆中心 0,0 没有旋转的椭圆问题\n        var relativeVector = rotate(x0 - cx, y0 - cy, -xRotation);\n        var x1 = relativeVector[0], y1 = relativeVector[1];\n        // 计算点到椭圆的最近的点\n        var relativePoint = ellipse_1.default.nearestPoint(0, 0, rx, ry, x1, y1);\n        // 获取点在椭圆上的角度\n        var angle = getAngle(rx, ry, relativePoint.x, relativePoint.y);\n        // 点没有在圆弧上\n        if (angle < startAngle) {\n            // 小于起始圆弧\n            relativePoint = getPoint(rx, ry, startAngle);\n        }\n        else if (angle > endAngle) {\n            // 大于结束圆弧\n            relativePoint = getPoint(rx, ry, endAngle);\n        }\n        // 旋转到 xRotation 的角度\n        var vector = rotate(relativePoint.x, relativePoint.y, xRotation);\n        return {\n            x: vector[0] + cx,\n            y: vector[1] + cy,\n        };\n    },\n    pointDistance: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {\n        var nearestPoint = this.nearestPoint(cx, cy, rx, ry, x0, y0);\n        return util_1.distance(nearestPoint.x, nearestPoint.y, x0, y0);\n    },\n    pointAt: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {\n        var angle = (endAngle - startAngle) * t + startAngle;\n        return {\n            x: xAt(cx, cy, rx, ry, xRotation, angle),\n            y: yAt(cx, cy, rx, ry, xRotation, angle),\n        };\n    },\n    tangentAngle: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {\n        var angle = (endAngle - startAngle) * t + startAngle;\n        var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\n        var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\n        return util_1.piMod(Math.atan2(dy, dx));\n    },\n};\n//# sourceMappingURL=arc.js.map","\n/**\n * @fileoverview 椭圆的一些计算，\n *  - 周长计算参考：https://www.mathsisfun.com/geometry/ellipse-perimeter.html\n *  - 距离计算参考：https://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/\n * @author dxq613@gmail.com\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nfunction copysign(v1, v2) {\n    var absv = Math.abs(v1);\n    return v2 > 0 ? absv : absv * -1;\n}\nexports.default = {\n    /**\n     * 包围盒计算\n     * @param {number} x  椭圆中心 x\n     * @param {number} y  椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @return {object} 包围盒\n     */\n    box: function (x, y, rx, ry) {\n        return {\n            x: x - rx,\n            y: y - ry,\n            width: rx * 2,\n            height: ry * 2,\n        };\n    },\n    /**\n     * 计算周长，使用近似法\n     * @param {number} x  椭圆中心 x\n     * @param {number} y  椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @return {number} 椭圆周长\n     */\n    length: function (x, y, rx, ry) {\n        return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));\n    },\n    /**\n     * 距离椭圆最近的点\n     * @param {number} x  椭圆中心 x\n     * @param {number} y  椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @param {number} x0  指定的点 x\n     * @param {number} y0  指定的点 y\n     * @return {object} 椭圆上距离指定点最近的点\n     */\n    nearestPoint: function (x, y, rx, ry, x0, y0) {\n        var a = rx;\n        var b = ry;\n        // 假如椭圆半径为0则返回圆心\n        if (a === 0 || b === 0) {\n            return {\n                x: x,\n                y: y,\n            };\n        }\n        // 转换成 0， 0 为中心的椭圆计算\n        var relativeX = x0 - x;\n        var relativeY = y0 - y;\n        var px = Math.abs(relativeX);\n        var py = Math.abs(relativeY);\n        var squareA = a * a;\n        var squareB = b * b;\n        // const angle0 = Math.atan2(relativeY, relativeX);\n        var t = Math.PI / 4;\n        var nearestX; // 椭圆上的任一点\n        var nearestY;\n        // 迭代 4 次\n        for (var i = 0; i < 4; i++) {\n            nearestX = a * Math.cos(t);\n            nearestY = b * Math.sin(t);\n            var ex = ((squareA - squareB) * Math.pow(Math.cos(t), 3)) / a;\n            var ey = ((squareB - squareA) * Math.pow(Math.sin(t), 3)) / b;\n            var rx1 = nearestX - ex;\n            var ry1 = nearestY - ey;\n            var qx = px - ex;\n            var qy = py - ey;\n            var r = Math.hypot(ry1, rx1);\n            var q = Math.hypot(qy, qx);\n            var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\n            var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\n            t += delta_t;\n            t = Math.min(Math.PI / 2, Math.max(0, t));\n        }\n        return {\n            x: x + copysign(nearestX, relativeX),\n            y: y + copysign(nearestY, relativeY),\n        };\n    },\n    /**\n     * 点到椭圆最近的距离\n     * @param {number} x  椭圆中心 x\n     * @param {number} y  椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @param {number} x0  指定的点 x\n     * @param {number} y0  指定的点 y\n     * @return {number} 点到椭圆的距离\n     */\n    pointDistance: function (x, y, rx, ry, x0, y0) {\n        var nearestPoint = this.nearestPoint(x, y, rx, ry, x0, y0);\n        return util_1.distance(nearestPoint.x, nearestPoint.y, x0, y0);\n    },\n    /**\n     * 根据比例获取点\n     * @param {number} x 椭圆中心 x\n     * @param {number} y 椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @param {number} t 指定比例，x轴方向为 0\n     * @return {object} 点\n     */\n    pointAt: function (x, y, rx, ry, t) {\n        var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n        return {\n            x: x + rx * Math.cos(angle),\n            y: y + ry * Math.sin(angle),\n        };\n    },\n    /**\n     * 根据比例计算切线角度\n     * @param {number} x 椭圆中心 x\n     * @param {number} y 椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @param {number} t 指定比例 0 - 1 之间，x轴方向为 0。在 0-1 范围之外是循环还是返回 null，还需要调整\n     * @return {number} 角度，在 0 - 2PI 之间\n     */\n    tangentAngle: function (x, y, rx, ry, t) {\n        var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n        // 直接使用 x,y 的导数计算， x' = -rx * sin(t); y' = ry * cos(t);\n        var tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle));\n        // 也可以使用指定点的切线方程计算，成本有些高\n        // const point = this.pointAt(0, 0, rx, ry, t); // 椭圆的切线同椭圆的中心不相关\n        // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));\n        // if (angle >= 0 && angle <= Math.PI) {\n        //   tangentAngle += Math.PI;\n        // }\n        return util_1.piMod(tangentAngle);\n    },\n};\n//# sourceMappingURL=ellipse.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar segments_1 = require(\"./segments\");\nvar polyline_1 = require(\"./polyline\");\nfunction getAllPoints(points) {\n    var tmp = points.slice(0);\n    if (points.length) {\n        tmp.push(points[0]);\n    }\n    return tmp;\n}\nexports.default = {\n    /**\n     * 计算多边形的包围盒\n     * @param {array} points 点的集合 [x,y] 的形式\n     * @return {object} 包围盒\n     */\n    box: function (points) {\n        return polyline_1.default.box(points);\n    },\n    /**\n     * 计算多边形的长度\n     * @param {array} points 点的集合 [x,y] 的形式\n     * @return {object} 多边形边的长度\n     */\n    length: function (points) {\n        return segments_1.lengthOfSegment(getAllPoints(points));\n    },\n    /**\n     * 根据比例获取多边形的点\n     * @param {array} points 点的集合 [x,y] 的形式\n     * @param {number} t 在多边形的长度上的比例\n     * @return {object} 根据比例值计算出来的点\n     */\n    pointAt: function (points, t) {\n        return segments_1.pointAtSegments(getAllPoints(points), t);\n    },\n    /**\n     * 指定点到多边形的距离\n     * @param {array} points 点的集合 [x,y] 的形式\n     * @param {number} x 指定点的 x\n     * @param {number} y 指定点的 y\n     * @return {number} 点到多边形的距离\n     */\n    pointDistance: function (points, x, y) {\n        return segments_1.distanceAtSegment(getAllPoints(points), x, y);\n    },\n    /**\n     * 根据比例获取多边形的切线角度\n     * @param {array} points 点的集合 [x,y] 的形式\n     * @param {number} t 在多边形的长度上的比例\n     * @return {object} 根据比例值计算出来的角度\n     */\n    tangentAngle: function (points, t) {\n        return segments_1.angleAtSegments(getAllPoints(points), t);\n    },\n};\n//# sourceMappingURL=polygon.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.distanceAtSegment = exports.angleAtSegments = exports.pointAtSegments = exports.lengthOfSegment = void 0;\nvar line_1 = require(\"./line\");\nvar util_1 = require(\"./util\");\nfunction analyzePoints(points) {\n    // 计算每段的长度和总的长度\n    var totalLength = 0;\n    var segments = [];\n    for (var i = 0; i < points.length - 1; i++) {\n        var from = points[i];\n        var to = points[i + 1];\n        var length_1 = util_1.distance(from[0], from[1], to[0], to[1]);\n        var seg = {\n            from: from,\n            to: to,\n            length: length_1,\n        };\n        segments.push(seg);\n        totalLength += length_1;\n    }\n    return { segments: segments, totalLength: totalLength };\n}\nfunction lengthOfSegment(points) {\n    if (points.length < 2) {\n        return 0;\n    }\n    var totalLength = 0;\n    for (var i = 0; i < points.length - 1; i++) {\n        var from = points[i];\n        var to = points[i + 1];\n        totalLength += util_1.distance(from[0], from[1], to[0], to[1]);\n    }\n    return totalLength;\n}\nexports.lengthOfSegment = lengthOfSegment;\n/**\n * 按照比例在数据片段中获取点\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n * @return {object} 点的坐标\n */\nfunction pointAtSegments(points, t) {\n    // 边界判断\n    if (t > 1 || t < 0 || points.length < 2) {\n        return null;\n    }\n    var _a = analyzePoints(points), segments = _a.segments, totalLength = _a.totalLength;\n    // 多个点有可能重合\n    if (totalLength === 0) {\n        return {\n            x: points[0][0],\n            y: points[0][1],\n        };\n    }\n    // 计算比例\n    var startRatio = 0;\n    var point = null;\n    for (var i = 0; i < segments.length; i++) {\n        var seg = segments[i];\n        var from = seg.from, to = seg.to;\n        var currentRatio = seg.length / totalLength;\n        if (t >= startRatio && t <= startRatio + currentRatio) {\n            var localRatio = (t - startRatio) / currentRatio;\n            point = line_1.default.pointAt(from[0], from[1], to[0], to[1], localRatio);\n            break;\n        }\n        startRatio += currentRatio;\n    }\n    return point;\n}\nexports.pointAtSegments = pointAtSegments;\n/**\n * 按照比例在数据片段中获取切线的角度\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n */\nfunction angleAtSegments(points, t) {\n    // 边界判断\n    if (t > 1 || t < 0 || points.length < 2) {\n        return 0;\n    }\n    var _a = analyzePoints(points), segments = _a.segments, totalLength = _a.totalLength;\n    // 计算比例\n    var startRatio = 0;\n    var angle = 0;\n    for (var i = 0; i < segments.length; i++) {\n        var seg = segments[i];\n        var from = seg.from, to = seg.to;\n        var currentRatio = seg.length / totalLength;\n        if (t >= startRatio && t <= startRatio + currentRatio) {\n            angle = Math.atan2(to[1] - from[1], to[0] - from[0]);\n            break;\n        }\n        startRatio += currentRatio;\n    }\n    return angle;\n}\nexports.angleAtSegments = angleAtSegments;\nfunction distanceAtSegment(points, x, y) {\n    var minDistance = Infinity;\n    for (var i = 0; i < points.length - 1; i++) {\n        var point = points[i];\n        var nextPoint = points[i + 1];\n        var distance_1 = line_1.default.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);\n        if (distance_1 < minDistance) {\n            minDistance = distance_1;\n        }\n    }\n    return minDistance;\n}\nexports.distanceAtSegment = distanceAtSegment;\n//# sourceMappingURL=segments.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar segments_1 = require(\"./segments\");\nvar util_1 = require(\"./util\");\nexports.default = {\n    /**\n     * 计算多折线的包围盒\n     * @param {array} points 点的集合 [x,y] 的形式\n     * @return {object} 包围盒\n     */\n    box: function (points) {\n        var xArr = [];\n        var yArr = [];\n        for (var i = 0; i < points.length; i++) {\n            var point = points[i];\n            xArr.push(point[0]);\n            yArr.push(point[1]);\n        }\n        return util_1.getBBoxByArray(xArr, yArr);\n    },\n    /**\n     * 计算多折线的长度\n     * @param {array} points 点的集合 [x,y] 的形式\n     * @return {object} 多条边的长度\n     */\n    length: function (points) {\n        return segments_1.lengthOfSegment(points);\n    },\n    /**\n     * 根据比例获取多折线的点\n     * @param {array} points 点的集合 [x,y] 的形式\n     * @param {number} t 在多折线的长度上的比例\n     * @return {object} 根据比例值计算出来的点\n     */\n    pointAt: function (points, t) {\n        return segments_1.pointAtSegments(points, t);\n    },\n    /**\n     * 指定点到多折线的距离\n     * @param {array} points 点的集合 [x,y] 的形式\n     * @param {number} x 指定点的 x\n     * @param {number} y 指定点的 y\n     * @return {number} 点到多折线的距离\n     */\n    pointDistance: function (points, x, y) {\n        return segments_1.distanceAtSegment(points, x, y);\n    },\n    /**\n     * 根据比例获取多折线的切线角度\n     * @param {array} points 点的集合 [x,y] 的形式\n     * @param {number} t 在多折线的长度上的比例\n     * @return {object} 根据比例值计算出来的角度\n     */\n    tangentAngle: function (points, t) {\n        return segments_1.angleAtSegments(points, t);\n    },\n};\n//# sourceMappingURL=polyline.js.map"]}