{"version":3,"sources":["index.js","parse-path.js","catmull-rom-2-bezier.js","fill-path.js","fill-path-by-diff.js","format-path.js","path-intersection.js","rect-path.js","path-2-curve.js","path-2-absolute.js","parse-path-string.js","process/segment-2-cubic.js","process/arc-2-cubic.js","process/quad-2-cubic.js","process/line-2-cubic.js","parse-path-array.js","get-arc-params.js","path-2-segments.js","get-line-intersect.js","is-polygons-intersect.js","point-in-polygon.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,ACHA,AHSA,ACHA;ACFA,ACHA,AHSA,ACHA;ACFA,ACHA,AHSA,ACHA;ACFA,AENA,ADGA,AHSA,ACHA;ACFA,AENA,ADGA,AHSA,ACHA;ACFA,AENA,ADGA,AHSA,ACHA;ACFA,AENA,ADGA,AENA,ALeA,ACHA;ACFA,AENA,ADGA,AENA,ALeA,ACHA;ACFA,AENA,ADGA,AENA,ALeA,ACHA;ACFA,AENA,ADGA,AENA,ALeA,ACHA,AKfA;AJaA,AENA,ADGA,AENA,ALeA,ACHA,AKfA;AJaA,AENA,ADGA,AENA,ALeA,ACHA,AKfA;AJaA,AENA,ADGA,AENA,ALeA,ACHA,AKfA,ACHA;ALgBA,AENA,ADGA,AENA,ALeA,ACHA,AKfA,ACHA;ALgBA,AENA,ADGA,AENA,ALeA,ACHA,AKfA,ACHA;ALgBA,AENA,ADGA,AENA,ALeA,ACHA,AOrBA,AFMA,ACHA;ALgBA,AENA,ADGA,AENA,ALeA,ACHA,AOrBA,AFMA,ACHA;ALgBA,AENA,ADGA,AENA,ALeA,ACHA,AOrBA,AFMA,ACHA;ALgBA,AENA,ADGA,AENA,ALeA,ACHA,AQxBA,ADGA,AFMA,ACHA;ALgBA,AENA,ADGA,AENA,ALeA,ACHA,AQxBA,ADGA,AFMA,ACHA;ALgBA,AENA,ADGA,AENA,ALeA,ACHA,AQxBA,ADGA,AFMA,ACHA;ALgBA,AENA,ADGA,AENA,ALeA,AU9BA,AT2BA,AQxBA,ADGA,AFMA,ACHA;ALgBA,AENA,ADGA,AENA,ALeA,AU9BA,AT2BA,AQxBA,ADGA,AFMA,ACHA;ALgBA,AENA,ADGA,AENA,ALeA,AU9BA,AT2BA,AQxBA,ADGA,AFMA,ACHA;ALgBA,AENA,ADGA,AENA,ALeA,AU9BA,AT2BA,AQxBA,ADGA,AFMA,AKfA,AJYA;ALgBA,AENA,ADGA,AENA,ALeA,AU9BA,AT2BA,AQxBA,ADGA,AFMA,AKfA,AJYA;ALgBA,AENA,ADGA,AENA,ALeA,AU9BA,AT2BA,AQxBA,ADGA,AFMA,AKfA,AJYA;ALgBA,AENA,ADGA,AENA,AKfA,AT2BA,AQxBA,ADGA,AFMA,AMlBA,ADGA,AJYA;ALgBA,AENA,ADGA,AENA,AKfA,AT2BA,AQxBA,ADGA,AFMA,AMlBA,ADGA,AJYA;ALgBA,AENA,ADGA,AENA,AKfA,AT2BA,AQxBA,ADGA,AFMA,AMlBA,ADGA,AJYA;ALgBA,AENA,ADGA,AENA,AKfA,AT2BA,AQxBA,ADGA,AFMA,AMlBA,ACHA,AFMA,AJYA;ALgBA,AENA,ADGA,AENA,AKfA,ADGA,ADGA,AFMA,AMlBA,ACHA,AFMA,AJYA;ALgBA,AENA,ADGA,AENA,AKfA,ADGA,ADGA,AFMA,AMlBA,ACHA,AFMA,AJYA;ALgBA,AENA,ADGA,AENA,AKfA,ADGA,ADGA,AFMA,AMlBA,AENA,ADGA,AFMA,AJYA;ALgBA,AENA,ADGA,AENA,AKfA,ADGA,ADGA,AFMA,AMlBA,AENA,ADGA,AFMA,AJYA;ALgBA,AENA,ADGA,AENA,AKfA,ADGA,ADGA,AFMA,AMlBA,AENA,ADGA,AFMA,AJYA;ALgBA,AENA,ADGA,AENA,AU9BA,ALeA,ADGA,ADGA,AFMA,AMlBA,AENA,ADGA,AFMA,AJYA;ALgBA,AENA,ADGA,AENA,AU9BA,ALeA,ADGA,ADGA,AFMA,AMlBA,AENA,ADGA,AFMA,AJYA;ALgBA,AENA,ADGA,AENA,AU9BA,ALeA,ADGA,ADGA,AFMA,AMlBA,AENA,ADGA,AFMA,AJYA;ALgBA,AENA,ADGA,AENA,AWjCA,ADGA,ALeA,ADGA,ADGA,AFMA,AMlBA,AENA,ADGA,AFMA,AJYA;ALgBA,AENA,ADGA,AENA,AWjCA,ADGA,ALeA,ADGA,ADGA,AFMA,AMlBA,AENA,ADGA,AFMA;AT4BA,AENA,ADGA,AENA,AWjCA,ADGA,ALeA,ADGA,ADGA,AFMA,AMlBA,AENA,ADGA,AFMA;AT4BA,AENA,ADGA,AENA,AWjCA,ADGA,ALeA,ADGA,ADGA,AS3BA,AXiCA,AMlBA,AENA,ADGA,AFMA;AT4BA,AENA,ADGA,AENA,AWjCA,ADGA,ALeA,ADGA,ADGA,AS3BA,AXiCA,AMlBA,AENA,ADGA,AFMA;AT4BA,AENA,ADGA,AENA,AWjCA,ANkBA,ADGA,ADGA,AS3BA,AXiCA,AMlBA,AENA,ADGA,AFMA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ARwBA,ADGA,ADGA,AS3BA,AXiCA,AMlBA,AENA,ADGA,AFMA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ARwBA,ADGA,ADGA,AS3BA,AXiCA,AMlBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ARwBA,ADGA,ADGA,AS3BA,AXiCA,AMlBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,AMlBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,AMlBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,AMlBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA,AHSA;AT4BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA;AZqCA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA;AZqCA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA;AZqCA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA;AZqCA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA;AZqCA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA;AZqCA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA,AENA;AZqCA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,ADGA,AS3BA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AENA,ACHA,AT2BA,ADGA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,Ac1CA,ARwBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AV+BA,AENA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;ARyBA,ADGA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AT4BA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AT4BA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AT4BA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AT4BA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AT4BA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AT4BA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AT4BA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AT4BA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AT4BA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AT4BA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AT4BA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AT4BA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;AT4BA,AENA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;APsBA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;APsBA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;APsBA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;APsBA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;APsBA,AWjCA,AGTA,AV8BA,AQxBA,AXiCA,AMlBA;APsBA,Ac1CA,AV8BA,AQxBA,AXiCA,AMlBA;APsBA,Ac1CA,AV8BA,AQxBA,AXiCA,AMlBA;APsBA,Ac1CA,AV8BA,AQxBA,AXiCA,AMlBA;APsBA,Ac1CA,AV8BA,AQxBA,AXiCA,AMlBA;APsBA,Ac1CA,AV8BA,AQxBA,AXiCA,AMlBA;AOpBA,AV8BA,AQxBA,AXiCA,AMlBA;AOpBA,AV8BA,AQxBA,AXiCA,AMlBA;AOpBA,AV8BA,AQxBA,AXiCA,AMlBA;AOpBA,AV8BA,AQxBA,AXiCA,AMlBA;AOpBA,AV8BA,AQxBA,AXiCA,AMlBA;AOpBA,AV8BA,AQxBA,AXiCA,AMlBA;AOpBA,AV8BA,AQxBA,AXiCA,AMlBA;AOpBA,AV8BA,AQxBA,AXiCA,AMlBA;AOpBA,AV8BA,AQxBA,AXiCA,AMlBA;AOpBA,AV8BA,AQxBA,AXiCA,AMlBA;AOpBA,AV8BA,AQxBA,AXiCA,AMlBA;AOpBA,AFMA,AXiCA,AMlBA;AOpBA,AFMA,AXiCA,AMlBA;AOpBA,AFMA,AXiCA,AMlBA;AOpBA,AFMA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA,AMlBA;AKdA,AXiCA;AWhCA,AXiCA;AWhCA,AXiCA;AWhCA,AXiCA;AWhCA,AXiCA;AWhCA,AXiCA;AWhCA,AXiCA;AWhCA,AXiCA;AWhCA,AXiCA;AWhCA,AXiCA;AWhCA,AXiCA;AWhCA,AXiCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isPointInPolygon = exports.isPolygonsIntersect = exports.getLineIntersect = exports.path2Segments = exports.getArcParams = exports.reactPath = exports.path2Absolute = exports.path2Curve = exports.parsePathString = exports.parsePathArray = exports.pathIntersection = exports.formatPath = exports.fillPathByDiff = exports.fillPath = exports.catmullRom2Bezier = exports.parsePath = void 0;\r\nvar parse_path_1 = require(\"./parse-path\");\r\nObject.defineProperty(exports, \"parsePath\", { enumerable: true, get: function () { return parse_path_1.default; } });\r\nvar catmull_rom_2_bezier_1 = require(\"./catmull-rom-2-bezier\");\r\nObject.defineProperty(exports, \"catmullRom2Bezier\", { enumerable: true, get: function () { return catmull_rom_2_bezier_1.default; } });\r\nvar fill_path_1 = require(\"./fill-path\");\r\nObject.defineProperty(exports, \"fillPath\", { enumerable: true, get: function () { return fill_path_1.default; } });\r\nvar fill_path_by_diff_1 = require(\"./fill-path-by-diff\");\r\nObject.defineProperty(exports, \"fillPathByDiff\", { enumerable: true, get: function () { return fill_path_by_diff_1.default; } });\r\nvar format_path_1 = require(\"./format-path\");\r\nObject.defineProperty(exports, \"formatPath\", { enumerable: true, get: function () { return format_path_1.default; } });\r\nvar path_intersection_1 = require(\"./path-intersection\");\r\nObject.defineProperty(exports, \"pathIntersection\", { enumerable: true, get: function () { return path_intersection_1.default; } });\r\nvar parse_path_array_1 = require(\"./parse-path-array\");\r\nObject.defineProperty(exports, \"parsePathArray\", { enumerable: true, get: function () { return parse_path_array_1.default; } });\r\nvar parse_path_string_1 = require(\"./parse-path-string\");\r\nObject.defineProperty(exports, \"parsePathString\", { enumerable: true, get: function () { return parse_path_string_1.default; } });\r\nvar path_2_curve_1 = require(\"./path-2-curve\");\r\nObject.defineProperty(exports, \"path2Curve\", { enumerable: true, get: function () { return path_2_curve_1.default; } });\r\nvar path_2_absolute_1 = require(\"./path-2-absolute\");\r\nObject.defineProperty(exports, \"path2Absolute\", { enumerable: true, get: function () { return path_2_absolute_1.default; } });\r\nvar rect_path_1 = require(\"./rect-path\");\r\nObject.defineProperty(exports, \"reactPath\", { enumerable: true, get: function () { return rect_path_1.default; } });\r\nvar get_arc_params_1 = require(\"./get-arc-params\");\r\nObject.defineProperty(exports, \"getArcParams\", { enumerable: true, get: function () { return get_arc_params_1.default; } });\r\nvar path_2_segments_1 = require(\"./path-2-segments\");\r\nObject.defineProperty(exports, \"path2Segments\", { enumerable: true, get: function () { return path_2_segments_1.default; } });\r\nvar get_line_intersect_1 = require(\"./get-line-intersect\");\r\nObject.defineProperty(exports, \"getLineIntersect\", { enumerable: true, get: function () { return get_line_intersect_1.default; } });\r\nvar is_polygons_intersect_1 = require(\"./is-polygons-intersect\");\r\nObject.defineProperty(exports, \"isPolygonsIntersect\", { enumerable: true, get: function () { return is_polygons_intersect_1.default; } });\r\nvar point_in_polygon_1 = require(\"./point-in-polygon\");\r\nObject.defineProperty(exports, \"isPointInPolygon\", { enumerable: true, get: function () { return point_in_polygon_1.default; } });\r\n//# sourceMappingURL=index.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = require(\"@antv/util\");\r\nvar regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;\r\nvar regexDot = /[^\\s\\,]+/ig;\r\nfunction parsePath(p) {\r\n    var path = p || [];\r\n    if ((0, util_1.isArray)(path)) {\r\n        return path;\r\n    }\r\n    if ((0, util_1.isString)(path)) {\r\n        path = path.match(regexTags);\r\n        (0, util_1.each)(path, function (item, index) {\r\n            // @ts-ignore\r\n            item = item.match(regexDot);\r\n            if (item[0].length > 1) {\r\n                var tag = item[0].charAt(0);\r\n                // @ts-ignore\r\n                item.splice(1, 0, item[0].substr(1));\r\n                // @ts-ignore\r\n                item[0] = tag;\r\n            }\r\n            // @ts-ignore\r\n            (0, util_1.each)(item, function (sub, i) {\r\n                if (!isNaN(sub)) {\r\n                    // @ts-ignore\r\n                    item[i] = +sub;\r\n                }\r\n            });\r\n            // @ts-ignore\r\n            path[index] = item;\r\n        });\r\n        return path;\r\n    }\r\n}\r\nexports.default = parsePath;\r\n//# sourceMappingURL=parse-path.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar matrix_util_1 = require(\"@antv/matrix-util\");\r\nfunction smoothBezier(points, smooth, isLoop, constraint) {\r\n    var cps = [];\r\n    var hasConstraint = !!constraint;\r\n    var prevPoint;\r\n    var nextPoint;\r\n    var min;\r\n    var max;\r\n    var nextCp0;\r\n    var cp1;\r\n    var cp0;\r\n    if (hasConstraint) {\r\n        min = constraint[0], max = constraint[1];\r\n        for (var i = 0, l = points.length; i < l; i += 1) {\r\n            var point = points[i];\r\n            min = matrix_util_1.vec2.min([0, 0], min, point);\r\n            max = matrix_util_1.vec2.max([0, 0], max, point);\r\n        }\r\n    }\r\n    for (var i = 0, len = points.length; i < len; i += 1) {\r\n        var point = points[i];\r\n        if (i === 0 && !isLoop) {\r\n            cp0 = point;\r\n        }\r\n        else if (i === len - 1 && !isLoop) {\r\n            cp1 = point;\r\n            cps.push(cp0);\r\n            cps.push(cp1);\r\n        }\r\n        else {\r\n            var prevIdx = [i ? i - 1 : len - 1, i - 1][isLoop ? 0 : 1];\r\n            prevPoint = points[prevIdx];\r\n            nextPoint = points[isLoop ? (i + 1) % len : i + 1];\r\n            var v = [0, 0];\r\n            v = matrix_util_1.vec2.sub(v, nextPoint, prevPoint);\r\n            v = matrix_util_1.vec2.scale(v, v, smooth);\r\n            var d0 = matrix_util_1.vec2.distance(point, prevPoint);\r\n            var d1 = matrix_util_1.vec2.distance(point, nextPoint);\r\n            var sum = d0 + d1;\r\n            if (sum !== 0) {\r\n                d0 /= sum;\r\n                d1 /= sum;\r\n            }\r\n            var v1 = matrix_util_1.vec2.scale([0, 0], v, -d0);\r\n            var v2 = matrix_util_1.vec2.scale([0, 0], v, d1);\r\n            cp1 = matrix_util_1.vec2.add([0, 0], point, v1);\r\n            nextCp0 = matrix_util_1.vec2.add([0, 0], point, v2);\r\n            // 下一个控制点必须在这个点和下一个点之间\r\n            nextCp0 = matrix_util_1.vec2.min([0, 0], nextCp0, matrix_util_1.vec2.max([0, 0], nextPoint, point));\r\n            nextCp0 = matrix_util_1.vec2.max([0, 0], nextCp0, matrix_util_1.vec2.min([0, 0], nextPoint, point));\r\n            // 重新计算 cp1 的值\r\n            v1 = matrix_util_1.vec2.sub([0, 0], nextCp0, point);\r\n            v1 = matrix_util_1.vec2.scale([0, 0], v1, -d0 / d1);\r\n            cp1 = matrix_util_1.vec2.add([0, 0], point, v1);\r\n            // 上一个控制点必须要在上一个点和这一个点之间\r\n            cp1 = matrix_util_1.vec2.min([0, 0], cp1, matrix_util_1.vec2.max([0, 0], prevPoint, point));\r\n            cp1 = matrix_util_1.vec2.max([0, 0], cp1, matrix_util_1.vec2.min([0, 0], prevPoint, point));\r\n            // 重新计算 nextCp0 的值\r\n            v2 = matrix_util_1.vec2.sub([0, 0], point, cp1);\r\n            v2 = matrix_util_1.vec2.scale([0, 0], v2, d1 / d0);\r\n            nextCp0 = matrix_util_1.vec2.add([0, 0], point, v2);\r\n            if (hasConstraint) {\r\n                cp1 = matrix_util_1.vec2.max([0, 0], cp1, min);\r\n                cp1 = matrix_util_1.vec2.min([0, 0], cp1, max);\r\n                nextCp0 = matrix_util_1.vec2.max([0, 0], nextCp0, min);\r\n                nextCp0 = matrix_util_1.vec2.min([0, 0], nextCp0, max);\r\n            }\r\n            cps.push(cp0);\r\n            cps.push(cp1);\r\n            cp0 = nextCp0;\r\n        }\r\n    }\r\n    if (isLoop) {\r\n        cps.push(cps.shift());\r\n    }\r\n    return cps;\r\n}\r\n/**\r\n * create bezier spline from catmull rom spline\r\n * @param {Array} crp Catmull Rom Points\r\n * @param {boolean} z Spline is loop\r\n * @param {Array} constraint Constraint\r\n */\r\nfunction catmullRom2Bezier(crp, z, constraint) {\r\n    if (z === void 0) { z = false; }\r\n    if (constraint === void 0) { constraint = [\r\n        [0, 0],\r\n        [1, 1],\r\n    ]; }\r\n    var isLoop = !!z;\r\n    var pointList = [];\r\n    for (var i = 0, l = crp.length; i < l; i += 2) {\r\n        pointList.push([crp[i], crp[i + 1]]);\r\n    }\r\n    var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\r\n    var len = pointList.length;\r\n    var d1 = [];\r\n    var cp1;\r\n    var cp2;\r\n    var p;\r\n    for (var i = 0; i < len - 1; i += 1) {\r\n        cp1 = controlPointList[i * 2];\r\n        cp2 = controlPointList[i * 2 + 1];\r\n        p = pointList[i + 1];\r\n        d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\r\n    }\r\n    if (isLoop) {\r\n        cp1 = controlPointList[len];\r\n        cp2 = controlPointList[len + 1];\r\n        p = pointList[0];\r\n        d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\r\n    }\r\n    return d1;\r\n}\r\nexports.default = catmullRom2Bezier;\r\n//# sourceMappingURL=catmull-rom-2-bezier.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction decasteljau(points, t) {\r\n    var left = [];\r\n    var right = [];\r\n    function recurse(points, t) {\r\n        if (points.length === 1) {\r\n            left.push(points[0]);\r\n            right.push(points[0]);\r\n        }\r\n        else {\r\n            var middlePoints = [];\r\n            for (var i = 0; i < points.length - 1; i++) {\r\n                if (i === 0) {\r\n                    left.push(points[0]);\r\n                }\r\n                if (i === points.length - 2) {\r\n                    right.push(points[i + 1]);\r\n                }\r\n                middlePoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];\r\n            }\r\n            recurse(middlePoints, t);\r\n        }\r\n    }\r\n    if (points.length) {\r\n        recurse(points, t);\r\n    }\r\n    return { left: left, right: right.reverse() };\r\n}\r\nfunction splitCurve(start, end, count) {\r\n    var points = [[start[1], start[2]]];\r\n    count = count || 2;\r\n    var segments = [];\r\n    if (end[0] === 'A') {\r\n        points.push(end[6]);\r\n        points.push(end[7]);\r\n    }\r\n    else if (end[0] === 'C') {\r\n        points.push([end[1], end[2]]);\r\n        points.push([end[3], end[4]]);\r\n        points.push([end[5], end[6]]);\r\n    }\r\n    else if (end[0] === 'S' || end[0] === 'Q') {\r\n        points.push([end[1], end[2]]);\r\n        points.push([end[3], end[4]]);\r\n    }\r\n    else {\r\n        points.push([end[1], end[2]]);\r\n    }\r\n    var leftSegments = points;\r\n    var t = 1 / count;\r\n    for (var i = 0; i < count - 1; i++) {\r\n        var rt = t / (1 - t * i);\r\n        var split = decasteljau(leftSegments, rt);\r\n        segments.push(split.left);\r\n        leftSegments = split.right;\r\n    }\r\n    segments.push(leftSegments);\r\n    var result = segments.map(function (segment) {\r\n        var cmd = [];\r\n        if (segment.length === 4) {\r\n            cmd.push('C');\r\n            cmd = cmd.concat(segment[2]);\r\n        }\r\n        if (segment.length >= 3) {\r\n            if (segment.length === 3) {\r\n                cmd.push('Q');\r\n            }\r\n            cmd = cmd.concat(segment[1]);\r\n        }\r\n        if (segment.length === 2) {\r\n            cmd.push('L');\r\n        }\r\n        cmd = cmd.concat(segment[segment.length - 1]);\r\n        return cmd;\r\n    });\r\n    return result;\r\n}\r\nfunction splitSegment(start, end, count) {\r\n    if (count === 1) {\r\n        return [[].concat(start)];\r\n    }\r\n    var segments = [];\r\n    if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {\r\n        segments = segments.concat(splitCurve(start, end, count));\r\n    }\r\n    else {\r\n        var temp = [].concat(start);\r\n        if (temp[0] === 'M') {\r\n            temp[0] = 'L';\r\n        }\r\n        for (var i = 0; i <= count - 1; i++) {\r\n            segments.push(temp);\r\n        }\r\n    }\r\n    return segments;\r\n}\r\nfunction fillPath(source, target) {\r\n    if (source.length === 1) {\r\n        return source;\r\n    }\r\n    var sourceLen = source.length - 1;\r\n    var targetLen = target.length - 1;\r\n    var ratio = sourceLen / targetLen;\r\n    var segmentsToFill = [];\r\n    if (source.length === 1 && source[0][0] === 'M') {\r\n        for (var i = 0; i < targetLen - sourceLen; i++) {\r\n            source.push(source[0]);\r\n        }\r\n        return source;\r\n    }\r\n    for (var i = 0; i < targetLen; i++) {\r\n        var index = Math.floor(ratio * i);\r\n        segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;\r\n    }\r\n    var filled = segmentsToFill.reduce(function (filled, count, i) {\r\n        if (i === sourceLen) {\r\n            return filled.concat(source[sourceLen]);\r\n        }\r\n        return filled.concat(splitSegment(source[i], source[i + 1], count));\r\n    }, []);\r\n    filled.unshift(source[0]);\r\n    if (target[targetLen] === 'Z' || target[targetLen] === 'z') {\r\n        filled.push('Z');\r\n    }\r\n    return filled;\r\n}\r\nexports.default = fillPath;\r\n//# sourceMappingURL=fill-path.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = require(\"@antv/util\");\r\nfunction getMinDiff(del, add, modify) {\r\n    var type = null;\r\n    var min = modify;\r\n    if (add < min) {\r\n        min = add;\r\n        type = 'add';\r\n    }\r\n    if (del < min) {\r\n        min = del;\r\n        type = 'del';\r\n    }\r\n    return {\r\n        type: type,\r\n        min: min,\r\n    };\r\n}\r\n/*\r\n * https://en.wikipedia.org/wiki/Levenshtein_distance\r\n * 计算两条path的编辑距离\r\n */\r\nvar levenshteinDistance = function (source, target) {\r\n    var sourceLen = source.length;\r\n    var targetLen = target.length;\r\n    var sourceSegment, targetSegment;\r\n    var temp = 0;\r\n    if (sourceLen === 0 || targetLen === 0) {\r\n        return null;\r\n    }\r\n    var dist = [];\r\n    for (var i = 0; i <= sourceLen; i++) {\r\n        dist[i] = [];\r\n        dist[i][0] = { min: i };\r\n    }\r\n    for (var j = 0; j <= targetLen; j++) {\r\n        dist[0][j] = { min: j };\r\n    }\r\n    for (var i = 1; i <= sourceLen; i++) {\r\n        sourceSegment = source[i - 1];\r\n        for (var j = 1; j <= targetLen; j++) {\r\n            targetSegment = target[j - 1];\r\n            if ((0, util_1.isEqual)(sourceSegment, targetSegment)) {\r\n                temp = 0;\r\n            }\r\n            else {\r\n                temp = 1;\r\n            }\r\n            var del = dist[i - 1][j].min + 1;\r\n            var add = dist[i][j - 1].min + 1;\r\n            var modify = dist[i - 1][j - 1].min + temp;\r\n            dist[i][j] = getMinDiff(del, add, modify);\r\n        }\r\n    }\r\n    return dist;\r\n};\r\nfunction fillPathByDiff(source, target) {\r\n    var diffMatrix = levenshteinDistance(source, target);\r\n    var sourceLen = source.length;\r\n    var targetLen = target.length;\r\n    var changes = [];\r\n    var index = 1;\r\n    var minPos = 1;\r\n    // 如果source和target不是完全不相等\r\n    // @ts-ignore\r\n    if (diffMatrix[sourceLen][targetLen] !== sourceLen) {\r\n        // 获取从source到target所需改动\r\n        for (var i = 1; i <= sourceLen; i++) {\r\n            var min = diffMatrix[i][i].min;\r\n            minPos = i;\r\n            for (var j = index; j <= targetLen; j++) {\r\n                if (diffMatrix[i][j].min < min) {\r\n                    min = diffMatrix[i][j].min;\r\n                    minPos = j;\r\n                }\r\n            }\r\n            index = minPos;\r\n            if (diffMatrix[i][index].type) {\r\n                changes.push({ index: i - 1, type: diffMatrix[i][index].type });\r\n            }\r\n        }\r\n        // 对source进行增删path\r\n        for (var i = changes.length - 1; i >= 0; i--) {\r\n            index = changes[i].index;\r\n            if (changes[i].type === 'add') {\r\n                // @ts-ignore\r\n                source.splice(index, 0, [].concat(source[index]));\r\n            }\r\n            else {\r\n                // @ts-ignore\r\n                source.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n    // source尾部补齐\r\n    sourceLen = source.length;\r\n    if (sourceLen < targetLen) {\r\n        for (var i = 0; i < (targetLen - sourceLen); i++) {\r\n            if (source[sourceLen - 1][0] === 'z' || source[sourceLen - 1][0] === 'Z') {\r\n                // @ts-ignore\r\n                source.splice(sourceLen - 2, 0, source[sourceLen - 2]);\r\n            }\r\n            else {\r\n                // @ts-ignore\r\n                source.push(source[sourceLen - 1]);\r\n            }\r\n        }\r\n    }\r\n    return source;\r\n}\r\nexports.default = fillPathByDiff;\r\n//# sourceMappingURL=fill-path-by-diff.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*\r\n * 抽取pathSegment中的关键点\r\n * M,L,A,Q,H,V一个端点\r\n * Q, S抽取一个端点，一个控制点\r\n * C抽取一个端点，两个控制点\r\n */\r\nfunction _getSegmentPoints(segment) {\r\n    var points = [];\r\n    switch (segment[0]) {\r\n        case 'M':\r\n            points.push([segment[1], segment[2]]);\r\n            break;\r\n        case 'L':\r\n            points.push([segment[1], segment[2]]);\r\n            break;\r\n        case 'A':\r\n            points.push([segment[6], segment[7]]);\r\n            break;\r\n        case 'Q':\r\n            points.push([segment[3], segment[4]]);\r\n            points.push([segment[1], segment[2]]);\r\n            break;\r\n        case 'T':\r\n            points.push([segment[1], segment[2]]);\r\n            break;\r\n        case 'C':\r\n            points.push([segment[5], segment[6]]);\r\n            points.push([segment[1], segment[2]]);\r\n            points.push([segment[3], segment[4]]);\r\n            break;\r\n        case 'S':\r\n            points.push([segment[3], segment[4]]);\r\n            points.push([segment[1], segment[2]]);\r\n            break;\r\n        case 'H':\r\n            points.push([segment[1], segment[1]]);\r\n            break;\r\n        case 'V':\r\n            points.push([segment[1], segment[1]]);\r\n            break;\r\n        default:\r\n    }\r\n    return points;\r\n}\r\n// 将两个点均分成count个点\r\nfunction _splitPoints(points, former, count) {\r\n    var result = [].concat(points);\r\n    var index;\r\n    var t = 1 / (count + 1);\r\n    var formerEnd = _getSegmentPoints(former)[0];\r\n    for (var i = 1; i <= count; i++) {\r\n        t *= i;\r\n        index = Math.floor(points.length * t);\r\n        if (index === 0) {\r\n            result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);\r\n        }\r\n        else {\r\n            result.splice(index, 0, [formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction formatPath(fromPath, toPath) {\r\n    if (fromPath.length <= 1) {\r\n        return fromPath;\r\n    }\r\n    var points;\r\n    for (var i = 0; i < toPath.length; i++) {\r\n        if (fromPath[i][0] !== toPath[i][0]) {\r\n            // 获取fromPath的pathSegment的端点，根据toPath的指令对其改造\r\n            points = _getSegmentPoints(fromPath[i]);\r\n            switch (toPath[i][0]) {\r\n                case 'M':\r\n                    fromPath[i] = ['M'].concat(points[0]);\r\n                    break;\r\n                case 'L':\r\n                    fromPath[i] = ['L'].concat(points[0]);\r\n                    break;\r\n                case 'A':\r\n                    fromPath[i] = [].concat(toPath[i]);\r\n                    fromPath[i][6] = points[0][0];\r\n                    fromPath[i][7] = points[0][1];\r\n                    break;\r\n                case 'Q':\r\n                    if (points.length < 2) {\r\n                        if (i > 0) {\r\n                            points = _splitPoints(points, fromPath[i - 1], 1);\r\n                        }\r\n                        else {\r\n                            fromPath[i] = toPath[i];\r\n                            break;\r\n                        }\r\n                    }\r\n                    fromPath[i] = ['Q'].concat(points.reduce(function (arr, i) { return arr.concat(i); }, []));\r\n                    break;\r\n                case 'T':\r\n                    fromPath[i] = ['T'].concat(points[0]);\r\n                    break;\r\n                case 'C':\r\n                    if (points.length < 3) {\r\n                        if (i > 0) {\r\n                            points = _splitPoints(points, fromPath[i - 1], 2);\r\n                        }\r\n                        else {\r\n                            fromPath[i] = toPath[i];\r\n                            break;\r\n                        }\r\n                    }\r\n                    fromPath[i] = ['C'].concat(points.reduce(function (arr, i) { return arr.concat(i); }, []));\r\n                    break;\r\n                case 'S':\r\n                    if (points.length < 2) {\r\n                        if (i > 0) {\r\n                            points = _splitPoints(points, fromPath[i - 1], 1);\r\n                        }\r\n                        else {\r\n                            fromPath[i] = toPath[i];\r\n                            break;\r\n                        }\r\n                    }\r\n                    fromPath[i] = ['S'].concat(points.reduce(function (arr, i) { return arr.concat(i); }, []));\r\n                    break;\r\n                default:\r\n                    fromPath[i] = toPath[i];\r\n            }\r\n        }\r\n    }\r\n    return fromPath;\r\n}\r\nexports.default = formatPath;\r\n//# sourceMappingURL=format-path.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = require(\"@antv/util\");\r\nvar rect_path_1 = require(\"./rect-path\");\r\nvar path_2_curve_1 = require(\"./path-2-curve\");\r\nvar base3 = function (t, p1, p2, p3, p4) {\r\n    var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;\r\n    var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\r\n    return t * t2 - 3 * p1 + 3 * p2;\r\n};\r\nvar bezlen = function (x1, y1, x2, y2, x3, y3, x4, y4, z) {\r\n    if (z === null) {\r\n        z = 1;\r\n    }\r\n    z = z > 1 ? 1 : z < 0 ? 0 : z;\r\n    var z2 = z / 2;\r\n    var n = 12;\r\n    var Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816];\r\n    var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];\r\n    var sum = 0;\r\n    for (var i = 0; i < n; i++) {\r\n        var ct = z2 * Tvalues[i] + z2;\r\n        var xbase = base3(ct, x1, x2, x3, x4);\r\n        var ybase = base3(ct, y1, y2, y3, y4);\r\n        var comb = xbase * xbase + ybase * ybase;\r\n        sum += Cvalues[i] * Math.sqrt(comb);\r\n    }\r\n    return z2 * sum;\r\n};\r\nvar curveDim = function (x0, y0, x1, y1, x2, y2, x3, y3) {\r\n    var tvalues = [];\r\n    var bounds = [\r\n        [],\r\n        [],\r\n    ];\r\n    var a;\r\n    var b;\r\n    var c;\r\n    var t;\r\n    for (var i = 0; i < 2; ++i) {\r\n        if (i === 0) {\r\n            b = 6 * x0 - 12 * x1 + 6 * x2;\r\n            a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\r\n            c = 3 * x1 - 3 * x0;\r\n        }\r\n        else {\r\n            b = 6 * y0 - 12 * y1 + 6 * y2;\r\n            a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\r\n            c = 3 * y1 - 3 * y0;\r\n        }\r\n        if (Math.abs(a) < 1e-12) {\r\n            if (Math.abs(b) < 1e-12) {\r\n                continue;\r\n            }\r\n            t = -c / b;\r\n            if (t > 0 && t < 1) {\r\n                tvalues.push(t);\r\n            }\r\n            continue;\r\n        }\r\n        var b2ac = b * b - 4 * c * a;\r\n        var sqrtb2ac = Math.sqrt(b2ac);\r\n        if (b2ac < 0) {\r\n            continue;\r\n        }\r\n        var t1 = (-b + sqrtb2ac) / (2 * a);\r\n        if (t1 > 0 && t1 < 1) {\r\n            tvalues.push(t1);\r\n        }\r\n        var t2 = (-b - sqrtb2ac) / (2 * a);\r\n        if (t2 > 0 && t2 < 1) {\r\n            tvalues.push(t2);\r\n        }\r\n    }\r\n    var j = tvalues.length;\r\n    var jlen = j;\r\n    var mt;\r\n    while (j--) {\r\n        t = tvalues[j];\r\n        mt = 1 - t;\r\n        bounds[0][j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\r\n        bounds[1][j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\r\n    }\r\n    bounds[0][jlen] = x0;\r\n    bounds[1][jlen] = y0;\r\n    bounds[0][jlen + 1] = x3;\r\n    bounds[1][jlen + 1] = y3;\r\n    bounds[0].length = bounds[1].length = jlen + 2;\r\n    return {\r\n        min: {\r\n            x: Math.min.apply(0, bounds[0]),\r\n            y: Math.min.apply(0, bounds[1]),\r\n        },\r\n        max: {\r\n            x: Math.max.apply(0, bounds[0]),\r\n            y: Math.max.apply(0, bounds[1]),\r\n        },\r\n    };\r\n};\r\nvar intersect = function (x1, y1, x2, y2, x3, y3, x4, y4) {\r\n    if (Math.max(x1, x2) < Math.min(x3, x4) ||\r\n        Math.min(x1, x2) > Math.max(x3, x4) ||\r\n        Math.max(y1, y2) < Math.min(y3, y4) ||\r\n        Math.min(y1, y2) > Math.max(y3, y4)) {\r\n        return;\r\n    }\r\n    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);\r\n    var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);\r\n    var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\r\n    if (!denominator) {\r\n        return;\r\n    }\r\n    var px = nx / denominator;\r\n    var py = ny / denominator;\r\n    var px2 = +px.toFixed(2);\r\n    var py2 = +py.toFixed(2);\r\n    if (px2 < +Math.min(x1, x2).toFixed(2) ||\r\n        px2 > +Math.max(x1, x2).toFixed(2) ||\r\n        px2 < +Math.min(x3, x4).toFixed(2) ||\r\n        px2 > +Math.max(x3, x4).toFixed(2) ||\r\n        py2 < +Math.min(y1, y2).toFixed(2) ||\r\n        py2 > +Math.max(y1, y2).toFixed(2) ||\r\n        py2 < +Math.min(y3, y4).toFixed(2) ||\r\n        py2 > +Math.max(y3, y4).toFixed(2)) {\r\n        return;\r\n    }\r\n    return {\r\n        x: px,\r\n        y: py,\r\n    };\r\n};\r\nvar isPointInsideBBox = function (bbox, x, y) {\r\n    return x >= bbox.x &&\r\n        x <= bbox.x + bbox.width &&\r\n        y >= bbox.y &&\r\n        y <= bbox.y + bbox.height;\r\n};\r\nvar box = function (x, y, width, height) {\r\n    if (x === null) {\r\n        x = y = width = height = 0;\r\n    }\r\n    if (y === null) {\r\n        y = x.y;\r\n        width = x.width;\r\n        height = x.height;\r\n        x = x.x;\r\n    }\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        width: width,\r\n        w: width,\r\n        height: height,\r\n        h: height,\r\n        x2: x + width,\r\n        y2: y + height,\r\n        cx: x + width / 2,\r\n        cy: y + height / 2,\r\n        r1: Math.min(width, height) / 2,\r\n        r2: Math.max(width, height) / 2,\r\n        r0: Math.sqrt(width * width + height * height) / 2,\r\n        path: (0, rect_path_1.default)(x, y, width, height),\r\n        vb: [x, y, width, height].join(' '),\r\n    };\r\n};\r\nvar isBBoxIntersect = function (bbox1, bbox2) {\r\n    // @ts-ignore\r\n    bbox1 = box(bbox1);\r\n    // @ts-ignore\r\n    bbox2 = box(bbox2);\r\n    return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\r\n};\r\nvar bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\r\n    if (!(0, util_1.isArray)(p1x)) {\r\n        p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\r\n    }\r\n    var bbox = curveDim.apply(null, p1x);\r\n    return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);\r\n};\r\nvar findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\r\n    var t1 = 1 - t;\r\n    var t13 = Math.pow(t1, 3);\r\n    var t12 = Math.pow(t1, 2);\r\n    var t2 = t * t;\r\n    var t3 = t2 * t;\r\n    var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;\r\n    var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;\r\n    var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);\r\n    var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);\r\n    var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);\r\n    var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);\r\n    var ax = t1 * p1x + t * c1x;\r\n    var ay = t1 * p1y + t * c1y;\r\n    var cx = t1 * c2x + t * p2x;\r\n    var cy = t1 * c2y + t * p2y;\r\n    var alpha = (90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI);\r\n    // (mx > nx || my < ny) && (alpha += 180);\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        m: {\r\n            x: mx,\r\n            y: my,\r\n        },\r\n        n: {\r\n            x: nx,\r\n            y: ny,\r\n        },\r\n        start: {\r\n            x: ax,\r\n            y: ay,\r\n        },\r\n        end: {\r\n            x: cx,\r\n            y: cy,\r\n        },\r\n        alpha: alpha,\r\n    };\r\n};\r\nvar interHelper = function (bez1, bez2, justCount) {\r\n    // @ts-ignore\r\n    var bbox1 = bezierBBox(bez1);\r\n    // @ts-ignore\r\n    var bbox2 = bezierBBox(bez2);\r\n    if (!isBBoxIntersect(bbox1, bbox2)) {\r\n        return justCount ? 0 : [];\r\n    }\r\n    var l1 = bezlen.apply(0, bez1);\r\n    var l2 = bezlen.apply(0, bez2);\r\n    var n1 = ~~(l1 / 8);\r\n    var n2 = ~~(l2 / 8);\r\n    var dots1 = [];\r\n    var dots2 = [];\r\n    var xy = {};\r\n    var res = justCount ? 0 : [];\r\n    for (var i = 0; i < n1 + 1; i++) {\r\n        var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));\r\n        dots1.push({\r\n            x: d.x,\r\n            y: d.y,\r\n            t: i / n1,\r\n        });\r\n    }\r\n    for (var i = 0; i < n2 + 1; i++) {\r\n        var d = findDotsAtSegment.apply(0, bez2.concat(i / n2));\r\n        dots2.push({\r\n            x: d.x,\r\n            y: d.y,\r\n            t: i / n2,\r\n        });\r\n    }\r\n    for (var i = 0; i < n1; i++) {\r\n        for (var j = 0; j < n2; j++) {\r\n            var di = dots1[i];\r\n            var di1 = dots1[i + 1];\r\n            var dj = dots2[j];\r\n            var dj1 = dots2[j + 1];\r\n            var ci = Math.abs(di1.x - di.x) < 0.001 ? 'y' : 'x';\r\n            var cj = Math.abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';\r\n            var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\r\n            if (is) {\r\n                if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {\r\n                    continue;\r\n                }\r\n                xy[is.x.toFixed(4)] = is.y.toFixed(4);\r\n                var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);\r\n                var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\r\n                if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\r\n                    if (justCount) {\r\n                        // @ts-ignore\r\n                        res++;\r\n                    }\r\n                    else {\r\n                        // @ts-ignore\r\n                        res.push({\r\n                            x: is.x,\r\n                            y: is.y,\r\n                            t1: t1,\r\n                            t2: t2,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n};\r\nvar interPathHelper = function (path1, path2, justCount) {\r\n    // @ts-ignore\r\n    path1 = (0, path_2_curve_1.default)(path1);\r\n    // @ts-ignore\r\n    path2 = (0, path_2_curve_1.default)(path2);\r\n    var x1;\r\n    var y1;\r\n    var x2;\r\n    var y2;\r\n    var x1m;\r\n    var y1m;\r\n    var x2m;\r\n    var y2m;\r\n    var bez1;\r\n    var bez2;\r\n    var res = justCount ? 0 : [];\r\n    for (var i = 0, ii = path1.length; i < ii; i++) {\r\n        var pi = path1[i];\r\n        if (pi[0] === 'M') {\r\n            x1 = x1m = pi[1];\r\n            y1 = y1m = pi[2];\r\n        }\r\n        else {\r\n            if (pi[0] === 'C') {\r\n                bez1 = [x1, y1].concat(pi.slice(1));\r\n                x1 = bez1[6];\r\n                y1 = bez1[7];\r\n            }\r\n            else {\r\n                bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\r\n                x1 = x1m;\r\n                y1 = y1m;\r\n            }\r\n            for (var j = 0, jj = path2.length; j < jj; j++) {\r\n                var pj = path2[j];\r\n                if (pj[0] === 'M') {\r\n                    x2 = x2m = pj[1];\r\n                    y2 = y2m = pj[2];\r\n                }\r\n                else {\r\n                    if (pj[0] === 'C') {\r\n                        bez2 = [x2, y2].concat(pj.slice(1));\r\n                        x2 = bez2[6];\r\n                        y2 = bez2[7];\r\n                    }\r\n                    else {\r\n                        bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\r\n                        x2 = x2m;\r\n                        y2 = y2m;\r\n                    }\r\n                    var intr = interHelper(bez1, bez2, justCount);\r\n                    if (justCount) {\r\n                        // @ts-ignore\r\n                        res += intr;\r\n                    }\r\n                    else {\r\n                        // @ts-ignore\r\n                        for (var k = 0, kk = intr.length; k < kk; k++) {\r\n                            intr[k].segment1 = i;\r\n                            intr[k].segment2 = j;\r\n                            intr[k].bez1 = bez1;\r\n                            intr[k].bez2 = bez2;\r\n                        }\r\n                        // @ts-ignore\r\n                        res = res.concat(intr);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n};\r\nfunction pathIntersection(path1, path2) {\r\n    // @ts-ignore\r\n    return interPathHelper(path1, path2);\r\n}\r\nexports.default = pathIntersection;\r\n//# sourceMappingURL=path-intersection.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction rectPath(x, y, w, h, r) {\r\n    if (r) {\r\n        return [\r\n            ['M', +x + (+r), y],\r\n            ['l', w - r * 2, 0],\r\n            ['a', r, r, 0, 0, 1, r, r],\r\n            ['l', 0, h - r * 2],\r\n            ['a', r, r, 0, 0, 1, -r, r],\r\n            ['l', r * 2 - w, 0],\r\n            ['a', r, r, 0, 0, 1, -r, -r],\r\n            ['l', 0, r * 2 - h],\r\n            ['a', r, r, 0, 0, 1, r, -r],\r\n            ['z'],\r\n        ];\r\n    }\r\n    return [\r\n        ['M', x, y],\r\n        ['l', w, 0],\r\n        ['l', 0, h],\r\n        ['l', -w, 0],\r\n        ['z'],\r\n    ];\r\n    // res.parsePathArray = parsePathArray;\r\n}\r\nexports.default = rectPath;\r\n//# sourceMappingURL=rect-path.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar path_2_absolute_1 = require(\"./path-2-absolute\");\r\nvar segment_2_cubic_1 = require(\"./process/segment-2-cubic\");\r\nfunction pathToCurve(path, needZCommandIndexes) {\r\n    if (needZCommandIndexes === void 0) { needZCommandIndexes = false; }\r\n    var pathArray = (0, path_2_absolute_1.default)(path);\r\n    var params = {\r\n        x1: 0, y1: 0, x2: 0, y2: 0, x: 0, y: 0, qx: null, qy: null,\r\n    };\r\n    var allPathCommands = [];\r\n    var pathCommand = '';\r\n    var ii = pathArray.length;\r\n    var segment;\r\n    var seglen;\r\n    var zCommandIndexes = [];\r\n    for (var i = 0; i < ii; i += 1) {\r\n        if (pathArray[i])\r\n            pathCommand = pathArray[i][0];\r\n        allPathCommands[i] = pathCommand;\r\n        pathArray[i] = (0, segment_2_cubic_1.segmentToCubic)(pathArray[i], params);\r\n        fixArc(pathArray, allPathCommands, i);\r\n        ii = pathArray.length; // solves curveArrays ending in Z\r\n        // keep Z command account for lineJoin\r\n        // @see https://github.com/antvis/util/issues/68\r\n        if (pathCommand === 'Z') {\r\n            zCommandIndexes.push(i);\r\n        }\r\n        segment = pathArray[i];\r\n        seglen = segment.length;\r\n        params.x1 = +segment[seglen - 2];\r\n        params.y1 = +segment[seglen - 1];\r\n        params.x2 = +(segment[seglen - 4]) || params.x1;\r\n        params.y2 = +(segment[seglen - 3]) || params.y1;\r\n    }\r\n    if (needZCommandIndexes) {\r\n        return [pathArray, zCommandIndexes];\r\n    }\r\n    else {\r\n        return pathArray;\r\n    }\r\n}\r\nexports.default = pathToCurve;\r\nfunction fixArc(pathArray, allPathCommands, i) {\r\n    if (pathArray[i].length > 7) {\r\n        pathArray[i].shift();\r\n        var pi = pathArray[i];\r\n        // const ni = i + 1;\r\n        var ni = i;\r\n        while (pi.length) {\r\n            // if created multiple C:s, their original seg is saved\r\n            allPathCommands[i] = 'A';\r\n            // @ts-ignore\r\n            pathArray.splice(ni += 1, 0, ['C'].concat(pi.splice(0, 6)));\r\n        }\r\n        pathArray.splice(i, 1);\r\n    }\r\n}\r\n//# sourceMappingURL=path-2-curve.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar parse_path_string_1 = require(\"./parse-path-string\");\r\nvar REGEX_MD = /[a-z]/;\r\nfunction toSymmetry(p, c) {\r\n    return [\r\n        c[0] + (c[0] - p[0]),\r\n        c[1] + (c[1] - p[1]),\r\n    ];\r\n}\r\nfunction pathToAbsolute(pathString) {\r\n    var pathArray = (0, parse_path_string_1.default)(pathString);\r\n    if (!pathArray || !pathArray.length) {\r\n        return [\r\n            ['M', 0, 0],\r\n        ];\r\n    }\r\n    var needProcess = false; // 如果存在小写的命令或者 V,H,T,S 则需要处理\r\n    for (var i = 0; i < pathArray.length; i++) {\r\n        var cmd = pathArray[i][0];\r\n        // 如果存在相对位置的命令，则中断返回\r\n        if (REGEX_MD.test(cmd) || ['V', 'H', 'T', 'S'].indexOf(cmd) >= 0) {\r\n            needProcess = true;\r\n            break;\r\n        }\r\n    }\r\n    // 如果不存在相对命令，则直接返回\r\n    // 如果在业务上都写绝对路径，这种方式最快，仅做了一次检测\r\n    if (!needProcess) {\r\n        return pathArray;\r\n    }\r\n    var res = [];\r\n    var x = 0;\r\n    var y = 0;\r\n    var mx = 0;\r\n    var my = 0;\r\n    var start = 0;\r\n    var pa0;\r\n    var dots;\r\n    var first = pathArray[0];\r\n    if (first[0] === 'M' || first[0] === 'm') {\r\n        x = +first[1];\r\n        y = +first[2];\r\n        mx = x;\r\n        my = y;\r\n        start++;\r\n        res[0] = ['M', x, y];\r\n    }\r\n    for (var i = start, ii = pathArray.length; i < ii; i++) {\r\n        var pa = pathArray[i];\r\n        var preParams = res[i - 1]; // 取前一个已经处理后的节点，否则会出现问题\r\n        var r = [];\r\n        var cmd = pa[0];\r\n        var upCmd = cmd.toUpperCase();\r\n        if (cmd !== upCmd) {\r\n            r[0] = upCmd;\r\n            switch (upCmd) {\r\n                case 'A':\r\n                    r[1] = pa[1];\r\n                    r[2] = pa[2];\r\n                    r[3] = pa[3];\r\n                    r[4] = pa[4];\r\n                    r[5] = pa[5];\r\n                    r[6] = +pa[6] + x;\r\n                    r[7] = +pa[7] + y;\r\n                    break;\r\n                case 'V':\r\n                    r[1] = +pa[1] + y;\r\n                    break;\r\n                case 'H':\r\n                    r[1] = +pa[1] + x;\r\n                    break;\r\n                case 'M':\r\n                    mx = +pa[1] + x;\r\n                    my = +pa[2] + y;\r\n                    r[1] = mx;\r\n                    r[2] = my;\r\n                    break; // for lint\r\n                default:\r\n                    for (var j = 1, jj = pa.length; j < jj; j++) {\r\n                        r[j] = +pa[j] + ((j % 2) ? x : y);\r\n                    }\r\n            }\r\n        }\r\n        else { // 如果本来已经大写，则不处理\r\n            r = pathArray[i];\r\n        }\r\n        // 需要在外面统一做，同时处理 V,H,S,T 等特殊指令\r\n        switch (upCmd) {\r\n            case 'Z':\r\n                x = +mx;\r\n                y = +my;\r\n                break;\r\n            case 'H':\r\n                x = r[1];\r\n                r = ['L', x, y];\r\n                break;\r\n            case 'V':\r\n                y = r[1];\r\n                r = ['L', x, y];\r\n                break;\r\n            case 'T':\r\n                x = r[1];\r\n                y = r[2];\r\n                // 以 x, y 为中心的，上一个控制点的对称点\r\n                // 需要假设上一个节点的命令为 Q\r\n                var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);\r\n                r = ['Q', symetricT[0], symetricT[1], x, y];\r\n                break;\r\n            case 'S':\r\n                x = r[r.length - 2];\r\n                y = r[r.length - 1];\r\n                // 以 x,y 为中心，取上一个控制点，\r\n                // 需要假设上一个线段为 C 或者 S\r\n                var length_1 = preParams.length;\r\n                var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);\r\n                r = ['C', symetricS[0], symetricS[1], r[1], r[2], x, y];\r\n                break;\r\n            case 'M':\r\n                mx = r[r.length - 2];\r\n                my = r[r.length - 1];\r\n                break; // for lint\r\n            default:\r\n                x = r[r.length - 2];\r\n                y = r[r.length - 1];\r\n        }\r\n        res.push(r);\r\n    }\r\n    return res;\r\n}\r\nexports.default = pathToAbsolute;\r\n//# sourceMappingURL=path-2-absolute.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar util_1 = require(\"@antv/util\");\r\nvar SPACES = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\r\nvar PATH_COMMAND = new RegExp('([a-z])[' + SPACES + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + SPACES + ']*,?[' + SPACES + ']*)+)', 'ig');\r\nvar PATH_VALUES = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + SPACES + ']*,?[' + SPACES + ']*', 'ig');\r\n// Parses given path string into an array of arrays of path segments\r\nfunction parsePathString(pathString) {\r\n    if (!pathString) {\r\n        return null;\r\n    }\r\n    if ((0, util_1.isArray)(pathString)) {\r\n        return pathString;\r\n    }\r\n    var paramCounts = {\r\n        a: 7,\r\n        c: 6,\r\n        o: 2,\r\n        h: 1,\r\n        l: 2,\r\n        m: 2,\r\n        r: 4,\r\n        q: 4,\r\n        s: 4,\r\n        t: 2,\r\n        v: 1,\r\n        u: 3,\r\n        z: 0,\r\n    };\r\n    var data = [];\r\n    String(pathString).replace(PATH_COMMAND, function (a, b, c) {\r\n        var params = [];\r\n        var name = b.toLowerCase();\r\n        c.replace(PATH_VALUES, function (a, b) {\r\n            b && params.push(+b);\r\n        });\r\n        if (name === 'm' && params.length > 2) {\r\n            data.push([b].concat(params.splice(0, 2)));\r\n            name = 'l';\r\n            b = b === 'm' ? 'l' : 'L';\r\n        }\r\n        if (name === 'o' && params.length === 1) {\r\n            data.push([b, params[0]]);\r\n        }\r\n        if (name === 'r') {\r\n            data.push([b].concat(params));\r\n        }\r\n        else {\r\n            while (params.length >= paramCounts[name]) {\r\n                data.push([b].concat(params.splice(0, paramCounts[name])));\r\n                if (!paramCounts[name]) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return '';\r\n    });\r\n    return data;\r\n}\r\nexports.default = parsePathString;\r\n//# sourceMappingURL=parse-path-string.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.segmentToCubic = void 0;\r\nvar arc_2_cubic_1 = require(\"./arc-2-cubic\");\r\nvar quad_2_cubic_1 = require(\"./quad-2-cubic\");\r\nvar line_2_cubic_1 = require(\"./line-2-cubic\");\r\nfunction segmentToCubic(segment, params) {\r\n    if ('TQ'.indexOf(segment[0]) < 0) {\r\n        params.qx = null;\r\n        params.qy = null;\r\n    }\r\n    var _a = segment.slice(1), s1 = _a[0], s2 = _a[1];\r\n    switch (segment[0]) {\r\n        case 'M':\r\n            params.x = s1;\r\n            params.y = s2;\r\n            return segment;\r\n        case 'A':\r\n            return ['C'].concat(arc_2_cubic_1.arcToCubic.apply(0, [params.x1, params.y1].concat(segment.slice(1))));\r\n        case 'Q':\r\n            params.qx = s1;\r\n            params.qy = s2;\r\n            return ['C'].concat(quad_2_cubic_1.quadToCubic.apply(0, [params.x1, params.y1].concat(segment.slice(1))));\r\n        case 'L':\r\n            // @ts-ignore\r\n            return ['C'].concat((0, line_2_cubic_1.lineToCubic)(params.x1, params.y1, segment[1], segment[2]));\r\n        case 'H':\r\n            // @ts-ignore\r\n            return ['C'].concat((0, line_2_cubic_1.lineToCubic)(params.x1, params.y1, segment[1], params.y1));\r\n        case 'V':\r\n            // @ts-ignore\r\n            return ['C'].concat((0, line_2_cubic_1.lineToCubic)(params.x1, params.y1, params.x1, segment[1]));\r\n        case 'Z':\r\n            // @ts-ignore\r\n            return ['C'].concat((0, line_2_cubic_1.lineToCubic)(params.x1, params.y1, params.x, params.y));\r\n        default:\r\n    }\r\n    return segment;\r\n}\r\nexports.segmentToCubic = segmentToCubic;\r\n//# sourceMappingURL=segment-2-cubic.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.arcToCubic = void 0;\r\nvar TAU = Math.PI * 2;\r\nvar mapToEllipse = function (_a, rx, ry, cosphi, sinphi, centerx, centery) {\r\n    var x = _a.x, y = _a.y;\r\n    x *= rx;\r\n    y *= ry;\r\n    var xp = cosphi * x - sinphi * y;\r\n    var yp = sinphi * x + cosphi * y;\r\n    return {\r\n        x: xp + centerx,\r\n        y: yp + centery\r\n    };\r\n};\r\nvar approxUnitArc = function (ang1, ang2) {\r\n    // If 90 degree circular arc, use a constant\r\n    // as derived from http://spencermortensen.com/articles/bezier-circle\r\n    var a = ang2 === 1.5707963267948966\r\n        ? 0.551915024494\r\n        : ang2 === -1.5707963267948966\r\n            ? -0.551915024494\r\n            : 4 / 3 * Math.tan(ang2 / 4);\r\n    var x1 = Math.cos(ang1);\r\n    var y1 = Math.sin(ang1);\r\n    var x2 = Math.cos(ang1 + ang2);\r\n    var y2 = Math.sin(ang1 + ang2);\r\n    return [\r\n        {\r\n            x: x1 - y1 * a,\r\n            y: y1 + x1 * a\r\n        },\r\n        {\r\n            x: x2 + y2 * a,\r\n            y: y2 - x2 * a\r\n        },\r\n        {\r\n            x: x2,\r\n            y: y2\r\n        }\r\n    ];\r\n};\r\nvar vectorAngle = function (ux, uy, vx, vy) {\r\n    var sign = (ux * vy - uy * vx < 0) ? -1 : 1;\r\n    var dot = ux * vx + uy * vy;\r\n    if (dot > 1) {\r\n        dot = 1;\r\n    }\r\n    if (dot < -1) {\r\n        dot = -1;\r\n    }\r\n    return sign * Math.acos(dot);\r\n};\r\nvar getArcCenter = function (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {\r\n    var rxsq = Math.pow(rx, 2);\r\n    var rysq = Math.pow(ry, 2);\r\n    var pxpsq = Math.pow(pxp, 2);\r\n    var pypsq = Math.pow(pyp, 2);\r\n    var radicant = (rxsq * rysq) - (rxsq * pypsq) - (rysq * pxpsq);\r\n    if (radicant < 0) {\r\n        radicant = 0;\r\n    }\r\n    radicant /= (rxsq * pypsq) + (rysq * pxpsq);\r\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\r\n    var centerxp = radicant * rx / ry * pyp;\r\n    var centeryp = radicant * -ry / rx * pxp;\r\n    var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\r\n    var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\r\n    var vx1 = (pxp - centerxp) / rx;\r\n    var vy1 = (pyp - centeryp) / ry;\r\n    var vx2 = (-pxp - centerxp) / rx;\r\n    var vy2 = (-pyp - centeryp) / ry;\r\n    var ang1 = vectorAngle(1, 0, vx1, vy1);\r\n    var ang2 = vectorAngle(vx1, vy1, vx2, vy2);\r\n    if (sweepFlag === 0 && ang2 > 0) {\r\n        ang2 -= TAU;\r\n    }\r\n    if (sweepFlag === 1 && ang2 < 0) {\r\n        ang2 += TAU;\r\n    }\r\n    return [centerx, centery, ang1, ang2];\r\n};\r\nvar arcToBezier = function (_a) {\r\n    var px = _a.px, py = _a.py, cx = _a.cx, cy = _a.cy, rx = _a.rx, ry = _a.ry, _b = _a.xAxisRotation, xAxisRotation = _b === void 0 ? 0 : _b, _c = _a.largeArcFlag, largeArcFlag = _c === void 0 ? 0 : _c, _d = _a.sweepFlag, sweepFlag = _d === void 0 ? 0 : _d;\r\n    var curves = [];\r\n    if (rx === 0 || ry === 0) {\r\n        return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];\r\n    }\r\n    var sinphi = Math.sin(xAxisRotation * TAU / 360);\r\n    var cosphi = Math.cos(xAxisRotation * TAU / 360);\r\n    var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;\r\n    var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;\r\n    if (pxp === 0 && pyp === 0) {\r\n        return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];\r\n    }\r\n    rx = Math.abs(rx);\r\n    ry = Math.abs(ry);\r\n    var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) +\r\n        Math.pow(pyp, 2) / Math.pow(ry, 2);\r\n    if (lambda > 1) {\r\n        rx *= Math.sqrt(lambda);\r\n        ry *= Math.sqrt(lambda);\r\n    }\r\n    var _e = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), centerx = _e[0], centery = _e[1], ang1 = _e[2], ang2 = _e[3];\r\n    // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\r\n    // 1.0000000001. This causes `segments` to be greater than one, which is an\r\n    // unecessary split, and adds extra points to the bezier curve. To alleviate\r\n    // this issue, we round to 1.0 when the ratio is close to 1.0.\r\n    var ratio = Math.abs(ang2) / (TAU / 4);\r\n    if (Math.abs(1.0 - ratio) < 0.0000001) {\r\n        ratio = 1.0;\r\n    }\r\n    var segments = Math.max(Math.ceil(ratio), 1);\r\n    ang2 /= segments;\r\n    for (var i = 0; i < segments; i++) {\r\n        curves.push(approxUnitArc(ang1, ang2));\r\n        ang1 += ang2;\r\n    }\r\n    return curves.map(function (curve) {\r\n        var _a = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _a.x, y1 = _a.y;\r\n        var _b = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _b.x, y2 = _b.y;\r\n        var _c = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _c.x, y = _c.y;\r\n        return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };\r\n    });\r\n};\r\nfunction arcToCubic(x1, y1, rx, ry, angle, LAF, SF, x2, y2) {\r\n    var curves = arcToBezier({\r\n        px: x1,\r\n        py: y1,\r\n        cx: x2,\r\n        cy: y2,\r\n        rx: rx,\r\n        ry: ry,\r\n        xAxisRotation: angle,\r\n        largeArcFlag: LAF,\r\n        sweepFlag: SF,\r\n    });\r\n    return curves.reduce(function (prev, cur) {\r\n        var x1 = cur.x1, y1 = cur.y1, x2 = cur.x2, y2 = cur.y2, x = cur.x, y = cur.y;\r\n        prev.push(x1, y1, x2, y2, x, y);\r\n        return prev;\r\n    }, []);\r\n}\r\nexports.arcToCubic = arcToCubic;\r\n//# sourceMappingURL=arc-2-cubic.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.quadToCubic = void 0;\r\nfunction quadToCubic(x1, y1, qx, qy, x2, y2) {\r\n    var r13 = 1 / 3;\r\n    var r23 = 2 / 3;\r\n    return [\r\n        r13 * x1 + r23 * qx,\r\n        r13 * y1 + r23 * qy,\r\n        r13 * x2 + r23 * qx,\r\n        r13 * y2 + r23 * qy,\r\n        x2, y2, // x,y\r\n    ];\r\n}\r\nexports.quadToCubic = quadToCubic;\r\n//# sourceMappingURL=quad-2-cubic.js.map","\r\n// export function getPointAtSegLength(p1x: number, p1y: number, c1x: number, c1y: number, c2x: number, c2y: number, p2x: number, p2y: number, t: number) {\r\n//   const t1 = 1 - t;\r\n//   return {\r\n//     x: (t1 ** 3) * p1x\r\n//       + t1 * t1 * 3 * t * c1x\r\n//       + t1 * 3 * t * t * c2x\r\n//       + (t ** 3) * p2x,\r\n//     y: (t1 ** 3) * p1y\r\n//       + t1 * t1 * 3 * t * c1y\r\n//       + t1 * 3 * t * t * c2y\r\n//       + (t ** 3) * p2y,\r\n//   };\r\n// }\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.lineToCubic = void 0;\r\n// export function midPoint(a: number[], b: number[], t: number) {\r\n//   const ax = a[0];\r\n//   const ay = a[1];\r\n//   const bx = b[0];\r\n//   const by = b[1];\r\n//   return [ax + (bx - ax) * t, ay + (by - ay) * t];\r\n// }\r\nfunction lineToCubic(x1, y1, x2, y2) {\r\n    return [x1, y1, x2, y2, x2, y2];\r\n    // const t = 0.5;\r\n    // const p0 = [x1, y1];\r\n    // const p1 = [x2, y2];\r\n    // const p2 = midPoint(p0, p1, t);\r\n    // const p3 = midPoint(p1, p2, t);\r\n    // const p4 = midPoint(p2, p3, t);\r\n    // const p5 = midPoint(p3, p4, t);\r\n    // const p6 = midPoint(p4, p5, t);\r\n    // const cp1 = getPointAtSegLength.apply(0, p0.concat(p2, p4, p6, t));\r\n    // const cp2 = getPointAtSegLength.apply(0, p6.concat(p5, p3, p1, 0));\r\n    // return [cp1.x, cp1.y, cp2.x, cp2.y, x2, y2];\r\n}\r\nexports.lineToCubic = lineToCubic;\r\n//# sourceMappingURL=line-2-cubic.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar p2s = /,?([a-z]),?/gi;\r\nfunction parsePathArray(path) {\r\n    return path.join(',').replace(p2s, '$1');\r\n}\r\nexports.default = parsePathArray;\r\n//# sourceMappingURL=parse-path-array.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isSamePoint = void 0;\r\nvar util_1 = require(\"@antv/util\");\r\n// 向量长度\r\nfunction vMag(v) {\r\n    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\r\n}\r\n// u.v/|u||v|，计算夹角的余弦值\r\nfunction vRatio(u, v) {\r\n    // 当存在一个向量的长度为 0 时，夹角也为 0，即夹角的余弦值为 1\r\n    return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;\r\n}\r\n// 向量角度\r\nfunction vAngle(u, v) {\r\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\r\n}\r\n/**\r\n * 判断两个点是否重合，点坐标的格式为 [x, y]\r\n * @param {Array} point1 第一个点\r\n * @param {Array} point2 第二个点\r\n */\r\nfunction isSamePoint(point1, point2) {\r\n    return point1[0] === point2[0] && point1[1] === point2[1];\r\n}\r\nexports.isSamePoint = isSamePoint;\r\n// A 0:rx 1:ry 2:x-axis-rotation 3:large-arc-flag 4:sweep-flag 5: x 6: y\r\nfunction getArcParams(startPoint, params) {\r\n    var rx = params[1];\r\n    var ry = params[2];\r\n    var xRotation = (0, util_1.mod)((0, util_1.toRadian)(params[3]), Math.PI * 2);\r\n    var arcFlag = params[4];\r\n    var sweepFlag = params[5];\r\n    // 弧形起点坐标\r\n    var x1 = startPoint[0];\r\n    var y1 = startPoint[1];\r\n    // 弧形终点坐标\r\n    var x2 = params[6];\r\n    var y2 = params[7];\r\n    var xp = (Math.cos(xRotation) * (x1 - x2)) / 2.0 + (Math.sin(xRotation) * (y1 - y2)) / 2.0;\r\n    var yp = (-1 * Math.sin(xRotation) * (x1 - x2)) / 2.0 + (Math.cos(xRotation) * (y1 - y2)) / 2.0;\r\n    var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\r\n    if (lambda > 1) {\r\n        rx *= Math.sqrt(lambda);\r\n        ry *= Math.sqrt(lambda);\r\n    }\r\n    var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);\r\n    var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;\r\n    if (arcFlag === sweepFlag) {\r\n        f *= -1;\r\n    }\r\n    if (isNaN(f)) {\r\n        f = 0;\r\n    }\r\n    // 旋转前的起点坐标，且当长半轴和短半轴的长度为 0 时，坐标按 (0, 0) 处理\r\n    var cxp = ry ? (f * rx * yp) / ry : 0;\r\n    var cyp = rx ? (f * -ry * xp) / rx : 0;\r\n    // 椭圆圆心坐标\r\n    var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;\r\n    var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;\r\n    // 起始点的单位向量\r\n    var u = [(xp - cxp) / rx, (yp - cyp) / ry];\r\n    // 终止点的单位向量\r\n    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\r\n    // 计算起始点和圆心的连线，与 x 轴正方向的夹角\r\n    var theta = vAngle([1, 0], u);\r\n    // 计算圆弧起始点和终止点与椭圆圆心连线的夹角\r\n    var dTheta = vAngle(u, v);\r\n    if (vRatio(u, v) <= -1) {\r\n        dTheta = Math.PI;\r\n    }\r\n    if (vRatio(u, v) >= 1) {\r\n        dTheta = 0;\r\n    }\r\n    if (sweepFlag === 0 && dTheta > 0) {\r\n        dTheta = dTheta - 2 * Math.PI;\r\n    }\r\n    if (sweepFlag === 1 && dTheta < 0) {\r\n        dTheta = dTheta + 2 * Math.PI;\r\n    }\r\n    return {\r\n        cx: cx,\r\n        cy: cy,\r\n        // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理\r\n        rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,\r\n        ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,\r\n        startAngle: theta,\r\n        endAngle: theta + dTheta,\r\n        xRotation: xRotation,\r\n        arcFlag: arcFlag,\r\n        sweepFlag: sweepFlag,\r\n    };\r\n}\r\nexports.default = getArcParams;\r\n//# sourceMappingURL=get-arc-params.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar get_arc_params_1 = require(\"./get-arc-params\");\r\nvar get_arc_params_2 = require(\"./get-arc-params\");\r\nvar parse_path_1 = require(\"./parse-path\");\r\n// 点对称\r\nfunction toSymmetry(point, center) {\r\n    return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];\r\n}\r\nfunction getSegments(path) {\r\n    path = (0, parse_path_1.default)(path);\r\n    var segments = [];\r\n    var currentPoint = null; // 当前图形\r\n    var nextParams = null; // 下一节点的 path 参数\r\n    var startMovePoint = null; // 开始 M 的点，可能会有多个\r\n    var lastStartMovePointIndex = 0; // 最近一个开始点 M 的索引\r\n    var count = path.length;\r\n    for (var i = 0; i < count; i++) {\r\n        var params = path[i];\r\n        nextParams = path[i + 1];\r\n        var command = params[0];\r\n        // 数学定义上的参数，便于后面的计算\r\n        var segment = {\r\n            command: command,\r\n            prePoint: currentPoint,\r\n            params: params,\r\n            startTangent: null,\r\n            endTangent: null,\r\n        };\r\n        switch (command) {\r\n            case 'M':\r\n                startMovePoint = [params[1], params[2]];\r\n                lastStartMovePointIndex = i;\r\n                break;\r\n            case 'A':\r\n                var arcParams = (0, get_arc_params_1.default)(currentPoint, params);\r\n                segment['arcParams'] = arcParams;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        if (command === 'Z') {\r\n            // 有了 Z 后，当前节点从开始 M 的点开始\r\n            currentPoint = startMovePoint;\r\n            // 如果当前点的命令为 Z，相当于当前点为最近一个 M 点，则下一个点直接指向最近一个 M 点的下一个点\r\n            nextParams = path[lastStartMovePointIndex + 1];\r\n        }\r\n        else {\r\n            var len = params.length;\r\n            currentPoint = [params[len - 2], params[len - 1]];\r\n        }\r\n        if (nextParams && nextParams[0] === 'Z') {\r\n            // 如果下一个点的命令为 Z，则下一个点直接指向最近一个 M 点\r\n            nextParams = path[lastStartMovePointIndex];\r\n            if (segments[lastStartMovePointIndex]) {\r\n                // 如果下一个点的命令为 Z，则最近一个 M 点的前一个点为当前点\r\n                segments[lastStartMovePointIndex].prePoint = currentPoint;\r\n            }\r\n        }\r\n        segment['currentPoint'] = currentPoint;\r\n        // 如果当前点与最近一个 M 点相同，则最近一个 M 点的前一个点为当前点的前一个点\r\n        if (segments[lastStartMovePointIndex] &&\r\n            (0, get_arc_params_2.isSamePoint)(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {\r\n            segments[lastStartMovePointIndex].prePoint = segment.prePoint;\r\n        }\r\n        var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;\r\n        segment['nextPoint'] = nextPoint;\r\n        // Add startTangent and endTangent\r\n        var prePoint = segment.prePoint;\r\n        if (['L', 'H', 'V'].includes(command)) {\r\n            segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];\r\n            segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];\r\n        }\r\n        else if (command === 'Q') {\r\n            // 二次贝塞尔曲线只有一个控制点\r\n            var cp = [params[1], params[2]];\r\n            // 二次贝塞尔曲线的终点为 currentPoint\r\n            segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];\r\n            segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];\r\n        }\r\n        else if (command === 'T') {\r\n            var preSegment = segments[i - 1];\r\n            var cp = toSymmetry(preSegment.currentPoint, prePoint);\r\n            if (preSegment.command === 'Q') {\r\n                segment.command = 'Q';\r\n                segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];\r\n                segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];\r\n            }\r\n            else {\r\n                segment.command = 'TL';\r\n                segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];\r\n                segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];\r\n            }\r\n        }\r\n        else if (command === 'C') {\r\n            // 三次贝塞尔曲线有两个控制点\r\n            var cp1 = [params[1], params[2]];\r\n            var cp2 = [params[3], params[4]];\r\n            segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];\r\n            segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\r\n            // horizontal line, eg. ['C', 100, 100, 100, 100, 200, 200]\r\n            if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {\r\n                segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];\r\n            }\r\n            if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {\r\n                segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];\r\n            }\r\n        }\r\n        else if (command === 'S') {\r\n            var preSegment = segments[i - 1];\r\n            var cp1 = toSymmetry(preSegment.currentPoint, prePoint);\r\n            var cp2 = [params[1], params[2]];\r\n            if (preSegment.command === 'C') {\r\n                segment.command = 'C'; // 将 S 命令变换为 C 命令\r\n                segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];\r\n                segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\r\n            }\r\n            else {\r\n                segment.command = 'SQ'; // 将 S 命令变换为 SQ 命令\r\n                segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];\r\n                segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\r\n            }\r\n        }\r\n        else if (command === 'A') {\r\n            var d = 0.001;\r\n            var _a = segment['arcParams'] || {}, _b = _a.cx, cx = _b === void 0 ? 0 : _b, _c = _a.cy, cy = _c === void 0 ? 0 : _c, _d = _a.rx, rx = _d === void 0 ? 0 : _d, _e = _a.ry, ry = _e === void 0 ? 0 : _e, _f = _a.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a.endAngle, endAngle = _h === void 0 ? 0 : _h;\r\n            if (sweepFlag === 0) {\r\n                d *= -1;\r\n            }\r\n            var dx1 = rx * Math.cos(startAngle - d) + cx;\r\n            var dy1 = ry * Math.sin(startAngle - d) + cy;\r\n            segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];\r\n            var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;\r\n            var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;\r\n            segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];\r\n        }\r\n        segments.push(segment);\r\n    }\r\n    return segments;\r\n}\r\nexports.default = getSegments;\r\n//# sourceMappingURL=path-2-segments.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar isBetween = function (value, min, max) { return value >= min && value <= max; };\r\nfunction getLineIntersect(p0, p1, p2, p3) {\r\n    var tolerance = 0.001;\r\n    var E = {\r\n        x: p2.x - p0.x,\r\n        y: p2.y - p0.y,\r\n    };\r\n    var D0 = {\r\n        x: p1.x - p0.x,\r\n        y: p1.y - p0.y,\r\n    };\r\n    var D1 = {\r\n        x: p3.x - p2.x,\r\n        y: p3.y - p2.y,\r\n    };\r\n    var kross = D0.x * D1.y - D0.y * D1.x;\r\n    var sqrKross = kross * kross;\r\n    var sqrLen0 = D0.x * D0.x + D0.y * D0.y;\r\n    var sqrLen1 = D1.x * D1.x + D1.y * D1.y;\r\n    var point = null;\r\n    if (sqrKross > tolerance * sqrLen0 * sqrLen1) {\r\n        var s = (E.x * D1.y - E.y * D1.x) / kross;\r\n        var t = (E.x * D0.y - E.y * D0.x) / kross;\r\n        if (isBetween(s, 0, 1) && isBetween(t, 0, 1)) {\r\n            point = {\r\n                x: p0.x + s * D0.x,\r\n                y: p0.y + s * D0.y,\r\n            };\r\n        }\r\n    }\r\n    return point;\r\n}\r\nexports.default = getLineIntersect;\r\n;\r\n//# sourceMappingURL=get-line-intersect.js.map","\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar point_in_polygon_1 = require(\"./point-in-polygon\");\r\nvar get_line_intersect_1 = require(\"./get-line-intersect\");\r\nvar util_1 = require(\"@antv/util\");\r\nfunction parseToLines(points) {\r\n    var lines = [];\r\n    var count = points.length;\r\n    for (var i = 0; i < count - 1; i++) {\r\n        var point = points[i];\r\n        var next = points[i + 1];\r\n        lines.push({\r\n            from: {\r\n                x: point[0],\r\n                y: point[1]\r\n            },\r\n            to: {\r\n                x: next[0],\r\n                y: next[1]\r\n            }\r\n        });\r\n    }\r\n    if (lines.length > 1) {\r\n        var first = points[0];\r\n        var last = points[count - 1];\r\n        lines.push({\r\n            from: {\r\n                x: last[0],\r\n                y: last[1]\r\n            },\r\n            to: {\r\n                x: first[0],\r\n                y: first[1]\r\n            }\r\n        });\r\n    }\r\n    return lines;\r\n}\r\nfunction lineIntersectPolygon(lines, line) {\r\n    var isIntersect = false;\r\n    (0, util_1.each)(lines, function (l) {\r\n        if ((0, get_line_intersect_1.default)(l.from, l.to, line.from, line.to)) {\r\n            isIntersect = true;\r\n            return false;\r\n        }\r\n    });\r\n    return isIntersect;\r\n}\r\nfunction getBBox(points) {\r\n    var xArr = points.map(function (p) { return p[0]; });\r\n    var yArr = points.map(function (p) { return p[1]; });\r\n    return {\r\n        minX: Math.min.apply(null, xArr),\r\n        maxX: Math.max.apply(null, xArr),\r\n        minY: Math.min.apply(null, yArr),\r\n        maxY: Math.max.apply(null, yArr)\r\n    };\r\n}\r\nfunction intersectBBox(box1, box2) {\r\n    return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\r\n}\r\nfunction isPolygonsIntersect(points1, points2) {\r\n    // 空数组，或者一个点返回 false\r\n    if (points1.length < 2 || points2.length < 2) {\r\n        return false;\r\n    }\r\n    var bbox1 = getBBox(points1);\r\n    var bbox2 = getBBox(points2);\r\n    // 判定包围盒是否相交，比判定点是否在多边形内要快的多，可以筛选掉大多数情况\r\n    if (!intersectBBox(bbox1, bbox2)) {\r\n        return false;\r\n    }\r\n    var isIn = false;\r\n    // 判定点是否在多边形内部，一旦有一个点在另一个多边形内，则返回\r\n    (0, util_1.each)(points2, function (point) {\r\n        if ((0, point_in_polygon_1.default)(points1, point[0], point[1])) {\r\n            isIn = true;\r\n            return false;\r\n        }\r\n    });\r\n    if (isIn) {\r\n        return true;\r\n    }\r\n    // 两个多边形都需要判定\r\n    (0, util_1.each)(points1, function (point) {\r\n        if ((0, point_in_polygon_1.default)(points2, point[0], point[1])) {\r\n            isIn = true;\r\n            return false;\r\n        }\r\n    });\r\n    if (isIn) {\r\n        return true;\r\n    }\r\n    var lines1 = parseToLines(points1);\r\n    var lines2 = parseToLines(points2);\r\n    var isIntersect = false;\r\n    (0, util_1.each)(lines2, function (line) {\r\n        if (lineIntersectPolygon(lines1, line)) {\r\n            isIntersect = true;\r\n            return false;\r\n        }\r\n    });\r\n    return isIntersect;\r\n}\r\nexports.default = isPolygonsIntersect;\r\n//# sourceMappingURL=is-polygons-intersect.js.map","\r\n/**\r\n * @fileoverview 判断点是否在多边形内\r\n * @author dxq613@gmail.com\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// 多边形的射线检测，参考：https://blog.csdn.net/WilliamSun0122/article/details/77994526\r\nvar tolerance = 1e-6;\r\n// 三态函数，判断两个double在eps精度下的大小关系\r\nfunction dcmp(x) {\r\n    if (Math.abs(x) < tolerance) {\r\n        return 0;\r\n    }\r\n    return x < 0 ? -1 : 1;\r\n}\r\n// 判断点Q是否在p1和p2的线段上\r\nfunction onSegment(p1, p2, q) {\r\n    if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) &&\r\n        Math.min(p1[0], p2[0]) <= q[0] &&\r\n        q[0] <= Math.max(p1[0], p2[0]) &&\r\n        Math.min(p1[1], p2[1]) <= q[1] &&\r\n        q[1] <= Math.max(p1[1], p2[1])) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n// 判断点P在多边形内-射线法\r\nfunction isInPolygon(points, x, y) {\r\n    var isHit = false;\r\n    var n = points.length;\r\n    if (n <= 2) {\r\n        // svg 中点小于 3 个时，不显示，也无法被拾取\r\n        return false;\r\n    }\r\n    for (var i = 0; i < n; i++) {\r\n        var p1 = points[i];\r\n        var p2 = points[(i + 1) % n];\r\n        if (onSegment(p1, p2, [x, y])) {\r\n            // 点在多边形一条边上\r\n            return true;\r\n        }\r\n        // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\r\n        // 后一个判断被测点 在 射线与边交点 的左边\r\n        if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 &&\r\n            dcmp(x - ((y - p1[1]) * (p1[0] - p2[0])) / (p1[1] - p2[1]) - p1[0]) < 0) {\r\n            isHit = !isHit;\r\n        }\r\n    }\r\n    return isHit;\r\n}\r\nexports.default = isInPolygon;\r\n//# sourceMappingURL=point-in-polygon.js.map"]}